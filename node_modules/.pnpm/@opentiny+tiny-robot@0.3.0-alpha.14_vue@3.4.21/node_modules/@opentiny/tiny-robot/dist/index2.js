import { n as w, x as I, aB as H, S as z, ac as R, Z as _, G as W, b as U, c as G, P as L, d as F, O as Z, j as $, aC as Q, aD as Y, f as q, g as j, aE as K, aF as X, h as J, $ as ee } from "./index7.js";
import * as N from "vue";
import { withDirectives as te, createVNode as M, vShow as ne } from "vue";
const k = (e) => e.stopPropagation(), V = ({ state: e, props: t, vm: n, slots: r }) => {
  let p = e.referenceElm || t.reference || n.$refs.reference && n.$refs.reference.$el || n.$refs.reference;
  return !p && r.reference && r.reference()[0] && (e.referenceElm = r.reference()[0].elm || r.reference()[0].el, p = e.referenceElm), p;
}, re = (e) => {
  if (!e || !e.nodeType) return;
  let t = (p) => parseInt(window.getComputedStyle(p).zIndex, 10) || 0, n = t(e), r;
  do {
    if (e = e.parentNode, e && e instanceof ShadowRoot && e.host && (e = e.host), e)
      r = t(e);
    else
      break;
    n = r > n ? r : n;
  } while (e !== document.body);
  return n + 1 + "";
}, oe = (e) => {
  const {
    parent: t,
    emit: n,
    nextTick: r,
    onBeforeUnmount: p,
    onDeactivated: c,
    props: o,
    watch: y,
    reactive: f,
    vm: i,
    slots: m,
    toRefs: h,
    popperVmRef: g
  } = e, a = f({
    popperJS: null,
    appended: !1,
    // arrow 是否添加
    popperElm: null,
    showPopper: o.manual ? !!o.modelValue : !1,
    referenceElm: null,
    currentPlacement: ""
  }), s = (l) => {
    if (a.appended)
      return;
    a.appended = !0;
    const u = document.createElement("div");
    u.setAttribute("x-arrow", ""), u.className = "popper__arrow", l.appendChild(u);
  }, b = (l) => {
    const { followReferenceHide: u = !0 } = (o == null ? void 0 : o.popperOptions) || {}, { _popper: v, _reference: d } = l;
    u && H(d) && (v.style.display = "none");
  }, P = (l) => o.zIndex === "relative" ? re(l) : I.nextZIndex(), B = (l) => {
    if (z || (a.currentPlacement = a.currentPlacement || o.placement, !/^(top|bottom|left|right)(-start|-end)?$/g.test(a.currentPlacement)))
      return;
    const u = o.popperOptions || { gpuAcceleration: !1 };
    a.popperElm = a.popperElm || o.popper || i.$refs.popper || g.popper || l;
    const v = a.popperElm;
    let d = V({ state: a, props: o, vm: i, slots: m });
    !v || !d || d.nodeType !== Node.ELEMENT_NODE || (o.visibleArrow && s(v), o.appendToBody || o.popperAppendToBody ? document.body.appendChild(a.popperElm) : (t && t.$el && t.$el.appendChild(a.popperElm), u.forceAbsolute = !0), u.placement = a.currentPlacement, u.offset = o.offset || 0, u.arrowOffset = o.arrowOffset || 0, u.adjustArrow = o.adjustArrow || !1, u.appendToBody = o.appendToBody || o.popperAppendToBody, a.popperJS = new R(d, v, u), n("created", a), typeof u.onUpdate == "function" && a.popperJS.onUpdate(u.onUpdate), a.popperJS._popper.style.zIndex = P(a.popperJS._reference), b(a.popperJS), _(a.popperElm, "click", k));
  }, S = (l) => {
    l && l !== !0 && (a.popperElm = l);
    const u = a.popperJS;
    u ? (u._reference = V({ state: a, props: o, vm: i, slots: m }), u.update(), u._popper && l !== !0 && (u._popper.style.zIndex = P(u._reference), b(a.popperJS))) : B(l && l !== !0 ? l : void 0);
  }, E = (l) => {
    !a.popperJS || a.showPopper && !l || (a.popperJS.destroy(), a.popperJS = null);
  }, x = (l) => {
    l && a.popperElm && a.popperElm.parentNode === document.body && (w(a.popperElm, "click", k), a.popperElm.remove());
  };
  return y(
    () => a.showPopper,
    (l) => {
      o.disabled || (l && r(S), o.trigger === "manual" && n("update:modelValue", l));
    }
  ), y(
    () => o.placement,
    (l) => {
      var u;
      a.currentPlacement = l, (u = a.popperJS) == null || u.setOptions({ placement: l }), !o.disabled && (l && r(S), o.trigger === "manual" && n("update:modelValue", l));
    }
  ), p(() => {
    r(() => {
      E(!0), (o.appendToBody || o.popperAppendToBody) && x("remove");
    });
  }), c(() => {
    E(!0), (o.appendToBody || o.popperAppendToBody) && x("remove");
  }), { updatePopper: S, destroyPopper: x, doDestroy: E, ...h(a) };
}, ae = ({ api: e, state: t, props: n }) => (r) => {
  const c = r && r.type === "mouseenter" ? 200 : 0;
  if (n.visible === "auto") {
    const { clientWidth: o, scrollWidth: y } = t.referenceElm;
    if (y <= o)
      return;
  }
  e.setExpectedState(!0), e.handleShowPopper(c);
}, pe = (e) => () => {
  e.setExpectedState(!1), e.debounceClose();
}, le = ({ api: e, state: t }) => () => {
  t.focusing = !0, e.show();
}, ue = ({ api: e, state: t }) => () => {
  t.focusing = !1, e.hide();
}, se = ({ api: e, state: t }) => () => {
  t.focusing = !1, e.show();
}, ie = ({ props: e, state: t }) => (n) => {
  !t.expectedState || e.manual || (clearTimeout(t.timeout), t.timeout = window.setTimeout(() => {
    t.showPopper = !0;
  }, e.openDelay || n), e.hideAfter > 0 && (t.timeoutPending = window.setTimeout(() => {
    t.showPopper = !1;
  }, e.hideAfter)));
}, de = ({ api: e, props: t, state: n }) => () => {
  t.enterable && n.expectedState || t.manual || (clearTimeout(n.timeout), n.timeoutPending && clearTimeout(n.timeoutPending), n.showPopper = !1, t.disabled && e.doDestroy());
}, fe = ({ props: e, api: t, state: n, popperVmRef: r }) => (p) => {
  if (e.manual)
    return;
  const c = n.referenceElm, o = r.popper;
  !o || !c || o.contains(p.target) || c.contains(p.target) || n.showPopper && (t.setExpectedState(!1), t.debounceClose());
}, ce = ({ state: e }) => (t) => {
  e.expectedState === !1 && clearTimeout(e.timeoutPending), e.expectedState = t;
}, me = ({ state: e, api: t, vm: n }) => () => {
  const r = e.referenceElm;
  e.showPopper = !1, r && r.nodeType === 1 && (w(document, "click", t.handleDocumentClick), w(r, "mouseenter", t.show), w(r, "mouseleave", t.hide), w(r, "focus", t.focusHandler), w(r, "blur", t.handleBlur), w(r, "click", t.removeFocusing)), n.popperVM && (typeof n.popperVM.$destroy == "function" && n.popperVM.$destroy(), n.popperVM = null);
}, ye = ({ api: e, props: t }) => W(t.closeDelay, () => {
  e.handleClosePopper();
}), be = (e) => (t) => {
  t ? U(e.referenceElm, "focusing") : G(e.referenceElm, "focusing");
}, he = ({ slots: e, api: t }) => () => {
  if (!e.default || !e.default().length) {
    t.handleFocus();
    return;
  }
  let n = e.default()[0];
  n = n.elm || n.el, n && n.focus ? n.focus() : t.handleFocus();
}, ge = ({ api: e, state: t, vm: n }) => (r) => {
  let p = null;
  n.$el.nodeType === 8 ? p = r : n.$el.nodeType === 1 && (p = n.$el), !(!p || p.nodeType === 8 || t.referenceElm) && (t.referenceElm = p, p.setAttribute("aria-describedby", t.tooltipId), p.setAttribute("tabindex", t.tabindex.toString()), _(document, "click", e.handleDocumentClick), _(p, "mouseenter", e.show), _(p, "mouseleave", e.hide), _(p, "focus", e.focusHandler), _(p, "blur", e.handleBlur), _(p, "click", e.removeFocusing));
}, ve = ({ state: e, popperVmRef: t }) => (n) => {
  for (let r of n)
    r.type === "attributes" && r.attributeName === "x-placement" && (e.xPlacement = t.popper.getAttribute("x-placement") || "bottom");
}, we = ({ vm: e, nextTick: t, popperVmRef: n }) => (r) => {
  t(() => e.bindEvent(r));
  let p = e.popperVM;
  e.$refs.popper ? n.popper = e.$refs.popper : n.popper = p.$el, t(() => {
    e.modelValue && e.updatePopper();
  });
}, _e = [
  "state",
  "bindEvent",
  "hide",
  "show",
  "doDestroy",
  "handleFocus",
  "debounceClose",
  "handleShowPopper",
  "handleClosePopper",
  "setExpectedState",
  "updatePopper",
  "focusHandler"
], Pe = ({ reactive: e, showPopper: t, popperElm: n, referenceElm: r, props: p, inject: c, popperJS: o, currentPlacement: y }) => e({
  popperJS: o,
  showPopper: t,
  popperElm: n,
  referenceElm: r,
  currentPlacement: y,
  timeout: null,
  focusing: !1,
  expectedState: void 0,
  tooltipId: L("tiny-tooltip-", 4),
  tabindex: p.tabindex,
  xPlacement: "bottom",
  showContent: c("showContent", null),
  tipsMaxWidth: c("tips-max-width", null)
}), Se = (e, {
  watch: t,
  toRefs: n,
  reactive: r,
  onBeforeUnmount: p,
  onDeactivated: c,
  onMounted: o,
  onUnmounted: y,
  inject: f
}, { vm: i, emit: m, slots: h, nextTick: g, parent: a }) => {
  const s = {}, b = {}, P = { emit: m, props: e, nextTick: g, toRefs: n, reactive: r, parent: a.$parent, vm: i, popperVmRef: b };
  Object.assign(P, { slots: h, onBeforeUnmount: p, onDeactivated: c, watch: t });
  const { showPopper: B, updatePopper: S, popperElm: E, referenceElm: x, doDestroy: l, popperJS: u, currentPlacement: v } = oe(
    P
  ), d = Pe({
    reactive: r,
    showPopper: B,
    popperElm: E,
    referenceElm: x,
    props: e,
    inject: f,
    popperJS: u,
    currentPlacement: v
  });
  return Object.assign(s, {
    state: d,
    doDestroy: l,
    updatePopper: S,
    show: ae({ api: s, state: d, props: e }),
    hide: pe(s),
    destroyed: me({ state: d, api: s, vm: i }),
    bindPopper: we({ vm: i, nextTick: g, popperVmRef: b }),
    watchFocusing: be(d),
    removeFocusing: se({ api: s, state: d }),
    handleBlur: ue({ api: s, state: d }),
    handleFocus: le({ api: s, state: d }),
    debounceClose: ye({ api: s, props: e }),
    setExpectedState: ce({ state: d }),
    handleShowPopper: ie({ props: e, state: d }),
    handleClosePopper: de({ api: s, props: e, state: d }),
    bindEvent: ge({ api: s, state: d, vm: i }),
    focusHandler: he({ slots: h, api: s }),
    handleDocumentClick: fe({ props: e, api: s, state: d, popperVmRef: b }),
    observeCallback: ve({ state: d, popperVmRef: b })
  }), t(() => d.focusing, s.watchFocusing), t(
    () => e.modelValue,
    (T) => g(() => e.manual && (d.showPopper = T))
  ), o(() => {
    if (s.bindPopper(), e.genArrowByHtml) {
      const T = { attributes: !0, childList: !1, subtree: !1 };
      s.observer = new MutationObserver(s.observeCallback), s.observer.observe(b.popper, T);
    }
  }), i.$on("tooltip-update", s.bindPopper), y(() => {
    s.destroyed(), s.observer && s.observer.disconnect(), i.$off("tooltip-update");
  }), s;
};
function O() {
  return O = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, O.apply(null, arguments);
}
var A = /* @__PURE__ */ F({
  name: j + "Tooltip",
  componentName: "Tooltip",
  props: O({}, J, {
    visible: {
      type: String,
      default: function() {
        return "always";
      },
      validator: function(t) {
        return ["always", "auto"].includes(t);
      }
    },
    adjustArrow: {
      type: Boolean,
      default: function() {
        return !1;
      }
    },
    appendToBody: {
      type: Boolean,
      default: function() {
        return !0;
      }
    },
    arrowOffset: {
      type: Number,
      default: function() {
        return 0;
      }
    },
    boundariesPadding: {
      type: Number,
      default: function() {
        return 5;
      }
    },
    closeDelay: {
      type: Number,
      default: function() {
        return 300;
      }
    },
    content: {
      type: [String, Object]
    },
    disabled: {
      type: Boolean
    },
    effect: {
      type: String,
      default: function() {
        return "dark";
      }
    },
    enterable: {
      type: Boolean,
      default: function() {
        return !0;
      }
    },
    hideAfter: {
      type: Number,
      default: function() {
        return 0;
      }
    },
    manual: {
      type: Boolean
    },
    modelValue: {
      type: Boolean
    },
    offset: {
      default: function() {
        return 0;
      }
    },
    openDelay: {
      type: Number,
      default: function() {
        return 0;
      }
    },
    placement: {
      type: String,
      default: function() {
        return "bottom";
      }
    },
    popper: {},
    popperClass: {
      type: String
    },
    popperOptions: {
      default: function() {
        return {
          gpuAcceleration: !1,
          boundariesPadding: 10
        };
      }
    },
    pre: {
      type: Boolean
    },
    reference: {},
    renderContent: {
      type: Function
    },
    tabindex: {
      type: Number,
      default: function() {
        return 0;
      }
    },
    transition: {
      type: String,
      default: function() {
        return "tiny-fade-in-linear";
      }
    },
    type: {
      type: String,
      validator: function(t) {
        return !!~["normal", "warning", "error", "info", "success"].indexOf(t);
      }
    },
    visibleArrow: {
      type: Boolean,
      default: function() {
        return !0;
      }
    },
    zIndex: {
      type: String,
      default: function() {
        return "next";
      }
    },
    contentMaxHeight: {
      type: String
    }
  }),
  setup: function(t, n) {
    return q({
      props: t,
      context: n,
      renderless: Se,
      api: _e
    });
  },
  render: function() {
    var t = this, n = function(f) {
      var i = f.slots.content && f.slots.content();
      if (i && (!N.Comment || i[0].type !== N.Comment))
        return i;
      var m;
      return f.renderContent ? m = f.renderContent($, f.content) : f.pre ? m = f.content ? $("pre", f.content) : null : m = f.content, m;
    };
    if (!Object.prototype.hasOwnProperty.call(this, "popperVM")) {
      var r = {
        value: null
      };
      this.d({
        popperVM: {
          get: function() {
            return r.value || (r.value = Z({
              el: document.createElement("div"),
              propsData: null,
              component: {
                render: function() {
                  var i = n(t), m = typeof i == "string", h = {
                    attrs: {
                      name: t.transition
                    },
                    on: {
                      "after-leave": t.doDestroy
                    }
                  }, g = "is-" + (t.type || t.effect || "dark"), a = function() {
                    return t.setExpectedState(!0);
                  }, s = function() {
                    t.setExpectedState(!1), t.debounceClose();
                  };
                  return t.$nextTick(function() {
                    !t.disabled && t.state.showPopper && i && t.updatePopper();
                  }), $("transition", h, [te(M("div", {
                    ref: "popper",
                    id: t.state.tooltipId,
                    class: ["tiny-tooltip", "tiny-tooltip__popper", g, t.popperClass, {
                      "tiny-tooltip__show-tips": t.state.showContent
                    }],
                    style: "max-width:" + t.state.tipsMaxWidth + "px",
                    role: "tooltip",
                    "aria-hidden": t.disabled || !t.state.showPopper ? "true" : "false",
                    onMouseenter: function() {
                      return a();
                    },
                    onMouseleave: function() {
                      return s();
                    }
                  }, [m ? M("div", {
                    class: "tiny-tooltip__content-wrapper",
                    style: "max-height:" + t.contentMaxHeight + ";"
                  }, [i]) : i]), [[ne, !t.disabled && t.state.showPopper && i]])]);
                }
              }
            })), r.value;
          },
          set: function(f) {
            return r.value = f;
          }
        }
      });
    }
    var p = function() {
      var f = t.slots.default && t.slots.default();
      if (!Array.isArray(f)) return null;
      for (var i = null, m = 0; m < f.length; m++) {
        var h = K(f[m]);
        if (!X(h)) {
          i = h;
          break;
        }
      }
      return i;
    }, c = p();
    if (!c) return null;
    var o = c.data || c.props || (c.props = {});
    return o.class = Q("tiny-tooltip " + Y(o.class)), c;
  }
});
function D() {
  return D = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, D.apply(null, arguments);
}
var Ee = function(t) {
  var n, r = typeof process == "object" ? (n = process.env) == null ? void 0 : n.TINY_MODE : null;
  return A;
}, xe = D({}, J, {
  visible: {
    type: String,
    default: function() {
      return "always";
    },
    validator: function(t) {
      return ["always", "auto"].includes(t);
    }
  },
  adjustArrow: {
    type: Boolean,
    default: function() {
      return !1;
    }
  },
  appendToBody: {
    type: Boolean,
    default: function() {
      return !0;
    }
  },
  arrowOffset: {
    type: Number,
    default: function() {
      return 0;
    }
  },
  content: {
    type: [String, Object]
  },
  disabled: {
    type: Boolean
  },
  enterable: {
    type: Boolean,
    default: function() {
      return !0;
    }
  },
  hideAfter: {
    type: Number,
    default: function() {
      return 0;
    }
  },
  manual: {
    type: Boolean
  },
  modelValue: {
    type: Boolean
  },
  offset: {
    default: function() {
      return 0;
    }
  },
  effect: {
    type: String,
    default: function() {
      return "";
    }
  },
  openDelay: {
    type: Number,
    default: function() {
      return 0;
    }
  },
  closeDelay: {
    type: Number,
    default: function() {
      return 100;
    }
  },
  placement: {
    type: String,
    default: function() {
      return "bottom";
    }
  },
  popper: {},
  popperClass: {
    type: String
  },
  popperOptions: {
    default: function() {
      return {};
    }
  },
  pre: {
    type: Boolean
  },
  reference: {},
  renderContent: {
    type: Function
  },
  tabindex: {
    type: Number,
    default: function() {
      return 0;
    }
  },
  transition: {
    type: String,
    default: function() {
      return "tiny-fade-in-linear";
    }
  },
  type: {
    type: String,
    validator: function(t) {
      return !!~["normal", "warning", "error", "info", "success"].indexOf(t);
    }
  },
  visibleArrow: {
    type: Boolean,
    default: function() {
      return !0;
    }
  },
  genArrowByHtml: {
    type: Boolean,
    default: function() {
      return !0;
    }
  },
  zIndex: {
    type: String,
    default: function() {
      return "next";
    }
  },
  contentMaxHeight: {
    type: String,
    default: function() {
      return "80vh";
    }
  }
}), C = F({
  name: j + "Tooltip",
  componentName: "Tooltip",
  props: xe,
  setup: function(t, n) {
    return ee({
      props: t,
      context: n,
      template: Ee
    });
  }
}), Ce = "3.undefined";
C.model = {
  prop: "modelValue",
  event: "update:modelValue"
};
C.install = function(e) {
  e.component(C.name, C);
};
C.version = Ce;
export {
  C as T,
  oe as k
};
