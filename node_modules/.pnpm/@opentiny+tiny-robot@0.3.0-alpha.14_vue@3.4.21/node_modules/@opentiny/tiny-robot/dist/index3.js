import { onMounted as re, nextTick as he, watch as k, getCurrentScope as me, onScopeDispose as we, isRef as ie, getCurrentInstance as j, toValue as b, hasInjectionContext as le, inject as ge, toRefs as be, customRef as ye, shallowRef as y, computed as F, reactive as Z, unref as Se, watchEffect as Te, ref as se, readonly as Oe } from "vue";
function z(e) {
  return me() ? (we(e), !0) : !1;
}
function ee() {
  const e = /* @__PURE__ */ new Set(), t = (i) => {
    e.delete(i);
  };
  return {
    on: (i) => {
      e.add(i);
      const c = () => t(i);
      return z(c), {
        off: c
      };
    },
    off: t,
    trigger: (...i) => Promise.all(Array.from(e).map((c) => c(...i))),
    clear: () => {
      e.clear();
    }
  };
}
const B = /* @__PURE__ */ new WeakMap(), Ee = (...e) => {
  var t;
  const o = e[0], n = (t = j()) == null ? void 0 : t.proxy;
  if (n == null && !le())
    throw new Error("injectLocal must be called in setup");
  return n && B.has(n) && o in B.get(n) ? B.get(n)[o] : ge(...e);
}, $ = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const xe = (e) => e != null, We = Object.prototype.toString, Me = (e) => We.call(e) === "[object Object]", W = () => {
}, Ie = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Pe = /* @__PURE__ */ Ae();
function Ae() {
  var e, t;
  return $ && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Y(e, t) {
  function o(...n) {
    return new Promise((u, i) => {
      Promise.resolve(e(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(u).catch(i);
    });
  }
  return o;
}
const Fe = (e) => e();
function ue(e, t = {}) {
  let o, n, u = W;
  const i = (l) => {
    clearTimeout(l), u(), u = W;
  };
  let c;
  return (l) => {
    const d = b(e), a = b(t.maxWait);
    return o && i(o), d <= 0 || a !== void 0 && a <= 0 ? (n && (i(n), n = void 0), Promise.resolve(l())) : new Promise((s, v) => {
      u = t.rejectOnCancel ? v : s, c = l, a && !n && (n = setTimeout(() => {
        o && i(o), n = void 0, s(c());
      }, a)), o = setTimeout(() => {
        n && i(n), n = void 0, s(l());
      }, d);
    });
  };
}
function ce(...e) {
  let t = 0, o, n = !0, u = W, i, c, r, l, d;
  !ie(e[0]) && typeof e[0] == "object" ? { delay: c, trailing: r = !0, leading: l = !0, rejectOnCancel: d = !1 } = e[0] : [c, r = !0, l = !0, d = !1] = e;
  const a = () => {
    o && (clearTimeout(o), o = void 0, u(), u = W);
  };
  return (v) => {
    const p = b(c), w = Date.now() - t, S = () => i = v();
    return a(), p <= 0 ? (t = Date.now(), S()) : (w > p && (l || !n) ? (t = Date.now(), S()) : r && (i = new Promise((f, h) => {
      u = d ? h : f, o = setTimeout(() => {
        t = Date.now(), n = !0, f(S()), a();
      }, Math.max(0, p - w));
    })), !l && !o && (o = setTimeout(() => n = !0, p)), n = !1, i);
  };
}
function te(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function _e(e, t, o = !1) {
  return t.reduce((n, u) => (u in e && (!o || e[u] !== void 0) && (n[u] = e[u]), n), {});
}
function R(e) {
  return Array.isArray(e) ? e : [e];
}
function Le(e) {
  return j();
}
function ke(e, t = 200, o = {}) {
  return Y(
    ue(t, o),
    e
  );
}
function De(e, t = 200, o = !1, n = !0, u = !1) {
  return Y(
    ce(t, o, n, u),
    e
  );
}
function ae(e, t, o = {}) {
  const {
    eventFilter: n = Fe,
    ...u
  } = o;
  return k(
    e,
    Y(
      n,
      t
    ),
    u
  );
}
function Ce(e, t = {}) {
  if (!ie(e))
    return be(e);
  const o = Array.isArray(e.value) ? Array.from({ length: e.value.length }) : {};
  for (const n in e.value)
    o[n] = ye(() => ({
      get() {
        return e.value[n];
      },
      set(u) {
        var i;
        if ((i = b(t.replaceRef)) != null ? i : !0)
          if (Array.isArray(e.value)) {
            const r = [...e.value];
            r[n] = u, e.value = r;
          } else {
            const r = { ...e.value, [n]: u };
            Object.setPrototypeOf(r, Object.getPrototypeOf(e.value)), e.value = r;
          }
        else
          e.value[n] = u;
      }
    }));
  return o;
}
function N(e, t = !0, o) {
  Le() ? re(e, o) : t ? e() : he(e);
}
function Xe(e, t, o = {}) {
  const {
    debounce: n = 0,
    maxWait: u = void 0,
    ...i
  } = o;
  return ae(
    e,
    t,
    {
      ...i,
      eventFilter: ue(n, { maxWait: u })
    }
  );
}
function Re(e, t, o) {
  return k(
    e,
    t,
    {
      ...o,
      immediate: !0
    }
  );
}
function Qe(e, t, o = {}) {
  const {
    throttle: n = 0,
    trailing: u = !0,
    leading: i = !0,
    ...c
  } = o;
  return ae(
    e,
    t,
    {
      ...c,
      eventFilter: ce(n, u, i)
    }
  );
}
const P = $ ? window : void 0, Ve = $ ? window.document : void 0;
function T(e) {
  var t;
  const o = b(e);
  return (t = o == null ? void 0 : o.$el) != null ? t : o;
}
function M(...e) {
  const t = [], o = () => {
    t.forEach((r) => r()), t.length = 0;
  }, n = (r, l, d, a) => (r.addEventListener(l, d, a), () => r.removeEventListener(l, d, a)), u = F(() => {
    const r = R(b(e[0])).filter((l) => l != null);
    return r.every((l) => typeof l != "string") ? r : void 0;
  }), i = Re(
    () => {
      var r, l;
      return [
        (l = (r = u.value) == null ? void 0 : r.map((d) => T(d))) != null ? l : [P].filter((d) => d != null),
        R(b(u.value ? e[1] : e[0])),
        R(Se(u.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        b(u.value ? e[3] : e[2])
      ];
    },
    ([r, l, d, a]) => {
      if (o(), !(r != null && r.length) || !(l != null && l.length) || !(d != null && d.length))
        return;
      const s = Me(a) ? { ...a } : a;
      t.push(
        ...r.flatMap(
          (v) => l.flatMap(
            (p) => d.map((w) => n(v, p, w, s))
          )
        )
      );
    },
    { flush: "post" }
  ), c = () => {
    i(), o();
  };
  return z(o), c;
}
let ne = !1;
function Ue(e, t, o = {}) {
  const { window: n = P, ignore: u = [], capture: i = !0, detectIframe: c = !1, controls: r = !1 } = o;
  if (!n)
    return r ? { stop: W, cancel: W, trigger: W } : W;
  if (Pe && !ne) {
    ne = !0;
    const f = { passive: !0 };
    Array.from(n.document.body.children).forEach((h) => h.addEventListener("click", W, f)), n.document.documentElement.addEventListener("click", W, f);
  }
  let l = !0;
  const d = (f) => b(u).some((h) => {
    if (typeof h == "string")
      return Array.from(n.document.querySelectorAll(h)).some((g) => g === f.target || f.composedPath().includes(g));
    {
      const g = T(h);
      return g && (f.target === g || f.composedPath().includes(g));
    }
  });
  function a(f) {
    const h = b(f);
    return h && h.$.subTree.shapeFlag === 16;
  }
  function s(f, h) {
    const g = b(f), O = g.$.subTree && g.$.subTree.children;
    return O == null || !Array.isArray(O) ? !1 : O.some((E) => E.el === h.target || h.composedPath().includes(E.el));
  }
  const v = (f) => {
    const h = T(e);
    if (f.target != null && !(!(h instanceof Element) && a(e) && s(e, f)) && !(!h || h === f.target || f.composedPath().includes(h))) {
      if ("detail" in f && f.detail === 0 && (l = !d(f)), !l) {
        l = !0;
        return;
      }
      t(f);
    }
  };
  let p = !1;
  const w = [
    M(n, "click", (f) => {
      p || (p = !0, setTimeout(() => {
        p = !1;
      }, 0), v(f));
    }, { passive: !0, capture: i }),
    M(n, "pointerdown", (f) => {
      const h = T(e);
      l = !d(f) && !!(h && !f.composedPath().includes(h));
    }, { passive: !0 }),
    c && M(n, "blur", (f) => {
      setTimeout(() => {
        var h;
        const g = T(e);
        ((h = n.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(g != null && g.contains(n.document.activeElement)) && t(f);
      }, 0);
    }, { passive: !0 })
  ].filter(Boolean), S = () => w.forEach((f) => f());
  return r ? {
    stop: S,
    cancel: () => {
      l = !1;
    },
    trigger: (f) => {
      l = !0, v(f), l = !1;
    }
  } : S;
}
function He() {
  const e = y(!1), t = j();
  return t && re(() => {
    e.value = !0;
  }, t), e;
}
function G(e) {
  const t = He();
  return F(() => (t.value, !!e()));
}
function fe(e, t, o = {}) {
  const { window: n = P, ...u } = o;
  let i;
  const c = G(() => n && "MutationObserver" in n), r = () => {
    i && (i.disconnect(), i = void 0);
  }, l = F(() => {
    const v = b(e), p = R(v).map(T).filter(xe);
    return new Set(p);
  }), d = k(
    () => l.value,
    (v) => {
      r(), c.value && v.size && (i = new MutationObserver(t), v.forEach((p) => i.observe(p, u)));
    },
    { immediate: !0, flush: "post" }
  ), a = () => i == null ? void 0 : i.takeRecords(), s = () => {
    d(), r();
  };
  return z(s), {
    isSupported: c,
    stop: s,
    takeRecords: a
  };
}
const ze = Symbol("vueuse-ssr-width");
function Ne() {
  const e = le() ? Ee(ze, null) : null;
  return typeof e == "number" ? e : void 0;
}
function Be(e, t = {}) {
  const { window: o = P, ssrWidth: n = Ne() } = t, u = G(() => o && "matchMedia" in o && typeof o.matchMedia == "function"), i = y(typeof n == "number"), c = y(), r = y(!1), l = (d) => {
    r.value = d.matches;
  };
  return Te(() => {
    if (i.value) {
      i.value = !u.value;
      const d = b(e).split(",");
      r.value = d.some((a) => {
        const s = a.includes("not all"), v = a.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), p = a.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let w = !!(v || p);
        return v && w && (w = n >= te(v[1])), p && w && (w = n <= te(p[1])), s ? !w : w;
      });
      return;
    }
    u.value && (c.value = o.matchMedia(b(e)), r.value = c.value.matches);
  }), M(c, "change", l, { passive: !0 }), F(() => r.value);
}
function de(e, t, o = {}) {
  const { window: n = P, ...u } = o;
  let i;
  const c = G(() => n && "ResizeObserver" in n), r = () => {
    i && (i.disconnect(), i = void 0);
  }, l = F(() => {
    const s = b(e);
    return Array.isArray(s) ? s.map((v) => T(v)) : [T(s)];
  }), d = k(
    l,
    (s) => {
      if (r(), c.value && n) {
        i = new ResizeObserver(t);
        for (const v of s)
          v && i.observe(v, u);
      }
    },
    { immediate: !0, flush: "post" }
  ), a = () => {
    r(), d();
  };
  return z(a), {
    isSupported: c,
    stop: a
  };
}
function qe(e, t = {}) {
  const {
    reset: o = !0,
    windowResize: n = !0,
    windowScroll: u = !0,
    immediate: i = !0,
    updateTiming: c = "sync"
  } = t, r = y(0), l = y(0), d = y(0), a = y(0), s = y(0), v = y(0), p = y(0), w = y(0);
  function S() {
    const h = T(e);
    if (!h) {
      o && (r.value = 0, l.value = 0, d.value = 0, a.value = 0, s.value = 0, v.value = 0, p.value = 0, w.value = 0);
      return;
    }
    const g = h.getBoundingClientRect();
    r.value = g.height, l.value = g.bottom, d.value = g.left, a.value = g.right, s.value = g.top, v.value = g.width, p.value = g.x, w.value = g.y;
  }
  function f() {
    c === "sync" ? S() : c === "next-frame" && requestAnimationFrame(() => S());
  }
  return de(e, f), k(() => T(e), (h) => !h && f()), fe(e, f, {
    attributeFilter: ["style", "class"]
  }), u && M("scroll", f, { capture: !0, passive: !0 }), n && M("resize", f, { passive: !0 }), N(() => {
    i && f();
  }), {
    height: r,
    bottom: l,
    left: d,
    right: a,
    top: s,
    width: v,
    x: p,
    y: w,
    update: f
  };
}
function Je(e, t = { width: 0, height: 0 }, o = {}) {
  const { window: n = P, box: u = "content-box" } = o, i = F(() => {
    var s, v;
    return (v = (s = T(e)) == null ? void 0 : s.namespaceURI) == null ? void 0 : v.includes("svg");
  }), c = y(t.width), r = y(t.height), { stop: l } = de(
    e,
    ([s]) => {
      const v = u === "border-box" ? s.borderBoxSize : u === "content-box" ? s.contentBoxSize : s.devicePixelContentBoxSize;
      if (n && i.value) {
        const p = T(e);
        if (p) {
          const w = p.getBoundingClientRect();
          c.value = w.width, r.value = w.height;
        }
      } else if (v) {
        const p = R(v);
        c.value = p.reduce((w, { inlineSize: S }) => w + S, 0), r.value = p.reduce((w, { blockSize: S }) => w + S, 0);
      } else
        c.value = s.contentRect.width, r.value = s.contentRect.height;
    },
    o
  );
  N(() => {
    const s = T(e);
    s && (c.value = "offsetWidth" in s ? s.offsetWidth : t.width, r.value = "offsetHeight" in s ? s.offsetHeight : t.height);
  });
  const d = k(
    () => T(e),
    (s) => {
      c.value = s ? t.width : 0, r.value = s ? t.height : 0;
    }
  );
  function a() {
    l(), d();
  }
  return {
    width: c,
    height: r,
    stop: a
  };
}
const je = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function $e(e) {
  if (!e)
    return null;
  if (e instanceof FileList)
    return e;
  const t = new DataTransfer();
  for (const o of e)
    t.items.add(o);
  return t.files;
}
function Ke(e = {}) {
  const {
    document: t = Ve
  } = e, o = se($e(e.initialFiles)), { on: n, trigger: u } = ee(), { on: i, trigger: c } = ee();
  let r;
  t && (r = T(e.input) || t.createElement("input"), r.type = "file", r.onchange = (a) => {
    const s = a.target;
    o.value = s.files, u(o.value);
  }, r.oncancel = () => {
    c();
  });
  const l = () => {
    o.value = null, r && r.value && (r.value = "", u(null));
  }, d = (a) => {
    if (!r)
      return;
    const s = {
      ...je,
      ...e,
      ...a
    };
    r.multiple = s.multiple, r.accept = s.accept, r.webkitdirectory = s.directory, Ie(s, "capture") && (r.capture = s.capture), s.reset && l(), r.click();
  };
  return {
    files: Oe(o),
    open: d,
    reset: l,
    onCancel: i,
    onChange: n
  };
}
const oe = 1;
function Ze(e, t = {}) {
  const {
    throttle: o = 0,
    idle: n = 200,
    onStop: u = W,
    onScroll: i = W,
    offset: c = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    observe: r = {
      mutation: !1
    },
    eventListenerOptions: l = {
      capture: !1,
      passive: !0
    },
    behavior: d = "auto",
    window: a = P,
    onError: s = (m) => {
      console.error(m);
    }
  } = t, v = typeof r == "boolean" ? {
    mutation: r
  } : r, p = y(0), w = y(0), S = F({
    get() {
      return p.value;
    },
    set(m) {
      h(m, void 0);
    }
  }), f = F({
    get() {
      return w.value;
    },
    set(m) {
      h(void 0, m);
    }
  });
  function h(m, _) {
    var x, D, C, H;
    if (!a)
      return;
    const I = b(e);
    if (!I)
      return;
    (C = I instanceof Document ? a.document.body : I) == null || C.scrollTo({
      top: (x = b(_)) != null ? x : f.value,
      left: (D = b(m)) != null ? D : S.value,
      behavior: b(d)
    });
    const A = ((H = I == null ? void 0 : I.document) == null ? void 0 : H.documentElement) || (I == null ? void 0 : I.documentElement) || I;
    S != null && (p.value = A.scrollLeft), f != null && (w.value = A.scrollTop);
  }
  const g = y(!1), O = Z({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), E = Z({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), X = (m) => {
    g.value && (g.value = !1, E.left = !1, E.right = !1, E.top = !1, E.bottom = !1, u(m));
  }, pe = ke(X, o + n), V = (m) => {
    var _;
    if (!a)
      return;
    const x = ((_ = m == null ? void 0 : m.document) == null ? void 0 : _.documentElement) || (m == null ? void 0 : m.documentElement) || T(m), { display: D, flexDirection: C, direction: H } = getComputedStyle(x), I = H === "rtl" ? -1 : 1, A = x.scrollLeft;
    E.left = A < p.value, E.right = A > p.value;
    const U = Math.abs(A * I) <= (c.left || 0), q = Math.abs(A * I) + x.clientWidth >= x.scrollWidth - (c.right || 0) - oe;
    D === "flex" && C === "row-reverse" ? (O.left = q, O.right = U) : (O.left = U, O.right = q), p.value = A;
    let L = x.scrollTop;
    m === a.document && !L && (L = a.document.body.scrollTop), E.top = L < w.value, E.bottom = L > w.value;
    const J = Math.abs(L) <= (c.top || 0), K = Math.abs(L) + x.clientHeight >= x.scrollHeight - (c.bottom || 0) - oe;
    D === "flex" && C === "column-reverse" ? (O.top = K, O.bottom = J) : (O.top = J, O.bottom = K), w.value = L;
  }, Q = (m) => {
    var _;
    if (!a)
      return;
    const x = (_ = m.target.documentElement) != null ? _ : m.target;
    V(x), g.value = !0, pe(m), i(m);
  };
  return M(
    e,
    "scroll",
    o ? De(Q, o, !0, !1) : Q,
    l
  ), N(() => {
    try {
      const m = b(e);
      if (!m)
        return;
      V(m);
    } catch (m) {
      s(m);
    }
  }), v != null && v.mutation && e != null && e !== a && e !== document && fe(
    e,
    () => {
      const m = b(e);
      m && V(m);
    },
    {
      attributes: !0,
      childList: !0,
      subtree: !0
    }
  ), M(
    e,
    "scrollend",
    X,
    l
  ), {
    x: S,
    y: f,
    isScrolling: g,
    arrivedState: O,
    directions: E,
    measure() {
      const m = b(e);
      a && m && V(m);
    }
  };
}
const ve = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
}, Ye = /* @__PURE__ */ Object.keys(ve);
function et(e = {}) {
  const {
    target: t = P
  } = e, o = y(!1), n = se(e.initialValue || {});
  Object.assign(n.value, ve, n.value);
  const u = (i) => {
    o.value = !0, !(e.pointerTypes && !e.pointerTypes.includes(i.pointerType)) && (n.value = _e(i, Ye, !1));
  };
  if (t) {
    const i = { passive: !0 };
    M(t, ["pointerdown", "pointermove", "pointerup"], u, i), M(t, "pointerleave", () => o.value = !1, i);
  }
  return {
    ...Ce(n),
    isInside: o
  };
}
function tt(e = {}) {
  const {
    window: t = P,
    initialWidth: o = Number.POSITIVE_INFINITY,
    initialHeight: n = Number.POSITIVE_INFINITY,
    listenOrientation: u = !0,
    includeScrollbar: i = !0,
    type: c = "inner"
  } = e, r = y(o), l = y(n), d = () => {
    if (t)
      if (c === "outer")
        r.value = t.outerWidth, l.value = t.outerHeight;
      else if (c === "visual" && t.visualViewport) {
        const { width: s, height: v, scale: p } = t.visualViewport;
        r.value = Math.round(s * p), l.value = Math.round(v * p);
      } else i ? (r.value = t.innerWidth, l.value = t.innerHeight) : (r.value = t.document.documentElement.clientWidth, l.value = t.document.documentElement.clientHeight);
  };
  d(), N(d);
  const a = { passive: !0 };
  if (M("resize", d, a), t && c === "visual" && t.visualViewport && M(t.visualViewport, "resize", d, a), u) {
    const s = Be("(orientation: portrait)");
    k(s, () => d());
  }
  return { width: r, height: l };
}
export {
  qe as a,
  T as b,
  tt as c,
  Ke as d,
  Je as e,
  Xe as f,
  M as g,
  Be as h,
  et as i,
  Ue as o,
  Ze as u,
  Qe as w
};
