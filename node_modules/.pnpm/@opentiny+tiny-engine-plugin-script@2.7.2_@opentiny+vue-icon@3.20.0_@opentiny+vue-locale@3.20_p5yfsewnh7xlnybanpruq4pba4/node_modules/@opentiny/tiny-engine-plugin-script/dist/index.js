import "./style.css";
import { callEntry as d, useCanvas as l, useNotify as f, useModal as v, useHelp as V, useLayout as I, useCompile as ne } from "@opentiny/tiny-engine-meta-register";
import { reactive as $, ref as re, nextTick as ee, watch as se, onActivated as ie, provide as ae, onBeforeUnmount as ce, resolveComponent as q, createBlock as le, openBlock as de, withCtx as K, createElementVNode as Q, createVNode as Z, withDirectives as me, vShow as pe, createTextVNode as ue } from "vue";
import { Button as ge } from "@opentiny/vue";
import { PluginPanel as J, VueMonaco as z } from "@opentiny/tiny-engine-common";
import { initCompletion as H } from "@opentiny/tiny-engine-common/js/completion";
import { lint as _, initLinter as G } from "@opentiny/tiny-engine-common/js/linter";
import { formatString as y, insertName as x, ast2String as E, string2Ast as S } from "@opentiny/tiny-engine-common/js/ast";
import { constants as j } from "@opentiny/tiny-engine-utils";
import { isFunction as D } from "@opentiny/vue-renderless/grid/static";
const te = {
  id: "engine.plugins.pagecontroller",
  title: "页面 JS",
  type: "plugins",
  icon: "plugin-icon-js",
  width: 600,
  widthResizable: !0,
  confirm: "close"
  // 当点击插件栏切换或关闭前是否需要确认, 会调用插件中confirm值指定的方法，e.g. 此处指向 close方法，会调用插件的close方法执行确认逻辑
}, {
  SCHEMA_DATA_TYPE: M
} = j, r = $({
  linterWorker: null,
  script: "",
  isChanged: !1,
  hasError: !1,
  editorSelection: null,
  completionProvider: null,
  // 记录当前是否已经有弹窗，防止使用 ctrl + s 的时候重复弹窗
  hasErrorPopup: !1
}), c = re(null);
let m = null;
const i = d(() => {
  var e, o;
  const t = ((o = (e = l()).getSchema) == null ? void 0 : o.call(e)) || {};
  return t.methods = (t == null ? void 0 : t.methods) || {}, t.methods;
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.getMethods"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), p = d(() => l().pageState.pageSchema && Object.keys(i()) || [], {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.getMethodNameList"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), L = d(() => Object.values(i()).map((t) => t.value), {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.getMethodContentList"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), h = d(() => {
  const e = Object.entries(i()).map(([o, n]) => x(o, n.value)).join(`
`);
  try {
    m = S(e);
  } catch (o) {
    f({
      type: "error",
      message: `代码静态检查有错误：${o}`
    });
  }
  return e;
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.getScriptString"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), w = d((t) => {
  const e = /\r\n/g;
  if (r.isChanged = t.replace(e, `
`) !== r.script.replace(e, `
`), !c.value)
    return;
  const o = c.value.getEditor().getModel();
  _(o, r.linterWorker);
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.change"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), u = d(({
  name: t,
  content: e
}) => {
  if (!t)
    return;
  const o = i(), n = {
    type: M.JSFunction,
    value: e
  };
  l().updateSchema({
    methods: {
      ...o,
      [t]: n
    }
  });
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.saveMethod"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), C = d(async () => {
  const {
    message: t
  } = v();
  if (!r.isChanged || r.hasErrorPopup)
    return !1;
  if (r.hasError)
    return r.hasErrorPopup = !0, t({
      status: "error",
      message: "代码静态检查有错误，请先修改后再保存",
      exec: () => {
        r.hasErrorPopup = !1;
      }
    }), !1;
  const e = c.value.getEditor().getValue(), o = S(e), n = {};
  o.program.body.forEach((s, N) => {
    var U, W;
    const k = (U = s == null ? void 0 : s.id) == null ? void 0 : U.name;
    (W = o.program.body[N + 1]) != null && W.leadingComments && s.trailingComments === o.program.body[N + 1].leadingComments && delete s.trailingComments;
    const T = y(E(s).trim(), "javascript");
    k && (n[k] = {
      type: M.JSFunction,
      value: T
    });
  }), l().updateSchema({
    methods: n
  }), l().setSaved(!1);
  const a = h();
  return r.script = "", await ee(), r.script = a, r.isChanged = !1, f({
    type: "success",
    message: "保存成功！"
  }), !0;
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.saveMethods"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), P = d((t) => (e) => {
  const {
    confirm: o
  } = v(), n = D(e) ? e : () => t("close");
  if (!r.isChanged) {
    n(!0);
    return;
  }
  o({
    title: "提示",
    message: "有改动未保存，您确定保存并关闭吗？",
    exec() {
      n(C());
    },
    cancel() {
      n(!0);
    }
  });
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.close"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), b = d(() => {
  if (!r.editorSelection || !c.value)
    return;
  const t = c.value.getEditor();
  t.setSelection(r.editorSelection), t.focus();
  const e = t.getTopForLineNumber(r.editorSelection.startLineNumber - 1);
  t.setScrollPosition({
    scrollLeft: 0,
    scrollTop: e
  }, 0);
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.setEditorSelection"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), g = d((t) => {
  var n;
  if (!t)
    return;
  const e = m == null ? void 0 : m.program.body.filter((a) => {
    var s;
    return t === ((s = a == null ? void 0 : a.id) == null ? void 0 : s.name);
  });
  if (e.length === 0)
    return;
  const o = (n = e[0]) == null ? void 0 : n.loc;
  o && (r.editorSelection = {
    startColumn: o.start.column,
    startLineNumber: o.start.line,
    endColumn: o.end.column + 1,
    endLineNumber: o.end.line
  }), r.editorSelection && b();
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.highlightMethod"
  },
  ctx: () => ({
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
}), R = ({
  emit: t
}) => (se(h, (e) => {
  r.script = e;
}), ie(d(() => {
  ee(() => {
    var e;
    r.script = h(), (e = c.value) == null || e.focus(), window.dispatchEvent(new Event("resize"));
  });
}, {
  metaData: {
    id: "engine.plugins.pagecontroller.js-method.onActivated[0]"
  },
  ctx: () => ({
    emit: t,
    useCanvas: l,
    useModal: v,
    useNotify: f,
    string2Ast: S,
    ast2String: E,
    insertName: x,
    formatString: y,
    constants: j,
    lint: _,
    isFunction: D,
    SCHEMA_DATA_TYPE: M,
    state: r,
    monaco: c,
    scriptAst: m,
    getMethods: i,
    getMethodNameList: p,
    getMethodContentList: L,
    getScriptString: h,
    change: w,
    saveMethod: u,
    saveMethods: C,
    close: P,
    setEditorSelection: b,
    highlightMethod: g
  })
})), {
  state: r,
  monaco: c,
  change: w,
  saveMethods: C,
  close: P(t)
}), Y = {
  saveMethod: u,
  highlightMethod: g,
  getMethodNameList: p,
  getMethods: i
}, he = {
  components: {
    MonacoEditor: z,
    TinyButton: ge,
    PluginPanel: J
  },
  props: {
    fixedPanels: {
      type: Array
    }
  },
  emits: ["close"],
  setup(t, {
    emit: e
  }) {
    const o = V().getDocsUrl("script"), n = "同一页面/区块的添加事件会统一保存到对应的页面JS中。", {
      state: a,
      monaco: s,
      change: N,
      close: k,
      saveMethods: T
    } = R({
      emit: e
    }), {
      PLUGIN_NAME: U
    } = I(), W = $({
      emitEvent: e
    });
    ae("panelState", W);
    const B = {
      language: "javascript",
      minimap: {
        enabled: !1
      },
      placeholder: `// ✅ 函数声明可以保存
       function topLevelFunction(){ 
      ​ ​ const message = 'hello tiny-engine.' 
      ​ ​ console.log(message) 
      } 
 
      // ❌ 顶层/常规 变量声明 
 const someVariable = 42 
      // ❌ 表达式 
 const result = someVariable + 10`,
      // 禁用滚动条边边一直显示的边框
      overviewRulerBorder: !1,
      renderLineHighlightOnlyWhenFocus: !0,
      tabSize: 2,
      insertSpaces: !0,
      formatOnPaste: !0,
      formatOnType: !0,
      autoIndent: "full",
      newLineCharacter: `
`,
      convertTabsToSpaces: !0,
      trimAutoWhitespace: !0,
      wordWrap: "on",
      wordWrapColumn: 120,
      wordWrapMinChars: 10,
      wordWrapStrategy: "advanced"
    }, F = d((O) => {
      var A;
      s.value && (a.completionProvider = H(s.value.getMonaco(), (A = s.value.getEditor()) == null ? void 0 : A.getModel()), a.linterWorker = G(O, s.value.getMonaco(), a));
    }, {
      metaData: {
        id: "engine.plugins.pagecontroller.Main.editorDidMount"
      },
      ctx: () => ({
        props: t,
        emit: e,
        docsUrl: o,
        docsContent: n,
        state: a,
        monaco: s,
        change: N,
        close: k,
        saveMethods: T,
        PLUGIN_NAME: U,
        panelState: W,
        options: B,
        editorDidMount: F,
        VueMonaco: z,
        PluginPanel: J,
        useHelp: V,
        useLayout: I,
        initCompletion: H,
        initLinter: G,
        useMethod: R,
        saveMethod: u,
        highlightMethod: g,
        getMethodNameList: p,
        getMethods: i,
        api: Y
      })
    });
    return ce(d(d(() => {
      var O, A, X;
      (O = a.completionProvider) == null || O.forEach((oe) => {
        oe.dispose();
      }), (X = (A = a.linterWorker) == null ? void 0 : A.terminate) == null || X.call(A);
    }, {
      metaData: {
        id: "engine.plugins.pagecontroller.Main.onBeforeUnmount[0]"
      },
      ctx: () => ({
        props: t,
        emit: e,
        docsUrl: o,
        docsContent: n,
        state: a,
        monaco: s,
        change: N,
        close: k,
        saveMethods: T,
        PLUGIN_NAME: U,
        panelState: W,
        options: B,
        editorDidMount: F,
        VueMonaco: z,
        PluginPanel: J,
        useHelp: V,
        useLayout: I,
        initCompletion: H,
        initLinter: G,
        useMethod: R,
        saveMethod: u,
        highlightMethod: g,
        getMethodNameList: p,
        getMethods: i,
        api: Y
      })
    }), {
      metaData: {
        id: "engine.plugins.pagecontroller.Main.onBeforeUnmount[0]"
      },
      ctx: () => ({
        props: t,
        emit: e,
        docsUrl: o,
        docsContent: n,
        state: a,
        monaco: s,
        change: N,
        close: k,
        saveMethods: T,
        PLUGIN_NAME: U,
        panelState: W,
        options: B,
        editorDidMount: F,
        _callEntry: d,
        _useCompile: ne,
        _metaData: te,
        VueMonaco: z,
        PluginPanel: J,
        useHelp: V,
        useLayout: I,
        initCompletion: H,
        initLinter: G,
        useMethod: R,
        saveMethod: u,
        highlightMethod: g,
        getMethodNameList: p,
        getMethods: i,
        api: Y
      })
    })), {
      PLUGIN_NAME: U,
      state: a,
      monaco: s,
      options: B,
      close: k,
      change: N,
      saveMethods: T,
      editorDidMount: F,
      docsUrl: o,
      docsContent: n
    };
  }
}, fe = (t, e) => {
  const o = t.__vccOpts || t;
  for (const [n, a] of e)
    o[n] = a;
  return o;
}, ve = { class: "icon-wrap" }, Se = { class: "red" }, Me = { class: "code-edit-content" };
function Ce(t, e, o, n, a, s) {
  const N = q("tiny-button"), k = q("monaco-editor"), T = q("plugin-panel");
  return de(), le(T, {
    title: "页面 JS",
    "fixed-name": n.PLUGIN_NAME.Page,
    fixedPanels: o.fixedPanels,
    docsUrl: n.docsUrl,
    docsContent: n.docsContent,
    isShowDocsIcon: !0,
    onClose: e[0] || (e[0] = (U) => t.$emit("close")),
    class: "plugin-page-js-container plugin-script"
  }, {
    header: K(() => [
      Q("span", ve, [
        me(Q("i", Se, null, 512), [
          [pe, n.state.isChanged]
        ]),
        Z(N, {
          type: "primary",
          onClick: n.saveMethods
        }, {
          default: K(() => e[1] || (e[1] = [
            ue("保存", -1)
          ])),
          _: 1,
          __: [1]
        }, 8, ["onClick"])
      ])
    ]),
    content: K(() => [
      Q("div", Me, [
        Z(k, {
          ref: "monaco",
          value: n.state.script,
          options: n.options,
          onChange: n.change,
          onEditorDidMount: n.editorDidMount,
          onShortcutSave: n.saveMethods
        }, null, 8, ["value", "options", "onChange", "onEditorDidMount", "onShortcutSave"])
      ])
    ]),
    _: 1
  }, 8, ["fixed-name", "fixedPanels", "docsUrl", "docsContent"]);
}
const _e = /* @__PURE__ */ fe(he, [["render", Ce], ["__scopeId", "data-v-83d0244f"]]), ke = {
  ...te,
  apis: Y,
  entry: _e
};
export {
  ke as default
};
//# sourceMappingURL=index.js.map
