import "./style.css";
import { getMergeMeta as O, useLayout as ve, usePage as We, callEntry as M, META_APP as w, getMergeMetaByType as yt, getMetaApi as ce, HOOK_NAME as _i } from "@opentiny/tiny-engine-meta-register";
import { computed as Sn, resolveComponent as Ce, createBlock as Ee, openBlock as A, withCtx as ht, createElementVNode as _e, createElementBlock as ye, Fragment as Ge, renderList as ze, createCommentVNode as Ue, resolveDynamicComponent as ke, createVNode as lt, defineComponent as bi, h as Mn, ref as nt, reactive as En, watch as Kt, normalizeStyle as wi, withModifiers as Et, normalizeClass as $e, withDirectives as dn, KeepAlive as Si, vShow as gn, unref as Ei, readonly as Pi, getCurrentScope as Di, onScopeDispose as xi, shallowRef as Oi, nextTick as Pn } from "vue";
import { constants as G, utils as de } from "@opentiny/tiny-engine-utils";
import { Popover as $n, Tooltip as Ii, TabItem as Li, Tabs as Mi, ConfigProvider as Ni } from "@opentiny/vue";
import { IconPopup as Ci } from "@opentiny/vue-icon";
import { PublicIcon as He, PluginRightMenu as xe } from "@opentiny/tiny-engine-common";
import Ai from "@opentiny/vue-design-smb";
const _t = {
  id: "engine.layout",
  type: "layout"
}, {
  OPEN_DELAY: Ti
} = G, Fi = {
  components: {
    TinyPopover: $n,
    IconPopup: Ci()
  },
  props: {
    collapseBar: {
      type: Array,
      default: () => []
    }
  },
  setup(t) {
    const e = Sn(() => t.collapseBar.map((n) => {
      if (typeof n == "string")
        return n;
      if (Array.isArray(n)) {
        const o = n.filter((r) => {
          var a;
          return (a = O(r)) == null ? void 0 : a.entry;
        });
        return o.length > 0 ? o : null;
      }
      return n;
    }).filter((n) => !!n));
    return {
      getMergeMeta: O,
      OPEN_DELAY: Ti,
      renderCollapseBar: e
    };
  }
}, Lt = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [n, o] of e)
    i[n] = o;
  return i;
}, ki = { class: "toolbar-ellipsis" }, Ri = { class: "collapse-content" }, Bi = {
  key: 0,
  class: "toolbar-list-button"
}, Gi = { key: 1 };
function Ui(t, e, i, n, o, r) {
  const a = Ce("svg-icon"), l = Ce("tiny-popover");
  return A(), Ee(l, {
    "visible-arrow": !1,
    width: "248",
    trigger: "click",
    "open-delay": n.OPEN_DELAY.Default
  }, {
    reference: ht(() => [
      _e("span", ki, [
        lt(a, { name: "ellipsis" })
      ])
    ]),
    default: ht(() => [
      _e("div", Ri, [
        (A(!0), ye(Ge, null, ze(n.renderCollapseBar, (s, u) => {
          var d;
          return A(), ye("div", {
            class: "empty-bar",
            key: u
          }, [
            typeof s == "string" ? (A(), ye("div", Bi, [
              (A(), Ee(ke((d = n.getMergeMeta(s)) == null ? void 0 : d.entry), {
                options: n.getMergeMeta(s).options,
                position: "collapse"
              }, null, 8, ["options"]))
            ])) : Ue("", !0),
            Array.isArray(s) ? (A(), ye("div", Gi, [
              (A(!0), ye(Ge, null, ze(s, (c) => {
                var g, m;
                return A(), ye("div", {
                  class: "toolbar-list-button",
                  key: c
                }, [
                  (A(), Ee(ke((g = n.getMergeMeta(c)) == null ? void 0 : g.entry), {
                    options: (m = n.getMergeMeta(c)) == null ? void 0 : m.options,
                    position: "collapse"
                  }, null, 8, ["options"]))
                ]);
              }), 128)),
              e[0] || (e[0] = _e("div", { class: "empty-line" }, null, -1))
            ])) : Ue("", !0)
          ]);
        }), 128))
      ])
    ]),
    _: 1
  }, 8, ["open-delay"]);
}
const ji = /* @__PURE__ */ Lt(Fi, [["render", Ui]]), Xi = {
  components: {
    ToolbarCollapse: ji
  },
  props: {
    layoutRegistry: {
      type: Object,
      default: () => ({})
    }
  },
  setup() {
    const {
      getFinalLayoutConfig: t
    } = ve(), e = Sn(() => t().toolbars);
    return {
      getMergeMeta: O,
      toolbars: e
    };
  }
}, Yi = { class: "tiny-engine-toolbar" }, Vi = { class: "toolbar-left" }, Wi = { class: "toolbar-center" }, Hi = { class: "toolbar-right" }, zi = { class: "toolbar-right-content" }, Qi = { key: 0 }, Ji = {
  key: 1,
  class: "toolbar-right-item-arr"
}, qi = {
  key: 0,
  class: "toolbar-right-line"
};
function Ki(t, e, i, n, o, r) {
  var l;
  const a = Ce("toolbar-collapse");
  return A(), ye("div", Yi, [
    _e("div", Vi, [
      (A(!0), ye(Ge, null, ze(n.toolbars.left, (s) => {
        var u, d;
        return A(), Ee(ke((u = n.getMergeMeta(s)) == null ? void 0 : u.entry), {
          key: s,
          options: (d = n.getMergeMeta(s)) == null ? void 0 : d.options
        }, null, 8, ["options"]);
      }), 128))
    ]),
    _e("div", Wi, [
      (A(!0), ye(Ge, null, ze(n.toolbars.center, (s) => {
        var u, d;
        return A(), Ee(ke((u = n.getMergeMeta(s)) == null ? void 0 : u.entry), {
          key: s,
          options: (d = n.getMergeMeta(s)) == null ? void 0 : d.options
        }, null, 8, ["options"]);
      }), 128))
    ]),
    _e("div", Hi, [
      _e("div", zi, [
        (A(!0), ye(Ge, null, ze(n.toolbars.right, (s, u) => {
          var d, c, g;
          return A(), ye("div", {
            class: "toolbar-right-item",
            key: u
          }, [
            typeof s == "string" ? (A(), ye("div", Qi, [
              (A(), Ee(ke((d = n.getMergeMeta(s)) == null ? void 0 : d.entry), {
                options: (c = n.getMergeMeta(s)) == null ? void 0 : c.options,
                position: "right"
              }, null, 8, ["options"]))
            ])) : Ue("", !0),
            Array.isArray(s) ? (A(), ye("div", Ji, [
              (A(!0), ye(Ge, null, ze(s, (m) => {
                var p, v;
                return A(), ye("div", {
                  class: "toolbar-right-item-comp",
                  key: m
                }, [
                  (A(), Ee(ke((p = n.getMergeMeta(m)) == null ? void 0 : p.entry), {
                    options: (v = n.getMergeMeta(m)) == null ? void 0 : v.options,
                    position: "right"
                  }, null, 8, ["options"]))
                ]);
              }), 128)),
              (g = i.layoutRegistry.options) != null && g.isShowLine ? (A(), ye("span", qi, "|")) : Ue("", !0)
            ])) : Ue("", !0)
          ]);
        }), 128))
      ]),
      (l = i.layoutRegistry.options) != null && l.isShowCollapse ? (A(), Ee(a, {
        key: 0,
        collapseBar: n.toolbars.collapse
      }, null, 8, ["collapseBar"])) : Ue("", !0)
    ])
  ]);
}
const At = /* @__PURE__ */ Lt(Xi, [["render", Ki], ["__scopeId", "data-v-09f0b215"]]);
/*!
  * vue-draggable-next v2.2.0
  * (c) 2023 Anish George
  * @license MIT
  */
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function Nn(t, e) {
  var i = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Ye(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nn(Object(i), !0).forEach(function(n) {
      Zi(t, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : Nn(Object(i)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return t;
}
function Ut(t) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ut = function(e) {
    return typeof e;
  } : Ut = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ut(t);
}
function Zi(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}
function Je() {
  return Je = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
    }
    return t;
  }, Je.apply(this, arguments);
}
function $i(t, e) {
  if (t == null) return {};
  var i = {}, n = Object.keys(t), o, r;
  for (r = 0; r < n.length; r++)
    o = n[r], !(e.indexOf(o) >= 0) && (i[o] = t[o]);
  return i;
}
function eo(t, e) {
  if (t == null) return {};
  var i = $i(t, e), n, o;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    for (o = 0; o < r.length; o++)
      n = r[o], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n]);
  }
  return i;
}
var to = "1.14.0";
function Qe(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var qe = Qe(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), Mt = Qe(/Edge/i), Cn = Qe(/firefox/i), Pt = Qe(/safari/i) && !Qe(/chrome/i) && !Qe(/android/i), ei = Qe(/iP(ad|od|hone)/i), no = Qe(/chrome/i) && Qe(/android/i), ti = {
  capture: !1,
  passive: !1
};
function me(t, e, i) {
  t.addEventListener(e, i, !qe && ti);
}
function pe(t, e, i) {
  t.removeEventListener(e, i, !qe && ti);
}
function Wt(t, e) {
  if (e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function io(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function je(t, e, i, n) {
  if (t) {
    i = i || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === i && Wt(t, e) : Wt(t, e)) || n && t === i)
        return t;
      if (t === i) break;
    } while (t = io(t));
  }
  return null;
}
var An = /\s+/g;
function Ae(t, e, i) {
  if (t && e)
    if (t.classList)
      t.classList[i ? "add" : "remove"](e);
    else {
      var n = (" " + t.className + " ").replace(An, " ").replace(" " + e + " ", " ");
      t.className = (n + (i ? " " + e : "")).replace(An, " ");
    }
}
function N(t, e, i) {
  var n = t && t.style;
  if (n) {
    if (i === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? i = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (i = t.currentStyle), e === void 0 ? i : i[e];
    !(e in n) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), n[e] = i + (typeof i == "string" ? "" : "px");
  }
}
function ft(t, e) {
  var i = "";
  if (typeof t == "string")
    i = t;
  else
    do {
      var n = N(t, "transform");
      n && n !== "none" && (i = n + " " + i);
    } while (!e && (t = t.parentNode));
  var o = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return o && new o(i);
}
function ni(t, e, i) {
  if (t) {
    var n = t.getElementsByTagName(e), o = 0, r = n.length;
    if (i)
      for (; o < r; o++)
        i(n[o], o);
    return n;
  }
  return [];
}
function Xe() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function De(t, e, i, n, o) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var r, a, l, s, u, d, c;
    if (t !== window && t.parentNode && t !== Xe() ? (r = t.getBoundingClientRect(), a = r.top, l = r.left, s = r.bottom, u = r.right, d = r.height, c = r.width) : (a = 0, l = 0, s = window.innerHeight, u = window.innerWidth, d = window.innerHeight, c = window.innerWidth), (e || i) && t !== window && (o = o || t.parentNode, !qe))
      do
        if (o && o.getBoundingClientRect && (N(o, "transform") !== "none" || i && N(o, "position") !== "static")) {
          var g = o.getBoundingClientRect();
          a -= g.top + parseInt(N(o, "border-top-width")), l -= g.left + parseInt(N(o, "border-left-width")), s = a + r.height, u = l + r.width;
          break;
        }
      while (o = o.parentNode);
    if (n && t !== window) {
      var m = ft(o || t), p = m && m.a, v = m && m.d;
      m && (a /= v, l /= p, c /= p, d /= v, s = a + d, u = l + c);
    }
    return {
      top: a,
      left: l,
      bottom: s,
      right: u,
      width: c,
      height: d
    };
  }
}
function Tn(t, e, i) {
  for (var n = tt(t, !0), o = De(t)[e]; n; ) {
    var r = De(n)[i], a = void 0;
    if (a = o >= r, !a) return n;
    if (n === Xe()) break;
    n = tt(n, !1);
  }
  return !1;
}
function pt(t, e, i, n) {
  for (var o = 0, r = 0, a = t.children; r < a.length; ) {
    if (a[r].style.display !== "none" && a[r] !== C.ghost && (n || a[r] !== C.dragged) && je(a[r], i.draggable, t, !1)) {
      if (o === e)
        return a[r];
      o++;
    }
    r++;
  }
  return null;
}
function Dn(t, e) {
  for (var i = t.lastElementChild; i && (i === C.ghost || N(i, "display") === "none" || e && !Wt(i, e)); )
    i = i.previousElementSibling;
  return i || null;
}
function Re(t, e) {
  var i = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== C.clone && (!e || Wt(t, e)) && i++;
  return i;
}
function Fn(t) {
  var e = 0, i = 0, n = Xe();
  if (t)
    do {
      var o = ft(t), r = o.a, a = o.d;
      e += t.scrollLeft * r, i += t.scrollTop * a;
    } while (t !== n && (t = t.parentNode));
  return [e, i];
}
function oo(t, e) {
  for (var i in t)
    if (t.hasOwnProperty(i)) {
      for (var n in e)
        if (e.hasOwnProperty(n) && e[n] === t[i][n]) return Number(i);
    }
  return -1;
}
function tt(t, e) {
  if (!t || !t.getBoundingClientRect) return Xe();
  var i = t, n = !1;
  do
    if (i.clientWidth < i.scrollWidth || i.clientHeight < i.scrollHeight) {
      var o = N(i);
      if (i.clientWidth < i.scrollWidth && (o.overflowX == "auto" || o.overflowX == "scroll") || i.clientHeight < i.scrollHeight && (o.overflowY == "auto" || o.overflowY == "scroll")) {
        if (!i.getBoundingClientRect || i === document.body) return Xe();
        if (n || e) return i;
        n = !0;
      }
    }
  while (i = i.parentNode);
  return Xe();
}
function ro(t, e) {
  if (t && e)
    for (var i in e)
      e.hasOwnProperty(i) && (t[i] = e[i]);
  return t;
}
function $t(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var Dt;
function ii(t, e) {
  return function() {
    if (!Dt) {
      var i = arguments, n = this;
      i.length === 1 ? t.call(n, i[0]) : t.apply(n, i), Dt = setTimeout(function() {
        Dt = void 0;
      }, e);
    }
  };
}
function ao() {
  clearTimeout(Dt), Dt = void 0;
}
function oi(t, e, i) {
  t.scrollLeft += e, t.scrollTop += i;
}
function ri(t) {
  var e = window.Polymer, i = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : i ? i(t).clone(!0)[0] : t.cloneNode(!0);
}
var Fe = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function so() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var n = [].slice.call(this.el.children);
        n.forEach(function(o) {
          if (!(N(o, "display") === "none" || o === C.ghost)) {
            t.push({
              target: o,
              rect: De(o)
            });
            var r = Ye({}, t[t.length - 1].rect);
            if (o.thisAnimationDuration) {
              var a = ft(o, !0);
              a && (r.top -= a.f, r.left -= a.e);
            }
            o.fromRect = r;
          }
        });
      }
    },
    addAnimationState: function(n) {
      t.push(n);
    },
    removeAnimationState: function(n) {
      t.splice(oo(t, {
        target: n
      }), 1);
    },
    animateAll: function(n) {
      var o = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof n == "function" && n();
        return;
      }
      var r = !1, a = 0;
      t.forEach(function(l) {
        var s = 0, u = l.target, d = u.fromRect, c = De(u), g = u.prevFromRect, m = u.prevToRect, p = l.rect, v = ft(u, !0);
        v && (c.top -= v.f, c.left -= v.e), u.toRect = c, u.thisAnimationDuration && $t(g, c) && !$t(d, c) && // Make sure animatingRect is on line between toRect & fromRect
        (p.top - c.top) / (p.left - c.left) === (d.top - c.top) / (d.left - c.left) && (s = uo(p, g, m, o.options)), $t(c, d) || (u.prevFromRect = d, u.prevToRect = c, s || (s = o.options.animation), o.animate(u, p, c, s)), s && (r = !0, a = Math.max(a, s), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, s), u.thisAnimationDuration = s);
      }), clearTimeout(e), r ? e = setTimeout(function() {
        typeof n == "function" && n();
      }, a) : typeof n == "function" && n(), t = [];
    },
    animate: function(n, o, r, a) {
      if (a) {
        N(n, "transition", ""), N(n, "transform", "");
        var l = ft(this.el), s = l && l.a, u = l && l.d, d = (o.left - r.left) / (s || 1), c = (o.top - r.top) / (u || 1);
        n.animatingX = !!d, n.animatingY = !!c, N(n, "transform", "translate3d(" + d + "px," + c + "px,0)"), this.forRepaintDummy = lo(n), N(n, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), N(n, "transform", "translate3d(0,0,0)"), typeof n.animated == "number" && clearTimeout(n.animated), n.animated = setTimeout(function() {
          N(n, "transition", ""), N(n, "transform", ""), n.animated = !1, n.animatingX = !1, n.animatingY = !1;
        }, a);
      }
    }
  };
}
function lo(t) {
  return t.offsetWidth;
}
function uo(t, e, i, n) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - i.top, 2) + Math.pow(e.left - i.left, 2)) * n.animation;
}
var ut = [], en = {
  initializeByDefault: !0
}, Nt = {
  mount: function(e) {
    for (var i in en)
      en.hasOwnProperty(i) && !(i in e) && (e[i] = en[i]);
    ut.forEach(function(n) {
      if (n.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), ut.push(e);
  },
  pluginEvent: function(e, i, n) {
    var o = this;
    this.eventCanceled = !1, n.cancel = function() {
      o.eventCanceled = !0;
    };
    var r = e + "Global";
    ut.forEach(function(a) {
      i[a.pluginName] && (i[a.pluginName][r] && i[a.pluginName][r](Ye({
        sortable: i
      }, n)), i.options[a.pluginName] && i[a.pluginName][e] && i[a.pluginName][e](Ye({
        sortable: i
      }, n)));
    });
  },
  initializePlugins: function(e, i, n, o) {
    ut.forEach(function(l) {
      var s = l.pluginName;
      if (!(!e.options[s] && !l.initializeByDefault)) {
        var u = new l(e, i, e.options);
        u.sortable = e, u.options = e.options, e[s] = u, Je(n, u.defaults);
      }
    });
    for (var r in e.options)
      if (e.options.hasOwnProperty(r)) {
        var a = this.modifyOption(e, r, e.options[r]);
        typeof a < "u" && (e.options[r] = a);
      }
  },
  getEventProperties: function(e, i) {
    var n = {};
    return ut.forEach(function(o) {
      typeof o.eventProperties == "function" && Je(n, o.eventProperties.call(i[o.pluginName], e));
    }), n;
  },
  modifyOption: function(e, i, n) {
    var o;
    return ut.forEach(function(r) {
      e[r.pluginName] && r.optionListeners && typeof r.optionListeners[i] == "function" && (o = r.optionListeners[i].call(e[r.pluginName], n));
    }), o;
  }
};
function co(t) {
  var e = t.sortable, i = t.rootEl, n = t.name, o = t.targetEl, r = t.cloneEl, a = t.toEl, l = t.fromEl, s = t.oldIndex, u = t.newIndex, d = t.oldDraggableIndex, c = t.newDraggableIndex, g = t.originalEvent, m = t.putSortable, p = t.extraEventProperties;
  if (e = e || i && i[Fe], !!e) {
    var v, b = e.options, P = "on" + n.charAt(0).toUpperCase() + n.substr(1);
    window.CustomEvent && !qe && !Mt ? v = new CustomEvent(n, {
      bubbles: !0,
      cancelable: !0
    }) : (v = document.createEvent("Event"), v.initEvent(n, !0, !0)), v.to = a || i, v.from = l || i, v.item = o || i, v.clone = r, v.oldIndex = s, v.newIndex = u, v.oldDraggableIndex = d, v.newDraggableIndex = c, v.originalEvent = g, v.pullMode = m ? m.lastPutMode : void 0;
    var D = Ye(Ye({}, p), Nt.getEventProperties(n, e));
    for (var x in D)
      v[x] = D[x];
    i && i.dispatchEvent(v), b[P] && b[P].call(e, v);
  }
}
var go = ["evt"], Ne = function(e, i) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = n.evt, r = eo(n, go);
  Nt.pluginEvent.bind(C)(e, i, Ye({
    dragEl: S,
    parentEl: we,
    ghostEl: k,
    rootEl: be,
    nextEl: st,
    lastDownEl: jt,
    cloneEl: Se,
    cloneHidden: et,
    dragStarted: bt,
    putSortable: Ie,
    activeSortable: C.active,
    originalEvent: o,
    oldIndex: gt,
    oldDraggableIndex: xt,
    newIndex: Te,
    newDraggableIndex: Ze,
    hideGhostForTarget: ui,
    unhideGhostForTarget: ci,
    cloneNowHidden: function() {
      et = !0;
    },
    cloneNowShown: function() {
      et = !1;
    },
    dispatchSortableEvent: function(l) {
      Me({
        sortable: i,
        name: l,
        originalEvent: o
      });
    }
  }, r));
};
function Me(t) {
  co(Ye({
    putSortable: Ie,
    cloneEl: Se,
    targetEl: S,
    rootEl: be,
    oldIndex: gt,
    oldDraggableIndex: xt,
    newIndex: Te,
    newDraggableIndex: Ze
  }, t));
}
var S, we, k, be, st, jt, Se, et, gt, Te, xt, Ze, Tt, Ie, dt = !1, Ht = !1, zt = [], rt, Be, tn, nn, kn, Rn, bt, ct, Ot, It = !1, Ft = !1, Xt, Le, on = [], fn = !1, Qt = [], Zt = typeof document < "u", kt = ei, Bn = Mt || qe ? "cssFloat" : "float", fo = Zt && !no && !ei && "draggable" in document.createElement("div"), ai = function() {
  if (Zt) {
    if (qe)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), si = function(e, i) {
  var n = N(e), o = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth), r = pt(e, 0, i), a = pt(e, 1, i), l = r && N(r), s = a && N(a), u = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + De(r).width, d = s && parseInt(s.marginLeft) + parseInt(s.marginRight) + De(a).width;
  if (n.display === "flex")
    return n.flexDirection === "column" || n.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (n.display === "grid")
    return n.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (r && l.float && l.float !== "none") {
    var c = l.float === "left" ? "left" : "right";
    return a && (s.clear === "both" || s.clear === c) ? "vertical" : "horizontal";
  }
  return r && (l.display === "block" || l.display === "flex" || l.display === "table" || l.display === "grid" || u >= o && n[Bn] === "none" || a && n[Bn] === "none" && u + d > o) ? "vertical" : "horizontal";
}, ho = function(e, i, n) {
  var o = n ? e.left : e.top, r = n ? e.right : e.bottom, a = n ? e.width : e.height, l = n ? i.left : i.top, s = n ? i.right : i.bottom, u = n ? i.width : i.height;
  return o === l || r === s || o + a / 2 === l + u / 2;
}, po = function(e, i) {
  var n;
  return zt.some(function(o) {
    var r = o[Fe].options.emptyInsertThreshold;
    if (!(!r || Dn(o))) {
      var a = De(o), l = e >= a.left - r && e <= a.right + r, s = i >= a.top - r && i <= a.bottom + r;
      if (l && s)
        return n = o;
    }
  }), n;
}, li = function(e) {
  function i(r, a) {
    return function(l, s, u, d) {
      var c = l.options.group.name && s.options.group.name && l.options.group.name === s.options.group.name;
      if (r == null && (a || c))
        return !0;
      if (r == null || r === !1)
        return !1;
      if (a && r === "clone")
        return r;
      if (typeof r == "function")
        return i(r(l, s, u, d), a)(l, s, u, d);
      var g = (a ? l : s).options.group.name;
      return r === !0 || typeof r == "string" && r === g || r.join && r.indexOf(g) > -1;
    };
  }
  var n = {}, o = e.group;
  (!o || Ut(o) != "object") && (o = {
    name: o
  }), n.name = o.name, n.checkPull = i(o.pull, !0), n.checkPut = i(o.put), n.revertClone = o.revertClone, e.group = n;
}, ui = function() {
  !ai && k && N(k, "display", "none");
}, ci = function() {
  !ai && k && N(k, "display", "");
};
Zt && document.addEventListener("click", function(t) {
  if (Ht)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), Ht = !1, !1;
}, !0);
var at = function(e) {
  if (S) {
    e = e.touches ? e.touches[0] : e;
    var i = po(e.clientX, e.clientY);
    if (i) {
      var n = {};
      for (var o in e)
        e.hasOwnProperty(o) && (n[o] = e[o]);
      n.target = n.rootEl = i, n.preventDefault = void 0, n.stopPropagation = void 0, i[Fe]._onDragOver(n);
    }
  }
}, mo = function(e) {
  S && S.parentNode[Fe]._isOutsideThisEl(e.target);
};
function C(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Je({}, e), t[Fe] = this;
  var i = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return si(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, l) {
      a.setData("Text", l.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: C.supportPointer !== !1 && "PointerEvent" in window && !Pt,
    emptyInsertThreshold: 5
  };
  Nt.initializePlugins(this, t, i);
  for (var n in i)
    !(n in e) && (e[n] = i[n]);
  li(e);
  for (var o in this)
    o.charAt(0) === "_" && typeof this[o] == "function" && (this[o] = this[o].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : fo, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? me(t, "pointerdown", this._onTapStart) : (me(t, "mousedown", this._onTapStart), me(t, "touchstart", this._onTapStart)), this.nativeDraggable && (me(t, "dragover", this), me(t, "dragenter", this)), zt.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Je(this, so());
}
C.prototype = /** @lends Sortable.prototype */
{
  constructor: C,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (ct = null);
  },
  _getDirection: function(e, i) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, i, S) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (e.cancelable) {
      var i = this, n = this.el, o = this.options, r = o.preventOnFilter, a = e.type, l = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, s = (l || e).target, u = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || s, d = o.filter;
      if (Po(n), !S && !(/mousedown|pointerdown/.test(a) && e.button !== 0 || o.disabled) && !u.isContentEditable && !(!this.nativeDraggable && Pt && s && s.tagName.toUpperCase() === "SELECT") && (s = je(s, o.draggable, n, !1), !(s && s.animated) && jt !== s)) {
        if (gt = Re(s), xt = Re(s, o.draggable), typeof d == "function") {
          if (d.call(this, e, s, this)) {
            Me({
              sortable: i,
              rootEl: u,
              name: "filter",
              targetEl: s,
              toEl: n,
              fromEl: n
            }), Ne("filter", i, {
              evt: e
            }), r && e.cancelable && e.preventDefault();
            return;
          }
        } else if (d && (d = d.split(",").some(function(c) {
          if (c = je(u, c.trim(), n, !1), c)
            return Me({
              sortable: i,
              rootEl: c,
              name: "filter",
              targetEl: s,
              fromEl: n,
              toEl: n
            }), Ne("filter", i, {
              evt: e
            }), !0;
        }), d)) {
          r && e.cancelable && e.preventDefault();
          return;
        }
        o.handle && !je(u, o.handle, n, !1) || this._prepareDragStart(e, l, s);
      }
    }
  },
  _prepareDragStart: function(e, i, n) {
    var o = this, r = o.el, a = o.options, l = r.ownerDocument, s;
    if (n && !S && n.parentNode === r) {
      var u = De(n);
      if (be = r, S = n, we = S.parentNode, st = S.nextSibling, jt = n, Tt = a.group, C.dragged = S, rt = {
        target: S,
        clientX: (i || e).clientX,
        clientY: (i || e).clientY
      }, kn = rt.clientX - u.left, Rn = rt.clientY - u.top, this._lastX = (i || e).clientX, this._lastY = (i || e).clientY, S.style["will-change"] = "all", s = function() {
        if (Ne("delayEnded", o, {
          evt: e
        }), C.eventCanceled) {
          o._onDrop();
          return;
        }
        o._disableDelayedDragEvents(), !Cn && o.nativeDraggable && (S.draggable = !0), o._triggerDragStart(e, i), Me({
          sortable: o,
          name: "choose",
          originalEvent: e
        }), Ae(S, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(d) {
        ni(S, d.trim(), rn);
      }), me(l, "dragover", at), me(l, "mousemove", at), me(l, "touchmove", at), me(l, "mouseup", o._onDrop), me(l, "touchend", o._onDrop), me(l, "touchcancel", o._onDrop), Cn && this.nativeDraggable && (this.options.touchStartThreshold = 4, S.draggable = !0), Ne("delayStart", this, {
        evt: e
      }), a.delay && (!a.delayOnTouchOnly || i) && (!this.nativeDraggable || !(Mt || qe))) {
        if (C.eventCanceled) {
          this._onDrop();
          return;
        }
        me(l, "mouseup", o._disableDelayedDrag), me(l, "touchend", o._disableDelayedDrag), me(l, "touchcancel", o._disableDelayedDrag), me(l, "mousemove", o._delayedDragTouchMoveHandler), me(l, "touchmove", o._delayedDragTouchMoveHandler), a.supportPointer && me(l, "pointermove", o._delayedDragTouchMoveHandler), o._dragStartTimer = setTimeout(s, a.delay);
      } else
        s();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var i = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(i.clientX - this._lastX), Math.abs(i.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    S && rn(S), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    pe(e, "mouseup", this._disableDelayedDrag), pe(e, "touchend", this._disableDelayedDrag), pe(e, "touchcancel", this._disableDelayedDrag), pe(e, "mousemove", this._delayedDragTouchMoveHandler), pe(e, "touchmove", this._delayedDragTouchMoveHandler), pe(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, i) {
    i = i || e.pointerType == "touch" && e, !this.nativeDraggable || i ? this.options.supportPointer ? me(document, "pointermove", this._onTouchMove) : i ? me(document, "touchmove", this._onTouchMove) : me(document, "mousemove", this._onTouchMove) : (me(S, "dragend", this), me(be, "dragstart", this._onDragStart));
    try {
      document.selection ? Yt(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, i) {
    if (dt = !1, be && S) {
      Ne("dragStarted", this, {
        evt: i
      }), this.nativeDraggable && me(document, "dragover", mo);
      var n = this.options;
      !e && Ae(S, n.dragClass, !1), Ae(S, n.ghostClass, !0), C.active = this, e && this._appendGhost(), Me({
        sortable: this,
        name: "start",
        originalEvent: i
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Be) {
      this._lastX = Be.clientX, this._lastY = Be.clientY, ui();
      for (var e = document.elementFromPoint(Be.clientX, Be.clientY), i = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Be.clientX, Be.clientY), e !== i); )
        i = e;
      if (S.parentNode[Fe]._isOutsideThisEl(e), i)
        do {
          if (i[Fe]) {
            var n = void 0;
            if (n = i[Fe]._onDragOver({
              clientX: Be.clientX,
              clientY: Be.clientY,
              target: e,
              rootEl: i
            }), n && !this.options.dragoverBubble)
              break;
          }
          e = i;
        } while (i = i.parentNode);
      ci();
    }
  },
  _onTouchMove: function(e) {
    if (rt) {
      var i = this.options, n = i.fallbackTolerance, o = i.fallbackOffset, r = e.touches ? e.touches[0] : e, a = k && ft(k, !0), l = k && a && a.a, s = k && a && a.d, u = kt && Le && Fn(Le), d = (r.clientX - rt.clientX + o.x) / (l || 1) + (u ? u[0] - on[0] : 0) / (l || 1), c = (r.clientY - rt.clientY + o.y) / (s || 1) + (u ? u[1] - on[1] : 0) / (s || 1);
      if (!C.active && !dt) {
        if (n && Math.max(Math.abs(r.clientX - this._lastX), Math.abs(r.clientY - this._lastY)) < n)
          return;
        this._onDragStart(e, !0);
      }
      if (k) {
        a ? (a.e += d - (tn || 0), a.f += c - (nn || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: d,
          f: c
        };
        var g = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        N(k, "webkitTransform", g), N(k, "mozTransform", g), N(k, "msTransform", g), N(k, "transform", g), tn = d, nn = c, Be = r;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!k) {
      var e = this.options.fallbackOnBody ? document.body : be, i = De(S, !0, kt, !0, e), n = this.options;
      if (kt) {
        for (Le = e; N(Le, "position") === "static" && N(Le, "transform") === "none" && Le !== document; )
          Le = Le.parentNode;
        Le !== document.body && Le !== document.documentElement ? (Le === document && (Le = Xe()), i.top += Le.scrollTop, i.left += Le.scrollLeft) : Le = Xe(), on = Fn(Le);
      }
      k = S.cloneNode(!0), Ae(k, n.ghostClass, !1), Ae(k, n.fallbackClass, !0), Ae(k, n.dragClass, !0), N(k, "transition", ""), N(k, "transform", ""), N(k, "box-sizing", "border-box"), N(k, "margin", 0), N(k, "top", i.top), N(k, "left", i.left), N(k, "width", i.width), N(k, "height", i.height), N(k, "opacity", "0.8"), N(k, "position", kt ? "absolute" : "fixed"), N(k, "zIndex", "100000"), N(k, "pointerEvents", "none"), C.ghost = k, e.appendChild(k), N(k, "transform-origin", kn / parseInt(k.style.width) * 100 + "% " + Rn / parseInt(k.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, i) {
    var n = this, o = e.dataTransfer, r = n.options;
    if (Ne("dragStart", this, {
      evt: e
    }), C.eventCanceled) {
      this._onDrop();
      return;
    }
    Ne("setupClone", this), C.eventCanceled || (Se = ri(S), Se.draggable = !1, Se.style["will-change"] = "", this._hideClone(), Ae(Se, this.options.chosenClass, !1), C.clone = Se), n.cloneId = Yt(function() {
      Ne("clone", n), !C.eventCanceled && (n.options.removeCloneOnHide || be.insertBefore(Se, S), n._hideClone(), Me({
        sortable: n,
        name: "clone"
      }));
    }), !i && Ae(S, r.dragClass, !0), i ? (Ht = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (pe(document, "mouseup", n._onDrop), pe(document, "touchend", n._onDrop), pe(document, "touchcancel", n._onDrop), o && (o.effectAllowed = "move", r.setData && r.setData.call(n, o, S)), me(document, "drop", n), N(S, "transform", "translateZ(0)")), dt = !0, n._dragStartId = Yt(n._dragStarted.bind(n, i, e)), me(document, "selectstart", n), bt = !0, Pt && N(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(e) {
    var i = this.el, n = e.target, o, r, a, l = this.options, s = l.group, u = C.active, d = Tt === s, c = l.sort, g = Ie || u, m, p = this, v = !1;
    if (fn) return;
    function b(vt, vi) {
      Ne(vt, p, Ye({
        evt: e,
        isOwner: d,
        axis: m ? "vertical" : "horizontal",
        revert: a,
        dragRect: o,
        targetRect: r,
        canSort: c,
        fromSortable: g,
        target: n,
        completed: D,
        onMove: function(Ln, yi) {
          return Rt(be, i, S, o, Ln, De(Ln), e, yi);
        },
        changed: x
      }, vi));
    }
    function P() {
      b("dragOverAnimationCapture"), p.captureAnimationState(), p !== g && g.captureAnimationState();
    }
    function D(vt) {
      return b("dragOverCompleted", {
        insertion: vt
      }), vt && (d ? u._hideClone() : u._showClone(p), p !== g && (Ae(S, Ie ? Ie.options.ghostClass : u.options.ghostClass, !1), Ae(S, l.ghostClass, !0)), Ie !== p && p !== C.active ? Ie = p : p === C.active && Ie && (Ie = null), g === p && (p._ignoreWhileAnimating = n), p.animateAll(function() {
        b("dragOverAnimationComplete"), p._ignoreWhileAnimating = null;
      }), p !== g && (g.animateAll(), g._ignoreWhileAnimating = null)), (n === S && !S.animated || n === i && !n.animated) && (ct = null), !l.dragoverBubble && !e.rootEl && n !== document && (S.parentNode[Fe]._isOutsideThisEl(e.target), !vt && at(e)), !l.dragoverBubble && e.stopPropagation && e.stopPropagation(), v = !0;
    }
    function x() {
      Te = Re(S), Ze = Re(S, l.draggable), Me({
        sortable: p,
        name: "change",
        toEl: i,
        newIndex: Te,
        newDraggableIndex: Ze,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), n = je(n, l.draggable, i, !0), b("dragOver"), C.eventCanceled) return v;
    if (S.contains(e.target) || n.animated && n.animatingX && n.animatingY || p._ignoreWhileAnimating === n)
      return D(!1);
    if (Ht = !1, u && !l.disabled && (d ? c || (a = we !== be) : Ie === this || (this.lastPutMode = Tt.checkPull(this, u, S, e)) && s.checkPut(this, u, S, e))) {
      if (m = this._getDirection(e, n) === "vertical", o = De(S), b("dragOverValid"), C.eventCanceled) return v;
      if (a)
        return we = be, P(), this._hideClone(), b("revert"), C.eventCanceled || (st ? be.insertBefore(S, st) : be.appendChild(S)), D(!0);
      var I = Dn(i, l.draggable);
      if (!I || bo(e, m, this) && !I.animated) {
        if (I === S)
          return D(!1);
        if (I && i === e.target && (n = I), n && (r = De(n)), Rt(be, i, S, o, n, r, e, !!n) !== !1)
          return P(), i.appendChild(S), we = i, x(), D(!0);
      } else if (I && _o(e, m, this)) {
        var f = pt(i, 0, l, !0);
        if (f === S)
          return D(!1);
        if (n = f, r = De(n), Rt(be, i, S, o, n, r, e, !1) !== !1)
          return P(), i.insertBefore(S, f), we = i, x(), D(!0);
      } else if (n.parentNode === i) {
        r = De(n);
        var y = 0, h, _ = S.parentNode !== i, E = !ho(S.animated && S.toRect || o, n.animated && n.toRect || r, m), F = m ? "top" : "left", T = Tn(n, "top", "top") || Tn(S, "top", "top"), it = T ? T.scrollTop : void 0;
        ct !== n && (h = r[F], It = !1, Ft = !E && l.invertSwap || _), y = wo(e, n, r, m, E ? 1 : l.swapThreshold, l.invertedSwapThreshold == null ? l.swapThreshold : l.invertedSwapThreshold, Ft, ct === n);
        var Ve;
        if (y !== 0) {
          var ot = Re(S);
          do
            ot -= y, Ve = we.children[ot];
          while (Ve && (N(Ve, "display") === "none" || Ve === k));
        }
        if (y === 0 || Ve === n)
          return D(!1);
        ct = n, Ot = y;
        var mt = n.nextElementSibling, Ke = !1;
        Ke = y === 1;
        var Ct = Rt(be, i, S, o, n, r, e, Ke);
        if (Ct !== !1)
          return (Ct === 1 || Ct === -1) && (Ke = Ct === 1), fn = !0, setTimeout(yo, 30), P(), Ke && !mt ? i.appendChild(S) : n.parentNode.insertBefore(S, Ke ? mt : n), T && oi(T, 0, it - T.scrollTop), we = S.parentNode, h !== void 0 && !Ft && (Xt = Math.abs(h - De(n)[F])), x(), D(!0);
      }
      if (i.contains(S))
        return D(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    pe(document, "mousemove", this._onTouchMove), pe(document, "touchmove", this._onTouchMove), pe(document, "pointermove", this._onTouchMove), pe(document, "dragover", at), pe(document, "mousemove", at), pe(document, "touchmove", at);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    pe(e, "mouseup", this._onDrop), pe(e, "touchend", this._onDrop), pe(e, "pointerup", this._onDrop), pe(e, "touchcancel", this._onDrop), pe(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var i = this.el, n = this.options;
    if (Te = Re(S), Ze = Re(S, n.draggable), Ne("drop", this, {
      evt: e
    }), we = S && S.parentNode, Te = Re(S), Ze = Re(S, n.draggable), C.eventCanceled) {
      this._nulling();
      return;
    }
    dt = !1, Ft = !1, It = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), hn(this.cloneId), hn(this._dragStartId), this.nativeDraggable && (pe(document, "drop", this), pe(i, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Pt && N(document.body, "user-select", ""), N(S, "transform", ""), e && (bt && (e.cancelable && e.preventDefault(), !n.dropBubble && e.stopPropagation()), k && k.parentNode && k.parentNode.removeChild(k), (be === we || Ie && Ie.lastPutMode !== "clone") && Se && Se.parentNode && Se.parentNode.removeChild(Se), S && (this.nativeDraggable && pe(S, "dragend", this), rn(S), S.style["will-change"] = "", bt && !dt && Ae(S, Ie ? Ie.options.ghostClass : this.options.ghostClass, !1), Ae(S, this.options.chosenClass, !1), Me({
      sortable: this,
      name: "unchoose",
      toEl: we,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), be !== we ? (Te >= 0 && (Me({
      rootEl: we,
      name: "add",
      toEl: we,
      fromEl: be,
      originalEvent: e
    }), Me({
      sortable: this,
      name: "remove",
      toEl: we,
      originalEvent: e
    }), Me({
      rootEl: we,
      name: "sort",
      toEl: we,
      fromEl: be,
      originalEvent: e
    }), Me({
      sortable: this,
      name: "sort",
      toEl: we,
      originalEvent: e
    })), Ie && Ie.save()) : Te !== gt && Te >= 0 && (Me({
      sortable: this,
      name: "update",
      toEl: we,
      originalEvent: e
    }), Me({
      sortable: this,
      name: "sort",
      toEl: we,
      originalEvent: e
    })), C.active && ((Te == null || Te === -1) && (Te = gt, Ze = xt), Me({
      sortable: this,
      name: "end",
      toEl: we,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Ne("nulling", this), be = S = we = k = st = Se = jt = et = rt = Be = bt = Te = Ze = gt = xt = ct = Ot = Ie = Tt = C.dragged = C.ghost = C.clone = C.active = null, Qt.forEach(function(e) {
      e.checked = !0;
    }), Qt.length = tn = nn = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        S && (this._onDragOver(e), vo(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var e = [], i, n = this.el.children, o = 0, r = n.length, a = this.options; o < r; o++)
      i = n[o], je(i, a.draggable, this.el, !1) && e.push(i.getAttribute(a.dataIdAttr) || Eo(i));
    return e;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(e, i) {
    var n = {}, o = this.el;
    this.toArray().forEach(function(r, a) {
      var l = o.children[a];
      je(l, this.options.draggable, o, !1) && (n[r] = l);
    }, this), i && this.captureAnimationState(), e.forEach(function(r) {
      n[r] && (o.removeChild(n[r]), o.appendChild(n[r]));
    }), i && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(e, i) {
    return je(e, i || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(e, i) {
    var n = this.options;
    if (i === void 0)
      return n[e];
    var o = Nt.modifyOption(this, e, i);
    typeof o < "u" ? n[e] = o : n[e] = i, e === "group" && li(n);
  },
  /**
   * Destroy
   */
  destroy: function() {
    Ne("destroy", this);
    var e = this.el;
    e[Fe] = null, pe(e, "mousedown", this._onTapStart), pe(e, "touchstart", this._onTapStart), pe(e, "pointerdown", this._onTapStart), this.nativeDraggable && (pe(e, "dragover", this), pe(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(i) {
      i.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), zt.splice(zt.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!et) {
      if (Ne("hideClone", this), C.eventCanceled) return;
      N(Se, "display", "none"), this.options.removeCloneOnHide && Se.parentNode && Se.parentNode.removeChild(Se), et = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (et) {
      if (Ne("showClone", this), C.eventCanceled) return;
      S.parentNode == be && !this.options.group.revertClone ? be.insertBefore(Se, S) : st ? be.insertBefore(Se, st) : be.appendChild(Se), this.options.group.revertClone && this.animate(S, Se), N(Se, "display", ""), et = !1;
    }
  }
};
function vo(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function Rt(t, e, i, n, o, r, a, l) {
  var s, u = t[Fe], d = u.options.onMove, c;
  return window.CustomEvent && !qe && !Mt ? s = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (s = document.createEvent("Event"), s.initEvent("move", !0, !0)), s.to = e, s.from = t, s.dragged = i, s.draggedRect = n, s.related = o || e, s.relatedRect = r || De(e), s.willInsertAfter = l, s.originalEvent = a, t.dispatchEvent(s), d && (c = d.call(u, s, a)), c;
}
function rn(t) {
  t.draggable = !1;
}
function yo() {
  fn = !1;
}
function _o(t, e, i) {
  var n = De(pt(i.el, 0, i.options, !0)), o = 10;
  return e ? t.clientX < n.left - o || t.clientY < n.top && t.clientX < n.right : t.clientY < n.top - o || t.clientY < n.bottom && t.clientX < n.left;
}
function bo(t, e, i) {
  var n = De(Dn(i.el, i.options.draggable)), o = 10;
  return e ? t.clientX > n.right + o || t.clientX <= n.right && t.clientY > n.bottom && t.clientX >= n.left : t.clientX > n.right && t.clientY > n.top || t.clientX <= n.right && t.clientY > n.bottom + o;
}
function wo(t, e, i, n, o, r, a, l) {
  var s = n ? t.clientY : t.clientX, u = n ? i.height : i.width, d = n ? i.top : i.left, c = n ? i.bottom : i.right, g = !1;
  if (!a) {
    if (l && Xt < u * o) {
      if (!It && (Ot === 1 ? s > d + u * r / 2 : s < c - u * r / 2) && (It = !0), It)
        g = !0;
      else if (Ot === 1 ? s < d + Xt : s > c - Xt)
        return -Ot;
    } else if (s > d + u * (1 - o) / 2 && s < c - u * (1 - o) / 2)
      return So(e);
  }
  return g = g || a, g && (s < d + u * r / 2 || s > c - u * r / 2) ? s > d + u / 2 ? 1 : -1 : 0;
}
function So(t) {
  return Re(S) < Re(t) ? 1 : -1;
}
function Eo(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, i = e.length, n = 0; i--; )
    n += e.charCodeAt(i);
  return n.toString(36);
}
function Po(t) {
  Qt.length = 0;
  for (var e = t.getElementsByTagName("input"), i = e.length; i--; ) {
    var n = e[i];
    n.checked && Qt.push(n);
  }
}
function Yt(t) {
  return setTimeout(t, 0);
}
function hn(t) {
  return clearTimeout(t);
}
Zt && me(document, "touchmove", function(t) {
  (C.active || dt) && t.cancelable && t.preventDefault();
});
C.utils = {
  on: me,
  off: pe,
  css: N,
  find: ni,
  is: function(e, i) {
    return !!je(e, i, e, !1);
  },
  extend: ro,
  throttle: ii,
  closest: je,
  toggleClass: Ae,
  clone: ri,
  index: Re,
  nextTick: Yt,
  cancelNextTick: hn,
  detectDirection: si,
  getChild: pt
};
C.get = function(t) {
  return t[Fe];
};
C.mount = function() {
  for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
    e[i] = arguments[i];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(n) {
    if (!n.prototype || !n.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(n));
    n.utils && (C.utils = Ye(Ye({}, C.utils), n.utils)), Nt.mount(n);
  });
};
C.create = function(t, e) {
  return new C(t, e);
};
C.version = to;
var Pe = [], wt, pn, mn = !1, an, sn, Jt, St;
function Do() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(i) {
      var n = i.originalEvent;
      this.sortable.nativeDraggable ? me(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? me(document, "pointermove", this._handleFallbackAutoScroll) : n.touches ? me(document, "touchmove", this._handleFallbackAutoScroll) : me(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(i) {
      var n = i.originalEvent;
      !this.options.dragOverBubble && !n.rootEl && this._handleAutoScroll(n);
    },
    drop: function() {
      this.sortable.nativeDraggable ? pe(document, "dragover", this._handleAutoScroll) : (pe(document, "pointermove", this._handleFallbackAutoScroll), pe(document, "touchmove", this._handleFallbackAutoScroll), pe(document, "mousemove", this._handleFallbackAutoScroll)), Gn(), Vt(), ao();
    },
    nulling: function() {
      Jt = pn = wt = mn = St = an = sn = null, Pe.length = 0;
    },
    _handleFallbackAutoScroll: function(i) {
      this._handleAutoScroll(i, !0);
    },
    _handleAutoScroll: function(i, n) {
      var o = this, r = (i.touches ? i.touches[0] : i).clientX, a = (i.touches ? i.touches[0] : i).clientY, l = document.elementFromPoint(r, a);
      if (Jt = i, n || this.options.forceAutoScrollFallback || Mt || qe || Pt) {
        ln(i, this.options, l, n);
        var s = tt(l, !0);
        mn && (!St || r !== an || a !== sn) && (St && Gn(), St = setInterval(function() {
          var u = tt(document.elementFromPoint(r, a), !0);
          u !== s && (s = u, Vt()), ln(i, o.options, u, n);
        }, 10), an = r, sn = a);
      } else {
        if (!this.options.bubbleScroll || tt(l, !0) === Xe()) {
          Vt();
          return;
        }
        ln(i, this.options, tt(l, !1), !1);
      }
    }
  }, Je(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function Vt() {
  Pe.forEach(function(t) {
    clearInterval(t.pid);
  }), Pe = [];
}
function Gn() {
  clearInterval(St);
}
var ln = ii(function(t, e, i, n) {
  if (e.scroll) {
    var o = (t.touches ? t.touches[0] : t).clientX, r = (t.touches ? t.touches[0] : t).clientY, a = e.scrollSensitivity, l = e.scrollSpeed, s = Xe(), u = !1, d;
    pn !== i && (pn = i, Vt(), wt = e.scroll, d = e.scrollFn, wt === !0 && (wt = tt(i, !0)));
    var c = 0, g = wt;
    do {
      var m = g, p = De(m), v = p.top, b = p.bottom, P = p.left, D = p.right, x = p.width, I = p.height, f = void 0, y = void 0, h = m.scrollWidth, _ = m.scrollHeight, E = N(m), F = m.scrollLeft, T = m.scrollTop;
      m === s ? (f = x < h && (E.overflowX === "auto" || E.overflowX === "scroll" || E.overflowX === "visible"), y = I < _ && (E.overflowY === "auto" || E.overflowY === "scroll" || E.overflowY === "visible")) : (f = x < h && (E.overflowX === "auto" || E.overflowX === "scroll"), y = I < _ && (E.overflowY === "auto" || E.overflowY === "scroll"));
      var it = f && (Math.abs(D - o) <= a && F + x < h) - (Math.abs(P - o) <= a && !!F), Ve = y && (Math.abs(b - r) <= a && T + I < _) - (Math.abs(v - r) <= a && !!T);
      if (!Pe[c])
        for (var ot = 0; ot <= c; ot++)
          Pe[ot] || (Pe[ot] = {});
      (Pe[c].vx != it || Pe[c].vy != Ve || Pe[c].el !== m) && (Pe[c].el = m, Pe[c].vx = it, Pe[c].vy = Ve, clearInterval(Pe[c].pid), (it != 0 || Ve != 0) && (u = !0, Pe[c].pid = setInterval((function() {
        n && this.layer === 0 && C.active._onTouchMove(Jt);
        var mt = Pe[this.layer].vy ? Pe[this.layer].vy * l : 0, Ke = Pe[this.layer].vx ? Pe[this.layer].vx * l : 0;
        typeof d == "function" && d.call(C.dragged.parentNode[Fe], Ke, mt, t, Jt, Pe[this.layer].el) !== "continue" || oi(Pe[this.layer].el, Ke, mt);
      }).bind({
        layer: c
      }), 24))), c++;
    } while (e.bubbleScroll && g !== s && (g = tt(g, !1)));
    mn = u;
  }
}, 30), di = function(e) {
  var i = e.originalEvent, n = e.putSortable, o = e.dragEl, r = e.activeSortable, a = e.dispatchSortableEvent, l = e.hideGhostForTarget, s = e.unhideGhostForTarget;
  if (i) {
    var u = n || r;
    l();
    var d = i.changedTouches && i.changedTouches.length ? i.changedTouches[0] : i, c = document.elementFromPoint(d.clientX, d.clientY);
    s(), u && !u.el.contains(c) && (a("spill"), this.onSpill({
      dragEl: o,
      putSortable: n
    }));
  }
};
function xn() {
}
xn.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var i = e.oldDraggableIndex;
    this.startIndex = i;
  },
  onSpill: function(e) {
    var i = e.dragEl, n = e.putSortable;
    this.sortable.captureAnimationState(), n && n.captureAnimationState();
    var o = pt(this.sortable.el, this.startIndex, this.options);
    o ? this.sortable.el.insertBefore(i, o) : this.sortable.el.appendChild(i), this.sortable.animateAll(), n && n.animateAll();
  },
  drop: di
};
Je(xn, {
  pluginName: "revertOnSpill"
});
function On() {
}
On.prototype = {
  onSpill: function(e) {
    var i = e.dragEl, n = e.putSortable, o = n || this.sortable;
    o.captureAnimationState(), i.parentNode && i.parentNode.removeChild(i), o.animateAll();
  },
  drop: di
};
Je(On, {
  pluginName: "removeOnSpill"
});
C.mount(new Do());
C.mount(On, xn);
function xo() {
  return typeof window < "u" ? window.console : global.console;
}
const Oo = xo();
function Io(t) {
  const e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] || (e[n] = t(n));
  };
}
const Lo = /-(\w)/g, Un = Io((t) => t.replace(Lo, (e, i) => i ? i.toUpperCase() : ""));
function un(t) {
  t.parentElement !== null && t.parentElement.removeChild(t);
}
function jn(t, e, i) {
  const n = i === 0 ? t.children[0] : t.children[i - 1].nextSibling;
  t.insertBefore(e, n);
}
function Mo(t, e) {
  return Object.values(t).indexOf(e);
}
function No(t, e, i, n) {
  if (!t)
    return [];
  const o = Object.values(t), r = e.length - n;
  return [...e].map((l, s) => s >= r ? o.length : o.indexOf(l));
}
function gi(t, e) {
  this.$nextTick(() => this.$emit(t.toLowerCase(), e));
}
function Co(t) {
  return (e) => {
    this.realList !== null && this["onDrag" + t](e), gi.call(this, t, e);
  };
}
function Ao(t) {
  return ["transition-group", "TransitionGroup"].includes(t);
}
function To(t) {
  if (!t || t.length !== 1)
    return !1;
  const [{ type: e }] = t;
  return e ? Ao(e.name) : !1;
}
function Fo(t, e) {
  return e ? { ...e.props, ...e.attrs } : t;
}
const vn = ["Start", "Add", "Remove", "Update", "End"], yn = ["Choose", "Unchoose", "Sort", "Filter", "Clone"], ko = ["Move", ...vn, ...yn].map((t) => "on" + t);
let cn = null;
const Ro = {
  options: Object,
  list: {
    type: Array,
    required: !1,
    default: null
  },
  noTransitionOnDrag: {
    type: Boolean,
    default: !1
  },
  clone: {
    type: Function,
    default: (t) => t
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: !1,
    default: null
  },
  component: {
    type: String,
    default: null
  },
  modelValue: {
    type: Array,
    required: !1,
    default: null
  }
}, Oe = bi({
  name: "VueDraggableNext",
  inheritAttrs: !1,
  emits: [
    "update:modelValue",
    "move",
    "change",
    ...vn.map((t) => t.toLowerCase()),
    ...yn.map((t) => t.toLowerCase())
  ],
  props: Ro,
  data() {
    return {
      transitionMode: !1,
      noneFunctionalComponentMode: !1,
      headerOffset: 0,
      footerOffset: 0,
      _sortable: {},
      visibleIndexes: [],
      context: {}
    };
  },
  render() {
    const t = this.$slots.default ? this.$slots.default() : null, e = Fo(this.$attrs, this.componentData);
    return t ? (this.transitionMode = To(t), Mn(this.getTag(), e, t)) : Mn(this.getTag(), e, []);
  },
  created() {
    this.list !== null && this.modelValue !== null && Oo.error("list props are mutually exclusive! Please set one.");
  },
  mounted() {
    const t = {};
    vn.forEach((o) => {
      t["on" + o] = Co.call(this, o);
    }), yn.forEach((o) => {
      t["on" + o] = gi.bind(this, o);
    });
    const e = Object.keys(this.$attrs).reduce((o, r) => (o[Un(r)] = this.$attrs[r], o), {}), i = Object.assign({}, e, t, {
      onMove: (o, r) => this.onDragMove(o, r)
    });
    !("draggable" in i) && (i.draggable = ">*");
    const n = this.$el.nodeType === 1 ? this.$el : this.$el.parentElement;
    this._sortable = new C(n, i), n.__draggable_component__ = this, this.computeIndexes();
  },
  beforeUnmount() {
    try {
      this._sortable !== void 0 && this._sortable.destroy();
    } catch {
    }
  },
  computed: {
    realList() {
      return this.list ? this.list : this.modelValue;
    }
  },
  watch: {
    $attrs: {
      handler(t) {
        this.updateOptions(t);
      },
      deep: !0
    },
    realList() {
      this.computeIndexes();
    }
  },
  methods: {
    getTag() {
      return this.component ? Ce(this.component) : this.tag;
    },
    updateOptions(t) {
      for (var e in t) {
        const i = Un(e);
        ko.indexOf(i) === -1 && this._sortable.option(i, t[e]);
      }
    },
    getChildrenNodes() {
      return this.$el.children;
    },
    computeIndexes() {
      this.$nextTick(() => {
        this.visibleIndexes = No(this.getChildrenNodes(), this.$el.children, this.transitionMode, this.footerOffset);
      });
    },
    getUnderlyingVm(t) {
      const e = Mo(this.getChildrenNodes() || [], t);
      if (e === -1)
        return null;
      const i = this.realList[e];
      return { index: e, element: i };
    },
    emitChanges(t) {
      this.$nextTick(() => {
        this.$emit("change", t);
      });
    },
    alterList(t) {
      if (this.list) {
        t(this.list);
        return;
      }
      const e = [...this.modelValue];
      t(e), this.$emit("update:modelValue", e);
    },
    spliceList() {
      const t = (e) => e.splice(...arguments);
      this.alterList(t);
    },
    updatePosition(t, e) {
      const i = (n) => n.splice(e, 0, n.splice(t, 1)[0]);
      this.alterList(i);
    },
    getVmIndex(t) {
      const e = this.visibleIndexes, i = e.length;
      return t > i - 1 ? i : e[t];
    },
    getComponent() {
      return this.$slots.default ? (
        //@ts-ignore
        this.$slots.default()[0].componentInstance
      ) : null;
    },
    resetTransitionData(t) {
      if (!this.noTransitionOnDrag || !this.transitionMode)
        return;
      var e = this.getChildrenNodes();
      e[t].data = null;
      const i = this.getComponent();
      i.children = [], i.kept = void 0;
    },
    onDragStart(t) {
      this.computeIndexes(), this.context = this.getUnderlyingVm(t.item), this.context && (t.item._underlying_vm_ = this.clone(this.context.element), cn = t.item);
    },
    onDragAdd(t) {
      const e = t.item._underlying_vm_;
      if (e === void 0)
        return;
      un(t.item);
      const i = this.getVmIndex(t.newIndex);
      this.spliceList(i, 0, e), this.computeIndexes();
      const n = { element: e, newIndex: i };
      this.emitChanges({ added: n });
    },
    onDragRemove(t) {
      if (jn(this.$el, t.item, t.oldIndex), t.pullMode === "clone") {
        un(t.clone);
        return;
      }
      if (!this.context)
        return;
      const e = this.context.index;
      this.spliceList(e, 1);
      const i = { element: this.context.element, oldIndex: e };
      this.resetTransitionData(e), this.emitChanges({ removed: i });
    },
    onDragUpdate(t) {
      un(t.item), jn(t.from, t.item, t.oldIndex);
      const e = this.context.index, i = this.getVmIndex(t.newIndex);
      this.updatePosition(e, i);
      const n = { element: this.context.element, oldIndex: e, newIndex: i };
      this.emitChanges({ moved: n });
    },
    updateProperty(t, e) {
      t.hasOwnProperty(e) && (t[e] += this.headerOffset);
    },
    onDragMove(t, e) {
      const i = this.move;
      if (!i || !this.realList)
        return !0;
      const n = this.getRelatedContextFromMoveEvent(t), o = this.context, r = this.computeFutureIndex(n, t);
      Object.assign(o, { futureIndex: r });
      const a = Object.assign({}, t, {
        relatedContext: n,
        draggedContext: o
      });
      return i(a, e);
    },
    onDragEnd() {
      this.computeIndexes(), cn = null;
    },
    getTrargetedComponent(t) {
      return t.__draggable_component__;
    },
    getRelatedContextFromMoveEvent({ to: t, related: e }) {
      const i = this.getTrargetedComponent(t);
      if (!i)
        return { component: i };
      const n = i.realList, o = { list: n, component: i };
      if (t !== e && n && i.getUnderlyingVm) {
        const r = i.getUnderlyingVm(e);
        if (r)
          return Object.assign(r, o);
      }
      return o;
    },
    computeFutureIndex(t, e) {
      const i = [...e.to.children].filter((a) => a.style.display !== "none");
      if (i.length === 0)
        return 0;
      const n = i.indexOf(e.related), o = t.component.getVmIndex(n);
      return i.indexOf(cn) !== -1 || !e.willInsertAfter ? o : o + 1;
    }
  }
}), Bo = {
  components: {
    PluginRightMenu: xe,
    VueDraggableNext: Oe,
    TinyPopover: $n,
    TinyTooltip: Ii,
    PublicIcon: He
  },
  props: {
    renderPanel: {
      type: String,
      default: ""
    },
    plugins: {
      type: Array,
      default: () => []
    },
    pluginList: {
      type: Array,
      default: () => []
    }
  },
  emits: ["click", "node-click", "changeLeftAlign"],
  setup(t, {
    emit: e
  }) {
    const i = nt(null), {
      isTemporaryPage: n
    } = We(), o = ve().getPluginState(), {
      changeLeftFixedPanels: r,
      leftFixedPanelsStorage: a,
      getPluginById: l,
      getPluginShown: s,
      PLUGIN_POSITION: u,
      getMoveDragBarState: d,
      isSameSide: c,
      dragPluginLayout: g,
      getFinalLayoutConfig: m
    } = ve(), p = nt(null), v = M((h, _, E, F, T) => {
      _ ? p.value.showContextMenu(h.clientX, h.clientY, _, E, F, T) : p.value.showContextMenu(h.clientX, h.clientY, _);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.showContextMenu"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    }), b = En({
      prevIdex: -2,
      topNavLists: m().plugins.left.top,
      bottomNavLists: m().plugins.left.bottom
    }), P = M((h) => {
      const _ = l(t.pluginList, h), E = b.topNavLists.findIndex((F) => F.id === _.id);
      E !== -1 && b.topNavLists.splice(E, 1), b.topNavLists.unshift(_);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.changeAlign"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    }), D = M(({
      item: h,
      index: _
    }) => {
      var F;
      if (h.id === w.EditorHelp || h.id === w.Robot) return;
      b.prevIdex = _;
      const E = t.plugins.find((T) => T.id === t.renderPanel);
      if (t.renderPanel && (E != null && E.confirm)) {
        const T = M((it) => it && e("click", {
          item: h,
          navLists: h.align === "leftTop" ? b.topNavLists[_] : b.bottomNavLists[_]
        }), {
          metaData: {
            id: "engine.layout.DesignPlugins.confirmCallback"
          },
          ctx: () => ({
            confirmCallback: T,
            item: h,
            index: _,
            lastPlugin: E,
            props: t,
            emit: e,
            pluginRef: i,
            isTemporaryPage: n,
            pluginState: o,
            changeLeftFixedPanels: r,
            leftFixedPanelsStorage: a,
            getPluginById: l,
            getPluginShown: s,
            PLUGIN_POSITION: u,
            getMoveDragBarState: d,
            isSameSide: c,
            dragPluginLayout: g,
            getFinalLayoutConfig: m,
            rightMenu: p,
            showContextMenu: v,
            state: b,
            changeAlign: P,
            clickMenu: D,
            close: x,
            switchAlign: I,
            fixPanel: f,
            onEnd: y,
            VueDraggableNext: Oe,
            useLayout: ve,
            usePage: We,
            META_APP: w,
            getMergeMeta: O,
            PublicIcon: He,
            PluginRightMenu: xe
          })
        });
        (F = i.value) == null || F[E.confirm](T);
      } else
        e("click", {
          item: h,
          navLists: h.align === "leftTop" ? b.topNavLists[_] : b.bottomNavLists[_]
        });
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.clickMenu"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    });
    Kt(n, () => {
      var h, _;
      if (n.saved) {
        const E = ((h = b.topNavLists) == null ? void 0 : h.find((T) => T.id === w.AppManage)) || null, F = ((_ = b.topNavLists) == null ? void 0 : _.findIndex((T) => T.id === w.AppManage)) || -1;
        E !== t.renderPanel && D({
          item: E,
          index: F
        });
      }
    });
    const x = M(() => {
      b.prevIdex = -2, ve().closePlugin(!0);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.close"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    }), I = M((h, _, E) => {
      E === u.leftTop ? b.topNavLists.splice(h, 1) : b.bottomNavLists.splice(h, 1), e("changeLeftAlign", _), c(h, 0) || x(), g(E, u.rightTop, h, 0);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.switchAlign"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    }), f = M((h) => {
      r(h);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.fixPanel"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    }), y = M((h) => {
      c(h.from.id, h.to.id) || x(), g(h.from.id, h.to.id, h.oldIndex, h.newIndex);
    }, {
      metaData: {
        id: "engine.layout.DesignPlugins.onEnd"
      },
      ctx: () => ({
        props: t,
        emit: e,
        pluginRef: i,
        isTemporaryPage: n,
        pluginState: o,
        changeLeftFixedPanels: r,
        leftFixedPanelsStorage: a,
        getPluginById: l,
        getPluginShown: s,
        PLUGIN_POSITION: u,
        getMoveDragBarState: d,
        isSameSide: c,
        dragPluginLayout: g,
        getFinalLayoutConfig: m,
        rightMenu: p,
        showContextMenu: v,
        state: b,
        changeAlign: P,
        clickMenu: D,
        close: x,
        switchAlign: I,
        fixPanel: f,
        onEnd: y,
        VueDraggableNext: Oe,
        useLayout: ve,
        usePage: We,
        META_APP: w,
        getMergeMeta: O,
        PublicIcon: He,
        PluginRightMenu: xe
      })
    });
    return {
      leftFixedPanelsStorage: a,
      changeAlign: P,
      rightMenu: p,
      PLUGIN_POSITION: u,
      showContextMenu: v,
      switchAlign: I,
      getPluginShown: s,
      onEnd: y,
      state: b,
      clickMenu: D,
      pluginRef: i,
      close: x,
      fixPanel: f,
      pluginState: o,
      getMoveDragBarState: d,
      getMergeMeta: O
    };
  }
}, Go = ["title", "onClick", "onContextmenu"], Uo = { key: 0 }, jo = { class: "item-icon" }, Xo = { class: "nav-panel-lists bottom" }, Yo = ["title", "onClick", "onContextmenu"], Vo = { class: "item-icon" }, Wo = { class: "left-panel-wrap" };
function Ho(t, e, i, n, o, r) {
  var d, c;
  const a = Ce("svg-icon"), l = Ce("vue-draggable-next"), s = Ce("public-icon"), u = Ce("plugin-right-menu");
  return A(), ye(Ge, null, [
    _e("div", {
      id: "tiny-engine-nav-panel",
      style: wi({ "pointer-events": n.pluginState.pluginEvent })
    }, [
      lt(l, {
        modelValue: n.state.topNavLists,
        "onUpdate:modelValue": e[0] || (e[0] = (g) => n.state.topNavLists = g),
        filter: ".panel-icon",
        class: "nav-panel-lists top",
        id: "leftTop",
        group: "plugins",
        onEnd: n.onEnd
      }, {
        default: ht(() => [
          (A(!0), ye(Ge, null, ze(n.state.topNavLists, (g, m) => {
            var p, v, b, P;
            return A(), ye("div", {
              key: m,
              class: $e({
                "list-item": !0,
                active: g === i.renderPanel,
                prev: n.state.prevIdex - 1 === m
              }),
              title: (p = n.getMergeMeta(g)) == null ? void 0 : p.title,
              onClick: (D) => n.clickMenu({ item: n.getMergeMeta(g), index: m }),
              onContextmenu: Et((D) => n.showContextMenu(D, !0, g, m, n.PLUGIN_POSITION.leftTop), ["prevent"])
            }, [
              n.getPluginShown(g) ? (A(), ye("div", Uo, [
                _e("span", jo, [
                  typeof ((v = n.getMergeMeta(g)) == null ? void 0 : v.icon) == "string" ? (A(), Ee(a, {
                    key: 0,
                    name: (b = n.getMergeMeta(g)) == null ? void 0 : b.icon,
                    class: "panel-icon"
                  }, null, 8, ["name"])) : (A(), Ee(ke((P = n.getMergeMeta(g)) == null ? void 0 : P.icon), {
                    key: 1,
                    class: "panel-icon"
                  }))
                ])
              ])) : Ue("", !0)
            ], 42, Go);
          }), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "onEnd"]),
      _e("div", Xo, [
        _e("div", {
          style: { flex: "1" },
          class: "list-item",
          onContextmenu: e[1] || (e[1] = Et((g) => n.showContextMenu(g, !1), ["prevent"]))
        }, null, 32),
        lt(l, {
          id: "leftBottom",
          modelValue: n.state.bottomNavLists,
          "onUpdate:modelValue": e[2] || (e[2] = (g) => n.state.bottomNavLists = g),
          filter: ".panel-icon",
          group: "plugins",
          onEnd: n.onEnd
        }, {
          default: ht(() => [
            (A(!0), ye(Ge, null, ze(n.state.bottomNavLists, (g, m) => {
              var p, v, b, P;
              return A(), ye("div", {
                key: m,
                class: $e([
                  "list-item",
                  {
                    active: i.renderPanel === g,
                    prev: n.state.prevIdex - 1 === m
                  }
                ]),
                title: (p = n.getMergeMeta(g)) == null ? void 0 : p.title,
                onClick: (D) => n.clickMenu({ item: n.getMergeMeta(g), index: m }),
                onContextmenu: Et((D) => n.showContextMenu(D, !0, g, m, n.PLUGIN_POSITION.leftBottom), ["prevent"])
              }, [
                n.getPluginShown(g) ? (A(), ye("div", {
                  key: 0,
                  class: $e({ "is-show": i.renderPanel })
                }, [
                  _e("span", Vo, [
                    typeof ((v = n.getMergeMeta(g)) == null ? void 0 : v.icon) == "string" ? (A(), Ee(s, {
                      key: 0,
                      name: (b = n.getMergeMeta(g)) == null ? void 0 : b.icon,
                      class: "panel-icon",
                      svgClass: "panel-svg"
                    }, null, 8, ["name"])) : (A(), Ee(ke((P = n.getMergeMeta(g)) == null ? void 0 : P.icon), {
                      key: 1,
                      class: "panel-icon"
                    }))
                  ])
                ], 2)) : Ue("", !0)
              ], 42, Yo);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "onEnd"])
      ])
    ], 4),
    _e("div", {
      class: $e({ "not-selected": n.getMoveDragBarState() })
    }, [
      dn(_e("div", {
        id: "tiny-engine-left-panel",
        class: $e([i.renderPanel, { "is-fixed": n.leftFixedPanelsStorage.includes(i.renderPanel) }])
      }, [
        _e("div", Wo, [
          (A(), Ee(Si, null, [
            (A(), Ee(ke((d = n.getMergeMeta(i.renderPanel)) == null ? void 0 : d.entry), {
              ref: "pluginRef",
              "fixed-panels": n.leftFixedPanelsStorage,
              onClose: n.close,
              onFixPanel: n.fixPanel
            }, null, 40, ["fixed-panels", "onClose", "onFixPanel"]))
          ], 1024))
        ])
      ], 2), [
        [gn, i.renderPanel && ((c = n.getMergeMeta(i.renderPanel)) == null ? void 0 : c.entry)]
      ])
    ], 2),
    lt(u, {
      ref: "rightMenu",
      list: [...n.state.topNavLists, ...n.state.bottomNavLists],
      align: "left",
      onSwitchAlign: n.switchAlign
    }, null, 8, ["list", "onSwitchAlign"])
  ], 64);
}
const Bt = /* @__PURE__ */ Lt(Bo, [["render", Ho], ["__scopeId", "data-v-afff3510"]]), zo = {
  components: {
    PluginRightMenu: xe,
    TinyTabs: Mi,
    TinyTabItem: Li,
    VueDraggableNext: Oe
  },
  props: {
    renderPanel: {
      type: String,
      default: ""
    },
    pluginList: {
      type: Array,
      default: () => []
    }
  },
  emits: ["changeRightAlign"],
  setup(t, {
    emit: e
  }) {
    const {
      getPluginById: i,
      PLUGIN_POSITION: n,
      rightFixedPanelsStorage: o,
      changeRightFixedPanels: r,
      dragPluginLayout: a,
      isSameSide: l,
      getPluginShown: s,
      getMoveDragBarState: u,
      layoutState: {
        settings: d
      },
      getFinalLayoutConfig: c
    } = ve(), g = nt(null), m = M((h, _, E, F, T) => {
      _ ? g.value.showContextMenu(h.clientX, h.clientY, _, E, F, T) : g.value.showContextMenu(h.clientX, h.clientY, _);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.showContextMenu"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), p = nt(c().plugins.right.top), v = Sn(() => {
      const h = {};
      return p.value.forEach((_) => {
        const E = O(_);
        E && (h[_] = E);
      }), h;
    }), b = M(() => {
      ve().closeSetting(!0);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.close"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), P = M((h, _, E) => {
      p.value.splice(h, 1), e("changeRightAlign", _), l(h, 0) || b(), a(E, n.leftTop, h, 0);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.switchAlign"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), D = M((h) => {
      const _ = i(t.pluginList, h), E = p.value.findIndex((F) => F.id === _.id);
      E !== -1 && p.value.splice(E, 1), p.value.unshift(_);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.changeAlign"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), x = M((h) => {
      d.render = h;
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.setRender"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), I = M(({
      item: h
    }) => {
      if (d.render == h.id) {
        ve().closeSetting(!0);
        return;
      }
      x(h.id);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.clickMenu"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    });
    Kt(() => t.renderPanel, (h) => {
      x(h);
    });
    const f = M((h) => {
      r(h);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.fixPanel"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    }), y = M((h) => {
      l(h.from.id, h.to.id) || b(), a(h.from.id, h.to.id, h.oldIndex, h.newIndex);
    }, {
      metaData: {
        id: "engine.layout.DesignSettings.onEnd"
      },
      ctx: () => ({
        props: t,
        emit: e,
        getPluginById: i,
        PLUGIN_POSITION: n,
        rightFixedPanelsStorage: o,
        changeRightFixedPanels: r,
        dragPluginLayout: a,
        isSameSide: l,
        getPluginShown: s,
        getMoveDragBarState: u,
        getFinalLayoutConfig: c,
        settingsState: d,
        rightMenu: g,
        showContextMenu: m,
        settingPlugins: p,
        settingPluginsMeta: v,
        close: b,
        switchAlign: P,
        changeAlign: D,
        setRender: x,
        clickMenu: I,
        fixPanel: f,
        onEnd: y,
        useLayout: ve,
        getMergeMeta: O,
        VueDraggableNext: Oe,
        PluginRightMenu: xe
      })
    });
    return {
      changeAlign: D,
      settingsState: d,
      settingPlugins: p,
      clickMenu: I,
      close: b,
      fixPanel: f,
      rightFixedPanelsStorage: o,
      onEnd: y,
      showContextMenu: m,
      PLUGIN_POSITION: n,
      getPluginShown: s,
      switchAlign: P,
      rightMenu: g,
      getMoveDragBarState: u,
      getMergeMeta: O,
      settingPluginsMeta: v
    };
  }
}, Qo = { class: "right-panel-wrap" }, Jo = { class: "active2" }, qo = { id: "tiny-engine-nav-panel" }, Ko = ["title", "onClick", "onContextmenu"], Zo = {
  key: 0,
  class: "item-icon"
};
function $o(t, e, i, n, o, r) {
  var u, d;
  const a = Ce("svg-icon"), l = Ce("vue-draggable-next"), s = Ce("plugin-right-menu");
  return A(), ye(Ge, null, [
    _e("div", {
      class: $e({ "not-selected": n.getMoveDragBarState() })
    }, [
      dn(_e("div", {
        id: "tiny-engine-right-panel",
        class: $e([i.renderPanel, { "is-fixed": n.rightFixedPanelsStorage.includes(i.renderPanel) }])
      }, [
        _e("div", Qo, [
          (A(), Ee(ke((u = n.settingPluginsMeta[i.renderPanel]) == null ? void 0 : u.entry), {
            "fixed-panels": n.rightFixedPanelsStorage,
            onClose: n.close,
            onFixPanel: n.fixPanel
          }, null, 40, ["fixed-panels", "onClose", "onFixPanel"])),
          dn(_e("div", Jo, null, 512), [
            [gn, n.settingsState.activating]
          ])
        ])
      ], 2), [
        [gn, i.renderPanel && ((d = n.settingPluginsMeta[i.renderPanel]) == null ? void 0 : d.entry)]
      ])
    ], 2),
    _e("div", qo, [
      lt(l, {
        id: "rightTop",
        modelValue: n.settingPlugins,
        "onUpdate:modelValue": e[1] || (e[1] = (c) => n.settingPlugins = c),
        filter: ".panel-icon",
        class: "nav-panel-lists",
        group: "plugins",
        onEnd: n.onEnd
      }, {
        default: ht(() => [
          (A(!0), ye(Ge, null, ze(n.settingPlugins, (c, g) => {
            var m, p, v, b;
            return A(), ye("div", {
              key: g,
              class: $e(["list-item", { active: c === i.renderPanel }]),
              title: (m = n.settingPluginsMeta[c]) == null ? void 0 : m.title,
              onClick: (P) => n.clickMenu({ item: n.settingPluginsMeta[c], index: g }),
              onContextmenu: Et((P) => n.showContextMenu(P, !0, c, g, n.PLUGIN_POSITION.rightTop), ["prevent"])
            }, [
              n.getPluginShown(c) ? (A(), ye("span", Zo, [
                typeof ((p = n.settingPluginsMeta[c]) == null ? void 0 : p.icon) == "string" ? (A(), Ee(a, {
                  key: 0,
                  name: (v = n.settingPluginsMeta[c]) == null ? void 0 : v.icon,
                  class: "panel-icon"
                }, null, 8, ["name"])) : (A(), Ee(ke((b = n.settingPluginsMeta[c]) == null ? void 0 : b.icon), {
                  key: 1,
                  class: "panel-icon"
                }))
              ])) : Ue("", !0)
            ], 42, Ko);
          }), 128)),
          _e("div", {
            style: { flex: "1" },
            class: "list-item",
            onContextmenu: e[0] || (e[0] = Et((c) => n.showContextMenu(c, !1), ["prevent"]))
          }, null, 32)
        ]),
        _: 1
      }, 8, ["modelValue", "onEnd"])
    ]),
    lt(s, {
      ref: "rightMenu",
      list: Object.values(n.settingPluginsMeta),
      align: n.PLUGIN_POSITION.rightTop,
      onSwitchAlign: n.switchAlign
    }, null, 8, ["list", "align", "onSwitchAlign"])
  ], 64);
}
const Gt = /* @__PURE__ */ Lt(zo, [["render", $o], ["__scopeId", "data-v-53374916"]]), er = {
  name: "TinyLowCode",
  components: {
    DesignToolbars: At,
    DesignPlugins: Bt,
    DesignSettings: Gt
  },
  provide() {
    return {
      editor: this
    };
  },
  setup() {
    var I;
    const t = O(_t.id), e = t.options.configProvider, i = t.options.configProviderDesign, {
      layoutState: n,
      leftMenuShownStorage: o,
      rightMenuShownStorage: r,
      initPluginStorageReactive: a
    } = ve(), {
      plugins: l,
      settings: s
    } = n, u = (I = O("engine.canvas")) == null ? void 0 : I.entry, d = yt("plugins"), c = yt("setting"), g = M(({
      item: f
    }) => {
      f.id && (l.render = l.render === f.id ? null : f.id);
    }, {
      metaData: {
        id: "engine.layout.Main.toggleNav"
      },
      ctx: () => ({
        layoutRegistry: t,
        configProvider: e,
        configProviderDesign: i,
        layoutState: n,
        leftMenuShownStorage: o,
        rightMenuShownStorage: r,
        initPluginStorageReactive: a,
        plugins: l,
        settings: s,
        canvasEntry: u,
        pluginRegistry: d,
        settingRegistry: c,
        toggleNav: g,
        left: m,
        right: p,
        changeLeftAlign: v,
        changeRightAlign: b,
        pluginList: P,
        plugin: D,
        PLUGIN_DEFAULT_WIDTH: x,
        useLayout: ve,
        getMergeMeta: O,
        getMergeMetaByType: yt,
        constants: G,
        DesignToolbars: At,
        DesignPlugins: Bt,
        DesignSettings: Gt,
        meta: _t
      })
    }), m = nt(null), p = nt(null), v = M((f) => {
      var y;
      (y = p.value) == null || y.changeAlign(f);
    }, {
      metaData: {
        id: "engine.layout.Main.changeLeftAlign"
      },
      ctx: () => ({
        layoutRegistry: t,
        configProvider: e,
        configProviderDesign: i,
        layoutState: n,
        leftMenuShownStorage: o,
        rightMenuShownStorage: r,
        initPluginStorageReactive: a,
        plugins: l,
        settings: s,
        canvasEntry: u,
        pluginRegistry: d,
        settingRegistry: c,
        toggleNav: g,
        left: m,
        right: p,
        changeLeftAlign: v,
        changeRightAlign: b,
        pluginList: P,
        plugin: D,
        PLUGIN_DEFAULT_WIDTH: x,
        useLayout: ve,
        getMergeMeta: O,
        getMergeMetaByType: yt,
        constants: G,
        DesignToolbars: At,
        DesignPlugins: Bt,
        DesignSettings: Gt,
        meta: _t
      })
    }), b = M((f) => {
      var y;
      (y = m.value) == null || y.changeAlign(f);
    }, {
      metaData: {
        id: "engine.layout.Main.changeRightAlign"
      },
      ctx: () => ({
        layoutRegistry: t,
        configProvider: e,
        configProviderDesign: i,
        layoutState: n,
        leftMenuShownStorage: o,
        rightMenuShownStorage: r,
        initPluginStorageReactive: a,
        plugins: l,
        settings: s,
        canvasEntry: u,
        pluginRegistry: d,
        settingRegistry: c,
        toggleNav: g,
        left: m,
        right: p,
        changeLeftAlign: v,
        changeRightAlign: b,
        pluginList: P,
        plugin: D,
        PLUGIN_DEFAULT_WIDTH: x,
        useLayout: ve,
        getMergeMeta: O,
        getMergeMetaByType: yt,
        constants: G,
        DesignToolbars: At,
        DesignPlugins: Bt,
        DesignSettings: Gt,
        meta: _t
      })
    }), P = [...d, ...c], D = {}, {
      PLUGIN_DEFAULT_WIDTH: x
    } = G;
    return P.forEach((f) => {
      if (f.id) {
        const y = (f == null ? void 0 : f.widthResizable) ?? !1;
        D[f.id] = {
          width: (f == null ? void 0 : f.width) || x,
          isShow: !0,
          entry: f.entry,
          id: f.id,
          icon: f.icon,
          widthResizable: y
        };
      }
    }), localStorage.setItem("plugin", JSON.stringify(D)), a(D), {
      left: m,
      right: p,
      changeLeftAlign: v,
      changeRightAlign: b,
      leftMenuShownStorage: o,
      rightMenuShownStorage: r,
      pluginList: P,
      layoutRegistry: t,
      configProvider: e,
      configProviderDesign: i,
      plugins: l,
      settings: s,
      toggleNav: g,
      layoutState: n,
      canvasEntry: u,
      pluginRegistry: d
    };
  }
}, tr = { id: "tiny-engine" }, nr = { class: "tiny-engine-main" }, ir = { class: "tiny-engine-left-wrap" }, or = { class: "tiny-engine-content-wrap" }, rr = { class: "tiny-engine-right-wrap" };
function ar(t, e, i, n, o, r) {
  const a = Ce("design-toolbars"), l = Ce("design-plugins"), s = Ce("design-settings");
  return A(), Ee(ke(n.configProvider), { design: n.configProviderDesign }, {
    default: ht(() => [
      _e("div", tr, [
        lt(a, { layoutRegistry: n.layoutRegistry }, null, 8, ["layoutRegistry"]),
        _e("div", nr, [
          _e("div", ir, [
            _e("div", or, [
              n.leftMenuShownStorage ? (A(), Ee(l, {
                key: 0,
                ref: "left",
                plugins: n.pluginRegistry,
                "plugin-list": n.pluginList,
                "render-panel": n.plugins.render,
                onChangeLeftAlign: n.changeLeftAlign,
                onClick: n.toggleNav
              }, null, 8, ["plugins", "plugin-list", "render-panel", "onChangeLeftAlign", "onClick"])) : Ue("", !0),
              (A(), Ee(ke(n.canvasEntry)))
            ])
          ]),
          _e("div", rr, [
            n.rightMenuShownStorage ? (A(), Ee(s, {
              key: 0,
              ref: "right",
              "render-panel": n.settings.render,
              "plugin-list": n.pluginList,
              onChangeRightAlign: n.changeRightAlign
            }, null, 8, ["render-panel", "plugin-list", "onChangeRightAlign"])) : Ue("", !0)
          ])
        ])
      ])
    ]),
    _: 1
  }, 8, ["design"]);
}
const sr = /* @__PURE__ */ Lt(er, [["render", ar], ["__scopeId", "data-v-52265d75"]]);
var Xn;
const fi = typeof window < "u", lr = (t) => typeof t == "function", ur = (t) => typeof t == "string", cr = () => {
};
fi && ((Xn = window == null ? void 0 : window.navigator) != null && Xn.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function In(t) {
  return typeof t == "function" ? t() : Ei(t);
}
function dr(t, e) {
  function i(...n) {
    return new Promise((o, r) => {
      Promise.resolve(t(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(o).catch(r);
    });
  }
  return i;
}
const hi = (t) => t();
function gr(t = hi) {
  const e = nt(!0);
  function i() {
    e.value = !1;
  }
  function n() {
    e.value = !0;
  }
  const o = (...r) => {
    e.value && t(...r);
  };
  return { isActive: Pi(e), pause: i, resume: n, eventFilter: o };
}
function fr(t) {
  return t;
}
function hr(t) {
  return Di() ? (xi(t), !0) : !1;
}
var Yn = Object.getOwnPropertySymbols, pr = Object.prototype.hasOwnProperty, mr = Object.prototype.propertyIsEnumerable, vr = (t, e) => {
  var i = {};
  for (var n in t)
    pr.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
  if (t != null && Yn)
    for (var n of Yn(t))
      e.indexOf(n) < 0 && mr.call(t, n) && (i[n] = t[n]);
  return i;
};
function yr(t, e, i = {}) {
  const n = i, {
    eventFilter: o = hi
  } = n, r = vr(n, [
    "eventFilter"
  ]);
  return Kt(t, dr(o, e), r);
}
var _r = Object.defineProperty, br = Object.defineProperties, wr = Object.getOwnPropertyDescriptors, qt = Object.getOwnPropertySymbols, pi = Object.prototype.hasOwnProperty, mi = Object.prototype.propertyIsEnumerable, Vn = (t, e, i) => e in t ? _r(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Sr = (t, e) => {
  for (var i in e || (e = {}))
    pi.call(e, i) && Vn(t, i, e[i]);
  if (qt)
    for (var i of qt(e))
      mi.call(e, i) && Vn(t, i, e[i]);
  return t;
}, Er = (t, e) => br(t, wr(e)), Pr = (t, e) => {
  var i = {};
  for (var n in t)
    pi.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
  if (t != null && qt)
    for (var n of qt(t))
      e.indexOf(n) < 0 && mi.call(t, n) && (i[n] = t[n]);
  return i;
};
function Dr(t, e, i = {}) {
  const n = i, {
    eventFilter: o
  } = n, r = Pr(n, [
    "eventFilter"
  ]), { eventFilter: a, pause: l, resume: s, isActive: u } = gr(o);
  return { stop: yr(t, e, Er(Sr({}, r), {
    eventFilter: a
  })), pause: l, resume: s, isActive: u };
}
function xr(t) {
  var e;
  const i = In(t);
  return (e = i == null ? void 0 : i.$el) != null ? e : i;
}
const _n = fi ? window : void 0;
function Wn(...t) {
  let e, i, n, o;
  if (ur(t[0]) || Array.isArray(t[0]) ? ([i, n, o] = t, e = _n) : [e, i, n, o] = t, !e)
    return cr;
  Array.isArray(i) || (i = [i]), Array.isArray(n) || (n = [n]);
  const r = [], a = () => {
    r.forEach((d) => d()), r.length = 0;
  }, l = (d, c, g, m) => (d.addEventListener(c, g, m), () => d.removeEventListener(c, g, m)), s = Kt(() => [xr(e), In(o)], ([d, c]) => {
    a(), d && r.push(...i.flatMap((g) => n.map((m) => l(d, g, m, c))));
  }, { immediate: !0, flush: "post" }), u = () => {
    s(), a();
  };
  return hr(u), u;
}
const bn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, wn = "__vueuse_ssr_handlers__";
bn[wn] = bn[wn] || {};
const Or = bn[wn];
function Ir(t, e) {
  return Or[t] || e;
}
function Lr(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
var Mr = Object.defineProperty, Hn = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, Cr = Object.prototype.propertyIsEnumerable, zn = (t, e, i) => e in t ? Mr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Qn = (t, e) => {
  for (var i in e || (e = {}))
    Nr.call(e, i) && zn(t, i, e[i]);
  if (Hn)
    for (var i of Hn(e))
      Cr.call(e, i) && zn(t, i, e[i]);
  return t;
};
const Ar = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, Jn = "vueuse-storage";
function j(t, e, i, n = {}) {
  var o;
  const {
    flush: r = "pre",
    deep: a = !0,
    listenToStorageChanges: l = !0,
    writeDefaults: s = !0,
    mergeDefaults: u = !1,
    shallow: d,
    window: c = _n,
    eventFilter: g,
    onError: m = (_) => {
      console.error(_);
    }
  } = n, p = (d ? Oi : nt)(e);
  if (!i)
    try {
      i = Ir("getDefaultStorage", () => {
        var _;
        return (_ = _n) == null ? void 0 : _.localStorage;
      })();
    } catch (_) {
      m(_);
    }
  if (!i)
    return p;
  const v = In(e), b = Lr(v), P = (o = n.serializer) != null ? o : Ar[b], { pause: D, resume: x } = Dr(p, () => I(p.value), { flush: r, deep: a, eventFilter: g });
  return c && l && (Wn(c, "storage", h), Wn(c, Jn, y)), h(), p;
  function I(_) {
    try {
      if (_ == null)
        i.removeItem(t);
      else {
        const E = P.write(_), F = i.getItem(t);
        F !== E && (i.setItem(t, E), c && c.dispatchEvent(new CustomEvent(Jn, {
          detail: {
            key: t,
            oldValue: F,
            newValue: E,
            storageArea: i
          }
        })));
      }
    } catch (E) {
      m(E);
    }
  }
  function f(_) {
    const E = _ ? _.newValue : i.getItem(t);
    if (E == null)
      return s && v !== null && i.setItem(t, P.write(v)), v;
    if (!_ && u) {
      const F = P.read(E);
      return lr(u) ? u(F, v) : b === "object" && !Array.isArray(F) ? Qn(Qn({}, v), F) : F;
    } else return typeof E != "string" ? E : P.read(E);
  }
  function y(_) {
    h(_.detail);
  }
  function h(_) {
    if (!(_ && _.storageArea !== i)) {
      if (_ && _.key == null) {
        p.value = v;
        return;
      }
      if (!(_ && _.key !== t)) {
        D();
        try {
          p.value = f(_);
        } catch (E) {
          m(E);
        } finally {
          _ ? Pn(x) : x();
        }
      }
    }
  }
}
var qn;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(qn || (qn = {}));
var Tr = Object.defineProperty, Kn = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, kr = Object.prototype.propertyIsEnumerable, Zn = (t, e, i) => e in t ? Tr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Rr = (t, e) => {
  for (var i in e || (e = {}))
    Fr.call(e, i) && Zn(t, i, e[i]);
  if (Kn)
    for (var i of Kn(e))
      kr.call(e, i) && Zn(t, i, e[i]);
  return t;
};
const Br = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Rr({
  linear: fr
}, Br);
const W = {
  plugins: {
    left: {
      top: [
        w.Materials,
        w.OutlineTree,
        w.AppManage,
        w.BlockManage,
        w.Collections,
        w.Bridge,
        w.I18n,
        w.Page,
        w.State
      ],
      bottom: [w.Schema, w.Help, w.Robot]
    },
    right: {
      top: [w.Props, w.Styles, w.Event]
    }
  },
  toolbars: {
    left: [w.Breadcrumb, w.Lock, w.Logo],
    center: [w.Media],
    right: [
      [w.ThemeSwitch, w.RedoUndo, w.Clean],
      [w.Preview],
      [w.GenerateCode, w.Save]
    ],
    collapse: [
      [w.Collaboration],
      [w.Refresh, w.Fullscreen],
      [w.Lang],
      [w.ViewSetting]
    ]
  }
}, {
  PAGE_STATUS: ge,
  STORAGE_KEY_LEFT_FIXED_PANELS: fe,
  STORAGE_KEY_RIGHT_FIXED_PANELS: he,
  PLUGIN_DEFAULT_WIDTH: H
} = G, {
  deepClone: V
} = de, U = {
  leftTop: "leftTop",
  leftBottom: "leftBottom",
  independence: "independence",
  rightTop: "rightTop",
  rightBottom: "rightBottom",
  fixed: "fixed"
}, z = En({
  pluginEvent: "all"
}), L = En({
  isMoveDragBar: !1,
  dimension: {
    deviceType: "desktop",
    width: "",
    maxWidth: "",
    minWidth: "",
    scale: 1,
    height: "100%"
  },
  plugins: {
    isShow: !0,
    fixedPanels: [w.Materials],
    render: w.Materials,
    pluginEvent: "all",
    activating: !1,
    // 
    showDesignSettings: !0
  },
  settings: {
    isShow: !0,
    fixedPanels: [w.Props, w.Styles, w.Event],
    render: w.Props,
    api: null,
    activating: !1,
    // 
    showDesignSettings: !0
  },
  toolbars: {
    visiblePopover: !1
  },
  pageStatus: {
    state: "",
    data: {}
  }
}), Q = M(() => L.isMoveDragBar, {
  metaData: {
    id: "engine.service.layout.useLayout.getMoveDragBarState"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), J = M((t) => {
  L.isMoveDragBar = t;
}, {
  metaData: {
    id: "engine.service.layout.useLayout.changeMoveDragBarState"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), X = j("leftMenuShown", L.plugins.isShow), Y = j("rightMenuShown", L.settings.isShow), q = M((t) => {
  switch (t) {
    case "left": {
      X.value = !X.value;
      break;
    }
    case "right": {
      Y.value = !Y.value;
      break;
    }
  }
}, {
  metaData: {
    id: "engine.service.layout.useLayout.changeMenuShown"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), R = j(fe, L.plugins.fixedPanels), B = j(he, L.settings.fixedPanels), K = M((t) => {
  var e, i;
  R.value = (e = R.value) != null && e.includes(t) ? (i = R.value) == null ? void 0 : i.filter((n) => n !== t) : [...R.value, t];
}, {
  metaData: {
    id: "engine.service.layout.useLayout.changeLeftFixedPanels"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), Z = M((t) => {
  var e, i;
  B.value = (e = B.value) != null && e.includes(t) ? (i = B.value) == null ? void 0 : i.filter((n) => n !== t) : [...B.value, t];
}, {
  metaData: {
    id: "engine.service.layout.useLayout.changeRightFixedPanels"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), $ = M(() => L.dimension.scale, {
  metaData: {
    id: "engine.service.layout.useLayout.getScale"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), ee = M(() => L.plugins, {
  metaData: {
    id: "engine.service.layout.useLayout.getPluginState"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), te = M(() => L.settings, {
  metaData: {
    id: "engine.service.layout.useLayout.getSettingState"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), ne = M(() => L.dimension, {
  metaData: {
    id: "engine.service.layout.useLayout.getDimension"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), ie = M((t) => {
  Object.assign(L.dimension, t);
}, {
  metaData: {
    id: "engine.service.layout.useLayout.setDimension"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), oe = M((t) => {
  const {
    settings: e
  } = L;
  e.render = t, Pn(() => {
    e.activating = !0, setTimeout(() => {
      e.activating = !1;
    }, 1e3);
  });
}, {
  metaData: {
    id: "engine.service.layout.useLayout.activeSetting"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), re = M(() => {
  const t = R.value.includes(L.plugins.render), e = B.value.includes(L.settings.render);
  return {
    leftPanelFixed: t,
    rightPanelFixed: e
  };
}, {
  metaData: {
    id: "engine.service.layout.useLayout.getFixedPanelsStatus"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), ae = M((t) => {
  const {
    settings: e
  } = L;
  (!B.value.includes(e.render) || t) && (e.render = "");
}, {
  metaData: {
    id: "engine.service.layout.useLayout.closeSetting"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), se = M((t, e) => {
  const {
    plugins: i
  } = L;
  return e || (i.render = t), new Promise((n) => {
    Pn(() => n(ce(t)));
  });
}, {
  metaData: {
    id: "engine.service.layout.useLayout.activePlugin"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), le = M((t) => {
  const {
    plugins: e
  } = L;
  (!R.value.includes(e.render) || t) && (e.render = "");
}, {
  metaData: {
    id: "engine.service.layout.useLayout.closePlugin"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), ue = M(() => {
  var t;
  return ((t = L.pageStatus) == null ? void 0 : t.state) === ge.Empty;
}, {
  metaData: {
    id: "engine.service.layout.useLayout.isEmptyPage"
  },
  ctx: () => ({
    useStorage: j,
    constants: G,
    PLUGIN_NAME: w,
    getMetaApi: ce,
    getMergeMeta: O,
    defaultLayout: W,
    utils: de,
    PAGE_STATUS: ge,
    STORAGE_KEY_LEFT_FIXED_PANELS: fe,
    STORAGE_KEY_RIGHT_FIXED_PANELS: he,
    PLUGIN_DEFAULT_WIDTH: H,
    deepClone: V,
    PLUGIN_POSITION: U,
    pluginState: z,
    layoutState: L,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeMenuShown: q,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getScale: $,
    getPluginState: ee,
    getSettingState: te,
    getDimension: ne,
    setDimension: ie,
    activeSetting: oe,
    getFixedPanelsStatus: re,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    isEmptyPage: ue
  })
}), Gr = () => {
  let t = {};
  try {
    const f = localStorage.getItem("plugin");
    f && (t = JSON.parse(f));
  } catch (f) {
    throw f instanceof Error ? new Error(f.message) : new Error("Failed to parse plugin storage");
  }
  const e = j("plugin", t), i = M((f) => {
    var y;
    return ((y = e.value[f]) == null ? void 0 : y.width) || H;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginWidth"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), n = M((f, y, h) => {
    Object.prototype.hasOwnProperty.call(e.value, f) ? (e.value[f].width = y, typeof h == "number" && (e.value[f].offset = h)) : e.value[f] = {
      width: y,
      index: 0,
      isShow: !0
    };
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.changePluginWidth"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), o = M((f) => {
    var y;
    return ((y = e.value[f]) == null ? void 0 : y.align) || "leftTop";
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginByLayout"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), r = M((f = "all") => {
    const y = Object.keys(e.value).filter((h) => e.value[h].align === f || f === "all");
    return y.sort((h, _) => e.value[h].index - e.value[_].index), y;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginsByLayout"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), a = M((f, y) => f.find((h) => h.id === y), {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginById"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), l = M((f, y) => r(f).map((_) => a(y, _)).filter((_) => !!_), {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginsByPosition"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), s = M((f, y) => {
    e.value[f] && (e.value[f].align = y);
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.changePluginLayout"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), u = M((f, y, h, _) => {
    if (f === y && h === _) return;
    const E = Object.values(e.value), F = E.find((T) => T.align === f && T.index === h);
    f === y ? h < _ ? E.forEach((T) => {
      T !== F && T.align === f && T.index > h && T.index <= _ && (T.index -= 1);
    }) : E.forEach((T) => {
      T !== F && T.align === f && T.index >= _ && T.index < h && (T.index += 1);
    }) : E.forEach((T) => {
      T !== F && T.align === f && T.index > h && (T.index -= 1), T !== F && T.align === y && T.index >= _ && (T.index += 1);
    }), F && (F.align = y, F.index = _);
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.dragPluginLayout"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), d = M((f, y) => {
    const h = [U.leftTop, U.leftBottom], _ = [U.rightTop, U.rightBottom], E = h.includes(f) && h.includes(y), F = _.includes(f) && _.includes(y);
    return E || F;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.isSameSide"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), c = M((f) => {
    var y;
    return ((y = e.value[f]) == null ? void 0 : y.isShow) || !1;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.getPluginShown"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), g = M((f) => {
    e.value[f] || (e.value[f] = {
      isShow: !0,
      index: 0
    }), e.value[f].isShow = !e.value[f].isShow;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.changePluginShown"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), m = M((f) => {
    var y;
    return ((y = e.value[f]) == null ? void 0 : y.widthResizable) || !1;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.isPanelWidthResizable"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), p = M((f) => {
    e.value = f;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.initPluginStorageReactive"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), v = M((f) => {
    Array.isArray(f) && f.forEach((y, h) => {
      Array.isArray(y) || Object.prototype.toString.call(y) === "[object Object]" ? v(y) : typeof y == "string" && !O(y) && f.splice(h, 1);
    }), Object.prototype.toString.call(f) === "[object Object]" && Object.values(f).forEach((y) => {
      v(y);
    });
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.removeUndefineLayoutId"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), b = M((f, y) => {
    Array.isArray(f) && f.forEach((h, _) => {
      Array.isArray(h) || Object.prototype.toString.call(h) === "[object Object]" ? b(h, y) : h === y && f.splice(_, 1);
    }), Object.prototype.toString.call(f) === "[object Object]" && Object.values(f).forEach((h) => {
      b(h, y);
    });
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.removeById"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), P = M((f, y, h, _) => {
    if (Array.isArray(f)) {
      for (let E = 0; E < f.length; E++) {
        const F = f[E];
        if (Array.isArray(F))
          P(F, y, h, _);
        else if (Object.prototype.toString.call(F) === "[object Object]")
          P(F, y, h, _);
        else if (F === h) {
          const T = _ === "before" ? E : E + 1;
          f.splice(T, 0, y);
          return;
        }
      }
      return;
    }
    Object.prototype.toString.call(f) === "[object Object]" && Object.values(f).forEach((E) => {
      P(E, y, h, _);
    });
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.replaceByPosition"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  }), D = M((f, y) => {
    const h = V(f);
    return Object.entries(y).forEach(([_, E]) => {
      E.insertBefore ? (b(h, _), P(h, _, E.insertBefore, "before")) : E.insertAfter && (b(h, _), P(h, _, E.insertAfter, "after"));
    }), v(h), h;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.computeFinalLayoutConfig"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  });
  let x = null;
  const I = M(() => {
    var h, _, E, F;
    if (x)
      return x;
    const f = (_ = (h = O("engine.layout")) == null ? void 0 : h.options) == null ? void 0 : _.layoutConfig;
    if (f)
      return f;
    const y = ((F = (E = O("engine.layout")) == null ? void 0 : E.options) == null ? void 0 : F.relativeLayoutConfig) || {};
    return x = D(V(W), y), x;
  }, {
    metaData: {
      id: "engine.service.layout.useLayout.getFinalLayoutConfig"
    },
    ctx: () => ({
      plugin: t,
      pluginStorageReactive: e,
      getPluginWidth: i,
      changePluginWidth: n,
      getPluginByLayout: o,
      getPluginsByLayout: r,
      getPluginById: a,
      getPluginsByPosition: l,
      changePluginLayout: s,
      dragPluginLayout: u,
      isSameSide: d,
      getPluginShown: c,
      changePluginShown: g,
      isPanelWidthResizable: m,
      initPluginStorageReactive: p,
      removeUndefineLayoutId: v,
      removeById: b,
      replaceByPosition: P,
      computeFinalLayoutConfig: D,
      finalLayoutConfig: x,
      getFinalLayoutConfig: I,
      useStorage: j,
      constants: G,
      PLUGIN_NAME: w,
      getMetaApi: ce,
      getMergeMeta: O,
      defaultLayout: W,
      utils: de,
      PAGE_STATUS: ge,
      STORAGE_KEY_LEFT_FIXED_PANELS: fe,
      STORAGE_KEY_RIGHT_FIXED_PANELS: he,
      PLUGIN_DEFAULT_WIDTH: H,
      deepClone: V,
      PLUGIN_POSITION: U,
      pluginState: z,
      layoutState: L,
      getMoveDragBarState: Q,
      changeMoveDragBarState: J,
      leftMenuShownStorage: X,
      rightMenuShownStorage: Y,
      changeMenuShown: q,
      leftFixedPanelsStorage: R,
      rightFixedPanelsStorage: B,
      changeLeftFixedPanels: K,
      changeRightFixedPanels: Z,
      getScale: $,
      getPluginState: ee,
      getSettingState: te,
      getDimension: ne,
      setDimension: ie,
      activeSetting: oe,
      getFixedPanelsStatus: re,
      closeSetting: ae,
      activePlugin: se,
      closePlugin: le,
      isEmptyPage: ue
    })
  });
  return {
    isPanelWidthResizable: m,
    getFixedPanelsStatus: re,
    initPluginStorageReactive: p,
    PLUGIN_NAME: w,
    PLUGIN_POSITION: U,
    activeSetting: oe,
    closeSetting: ae,
    activePlugin: se,
    closePlugin: le,
    layoutState: L,
    getScale: $,
    setDimension: ie,
    getDimension: ne,
    getPluginById: a,
    pluginState: z,
    getPluginState: ee,
    getSettingState: te,
    isEmptyPage: ue,
    getPluginWidth: i,
    changePluginWidth: n,
    leftFixedPanelsStorage: R,
    rightFixedPanelsStorage: B,
    leftMenuShownStorage: X,
    rightMenuShownStorage: Y,
    changeLeftFixedPanels: K,
    changeRightFixedPanels: Z,
    getPluginsByLayout: r,
    changePluginLayout: s,
    getPluginByLayout: o,
    dragPluginLayout: u,
    isSameSide: d,
    getPluginShown: c,
    changePluginShown: g,
    changeMenuShown: q,
    getMoveDragBarState: Q,
    changeMoveDragBarState: J,
    getPluginsByPosition: l,
    getFinalLayoutConfig: I
  };
}, Ur = {
  id: "engine.service.layout",
  type: "MetaService",
  apis: Gr(),
  composable: {
    name: _i.useLayout
  }
}, qr = {
  ..._t,
  component: sr,
  options: {
    configProvider: Ni,
    configProviderDesign: Ai,
    isShowLine: !0,
    isShowCollapse: !0
  },
  metas: [Ur]
};
export {
  Ur as LayoutService,
  qr as default
};
//# sourceMappingURL=index.js.map
