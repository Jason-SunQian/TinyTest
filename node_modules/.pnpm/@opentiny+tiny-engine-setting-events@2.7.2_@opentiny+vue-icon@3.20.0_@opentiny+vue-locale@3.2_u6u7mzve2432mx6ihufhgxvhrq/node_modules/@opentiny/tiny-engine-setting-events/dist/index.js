import "./style.css";
import { ref as Lt, reactive as Ut, provide as he, nextTick as Ee, resolveComponent as B, createBlock as tt, openBlock as S, withCtx as I, createElementVNode as m, createVNode as _, resolveDynamicComponent as te, createTextVNode as Dt, unref as O, createElementBlock as J, Fragment as $t, withDirectives as ee, renderList as Ht, normalizeClass as It, toDisplayString as W, createCommentVNode as zt, vShow as ne, computed as Tt, watchEffect as ue, watch as ie, inject as ge } from "vue";
import { callEntry as b, META_APP as C, getMetaApi as k, getOptions as X, useLayout as N, useHistory as K, useCanvas as y, getMergeMeta as L, useBlock as pt, useMaterial as vt, useModal as bt, useMessage as _t, useProperties as $ } from "@opentiny/tiny-engine-meta-register";
import { TinyAlert as ye, DialogBox as fe, Button as Ft, Form as we, FormItem as oe, Input as qt, Popover as xe, Tooltip as Ce, Collapse as ke, CollapseItem as se, Checkbox as De, Search as Se } from "@opentiny/vue";
import Et from "@opentiny/tiny-engine-common/js/i18n";
import { SvgButton as yt, BlockLinkEvent as wt, PluginPanel as Ae, VueMonaco as St } from "@opentiny/tiny-engine-common";
import { iconChevronDown as xt } from "@opentiny/vue-icon";
import { string2Ast as H } from "@opentiny/tiny-engine-common/js/ast";
import { CodeConfigurator as st, InputConfigurator as rt, VariableConfigurator as at, SwitchConfigurator as lt } from "@opentiny/tiny-engine-configurator";
import { PROP_DATA_TYPE as G } from "@opentiny/tiny-engine-common/js/constants";
import { constants as ht, utils as ut } from "@opentiny/tiny-engine-utils";
const R = {
  id: "engine.setting.event",
  title: "高级",
  type: "plugins",
  name: "event",
  icon: "target"
};
var Ne = 44, Ie = 59, re = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", me = new Uint8Array(64), Le = new Uint8Array(128);
for (let c = 0; c < re.length; c++) {
  const t = re.charCodeAt(c);
  me[c] = t, Le[t] = c;
}
function Vt(c, t, n) {
  let e = t - n;
  e = e < 0 ? -e << 1 | 1 : e << 1;
  do {
    let i = e & 31;
    e >>>= 5, e > 0 && (i |= 32), c.write(me[i]);
  } while (e > 0);
  return t;
}
var ae = 1024 * 16, le = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
  decode(c) {
    return Buffer.from(c.buffer, c.byteOffset, c.byteLength).toString();
  }
} : {
  decode(c) {
    let t = "";
    for (let n = 0; n < c.length; n++)
      t += String.fromCharCode(c[n]);
    return t;
  }
}, Be = class {
  constructor() {
    this.pos = 0, this.out = "", this.buffer = new Uint8Array(ae);
  }
  write(c) {
    const { buffer: t } = this;
    t[this.pos++] = c, this.pos === ae && (this.out += le.decode(t), this.pos = 0);
  }
  flush() {
    const { buffer: c, out: t, pos: n } = this;
    return n > 0 ? t + le.decode(c.subarray(0, n)) : t;
  }
};
function Pe(c) {
  const t = new Be();
  let n = 0, e = 0, i = 0, o = 0;
  for (let s = 0; s < c.length; s++) {
    const r = c[s];
    if (s > 0 && t.write(Ie), r.length === 0) continue;
    let a = 0;
    for (let d = 0; d < r.length; d++) {
      const f = r[d];
      d > 0 && t.write(Ne), a = Vt(t, f[0], a), f.length !== 1 && (n = Vt(t, f[1], n), e = Vt(t, f[2], e), i = Vt(t, f[3], i), f.length !== 4 && (o = Vt(t, f[4], o)));
    }
  }
  return t.flush();
}
class Jt {
  constructor(t) {
    this.bits = t instanceof Jt ? t.bits.slice() : [];
  }
  add(t) {
    this.bits[t >> 5] |= 1 << (t & 31);
  }
  has(t) {
    return !!(this.bits[t >> 5] & 1 << (t & 31));
  }
}
class Rt {
  constructor(t, n, e) {
    this.start = t, this.end = n, this.original = e, this.intro = "", this.outro = "", this.content = e, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
  }
  appendLeft(t) {
    this.outro += t;
  }
  appendRight(t) {
    this.intro = this.intro + t;
  }
  clone() {
    const t = new Rt(this.start, this.end, this.original);
    return t.intro = this.intro, t.outro = this.outro, t.content = this.content, t.storeName = this.storeName, t.edited = this.edited, t;
  }
  contains(t) {
    return this.start < t && t < this.end;
  }
  eachNext(t) {
    let n = this;
    for (; n; )
      t(n), n = n.next;
  }
  eachPrevious(t) {
    let n = this;
    for (; n; )
      t(n), n = n.previous;
  }
  edit(t, n, e) {
    return this.content = t, e || (this.intro = "", this.outro = ""), this.storeName = n, this.edited = !0, this;
  }
  prependLeft(t) {
    this.outro = t + this.outro;
  }
  prependRight(t) {
    this.intro = t + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(t) {
    const n = t - this.start, e = this.original.slice(0, n), i = this.original.slice(n);
    this.original = e;
    const o = new Rt(t, this.end, i);
    return o.outro = this.outro, this.outro = "", this.end = t, this.edited ? (o.edit("", !1), this.content = "") : this.content = e, o.next = this.next, o.next && (o.next.previous = o), o.previous = this, this.next = o, o;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(t) {
    if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
    const n = this.content.replace(t, "");
    if (n.length)
      return n !== this.content && (this.split(this.start + n.length).edit("", void 0, !0), this.edited && this.edit(n, this.storeName, !0)), !0;
    if (this.edit("", void 0, !0), this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
  }
  trimStart(t) {
    if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
    const n = this.content.replace(t, "");
    if (n.length) {
      if (n !== this.content) {
        const e = this.split(this.end - n.length);
        this.edited && e.edit(n, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
  }
}
function Ve() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (c) => globalThis.btoa(unescape(encodeURIComponent(c))) : typeof Buffer == "function" ? (c) => Buffer.from(c, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
const Me = /* @__PURE__ */ Ve();
class Oe {
  constructor(t) {
    this.version = 3, this.file = t.file, this.sources = t.sources, this.sourcesContent = t.sourcesContent, this.names = t.names, this.mappings = Pe(t.mappings), typeof t.x_google_ignoreList < "u" && (this.x_google_ignoreList = t.x_google_ignoreList), typeof t.debugId < "u" && (this.debugId = t.debugId);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + Me(this.toString());
  }
}
function Te(c) {
  const t = c.split(`
`), n = t.filter((o) => /^\t+/.test(o)), e = t.filter((o) => /^ {2,}/.test(o));
  if (n.length === 0 && e.length === 0)
    return null;
  if (n.length >= e.length)
    return "	";
  const i = e.reduce((o, s) => {
    const r = /^ +/.exec(s)[0].length;
    return Math.min(r, o);
  }, 1 / 0);
  return new Array(i + 1).join(" ");
}
function Re(c, t) {
  const n = c.split(/[/\\]/), e = t.split(/[/\\]/);
  for (n.pop(); n[0] === e[0]; )
    n.shift(), e.shift();
  if (n.length) {
    let i = n.length;
    for (; i--; ) n[i] = "..";
  }
  return n.concat(e).join("/");
}
const Ue = Object.prototype.toString;
function je(c) {
  return Ue.call(c) === "[object Object]";
}
function de(c) {
  const t = c.split(`
`), n = [];
  for (let e = 0, i = 0; e < t.length; e++)
    n.push(i), i += t[e].length + 1;
  return function(i) {
    let o = 0, s = n.length;
    for (; o < s; ) {
      const d = o + s >> 1;
      i < n[d] ? s = d : o = d + 1;
    }
    const r = o - 1, a = i - n[r];
    return { line: r, column: a };
  };
}
const $e = /\w/;
class ze {
  constructor(t) {
    this.hires = t, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(t, n, e, i) {
    if (n.length) {
      const o = n.length - 1;
      let s = n.indexOf(`
`, 0), r = -1;
      for (; s >= 0 && o > s; ) {
        const d = [this.generatedCodeColumn, t, e.line, e.column];
        i >= 0 && d.push(i), this.rawSegments.push(d), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, r = s, s = n.indexOf(`
`, s + 1);
      }
      const a = [this.generatedCodeColumn, t, e.line, e.column];
      i >= 0 && a.push(i), this.rawSegments.push(a), this.advance(n.slice(r + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(n));
    this.pending = null;
  }
  addUneditedChunk(t, n, e, i, o) {
    let s = n.start, r = !0, a = !1;
    for (; s < n.end; ) {
      if (e[s] === `
`)
        i.line += 1, i.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, r = !0, a = !1;
      else {
        if (this.hires || r || o.has(s)) {
          const d = [this.generatedCodeColumn, t, i.line, i.column];
          this.hires === "boundary" ? $e.test(e[s]) ? a || (this.rawSegments.push(d), a = !0) : (this.rawSegments.push(d), a = !1) : this.rawSegments.push(d);
        }
        i.column += 1, this.generatedCodeColumn += 1, r = !1;
      }
      s += 1;
    }
    this.pending = null;
  }
  advance(t) {
    if (!t) return;
    const n = t.split(`
`);
    if (n.length > 1) {
      for (let e = 0; e < n.length - 1; e++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += n[n.length - 1].length;
  }
}
const Mt = `
`, At = {
  insertLeft: !1,
  insertRight: !1,
  storeName: !1
};
class U {
  constructor(t, n = {}) {
    const e = new Rt(0, t.length, t);
    Object.defineProperties(this, {
      original: { writable: !0, value: t },
      outro: { writable: !0, value: "" },
      intro: { writable: !0, value: "" },
      firstChunk: { writable: !0, value: e },
      lastChunk: { writable: !0, value: e },
      lastSearchedChunk: { writable: !0, value: e },
      byStart: { writable: !0, value: {} },
      byEnd: { writable: !0, value: {} },
      filename: { writable: !0, value: n.filename },
      indentExclusionRanges: { writable: !0, value: n.indentExclusionRanges },
      sourcemapLocations: { writable: !0, value: new Jt() },
      storedNames: { writable: !0, value: {} },
      indentStr: { writable: !0, value: void 0 },
      ignoreList: { writable: !0, value: n.ignoreList },
      offset: { writable: !0, value: n.offset || 0 }
    }), this.byStart[0] = e, this.byEnd[t.length] = e;
  }
  addSourcemapLocation(t) {
    this.sourcemapLocations.add(t);
  }
  append(t) {
    if (typeof t != "string") throw new TypeError("outro content must be a string");
    return this.outro += t, this;
  }
  appendLeft(t, n) {
    if (t = t + this.offset, typeof n != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const e = this.byEnd[t];
    return e ? e.appendLeft(n) : this.intro += n, this;
  }
  appendRight(t, n) {
    if (t = t + this.offset, typeof n != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const e = this.byStart[t];
    return e ? e.appendRight(n) : this.outro += n, this;
  }
  clone() {
    const t = new U(this.original, { filename: this.filename, offset: this.offset });
    let n = this.firstChunk, e = t.firstChunk = t.lastSearchedChunk = n.clone();
    for (; n; ) {
      t.byStart[e.start] = e, t.byEnd[e.end] = e;
      const i = n.next, o = i && i.clone();
      o && (e.next = o, o.previous = e, e = o), n = i;
    }
    return t.lastChunk = e, this.indentExclusionRanges && (t.indentExclusionRanges = this.indentExclusionRanges.slice()), t.sourcemapLocations = new Jt(this.sourcemapLocations), t.intro = this.intro, t.outro = this.outro, t;
  }
  generateDecodedMap(t) {
    t = t || {};
    const n = 0, e = Object.keys(this.storedNames), i = new ze(t.hires), o = de(this.original);
    return this.intro && i.advance(this.intro), this.firstChunk.eachNext((s) => {
      const r = o(s.start);
      s.intro.length && i.advance(s.intro), s.edited ? i.addEdit(
        n,
        s.content,
        r,
        s.storeName ? e.indexOf(s.original) : -1
      ) : i.addUneditedChunk(n, s, this.original, r, this.sourcemapLocations), s.outro.length && i.advance(s.outro);
    }), {
      file: t.file ? t.file.split(/[/\\]/).pop() : void 0,
      sources: [
        t.source ? Re(t.file || "", t.source) : t.file || ""
      ],
      sourcesContent: t.includeContent ? [this.original] : void 0,
      names: e,
      mappings: i.raw,
      x_google_ignoreList: this.ignoreList ? [n] : void 0
    };
  }
  generateMap(t) {
    return new Oe(this.generateDecodedMap(t));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = Te(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(t, n) {
    const e = /^[^\r\n]/gm;
    if (je(t) && (n = t, t = void 0), t === void 0 && (this._ensureindentStr(), t = this.indentStr || "	"), t === "") return this;
    n = n || {};
    const i = {};
    n.exclude && (typeof n.exclude[0] == "number" ? [n.exclude] : n.exclude).forEach((f) => {
      for (let l = f[0]; l < f[1]; l += 1)
        i[l] = !0;
    });
    let o = n.indentStart !== !1;
    const s = (d) => o ? `${t}${d}` : (o = !0, d);
    this.intro = this.intro.replace(e, s);
    let r = 0, a = this.firstChunk;
    for (; a; ) {
      const d = a.end;
      if (a.edited)
        i[r] || (a.content = a.content.replace(e, s), a.content.length && (o = a.content[a.content.length - 1] === `
`));
      else
        for (r = a.start; r < d; ) {
          if (!i[r]) {
            const f = this.original[r];
            f === `
` ? o = !0 : f !== "\r" && o && (o = !1, r === a.start || (this._splitChunk(a, r), a = a.next), a.prependRight(t));
          }
          r += 1;
        }
      r = a.end, a = a.next;
    }
    return this.outro = this.outro.replace(e, s), this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(t, n) {
    return At.insertLeft || (console.warn(
      "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
    ), At.insertLeft = !0), this.appendLeft(t, n);
  }
  insertRight(t, n) {
    return At.insertRight || (console.warn(
      "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
    ), At.insertRight = !0), this.prependRight(t, n);
  }
  move(t, n, e) {
    if (t = t + this.offset, n = n + this.offset, e = e + this.offset, e >= t && e <= n) throw new Error("Cannot move a selection inside itself");
    this._split(t), this._split(n), this._split(e);
    const i = this.byStart[t], o = this.byEnd[n], s = i.previous, r = o.next, a = this.byStart[e];
    if (!a && o === this.lastChunk) return this;
    const d = a ? a.previous : this.lastChunk;
    return s && (s.next = r), r && (r.previous = s), d && (d.next = i), a && (a.previous = o), i.previous || (this.firstChunk = o.next), o.next || (this.lastChunk = i.previous, this.lastChunk.next = null), i.previous = d, o.next = a || null, d || (this.firstChunk = i), a || (this.lastChunk = o), this;
  }
  overwrite(t, n, e, i) {
    return i = i || {}, this.update(t, n, e, { ...i, overwrite: !i.contentOnly });
  }
  update(t, n, e, i) {
    if (t = t + this.offset, n = n + this.offset, typeof e != "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; n < 0; ) n += this.original.length;
    }
    if (n > this.original.length) throw new Error("end is out of bounds");
    if (t === n)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(t), this._split(n), i === !0 && (At.storeName || (console.warn(
      "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
    ), At.storeName = !0), i = { storeName: !0 });
    const o = i !== void 0 ? i.storeName : !1, s = i !== void 0 ? i.overwrite : !1;
    if (o) {
      const d = this.original.slice(t, n);
      Object.defineProperty(this.storedNames, d, {
        writable: !0,
        value: !0,
        enumerable: !0
      });
    }
    const r = this.byStart[t], a = this.byEnd[n];
    if (r) {
      let d = r;
      for (; d !== a; ) {
        if (d.next !== this.byStart[d.end])
          throw new Error("Cannot overwrite across a split point");
        d = d.next, d.edit("", !1);
      }
      r.edit(e, o, !s);
    } else {
      const d = new Rt(t, n, "").edit(e, o);
      a.next = d, d.previous = a;
    }
    return this;
  }
  prepend(t) {
    if (typeof t != "string") throw new TypeError("outro content must be a string");
    return this.intro = t + this.intro, this;
  }
  prependLeft(t, n) {
    if (t = t + this.offset, typeof n != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const e = this.byEnd[t];
    return e ? e.prependLeft(n) : this.intro = n + this.intro, this;
  }
  prependRight(t, n) {
    if (t = t + this.offset, typeof n != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const e = this.byStart[t];
    return e ? e.prependRight(n) : this.outro = n + this.outro, this;
  }
  remove(t, n) {
    if (t = t + this.offset, n = n + this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; n < 0; ) n += this.original.length;
    }
    if (t === n) return this;
    if (t < 0 || n > this.original.length) throw new Error("Character is out of bounds");
    if (t > n) throw new Error("end must be greater than start");
    this._split(t), this._split(n);
    let e = this.byStart[t];
    for (; e; )
      e.intro = "", e.outro = "", e.edit(""), e = n > e.end ? this.byStart[e.end] : null;
    return this;
  }
  reset(t, n) {
    if (t = t + this.offset, n = n + this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; n < 0; ) n += this.original.length;
    }
    if (t === n) return this;
    if (t < 0 || n > this.original.length) throw new Error("Character is out of bounds");
    if (t > n) throw new Error("end must be greater than start");
    this._split(t), this._split(n);
    let e = this.byStart[t];
    for (; e; )
      e.reset(), e = n > e.end ? this.byStart[e.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let t = this.lastChunk;
    do {
      if (t.outro.length) return t.outro[t.outro.length - 1];
      if (t.content.length) return t.content[t.content.length - 1];
      if (t.intro.length) return t.intro[t.intro.length - 1];
    } while (t = t.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let t = this.outro.lastIndexOf(Mt);
    if (t !== -1) return this.outro.substr(t + 1);
    let n = this.outro, e = this.lastChunk;
    do {
      if (e.outro.length > 0) {
        if (t = e.outro.lastIndexOf(Mt), t !== -1) return e.outro.substr(t + 1) + n;
        n = e.outro + n;
      }
      if (e.content.length > 0) {
        if (t = e.content.lastIndexOf(Mt), t !== -1) return e.content.substr(t + 1) + n;
        n = e.content + n;
      }
      if (e.intro.length > 0) {
        if (t = e.intro.lastIndexOf(Mt), t !== -1) return e.intro.substr(t + 1) + n;
        n = e.intro + n;
      }
    } while (e = e.previous);
    return t = this.intro.lastIndexOf(Mt), t !== -1 ? this.intro.substr(t + 1) + n : this.intro + n;
  }
  slice(t = 0, n = this.original.length - this.offset) {
    if (t = t + this.offset, n = n + this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; n < 0; ) n += this.original.length;
    }
    let e = "", i = this.firstChunk;
    for (; i && (i.start > t || i.end <= t); ) {
      if (i.start < n && i.end >= n)
        return e;
      i = i.next;
    }
    if (i && i.edited && i.start !== t)
      throw new Error(`Cannot use replaced character ${t} as slice start anchor.`);
    const o = i;
    for (; i; ) {
      i.intro && (o !== i || i.start === t) && (e += i.intro);
      const s = i.start < n && i.end >= n;
      if (s && i.edited && i.end !== n)
        throw new Error(`Cannot use replaced character ${n} as slice end anchor.`);
      const r = o === i ? t - i.start : 0, a = s ? i.content.length + n - i.end : i.content.length;
      if (e += i.content.slice(r, a), i.outro && (!s || i.end === n) && (e += i.outro), s)
        break;
      i = i.next;
    }
    return e;
  }
  // TODO deprecate this? not really very useful
  snip(t, n) {
    const e = this.clone();
    return e.remove(0, t), e.remove(n, e.original.length), e;
  }
  _split(t) {
    if (this.byStart[t] || this.byEnd[t]) return;
    let n = this.lastSearchedChunk;
    const e = t > n.end;
    for (; n; ) {
      if (n.contains(t)) return this._splitChunk(n, t);
      n = e ? this.byStart[n.end] : this.byEnd[n.start];
    }
  }
  _splitChunk(t, n) {
    if (t.edited && t.content.length) {
      const i = de(this.original)(n);
      throw new Error(
        `Cannot split a chunk that has already been edited (${i.line}:${i.column} – "${t.original}")`
      );
    }
    const e = t.split(n);
    return this.byEnd[n] = t, this.byStart[n] = e, this.byEnd[e.end] = e, t === this.lastChunk && (this.lastChunk = e), this.lastSearchedChunk = t, !0;
  }
  toString() {
    let t = this.intro, n = this.firstChunk;
    for (; n; )
      t += n.toString(), n = n.next;
    return t + this.outro;
  }
  isEmpty() {
    let t = this.firstChunk;
    do
      if (t.intro.length && t.intro.trim() || t.content.length && t.content.trim() || t.outro.length && t.outro.trim())
        return !1;
    while (t = t.next);
    return !0;
  }
  length() {
    let t = this.firstChunk, n = 0;
    do
      n += t.intro.length + t.content.length + t.outro.length;
    while (t = t.next);
    return n;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(t) {
    return this.trimStart(t).trimEnd(t);
  }
  trimEndAborted(t) {
    const n = new RegExp((t || "\\s") + "+$");
    if (this.outro = this.outro.replace(n, ""), this.outro.length) return !0;
    let e = this.lastChunk;
    do {
      const i = e.end, o = e.trimEnd(n);
      if (e.end !== i && (this.lastChunk === e && (this.lastChunk = e.next), this.byEnd[e.end] = e, this.byStart[e.next.start] = e.next, this.byEnd[e.next.end] = e.next), o) return !0;
      e = e.previous;
    } while (e);
    return !1;
  }
  trimEnd(t) {
    return this.trimEndAborted(t), this;
  }
  trimStartAborted(t) {
    const n = new RegExp("^" + (t || "\\s") + "+");
    if (this.intro = this.intro.replace(n, ""), this.intro.length) return !0;
    let e = this.firstChunk;
    do {
      const i = e.end, o = e.trimStart(n);
      if (e.end !== i && (e === this.lastChunk && (this.lastChunk = e.next), this.byEnd[e.end] = e, this.byStart[e.next.start] = e.next, this.byEnd[e.next.end] = e.next), o) return !0;
      e = e.next;
    } while (e);
    return !1;
  }
  trimStart(t) {
    return this.trimStartAborted(t), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(t, n) {
    function e(o, s) {
      return typeof n == "string" ? n.replace(/\$(\$|&|\d+)/g, (r, a) => a === "$" ? "$" : a === "&" ? o[0] : +a < o.length ? o[+a] : `$${a}`) : n(...o, o.index, s, o.groups);
    }
    function i(o, s) {
      let r;
      const a = [];
      for (; r = o.exec(s); )
        a.push(r);
      return a;
    }
    if (t.global)
      i(t, this.original).forEach((s) => {
        if (s.index != null) {
          const r = e(s, this.original);
          r !== s[0] && this.overwrite(s.index, s.index + s[0].length, r);
        }
      });
    else {
      const o = this.original.match(t);
      if (o && o.index != null) {
        const s = e(o, this.original);
        s !== o[0] && this.overwrite(o.index, o.index + o[0].length, s);
      }
    }
    return this;
  }
  _replaceString(t, n) {
    const { original: e } = this, i = e.indexOf(t);
    return i !== -1 && this.overwrite(i, i + t.length, n), this;
  }
  replace(t, n) {
    return typeof t == "string" ? this._replaceString(t, n) : this._replaceRegexp(t, n);
  }
  _replaceAllString(t, n) {
    const { original: e } = this, i = t.length;
    for (let o = e.indexOf(t); o !== -1; o = e.indexOf(t, o + i))
      e.slice(o, o + i) !== n && this.overwrite(o, o + i, n);
    return this;
  }
  replaceAll(t, n) {
    if (typeof t == "string")
      return this._replaceAllString(t, n);
    if (!t.global)
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    return this._replaceRegexp(t, n);
  }
}
const Bt = (c, t) => {
  const n = c.__vccOpts || c;
  for (const [e, i] of t)
    n[e] = i;
  return n;
}, j = Lt(!1), V = b(() => {
  j.value = !0;
}, {
  metaData: {
    id: "engine.setting.event.BindEventsDialog.open"
  },
  ctx: () => ({
    string2Ast: H,
    getMergeMeta: L,
    useCanvas: y,
    useHistory: K,
    useLayout: N,
    getOptions: X,
    getMetaApi: k,
    META_APP: C,
    MagicString: U,
    meta: R,
    dialogVisible: j,
    open: V,
    close: F
  })
}), F = b(() => {
  j.value = !1;
}, {
  metaData: {
    id: "engine.setting.event.BindEventsDialog.close"
  },
  ctx: () => ({
    string2Ast: H,
    getMergeMeta: L,
    useCanvas: y,
    useHistory: K,
    useLayout: N,
    getOptions: X,
    getMetaApi: k,
    META_APP: C,
    MagicString: U,
    meta: R,
    dialogVisible: j,
    open: V,
    close: F
  })
}), Fe = {
  components: {
    TinyButton: Ft,
    TinyDialogBox: fe,
    TinyAlert: ye
  },
  inheritAttrs: !1,
  props: {
    eventBinding: {
      type: Object,
      default: () => ({})
    }
  },
  setup(c) {
    const {
      BindEventsDialogSidebar: t,
      BindEventsDialogContent: n
    } = L(R.id).components, {
      PLUGIN_NAME: e,
      activePlugin: i
    } = N(), {
      pageState: o
    } = y(), {
      getMethods: s,
      saveMethod: r,
      highlightMethod: a
    } = k(C.Page), d = Ut({
      editorContent: "",
      bindMethodInfo: {},
      tip: "",
      tipError: !1,
      enableExtraParams: !1,
      isValidParams: !0
    });
    he("context", d);
    const f = b((E) => {
      d.bindMethodInfo = E;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.selectMethod"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), l = b((E) => {
      var Y, q;
      if (!E)
        return;
      const v = (Y = c.eventBinding) == null ? void 0 : Y.eventName;
      if (!v)
        return;
      const D = (q = o == null ? void 0 : o.currentSchema) == null ? void 0 : q.props;
      if (!D)
        return;
      const {
        name: M,
        extra: et
      } = E;
      c[v] || (D[v] = {
        type: "JSExpression",
        value: ""
      }), et && d.enableExtraParams && (D[v].params = et), D[v].value = `this.${M}`, K().addHistory();
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.bindMethod"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), u = b(() => {
      d.tipError = !1, d.tip = "", d.isValidParams = !0;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.resetTipError"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), h = b(() => {
      let E = "";
      if (d.enableExtraParams)
        try {
          E = JSON.parse(d.editorContent), d.isValidParams = Array.isArray(E);
        } catch {
          d.isValidParams = !1;
        }
      return E;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.getExtraParams"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), g = b((E) => Array.from({
      length: E.length
    }, (v, D) => `args${D}`).join(","), {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.getFormatParams"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), p = b((E, v, D, M, et) => {
      var nt, it, ot, Z, jt;
      const Y = et && M.length ? `event,${D}` : D, q = `function ${v} (${Y}) {
}
`;
      if (!E)
        return q;
      try {
        const gt = new U(E), T = H(E);
        if (((it = (nt = T == null ? void 0 : T.program) == null ? void 0 : nt.body[0]) == null ? void 0 : it.type) !== "FunctionDeclaration")
          return q;
        if (((ot = T == null ? void 0 : T.program) == null ? void 0 : ot.body[0].params.length) === M.length + 1)
          return E;
        const Pt = (Z = T == null ? void 0 : T.program) == null ? void 0 : Z.body[0].id.end, Xt = (jt = T == null ? void 0 : T.program) == null ? void 0 : jt.body[0].body.start;
        return gt.remove(Pt, Xt), gt.appendLeft(Pt, `(${Y})`), gt.toString();
      } catch {
        return q;
      }
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.rewriteMethodParams"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), w = b(() => {
      i(e.Page).then(() => {
        Ee(() => {
          var E;
          a && a((E = d.bindMethodInfo) == null ? void 0 : E.name);
        });
      });
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.activePagePlugin"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), x = b(async () => {
      var it, ot;
      if (d.tipError)
        return;
      let E = "event";
      const v = h();
      let D = E;
      if (!d.isValidParams)
        return;
      v && (E = v.join(","), D = g(v)), l({
        ...d.bindMethodInfo,
        params: E,
        extra: v
      });
      const {
        name: M
      } = d.bindMethodInfo, et = (ot = (it = s()) == null ? void 0 : it[d.bindMethodInfo.name]) == null ? void 0 : ot.value, Y = p(et, M, D, v, d.enableExtraParams), q = {
        name: M,
        content: Y
      }, {
        beforeSaveMethod: nt
      } = X(R.id);
      typeof nt == "function" && await nt(q, d.bindMethodInfo), r == null || r(q), w(), F();
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.confirm"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), A = b(() => {
      var E, v, D;
      d.enableExtraParams = !!((v = (E = c.eventBinding) == null ? void 0 : E.params) != null && v.length), d.editorContent = JSON.stringify(((D = c.eventBinding) == null ? void 0 : D.params) || [], null, 2), u();
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.openedDialog"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    }), P = b(() => {
      u(), F();
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialog.closeDialog"
      },
      ctx: () => ({
        props: c,
        BindEventsDialogSidebar: t,
        BindEventsDialogContent: n,
        PLUGIN_NAME: e,
        activePlugin: i,
        pageState: o,
        getMethods: s,
        saveMethod: r,
        highlightMethod: a,
        state: d,
        selectMethod: f,
        bindMethod: l,
        resetTipError: u,
        getExtraParams: h,
        getFormatParams: g,
        rewriteMethodParams: p,
        activePagePlugin: w,
        confirm: x,
        openedDialog: A,
        closeDialog: P,
        string2Ast: H,
        getMergeMeta: L,
        useCanvas: y,
        useHistory: K,
        useLayout: N,
        getOptions: X,
        getMetaApi: k,
        META_APP: C,
        MagicString: U,
        meta: R,
        dialogVisible: j,
        open: V,
        close: F
      })
    });
    return {
      BindEventsDialogSidebar: t,
      BindEventsDialogContent: n,
      state: d,
      dialogVisible: j,
      confirm: x,
      closeDialog: P,
      openedDialog: A,
      selectMethod: f
    };
  }
}, Je = { class: "bind-event-dialog-tip" }, Xe = { class: "bind-event-dialog-content" }, Ke = { class: "bind-dialog-footer" };
function He(c, t, n, e, i, o) {
  const s = B("tiny-alert"), r = B("tiny-button"), a = B("tiny-dialog-box");
  return S(), tt(a, {
    visible: e.dialogVisible,
    title: "事件绑定",
    width: "50%",
    "dialog-class": "bind-event-dialog",
    draggable: "",
    "append-to-body": !0,
    onClose: e.closeDialog,
    onOpened: e.openedDialog
  }, {
    footer: I(() => [
      m("div", Ke, [
        _(r, { onClick: e.closeDialog }, {
          default: I(() => t[0] || (t[0] = [
            Dt("取 消", -1)
          ])),
          _: 1,
          __: [0]
        }, 8, ["onClick"]),
        _(r, {
          type: "info",
          onClick: e.confirm
        }, {
          default: I(() => t[1] || (t[1] = [
            Dt("确 定", -1)
          ])),
          _: 1,
          __: [1]
        }, 8, ["onClick"])
      ])
    ]),
    default: I(() => [
      m("div", Je, [
        _(s, {
          type: "info",
          description: "选择已有方法或者添加新方法（点击 确定 之后将在JS面板中创建一个该名称的新方法）。",
          class: "header-alert",
          closable: !1
        })
      ]),
      m("div", Xe, [
        (S(), tt(te(e.BindEventsDialogSidebar), {
          dialogVisible: e.dialogVisible,
          eventBinding: n.eventBinding
        }, null, 8, ["dialogVisible", "eventBinding"])),
        (S(), tt(te(e.BindEventsDialogContent), { dialogVisible: e.dialogVisible }, null, 8, ["dialogVisible"]))
      ])
    ]),
    _: 1
  }, 8, ["visible", "onClose", "onOpened"]);
}
const Ct = /* @__PURE__ */ Bt(Fe, [["render", He], ["__scopeId", "data-v-84897b97"]]), pe = {
  onClick: {
    label: {
      zh_CN: "点击事件"
    },
    description: {
      zh_CN: "鼠标单击时触发的回调函数"
    },
    type: "event",
    functionInfo: {
      params: [],
      returns: {}
    },
    defaultValue: ""
  },
  onChange: {
    label: {
      zh_CN: "值被改变时触发"
    },
    description: {
      zh_CN: "当用户更改 <input>、<select> 和 <textarea> 元素的值时，被触发的回调函数，"
    },
    type: "event",
    functionInfo: {
      params: [],
      returns: {}
    },
    defaultValue: ""
  },
  onFocus: {
    label: {
      zh_CN: "元素获得焦点"
    },
    description: {
      zh_CN: "元素获得焦点时触发的回调函数"
    },
    type: "event",
    functionInfo: {
      params: [],
      returns: {}
    },
    defaultValue: ""
  },
  onMousemove: {
    label: {
      zh_CN: "鼠标移动时触发"
    },
    description: {
      zh_CN: "鼠标移动时触发的回调函数"
    },
    type: "event",
    functionInfo: {
      params: [],
      returns: {}
    },
    defaultValue: ""
  }
}, ce = ["onabort", "onafterprint", "onanimationend", "onanimationiteration", "onanimationstart", "onappinstalled", "onauxclick", "onbeforeinstallprompt", "onbeforeprint", "onbeforeunload", "onbeforexrselect", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onformdata", "ongotpointercapture", "onhashchange", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onlanguagechange", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmessage", "onmessageerror", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onoffline", "ononline", "onpagehide", "onpageshow", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerrawupdate", "onpointerup", "onpopstate", "onprogress", "onratechange", "onrejectionhandled", "onreset", "onresize", "onscroll", "onsearch", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onstorage", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onunhandledrejection", "onunload", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"], Ot = b((c) => !!ce.map((n) => {
  const e = n[2].toUpperCase();
  return `${n.substring(0, 2)}${e}${n.substring(3)}`;
}).includes(c), {
  metaData: {
    id: "engine.setting.event.commonjs-events.checkEvent"
  },
  ctx: () => ({
    commonEvents: pe,
    allEvents: ce,
    checkEvent: Ot
  })
}), qe = { class: "footer" }, Ge = {
  __name: "AddEventsDialog",
  props: {
    visible: {
      type: Boolean,
      default: !1
    },
    componentEvents: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["closeDialog", "addEvent"],
  setup(c, { emit: t }) {
    const n = c, e = t, i = Ut({
      eventDescription: "",
      eventName: ""
    }), o = Lt(null), s = b((f, l, u) => {
      if (n.componentEvents[i.eventName]) {
        u(new Error("事件名已存在"));
        return;
      }
      if (!Ot(i.eventName)) {
        u(new Error("请输入正确的浏览器事件名"));
        return;
      }
      u();
    }, {
      metaData: {
        id: "engine.setting.event.AddEventsDialog.eventNameValidator"
      },
      ctx: () => ({
        checkEvent: Ot,
        props: n,
        emits: e,
        formData: i,
        ruleForm: o,
        eventNameValidator: s,
        rules: r,
        closeDialog: a,
        addMethod: d
      })
    }), r = {
      eventDescription: [{
        required: !0,
        message: "必填"
      }],
      eventName: [{
        required: !0,
        message: "必填"
      }, {
        validator: s
      }]
    }, a = b(() => {
      e("closeDialog");
    }, {
      metaData: {
        id: "engine.setting.event.AddEventsDialog.closeDialog"
      },
      ctx: () => ({
        checkEvent: Ot,
        props: n,
        emits: e,
        formData: i,
        ruleForm: o,
        eventNameValidator: s,
        rules: r,
        closeDialog: a,
        addMethod: d
      })
    }), d = b(() => {
      o.value && o.value.validate((f) => {
        if (!f)
          return;
        const {
          eventName: l,
          eventDescription: u
        } = i;
        e("addEvent", {
          eventName: l,
          eventDescription: u
        });
      });
    }, {
      metaData: {
        id: "engine.setting.event.AddEventsDialog.addMethod"
      },
      ctx: () => ({
        checkEvent: Ot,
        props: n,
        emits: e,
        formData: i,
        ruleForm: o,
        eventNameValidator: s,
        rules: r,
        closeDialog: a,
        addMethod: d
      })
    });
    return (f, l) => (S(), tt(O(fe), {
      visible: c.visible,
      title: "添加新事件",
      width: "400px",
      "append-to-body": !0,
      "close-on-click-modal": !1,
      onClose: O(a)
    }, {
      footer: I(() => [
        m("div", qe, [
          _(O(Ft), { onClick: O(a) }, {
            default: I(() => l[2] || (l[2] = [
              Dt(" 取消", -1)
            ])),
            _: 1,
            __: [2]
          }, 8, ["onClick"]),
          _(O(Ft), {
            type: "primary",
            onClick: O(d)
          }, {
            default: I(() => l[3] || (l[3] = [
              Dt(" 确定", -1)
            ])),
            _: 1,
            __: [3]
          }, 8, ["onClick"])
        ])
      ]),
      default: I(() => [
        _(O(we), {
          ref_key: "ruleForm",
          ref: o,
          model: i,
          rules: r,
          "label-width": "80px",
          "inline-message": !0,
          "validate-type": "text",
          "label-position": "left",
          class: "add-custom-event-form"
        }, {
          default: I(() => [
            _(O(oe), {
              label: "事件函数名",
              prop: "eventName",
              required: ""
            }, {
              default: I(() => [
                _(O(qt), {
                  modelValue: i.eventName,
                  "onUpdate:modelValue": l[0] || (l[0] = (u) => i.eventName = u),
                  placeholder: "小驼峰格式，如：onDrag"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            _(O(oe), {
              label: "事件描述",
              prop: "eventDescription",
              required: ""
            }, {
              default: I(() => [
                _(O(qt), {
                  modelValue: i.eventDescription,
                  "onUpdate:modelValue": l[1] || (l[1] = (u) => i.eventDescription = u)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model"])
      ]),
      _: 1
    }, 8, ["visible", "onClose"]));
  }
}, kt = /* @__PURE__ */ Bt(Ge, [["__scopeId", "data-v-2ed7fac6"]]), We = {
  components: {
    BlockLinkEvent: wt,
    BindEventsDialog: Ct,
    TinyPopover: xe,
    TinyButton: Ft,
    IconChevronDown: xt(),
    SvgButton: yt,
    AddEventsDialog: kt
  },
  inheritAttrs: !1,
  setup() {
    const {
      PLUGIN_NAME: c,
      activePlugin: t
    } = N(), {
      pageState: n
    } = y(), {
      getBlockEvents: e,
      getCurrentBlock: i,
      removeEventLink: o
    } = pt(), {
      getMaterial: s
    } = vt(), {
      confirm: r
    } = bt(), a = Et.global.locale.value, {
      highlightMethod: d
    } = k(C.Page), {
      commonEvents: f = {}
    } = L("engine.setting.event").options, l = Ut({
      eventName: "",
      // 事件名称
      eventBinding: null,
      // 事件绑定的处理方法对象
      componentEvent: {},
      customEvents: f,
      bindActions: {},
      showBindEventDialog: !1
    }), u = Tt(() => !!n.isBlock), h = Tt(() => Object.keys(l.bindActions).length === 0), g = Tt(() => ({
      ...l.componentEvent,
      ...l.customEvents
    }));
    ue(() => {
      var Y, q, nt, it, ot;
      const v = (Y = n == null ? void 0 : n.currentSchema) == null ? void 0 : Y.componentName, D = s(v);
      l.componentEvent = ((nt = (q = D == null ? void 0 : D.content) == null ? void 0 : q.schema) == null ? void 0 : nt.events) || ((it = D == null ? void 0 : D.schema) == null ? void 0 : it.events) || {};
      const M = ((ot = n == null ? void 0 : n.currentSchema) == null ? void 0 : ot.props) || {}, et = Object.keys(M);
      l.bindActions = {}, Object.entries(g.value).forEach(([Z, jt]) => {
        var gt, T, Pt;
        if (et.indexOf(Z) > -1) {
          const Xt = M[Z], {
            value: ve,
            params: Gt
          } = Xt, be = !Gt && ((T = (gt = ve.match(/\((.+)\)$/)) == null ? void 0 : gt[1]) == null ? void 0 : T.split(",")) || Gt, ft = {
            eventName: Z,
            ref: "",
            event: M[Z],
            params: be
          };
          if (ft.event.type === "JSExpression" && (ft.ref = ft.event.value.replace("this.", "").replace(/\(.*\)$/, "")), n.isBlock) {
            ft.metaEvent = jt;
            const Wt = e(i()), Yt = (Pt = n == null ? void 0 : n.currentSchema) == null ? void 0 : Pt.id;
            Yt && Wt && Object.entries(Wt).forEach(([_e, mt]) => {
              var Zt, Qt;
              Yt === ((Zt = mt == null ? void 0 : mt.linked) == null ? void 0 : Zt.id) && Z === ((Qt = mt == null ? void 0 : mt.linked) == null ? void 0 : Qt.event) && (ft.linked = mt.linked, ft.linkedEventName = _e);
            });
          }
          l.bindActions[Z] = ft;
        }
      });
    });
    const p = b((v, D) => {
      D && l.bindActions[v.eventName] || (l.eventBinding = v, V());
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.openActionDialog"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    }), w = b((v) => {
      var M;
      Object.keys(((M = n == null ? void 0 : n.currentSchema) == null ? void 0 : M.props) || {}).indexOf(v.eventName) > -1 && (delete n.currentSchema.props[v.eventName], _t().publish({
        topic: "schemaChange",
        data: {
          props: n.currentSchema.props
        }
      }));
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.deleteAction"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    }), x = b((v) => {
      r({
        title: "提示",
        message: `您确定要删除事件 ${v.eventName} 吗?`,
        exec() {
          n.isBlock && o({
            linked: v.linked
          }), w(v);
        }
      });
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.delEvent"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    }), A = b((v) => {
      v && t(c.Page).then(() => {
        d && d(v.ref);
      });
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.openCodePanel"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    }), P = b((v) => {
      l.showBindEventDialog = v;
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.handleToggleAddEventDialog"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    }), E = b((v) => {
      const {
        eventName: D,
        eventDescription: M
      } = v;
      Object.assign(l.customEvents, {
        [D]: {
          label: {
            zh_CN: M
          },
          description: {
            zh_CN: `${M}的回调函数`
          },
          type: "event",
          functionInfo: {
            params: [],
            returns: {}
          },
          defaultValue: ""
        }
      }), l.showBindEventDialog = !1;
    }, {
      metaData: {
        id: "engine.setting.event.BindEvents.handleAddEvent"
      },
      ctx: () => ({
        PLUGIN_NAME: c,
        activePlugin: t,
        pageState: n,
        getBlockEvents: e,
        getCurrentBlock: i,
        removeEventLink: o,
        getMaterial: s,
        confirm: r,
        locale: a,
        highlightMethod: d,
        commonEvents: f,
        state: l,
        isBlock: u,
        isEmpty: h,
        renderEventList: g,
        openActionDialog: p,
        deleteAction: w,
        delEvent: x,
        openCodePanel: A,
        handleToggleAddEventDialog: P,
        handleAddEvent: E,
        useModal: bt,
        getMergeMeta: L,
        useCanvas: y,
        useLayout: N,
        useBlock: pt,
        useMaterial: vt,
        getMetaApi: k,
        META_APP: C,
        useMessage: _t,
        i18n: Et,
        BlockLinkEvent: wt,
        SvgButton: yt,
        iconChevronDown: xt,
        BindEventsDialog: Ct,
        openDialog: V,
        AddEventsDialog: kt
      })
    });
    return {
      state: l,
      isBlock: u,
      isEmpty: h,
      delEvent: x,
      openCodePanel: A,
      openActionDialog: p,
      handleAddEvent: E,
      handleToggleAddEventDialog: P,
      renderEventList: g,
      locale: a
    };
  }
}, Ye = { class: "bind-action-list" }, Ze = { class: "popover-head" }, Qe = { class: "bind-event-list" }, tn = ["onClick"], en = { class: "bind-actions" }, nn = { class: "action-item bind-action-item" }, on = ["onClick"], sn = { class: "event-bind" }, rn = { class: "action-buttons" }, an = { class: "empty-action" }, ln = { class: "icon" };
function dn(c, t, n, e, i, o) {
  const s = B("icon-chevron-down"), r = B("tiny-button"), a = B("tiny-popover"), d = B("svg-icon"), f = B("block-link-event"), l = B("svg-button"), u = B("bind-events-dialog"), h = B("add-events-dialog");
  return S(), J($t, null, [
    m("div", Ye, [
      m("div", Ze, [
        _(a, {
          popperClass: "option-popper setting-advanced-bind-event-list",
          placement: "bottom-start",
          trigger: "hover",
          class: "bind-action-button-item",
          width: "256",
          "visible-arrow": !1
        }, {
          reference: I(() => [
            _(r, { class: "bind-event-btn" }, {
              default: I(() => [
                t[2] || (t[2] = m("span", null, "绑定事件", -1)),
                _(s, { class: "icon-chevron-down bind-event-btn-icon" })
              ]),
              _: 1,
              __: [2]
            })
          ]),
          default: I(() => [
            m("ul", Qe, [
              (S(!0), J($t, null, Ht(e.renderEventList, (g, p) => {
                var w;
                return S(), J("li", {
                  key: p,
                  class: It(["bind-event-list-item", { "bind-event-list-item-notallow": e.state.bindActions[p] }]),
                  onClick: (x) => e.openActionDialog({ eventName: p }, !0)
                }, [
                  m("div", null, W(p) + "  |  " + W(((w = g == null ? void 0 : g.label) == null ? void 0 : w[e.locale]) || p), 1)
                ], 10, tn);
              }), 128))
            ])
          ]),
          _: 1
        }),
        _(r, {
          class: "title add-custom-event-button bind-action-button-item",
          onClick: t[0] || (t[0] = (g) => e.handleToggleAddEventDialog(!0))
        }, {
          default: I(() => [
            _(d, {
              name: "add",
              class: "custom-event-button-icon"
            }),
            t[3] || (t[3] = m("span", { class: "custom-event-button-text" }, "添加新事件", -1))
          ]),
          _: 1,
          __: [3]
        })
      ]),
      ee(m("ul", en, [
        (S(!0), J($t, null, Ht(e.state.bindActions, (g) => {
          var p, w;
          return S(), J("li", {
            key: g.eventName
          }, [
            m("div", nn, [
              m("div", {
                class: "binding-name",
                onClick: (x) => e.openActionDialog(g)
              }, [
                m("div", null, [
                  Dt(W(g.eventName), 1),
                  m("span", null, W((w = (p = e.renderEventList[g.eventName]) == null ? void 0 : p.label) == null ? void 0 : w[e.locale]), 1)
                ]),
                m("div", {
                  class: It({ linked: g.linked })
                }, W(g.linkedEventName), 3),
                m("span", sn, W(g.ref), 1)
              ], 8, on),
              m("div", rn, [
                e.isBlock ? (S(), tt(f, {
                  key: 0,
                  data: g
                }, null, 8, ["data"])) : zt("", !0),
                _(l, {
                  name: "plugin-icon-page-schema",
                  tips: "定位到代码",
                  placement: "top",
                  hoverBgColor: !1,
                  onClick: (x) => e.openCodePanel(g)
                }, null, 8, ["onClick"]),
                _(l, {
                  name: "setting",
                  hoverBgColor: !1,
                  onClick: (x) => e.openActionDialog(g, !1)
                }, null, 8, ["onClick"]),
                _(l, {
                  name: "delete",
                  hoverBgColor: !1,
                  onClick: (x) => e.delEvent(g)
                }, null, 8, ["onClick"])
              ])
            ])
          ]);
        }), 128))
      ], 512), [
        [ne, !e.isEmpty]
      ]),
      ee(m("div", an, [
        m("div", ln, [
          _(d, {
            name: "empty-action",
            class: "empty-action-icon"
          })
        ]),
        t[4] || (t[4] = m("div", { class: "center" }, "支持添加原生DOM事件，然后点击 绑定事件 为画布所选元素增加事件", -1))
      ], 512), [
        [ne, e.isEmpty]
      ])
    ]),
    _(u, {
      eventBinding: e.state.eventBinding
    }, null, 8, ["eventBinding"]),
    _(h, {
      visible: e.state.showBindEventDialog,
      componentEvents: e.renderEventList,
      onCloseDialog: t[1] || (t[1] = (g) => e.handleToggleAddEventDialog(!1)),
      onAddEvent: e.handleAddEvent
    }, null, 8, ["visible", "componentEvents", "onAddEvent"])
  ], 64);
}
const cn = /* @__PURE__ */ Bt(We, [["render", dn], ["__scopeId", "data-v-64f96b67"]]), {
  DEFAULT_LOOP_NAME: z
} = ht, {
  string2Obj: dt
} = ut, hn = {
  components: {
    SwitchConfigurator: lt,
    TinyTooltip: Ce,
    VariableConfigurator: at,
    InputConfigurator: rt,
    CodeConfigurator: st
  },
  inheritAttrs: !1,
  setup() {
    const {
      pageState: c
    } = y(), t = Lt(!1), n = Tt(() => {
      var l;
      return ((l = t.value) == null ? void 0 : l.type) === G.JSEXPRESSION;
    }), e = b(() => {
      var l, u;
      return ((u = (l = $().getSchema()) == null ? void 0 : l.loopArgs) == null ? void 0 : u[1]) || z.INDEX;
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.getIndexName"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    }), i = Ut({
      loopData: {
        type: G.JSEXPRESSION,
        value: "[]"
      },
      loopItem: "item",
      loopIndex: "index",
      isLoop: Tt(() => {
        var l;
        return ((l = i.loopData) == null ? void 0 : l.type) === G.JSEXPRESSION;
      }),
      loopKey: "",
      shouldUpdate: !1
    });
    ie(() => [c == null ? void 0 : c.currentSchema, i.shouldUpdate], ([l]) => {
      var u, h, g, p;
      t.value = (l == null ? void 0 : l.condition) === void 0 ? !0 : l == null ? void 0 : l.condition, i.loopData = l == null ? void 0 : l.loop, i.loopItem = ((u = l == null ? void 0 : l.loopArgs) == null ? void 0 : u[0]) || "", i.loopIndex = ((h = l == null ? void 0 : l.loopArgs) == null ? void 0 : h[1]) || "", i.loopKey = ((p = (g = l == null ? void 0 : l.props) == null ? void 0 : g.key) == null ? void 0 : p.value) || "";
    });
    const o = b((l = "") => {
      var x;
      l = l.replace(/\s*/g, "");
      const {
        getSchema: u,
        setProp: h
      } = $(), g = u();
      if (!g)
        return;
      const p = Number(l).toString() !== "NaN";
      let w = (x = g.props) == null ? void 0 : x.key;
      l && !p && (w = {
        type: G.JSEXPRESSION,
        value: l
      }), l || (i.isLoop ? w = {
        type: G.JSEXPRESSION,
        value: e()
      } : w = ""), h("key", w);
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.setLoopKey"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    });
    ie([() => i.isLoop, () => i.loopIndex], () => {
      !i.loopKey && i.isLoop && o(e()), i.isLoop || o("");
    });
    const s = b(() => {
      var l;
      i.loopData = (l = $().getSchema()) == null ? void 0 : l.loop;
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.openEditor"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    }), r = b((l) => {
      const {
        getSchema: u
      } = $(), h = u();
      if (!h)
        return;
      const {
        operateNode: g
      } = y();
      if (l === !1 || l != null && l.type)
        g({
          type: "updateAttributes",
          id: h.id,
          value: {
            condition: l
          }
        });
      else {
        const {
          condition: p,
          children: w,
          ...x
        } = h;
        g({
          type: "updateAttributes",
          id: h.id,
          value: {
            ...x
          },
          overwrite: !0
        });
      }
      y().canvasApi.value.updateRect(), t.value = l;
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.setConfig"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    }), a = b((l) => {
      const u = $().getSchema();
      let h = u.loopArgs;
      const {
        operateNode: g
      } = y();
      h ? h[1] = l || z.INDEX : h = [z.ITEM, l], g({
        type: "updateAttributes",
        id: u.id,
        value: {
          loopArgs: h
        }
      });
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.setLoopIndex"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    }), d = b((l) => {
      const {
        operateNode: u
      } = y(), {
        getSchema: h
      } = $(), g = h();
      if (l) {
        const p = l != null && l.type ? l : dt(l);
        u({
          type: "updateAttributes",
          id: g.id,
          value: {
            loop: p
          }
        }), a(z.INDEX);
      } else {
        o();
        const {
          loop: p,
          loopArgs: w,
          children: x,
          ...A
        } = g;
        u({
          type: "updateAttributes",
          id: g.id,
          value: A,
          overwrite: !0
        });
      }
      i.shouldUpdate = !i.shouldUpdate;
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.setLoop"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    }), f = b((l) => {
      const u = $().getSchema();
      let h = u.loopArgs;
      const {
        operateNode: g
      } = y();
      h ? h[0] = l || z.ITEM : h = [l, z.INDEX], g({
        type: "updateAttributes",
        id: u.id,
        value: {
          loopArgs: h
        }
      });
    }, {
      metaData: {
        id: "engine.setting.event.AdvanceConfig.setLoopItem"
      },
      ctx: () => ({
        pageState: c,
        condition: t,
        isBind: n,
        getIndexName: e,
        state: i,
        setLoopKey: o,
        openEditor: s,
        setConfig: r,
        setLoopIndex: a,
        setLoop: d,
        setLoopItem: f,
        CodeConfigurator: st,
        InputConfigurator: rt,
        SwitchConfigurator: lt,
        VariableConfigurator: at,
        useProperties: $,
        useCanvas: y,
        PROP_DATA_TYPE: G,
        constants: ht,
        utils: ut,
        DEFAULT_LOOP_NAME: z,
        string2Obj: dt
      })
    });
    return {
      condition: t,
      setConfig: r,
      isBind: n,
      state: i,
      setLoop: d,
      setLoopItem: f,
      DEFAULT_LOOP_NAME: z,
      openEditor: s,
      setLoopIndex: a,
      setLoopKey: o,
      getIndexName: e
    };
  }
}, un = { class: "advanced-config-container" }, gn = { class: "advnce-config" }, fn = { class: "advanced-config-form-item" }, mn = ["title"], pn = { class: "advnce-config loop-data-item" }, vn = { class: "advanced-config-form-item" }, bn = ["title"], _n = { class: "advnce-config" }, En = { class: "advanced-config-form-item" }, yn = { class: "advnce-config" }, wn = { class: "advanced-config-form-item" }, xn = { class: "advnce-config" }, Cn = { class: "advanced-config-form-item" };
function kn(c, t, n, e, i, o) {
  var l, u;
  const s = B("switch-configurator"), r = B("variable-configurator"), a = B("code-configurator"), d = B("input-configurator"), f = B("tiny-tooltip");
  return S(), J("div", un, [
    m("div", gn, [
      t[6] || (t[6] = m("label", { class: "text-ellipsis-multiple" }, "是否渲染", -1)),
      m("div", fn, [
        e.isBind ? (S(), J("div", {
          key: 1,
          class: "binding-state text-ellipsis-multiple",
          title: e.condition.value
        }, " 已绑定：" + W(e.condition.value), 9, mn)) : (S(), tt(s, {
          key: 0,
          modelValue: e.condition,
          "onUpdate:modelValue": e.setConfig
        }, null, 8, ["modelValue", "onUpdate:modelValue"])),
        _(r, {
          modelValue: e.condition,
          "onUpdate:modelValue": [
            t[0] || (t[0] = (h) => e.condition = h),
            e.setConfig
          ],
          name: "advance"
        }, null, 8, ["modelValue", "onUpdate:modelValue"])
      ])
    ]),
    m("div", pn, [
      t[7] || (t[7] = m("label", { class: "text-ellipsis-multiple" }, "循环数据", -1)),
      m("div", vn, [
        e.state.isLoop ? (S(), J("div", {
          key: 1,
          class: "binding-state text-ellipsis-multiple",
          title: (l = e.state.loopData) == null ? void 0 : l.value
        }, " 已绑定：" + W((u = e.state.loopData) == null ? void 0 : u.value), 9, bn)) : (S(), tt(a, {
          key: 0,
          modelValue: e.state.loopData,
          "onUpdate:modelValue": [
            t[1] || (t[1] = (h) => e.state.loopData = h),
            e.setLoop
          ],
          "data-type": "JSExpression",
          onOpen: e.openEditor
        }, null, 8, ["modelValue", "onUpdate:modelValue", "onOpen"])),
        _(r, {
          modelValue: e.state.loopData,
          "onUpdate:modelValue": [
            t[2] || (t[2] = (h) => e.state.loopData = h),
            e.setLoop
          ],
          name: "advance"
        }, null, 8, ["modelValue", "onUpdate:modelValue"])
      ])
    ]),
    m("div", _n, [
      t[8] || (t[8] = m("label", { class: "text-ellipsis-multiple" }, "迭代变量名", -1)),
      m("div", En, [
        _(d, {
          modelValue: e.state.loopItem,
          "onUpdate:modelValue": [
            t[3] || (t[3] = (h) => e.state.loopItem = h),
            e.setLoopItem
          ],
          placeholder: `默认值为：${e.DEFAULT_LOOP_NAME.ITEM}`
        }, null, 8, ["modelValue", "placeholder", "onUpdate:modelValue"])
      ])
    ]),
    m("div", yn, [
      t[9] || (t[9] = m("label", { class: "text-ellipsis-multiple" }, "索引变量名", -1)),
      m("div", wn, [
        _(d, {
          modelValue: e.state.loopIndex,
          "onUpdate:modelValue": [
            t[4] || (t[4] = (h) => e.state.loopIndex = h),
            e.setLoopIndex
          ],
          placeholder: `默认值为：${e.DEFAULT_LOOP_NAME.INDEX}`
        }, null, 8, ["modelValue", "placeholder", "onUpdate:modelValue"])
      ])
    ]),
    m("div", xn, [
      t[10] || (t[10] = m("label", { class: "text-ellipsis-multiple" }, "key", -1)),
      m("div", Cn, [
        _(f, {
          content: "建议填写循环项中的唯一值（如item.id），如果填写为数字将不保存",
          effect: "light"
        }, {
          default: I(() => [
            _(d, {
              modelValue: e.state.loopKey,
              "onUpdate:modelValue": [
                t[5] || (t[5] = (h) => e.state.loopKey = h),
                e.setLoopKey
              ],
              placeholder: `默认为索引名：${e.getIndexName()}`
            }, null, 8, ["modelValue", "placeholder", "onUpdate:modelValue"])
          ]),
          _: 1
        })
      ])
    ])
  ]);
}
const Dn = /* @__PURE__ */ Bt(hn, [["render", kn], ["__scopeId", "data-v-275ffc6c"]]), Sn = {
  __name: "Main",
  props: {
    fixedPanels: Array
  },
  emits: [],
  setup(c, { emit: t }) {
    const n = Lt(["bindEvent", "advancedConfig"]), {
      PLUGIN_NAME: e
    } = N(), o = Ut({
      emitEvent: t
    });
    return he("panelState", o), (s, r) => (S(), tt(O(Ae), {
      title: "高级",
      "fixed-panels": c.fixedPanels,
      "fixed-name": O(e).Event,
      "header-margin-bottom": 0,
      onClose: r[1] || (r[1] = (a) => s.$emit("close"))
    }, {
      content: I(() => [
        _(O(ke), {
          modelValue: n.value,
          "onUpdate:modelValue": r[0] || (r[0] = (a) => n.value = a)
        }, {
          default: I(() => [
            _(O(se), {
              title: "事件绑定",
              name: "bindEvent"
            }, {
              default: I(() => [
                _(cn)
              ]),
              _: 1
            }),
            _(O(se), {
              title: "高级配置",
              name: "advancedConfig"
            }, {
              default: I(() => [
                _(Dn)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    }, 8, ["fixed-panels", "fixed-name"]));
  }
}, Q = "newMethod", Kt = /[^0-9a-zA-Z_$]/, Nt = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/, ct = {
  default: "选择已有方法或者添加新方法(点击 确定 之后将在JS面板中创建一个该名称的新方法)",
  exist: "方法名称已存在",
  ruleInvalid: "请输入有效的方法名，可以由字母、数字、下划线、$ 符号组成，不能以数字开头",
  empty: "方法名称不能为空"
}, An = {
  components: {
    MonacoEditor: St,
    TinyInput: qt,
    TinyCheckbox: De
  },
  props: {
    dialogVisible: Boolean
  },
  setup() {
    const {
      getMethodNameList: c
    } = k(C.Page), t = ge("context"), n = {
      language: "json",
      lineNumbers: !1,
      minimap: {
        enabled: !1
      }
    }, e = b((a) => {
      t.editorContent = a;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialogContent.editorContentChange"
      },
      ctx: () => ({
        getMethodNameList: c,
        context: t,
        editorOptions: n,
        editorContentChange: e,
        validMethodNameEmpty: i,
        validMethodNameExist: o,
        invalidMethodName: s,
        change: r,
        VueMonaco: St,
        getMetaApi: k,
        META_APP: C,
        METHOD_TIPS_MAP: ct,
        NEW_METHOD_TYPE: Q,
        VALID_VARNAME_RE: Nt
      })
    }), i = b((a) => !a, {
      metaData: {
        id: "engine.setting.event.BindEventsDialogContent.validMethodNameEmpty"
      },
      ctx: () => ({
        getMethodNameList: c,
        context: t,
        editorOptions: n,
        editorContentChange: e,
        validMethodNameEmpty: i,
        validMethodNameExist: o,
        invalidMethodName: s,
        change: r,
        VueMonaco: St,
        getMetaApi: k,
        META_APP: C,
        METHOD_TIPS_MAP: ct,
        NEW_METHOD_TYPE: Q,
        VALID_VARNAME_RE: Nt
      })
    }), o = b((a) => c == null ? void 0 : c().includes(a), {
      metaData: {
        id: "engine.setting.event.BindEventsDialogContent.validMethodNameExist"
      },
      ctx: () => ({
        getMethodNameList: c,
        context: t,
        editorOptions: n,
        editorContentChange: e,
        validMethodNameEmpty: i,
        validMethodNameExist: o,
        invalidMethodName: s,
        change: r,
        VueMonaco: St,
        getMetaApi: k,
        META_APP: C,
        METHOD_TIPS_MAP: ct,
        NEW_METHOD_TYPE: Q,
        VALID_VARNAME_RE: Nt
      })
    }), s = b((a) => !Nt.test(a), {
      metaData: {
        id: "engine.setting.event.BindEventsDialogContent.invalidMethodName"
      },
      ctx: () => ({
        getMethodNameList: c,
        context: t,
        editorOptions: n,
        editorContentChange: e,
        validMethodNameEmpty: i,
        validMethodNameExist: o,
        invalidMethodName: s,
        change: r,
        VueMonaco: St,
        getMetaApi: k,
        META_APP: C,
        METHOD_TIPS_MAP: ct,
        NEW_METHOD_TYPE: Q,
        VALID_VARNAME_RE: Nt
      })
    }), r = b((a) => {
      const d = [{
        validator: i,
        tip: ct.empty
      }, {
        validator: o,
        tip: ct.exist
      }, {
        validator: s,
        tip: ct.ruleInvalid
      }];
      for (let f = 0; f < d.length; f++) {
        const l = d[f];
        if (l.validator(a)) {
          t.tipError = !0, t.tip = l.tip;
          return;
        }
      }
      t.tipError = !1, t.tip = "";
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialogContent.change"
      },
      ctx: () => ({
        getMethodNameList: c,
        context: t,
        editorOptions: n,
        editorContentChange: e,
        validMethodNameEmpty: i,
        validMethodNameExist: o,
        invalidMethodName: s,
        change: r,
        VueMonaco: St,
        getMetaApi: k,
        META_APP: C,
        METHOD_TIPS_MAP: ct,
        NEW_METHOD_TYPE: Q,
        VALID_VARNAME_RE: Nt
      })
    });
    return {
      NEW_METHOD_TYPE: Q,
      context: t,
      editorOptions: n,
      change: r,
      editorContentChange: e
    };
  }
}, Nn = { class: "content-right" }, In = { class: "new-action-tip" }, Ln = { class: "content-right-title" }, Bn = { class: "set-params-tip" }, Pn = { class: "content-right-monaco" }, Vn = {
  key: 1,
  class: "mark"
}, Mn = {
  key: 0,
  class: "params-tip"
};
function On(c, t, n, e, i, o) {
  const s = B("tiny-input"), r = B("tiny-checkbox"), a = B("monaco-editor");
  return S(), J("div", Nn, [
    m("div", {
      class: It(["content-right-top", { "tip-error": e.context.tipError }])
    }, [
      t[2] || (t[2] = m("div", { class: "content-right-title" }, "方法名称", -1)),
      _(s, {
        modelValue: e.context.bindMethodInfo.name,
        "onUpdate:modelValue": [
          t[0] || (t[0] = (d) => e.context.bindMethodInfo.name = d),
          e.change
        ],
        disabled: e.context.bindMethodInfo.type !== e.NEW_METHOD_TYPE,
        class: It([{ "status-error": e.context.tipError }]),
        placeholder: "请从左侧选择一个方法进行绑定，或者选择添加新方法，输入自定义方法名称。"
      }, null, 8, ["modelValue", "disabled", "class", "onUpdate:modelValue"]),
      m("div", In, W(e.context.tip), 1)
    ], 2),
    m("div", {
      class: It(["content-right-bottom", { "tip-error": !e.context.isValidParams }])
    }, [
      m("div", Ln, [
        _(r, {
          modelValue: e.context.enableExtraParams,
          "onUpdate:modelValue": t[1] || (t[1] = (d) => e.context.enableExtraParams = d),
          name: "tiny-checkbox"
        }, {
          default: I(() => t[3] || (t[3] = [
            Dt("扩展参数设置", -1)
          ])),
          _: 1,
          __: [3]
        }, 8, ["modelValue"]),
        m("div", Bn, [
          t[4] || (t[4] = m("div", null, "扩展参数：调用当前事件传入的真实参数，数组格式，追加在原有事件参数之后", -1)),
          Dt(" 如: " + W(e.context.bindMethodInfo.name) + "(eventArgs, extParam1, extParam2, ...) ", 1)
        ])
      ]),
      m("div", Pn, [
        n.dialogVisible ? (S(), tt(a, {
          key: 0,
          value: e.context.editorContent,
          options: e.editorOptions,
          onChange: e.editorContentChange,
          class: "monaco-editor"
        }, null, 8, ["value", "options", "onChange"])) : zt("", !0),
        e.context.enableExtraParams ? zt("", !0) : (S(), J("div", Vn))
      ]),
      !e.context.isValidParams && e.context.enableExtraParams ? (S(), J("div", Mn, ' 请输入数组格式的参数，参数可以为表达式。例如：["extParam1", "item.status", 1, "getNames()"] ')) : zt("", !0)
    ], 2)
  ]);
}
const Tn = /* @__PURE__ */ Bt(An, [["render", On], ["__scopeId", "data-v-fc0b367d"]]), Rn = {
  components: {
    TinySearch: Se
  },
  props: {
    eventBinding: {
      type: Object,
      default: () => ({})
    }
  },
  setup(c) {
    const {
      getMethodNameList: t
    } = k(C.Page), n = Lt(""), e = Lt([]), i = ge("context"), o = b((r, a) => {
      const d = r.map((u) => {
        var h;
        return Number.parseInt((h = u.match(/\d+$/)) == null ? void 0 : h[0]) || 0;
      }).sort((u, h) => u - h).pop();
      let l = `${(a == null ? void 0 : a.replace(Kt, "_")) || ""}New`;
      return d > -1 && (l += `${d + 1}`), l;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialogSidebar.generateMethodName"
      },
      ctx: () => ({
        props: c,
        getMethodNameList: t,
        searchValue: n,
        filteredMethodList: e,
        context: i,
        generateMethodName: o,
        selectMethod: s,
        getMetaApi: k,
        META_APP: C,
        INVALID_VARNAME_CHAR_RE: Kt,
        NEW_METHOD_TYPE: Q
      })
    }), s = b((r) => {
      i.bindMethodInfo = r;
    }, {
      metaData: {
        id: "engine.setting.event.BindEventsDialogSidebar.selectMethod"
      },
      ctx: () => ({
        props: c,
        getMethodNameList: t,
        searchValue: n,
        filteredMethodList: e,
        context: i,
        generateMethodName: o,
        selectMethod: s,
        getMetaApi: k,
        META_APP: C,
        INVALID_VARNAME_CHAR_RE: Kt,
        NEW_METHOD_TYPE: Q
      })
    });
    return ue(() => {
      var u, h;
      const r = (u = c.eventBinding) == null ? void 0 : u.eventName, a = (t == null ? void 0 : t().filter((g) => g.includes(r))) || [], f = {
        title: "添加新方法",
        name: o(a, r),
        type: Q
      };
      (h = c.eventBinding) != null && h.ref ? s({
        name: c.eventBinding.ref
      }) : s(f);
      const l = (t == null ? void 0 : t().filter((g) => g.includes(n.value)).map((g) => ({
        name: g
      }))) || [];
      e.value = [f, ...l];
    }), {
      context: i,
      searchValue: n,
      filteredMethodList: e,
      selectMethod: s
    };
  }
}, Un = { class: "dialog-content-left" }, jn = { class: "left-list-wrap" }, $n = { class: "left-action-list" }, zn = { class: "action-list-wrap" }, Fn = ["onClick"];
function Jn(c, t, n, e, i, o) {
  const s = B("tiny-search");
  return S(), J("div", Un, [
    t[1] || (t[1] = m("div", { class: "left-title" }, "响应方法", -1)),
    m("div", jn, [
      m("div", $n, [
        _(s, {
          modelValue: e.searchValue,
          "onUpdate:modelValue": t[0] || (t[0] = (r) => e.searchValue = r),
          placeholder: "搜索"
        }, null, 8, ["modelValue"]),
        m("ul", zn, [
          (S(!0), J($t, null, Ht(e.filteredMethodList, (r) => (S(), J("li", {
            key: r.name,
            onClick: (a) => e.selectMethod(r)
          }, [
            m("div", {
              class: It(["action-name", { active: r.name === e.context.bindMethodInfo.name }])
            }, W(r.title || r.name), 3)
          ], 8, Fn))), 128))
        ])
      ])
    ])
  ]);
}
const Xn = /* @__PURE__ */ Bt(Rn, [["render", Jn], ["__scopeId", "data-v-9bcc2645"]]), ii = {
  ...R,
  entry: Sn,
  options: { commonEvents: pe },
  components: {
    BindEventsDialogSidebar: Xn,
    BindEventsDialogContent: Tn
  }
};
export {
  ii as default
};
//# sourceMappingURL=index.js.map
