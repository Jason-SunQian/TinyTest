import { Ref, Reactive } from 'vue';

/**
 * 模型Provider基类
 */
declare abstract class BaseModelProvider {
    protected config: AIModelConfig;
    /**
     * @param config AI模型配置
     */
    constructor(config: AIModelConfig);
    /**
     * 发送聊天请求并获取响应
     * @param request 聊天请求参数
     * @returns 聊天响应
     */
    abstract chat(request: ChatCompletionRequest): Promise<ChatCompletionResponse>;
    /**
     * 发送流式聊天请求并通过处理器处理响应
     * @param request 聊天请求参数
     * @param handler 流式响应处理器
     */
    abstract chatStream(request: ChatCompletionRequest, handler: StreamHandler): Promise<void>;
    /**
     * 更新配置
     * @param config 新的AI模型配置
     */
    updateConfig(config: AIModelConfig): void;
    /**
     * 获取当前配置
     * @returns AI模型配置
     */
    getConfig(): AIModelConfig;
    /**
     * 验证请求参数
     * @param request 聊天请求参数
     */
    protected validateRequest(request: ChatCompletionRequest): void;
}

/**
 * 消息角色类型
 */
type MessageRole = 'system' | 'user' | 'assistant';
/**
 * 聊天消息接口
 */
interface ChatMessage {
    role: MessageRole;
    content: string;
    name?: string;
}
/**
 * 聊天历史记录
 */
type ChatHistory = ChatMessage[];
/**
 * 聊天完成请求选项
 */
interface ChatCompletionOptions {
    model?: string;
    temperature?: number;
    top_p?: number;
    n?: number;
    stream?: boolean;
    max_tokens?: number;
    signal?: AbortSignal;
}
/**
 * 聊天完成请求参数
 */
interface ChatCompletionRequest {
    messages: ChatMessage[];
    options?: ChatCompletionOptions;
}
/**
 * 聊天完成响应消息
 */
interface ChatCompletionResponseMessage {
    role: MessageRole;
    content: string;
}
/**
 * 聊天完成响应选择
 */
interface ChatCompletionResponseChoice {
    index: number;
    message: ChatCompletionResponseMessage;
    finish_reason: string;
}
/**
 * 聊天完成响应使用情况
 */
interface ChatCompletionResponseUsage {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
}
/**
 * 聊天完成响应
 */
interface ChatCompletionResponse {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChatCompletionResponseChoice[];
    usage: ChatCompletionResponseUsage;
}
/**
 * 流式聊天完成响应增量
 */
interface ChatCompletionStreamResponseDelta {
    content?: string;
    role?: MessageRole;
}
/**
 * 流式聊天完成响应选择
 */
interface ChatCompletionStreamResponseChoice {
    index: number;
    delta: ChatCompletionStreamResponseDelta;
    finish_reason: string | null;
}
/**
 * 流式聊天完成响应
 */
interface ChatCompletionStreamResponse {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChatCompletionStreamResponseChoice[];
}
/**
 * AI模型提供商类型
 */
type AIProvider = 'openai' | 'deepseek' | 'custom';
/**
 * AI模型配置接口
 */
interface AIModelConfig {
    provider: AIProvider;
    providerImplementation?: BaseModelProvider;
    apiKey?: string;
    apiUrl?: string;
    apiVersion?: string;
    defaultModel?: string;
    defaultOptions?: ChatCompletionOptions;
}
/**
 * 错误类型
 */
declare enum ErrorType {
    NETWORK_ERROR = "network_error",
    AUTHENTICATION_ERROR = "authentication_error",
    RATE_LIMIT_ERROR = "rate_limit_error",
    SERVER_ERROR = "server_error",
    MODEL_ERROR = "model_error",
    TIMEOUT_ERROR = "timeout_error",
    UNKNOWN_ERROR = "unknown_error"
}
/**
 * AI适配器错误
 */
interface AIAdapterError {
    type: ErrorType;
    message: string;
    statusCode?: number;
    originalError?: object;
}
/**
 * 流式响应事件类型
 */
declare enum StreamEventType {
    DATA = "data",
    ERROR = "error",
    DONE = "done"
}
/**
 * 流式响应处理器
 */
interface StreamHandler {
    onData: (data: ChatCompletionStreamResponse) => void;
    onError: (error: AIAdapterError) => void;
    onDone: () => void;
}

/**
 * AI客户端类
 * 负责根据配置选择合适的提供商并处理请求
 */

/**
 * AI客户端类
 */
declare class AIClient {
    private provider;
    private config;
    /**
     * 构造函数
     * @param config AI模型配置
     */
    constructor(config: AIModelConfig);
    /**
     * 创建提供商实例
     * @param config AI模型配置
     * @returns 提供商实例
     */
    private createProvider;
    /**
     * 发送聊天请求并获取响应
     * @param request 聊天请求参数
     * @returns 聊天响应
     */
    chat(request: ChatCompletionRequest): Promise<ChatCompletionResponse>;
    /**
     * 发送流式聊天请求并通过处理器处理响应
     * @param request 聊天请求参数
     * @param handler 流式响应处理器
     */
    chatStream(request: ChatCompletionRequest, handler: StreamHandler): Promise<void>;
    /**
     * 获取当前配置
     * @returns AI模型配置
     */
    getConfig(): AIModelConfig;
    /**
     * 更新配置
     * @param config 新的AI模型配置
     */
    updateConfig(config: Partial<AIModelConfig>): void;
}

/**
 * OpenAI提供商
 * 用于与OpenAI API进行交互
 */

declare class OpenAIProvider extends BaseModelProvider {
    private baseURL;
    private apiKey;
    private defaultModel;
    /**
     * @param config AI模型配置
     */
    constructor(config: AIModelConfig);
    /**
     * 发送聊天请求并获取响应
     * @param request 聊天请求参数
     * @returns 聊天响应
     */
    chat(request: ChatCompletionRequest): Promise<ChatCompletionResponse>;
    /**
     * 发送流式聊天请求并通过处理器处理响应
     * @param request 聊天请求参数
     * @param handler 流式响应处理器
     */
    chatStream(request: ChatCompletionRequest, handler: StreamHandler): Promise<void>;
    /**
     * 更新配置
     * @param config 新的AI模型配置
     */
    updateConfig(config: AIModelConfig): void;
}

/**
 * 工具函数模块
 * 提供一些实用的辅助函数
 */

/**
 * 处理SSE流式响应
 * @param response fetch响应对象
 * @param handler 流处理器
 */
declare function handleSSEStream(response: Response, handler: StreamHandler, signal?: AbortSignal): Promise<void>;
/**
 * 格式化消息
 * 将各种格式的消息转换为标准的ChatMessage格式
 * @param messages 消息数组
 * @returns 标准格式的消息数组
 */
declare function formatMessages(messages: Array<ChatMessage | string>): ChatMessage[];
/**
 * 从响应中提取文本内容
 * @param response 聊天完成响应
 * @returns 文本内容
 */
declare function extractTextFromResponse(response: ChatCompletionResponse): string;

/**
 * useMessage composable
 * 提供消息管理和状态控制功能
 */

declare enum STATUS {
    INIT = "init",// 初始状态
    PROCESSING = "processing",// AI请求正在处理中, 还未响应，显示加载动画
    STREAMING = "streaming",// 流式响应中分块数据返回中
    FINISHED = "finished",// AI请求已完成
    ABORTED = "aborted",// 用户中止请求
    ERROR = "error"
}
declare const GeneratingStatus: STATUS[];
declare const FinalStatus: STATUS[];
/**
 * 消息状态接口
 */
interface MessageState {
    status: STATUS;
    errorMsg: string | null;
}
/**
 * useMessage选项接口
 */
interface UseMessageOptions {
    /** AI客户端实例 */
    client: AIClient;
    /** 是否默认使用流式响应 */
    useStreamByDefault?: boolean;
    /** 错误消息模板 */
    errorMessage?: string;
    /** 初始消息列表 */
    initialMessages?: ChatMessage[];
}
/**
 * useMessage返回值接口
 */
interface UseMessageReturn {
    messages: Ref<ChatMessage[]>;
    /** 消息状态 */
    messageState: Reactive<MessageState>;
    /** 输入消息 */
    inputMessage: Ref<string>;
    /** 是否使用流式响应 */
    useStream: Ref<boolean>;
    /** 发送消息 */
    sendMessage: (content?: string, clearInput?: boolean) => Promise<void>;
    /** 清空消息 */
    clearMessages: () => void;
    /** 添加消息 */
    addMessage: (message: ChatMessage) => void;
    /** 中止请求 */
    abortRequest: () => void;
    /** 重试请求 */
    retryRequest: (msgIndex: number) => Promise<void>;
}
/**
 * useMessage composable
 * 提供消息管理和状态控制功能
 *
 * @param options useMessage选项
 * @returns UseMessageReturn
 */
declare function useMessage(options: UseMessageOptions): UseMessageReturn;

/**
 * useConversation composable
 * 提供会话管理和持久化功能
 */

/**
 * 会话接口
 */
interface Conversation {
    /** 会话ID */
    id: string;
    /** 会话标题 */
    title: string;
    /** 创建时间 */
    createdAt: number;
    /** 更新时间 */
    updatedAt: number;
    /** 自定义元数据 */
    metadata?: Record<string, unknown>;
    /** 会话消息 */
    messages: ChatMessage[];
}
/**
 * 存储策略接口
 */
interface ConversationStorageStrategy {
    /** 保存会话列表 */
    saveConversations: (conversations: Conversation[]) => Promise<void> | void;
    /** 加载会话列表 */
    loadConversations: () => Promise<Conversation[]> | Conversation[];
}
/**
 * 本地存储策略
 */
declare class LocalStorageStrategy implements ConversationStorageStrategy {
    private storageKey;
    constructor(storageKey?: string);
    saveConversations(conversations: Conversation[]): void;
    loadConversations(): Conversation[];
}
/**
 * 会话状态接口
 */
interface ConversationState {
    /** 会话列表 */
    conversations: Conversation[];
    /** 当前会话ID */
    currentId: string | null;
    /** 是否正在加载 */
    loading: boolean;
}
/**
 * useConversation选项接口
 */
interface UseConversationOptions {
    /** AI客户端实例 */
    client: AIClient;
    /** 存储策略 */
    storage?: ConversationStorageStrategy;
    /** 是否自动保存 */
    autoSave?: boolean;
    /** 是否默认使用流式响应 */
    useStreamByDefault?: boolean;
    /** 错误消息模板 */
    errorMessage?: string;
}
/**
 * useConversation返回值接口
 */
interface UseConversationReturn {
    /** 会话状态 */
    state: ConversationState;
    /** 消息管理 */
    messageManager: UseMessageReturn;
    /** 创建新会话 */
    createConversation: (title?: string, metadata?: Record<string, unknown>) => string;
    /** 切换会话 */
    switchConversation: (id: string) => void;
    /** 删除会话 */
    deleteConversation: (id: string) => void;
    /** 更新会话标题 */
    updateTitle: (id: string, title: string) => void;
    /** 更新会话元数据 */
    updateMetadata: (id: string, metadata: Record<string, unknown>) => void;
    /** 保存会话 */
    saveConversations: () => Promise<void>;
    /** 加载会话 */
    loadConversations: () => Promise<void>;
    /** 生成会话标题 */
    generateTitle: (id: string) => Promise<string>;
    /** 获取当前会话 */
    getCurrentConversation: () => Conversation | null;
}
/**
 * useConversation composable
 * 提供会话管理和持久化功能
 *
 * @param options useConversation选项
 * @returns UseConversationReturn
 */
declare function useConversation(options: UseConversationOptions): UseConversationReturn;

export { type AIAdapterError, AIClient, type AIModelConfig, type AIProvider, BaseModelProvider, type ChatCompletionOptions, type ChatCompletionRequest, type ChatCompletionResponse, type ChatCompletionResponseChoice, type ChatCompletionResponseMessage, type ChatCompletionResponseUsage, type ChatCompletionStreamResponse, type ChatCompletionStreamResponseChoice, type ChatCompletionStreamResponseDelta, type ChatHistory, type ChatMessage, type Conversation, type ConversationState, type ConversationStorageStrategy, ErrorType, FinalStatus, GeneratingStatus, LocalStorageStrategy, type MessageRole, type MessageState, OpenAIProvider, STATUS, StreamEventType, type StreamHandler, type UseConversationOptions, type UseConversationReturn, type UseMessageOptions, type UseMessageReturn, extractTextFromResponse, formatMessages, handleSSEStream, useConversation, useMessage };
