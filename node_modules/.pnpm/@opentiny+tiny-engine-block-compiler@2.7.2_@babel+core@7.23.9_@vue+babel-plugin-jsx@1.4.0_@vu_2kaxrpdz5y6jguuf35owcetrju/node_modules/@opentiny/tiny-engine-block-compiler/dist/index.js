import { transformSync as hg } from "@babel/core";
import fg from "@vue/babel-plugin-jsx";
/**
* @vue/compiler-sfc v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Xe(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r of t.split(",")) e[r] = 1;
  return (r) => r in e;
}
const pg = Object.freeze({}), qa = () => {
}, Os = () => !1, Id = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Bt = Object.assign, dg = Object.prototype.hasOwnProperty, Lu = (t, e) => dg.call(t, e), $e = Array.isArray, mg = (t) => Ru(t) === "[object Map]", yg = (t) => Ru(t) === "[object Set]", Nd = (t) => typeof t == "function", Se = (t) => typeof t == "string", fr = (t) => typeof t == "symbol", pr = (t) => t !== null && typeof t == "object", Od = Object.prototype.toString, Ru = (t) => Od.call(t), kd = (t) => Ru(t) === "[object Object]", hh = /* @__PURE__ */ Xe(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Du = /* @__PURE__ */ Xe(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), $n = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (r) => e[r] || (e[r] = t(r));
}, gg = /-(\w)/g, ut = $n(
  (t) => t.replace(gg, (e, r) => r ? r.toUpperCase() : "")
), bg = /\B([A-Z])/g, Sg = $n(
  (t) => t.replace(bg, "-$1").toLowerCase()
), lr = $n((t) => t.charAt(0).toUpperCase() + t.slice(1)), vg = $n(
  (t) => t ? `on${lr(t)}` : ""
), xg = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function pn(t) {
  return xg.test(t) ? `__props.${t}` : `__props[${JSON.stringify(t)}]`;
}
function Eg(t, e) {
  return t + JSON.stringify(
    e,
    (r, i) => typeof i == "function" ? i.toString() : i
  );
}
const Ls = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "NEED_HYDRATION",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "CACHED",
  [-2]: "BAIL"
}, Tg = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
}, wg = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", Ld = /* @__PURE__ */ Xe(wg), fh = 2;
function ti(t, e = 0, r = t.length) {
  if (e = Math.max(0, Math.min(e, t.length)), r = Math.max(0, Math.min(r, t.length)), e > r) return "";
  let i = t.split(/(\r?\n)/);
  const n = i.filter((h, c) => c % 2 === 1);
  i = i.filter((h, c) => c % 2 === 0);
  let u = 0;
  const l = [];
  for (let h = 0; h < i.length; h++)
    if (u += i[h].length + (n[h] && n[h].length || 0), u >= e) {
      for (let c = h - fh; c <= h + fh || r > u; c++) {
        if (c < 0 || c >= i.length) continue;
        const p = c + 1;
        l.push(
          `${p}${" ".repeat(Math.max(3 - String(p).length, 0))}|  ${i[c]}`
        );
        const d = i[c].length, m = n[c] && n[c].length || 0;
        if (c === h) {
          const y = e - (u - (d + m)), g = Math.max(
            1,
            r > u ? d - y : r - e
          );
          l.push("   |  " + " ".repeat(y) + "^".repeat(g));
        } else if (c > h) {
          if (r > u) {
            const y = Math.max(Math.min(r - u, d), 1);
            l.push("   |  " + "^".repeat(y));
          }
          u += d + m;
        }
      }
      break;
    }
  return l.join(`
`);
}
function Rd(t) {
  if ($e(t)) {
    const e = {};
    for (let r = 0; r < t.length; r++) {
      const i = t[r], n = Se(i) ? Dd(i) : Rd(i);
      if (n)
        for (const u in n)
          e[u] = n[u];
    }
    return e;
  } else if (Se(t) || pr(t))
    return t;
}
const Pg = /;(?![^(]*\))/g, _g = /:([^]+)/, Ag = /\/\*[^]*?\*\//g;
function Dd(t) {
  const e = {};
  return t.replace(Ag, "").split(Pg).forEach((r) => {
    if (r) {
      const i = r.split(_g);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Cg(t) {
  if (!t) return "";
  if (Se(t)) return t;
  let e = "";
  for (const r in t) {
    const i = t[r];
    if (Se(i) || typeof i == "number") {
      const n = r.startsWith("--") ? r : Sg(r);
      e += `${n}:${i};`;
    }
  }
  return e;
}
function Md(t) {
  let e = "";
  if (Se(t))
    e = t;
  else if ($e(t))
    for (let r = 0; r < t.length; r++) {
      const i = Md(t[r]);
      i && (e += i + " ");
    }
  else if (pr(t))
    for (const r in t)
      t[r] && (e += r + " ");
  return e.trim();
}
const Ig = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Ng = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Og = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", kg = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", Lg = /* @__PURE__ */ Xe(Ig), Rg = /* @__PURE__ */ Xe(Ng), Dg = /* @__PURE__ */ Xe(Og), Fd = /* @__PURE__ */ Xe(kg), Mg = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Bd = /* @__PURE__ */ Xe(
  Mg + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
), Fg = /[>/="'\u0009\u000a\u000c\u0020]/, ja = {};
function Bg(t) {
  if (ja.hasOwnProperty(t))
    return ja[t];
  const e = Fg.test(t);
  return e && console.error(`unsafe attribute name: ${t}`), ja[t] = !e;
}
const $g = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, Ug = /* @__PURE__ */ Xe(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), qg = /* @__PURE__ */ Xe(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
), jg = /* @__PURE__ */ Xe(
  "accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns"
), Vg = /["'&<>]/;
function Dt(t) {
  const e = "" + t, r = Vg.exec(e);
  if (!r)
    return e;
  let i = "", n, u, l = 0;
  for (u = r.index; u < e.length; u++) {
    switch (e.charCodeAt(u)) {
      case 34:
        n = "&quot;";
        break;
      case 38:
        n = "&amp;";
        break;
      case 39:
        n = "&#39;";
        break;
      case 60:
        n = "&lt;";
        break;
      case 62:
        n = "&gt;";
        break;
      default:
        continue;
    }
    l !== u && (i += e.slice(l, u)), l = u + 1, i += n;
  }
  return l !== u ? i + e.slice(l, u) : i;
}
const zg = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function Wg(t, e) {
  return t.replace(
    zg,
    (r) => e ? r === '"' ? '\\\\\\"' : `\\\\${r}` : `\\${r}`
  );
}
const $d = (t) => !!(t && t.__v_isRef === !0), Un = (t) => Se(t) ? t : t == null ? "" : $e(t) || pr(t) && (t.toString === Od || !Nd(t.toString)) ? $d(t) ? Un(t.value) : JSON.stringify(t, Ud, 2) : String(t), Ud = (t, e) => $d(e) ? Ud(t, e.value) : mg(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (r, [i, n], u) => (r[Va(i, u) + " =>"] = n, r),
    {}
  )
} : yg(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((r) => Va(r))
} : fr(e) ? Va(e) : pr(e) && !$e(e) && !kd(e) ? String(e) : e, Va = (t, e = "") => {
  var r;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    fr(t) ? `Symbol(${(r = t.description) != null ? r : e})` : t
  );
}, ss = Symbol("Fragment"), _r = Symbol("Teleport"), cs = Symbol("Suspense"), Vs = Symbol("KeepAlive"), Mu = Symbol(
  "BaseTransition"
), cr = Symbol("openBlock"), Fu = Symbol("createBlock"), Bu = Symbol(
  "createElementBlock"
), ri = Symbol("createVNode"), qn = Symbol(
  "createElementVNode"
), hs = Symbol(
  "createCommentVNode"
), jn = Symbol(
  "createTextVNode"
), Vn = Symbol(
  "createStaticVNode"
), zs = Symbol(
  "resolveComponent"
), si = Symbol(
  "resolveDynamicComponent"
), zn = Symbol(
  "resolveDirective"
), qd = Symbol(
  "resolveFilter"
), Wn = Symbol(
  "withDirectives"
), Hn = Symbol("renderList"), $u = Symbol("renderSlot"), Uu = Symbol("createSlots"), ii = Symbol(
  "toDisplayString"
), Or = Symbol("mergeProps"), Gn = Symbol(
  "normalizeClass"
), Xn = Symbol(
  "normalizeStyle"
), is = Symbol(
  "normalizeProps"
), fs = Symbol(
  "guardReactiveProps"
), Jn = Symbol("toHandlers"), dn = Symbol("camelize"), jd = Symbol("capitalize"), mn = Symbol(
  "toHandlerKey"
), Ws = Symbol(
  "setBlockTracking"
), Vd = Symbol("pushScopeId"), zd = Symbol("popScopeId"), Kn = Symbol("withCtx"), ns = Symbol("unref"), Hs = Symbol("isRef"), Yn = Symbol("withMemo"), qu = Symbol("isMemoSame"), ot = {
  [ss]: "Fragment",
  [_r]: "Teleport",
  [cs]: "Suspense",
  [Vs]: "KeepAlive",
  [Mu]: "BaseTransition",
  [cr]: "openBlock",
  [Fu]: "createBlock",
  [Bu]: "createElementBlock",
  [ri]: "createVNode",
  [qn]: "createElementVNode",
  [hs]: "createCommentVNode",
  [jn]: "createTextVNode",
  [Vn]: "createStaticVNode",
  [zs]: "resolveComponent",
  [si]: "resolveDynamicComponent",
  [zn]: "resolveDirective",
  [qd]: "resolveFilter",
  [Wn]: "withDirectives",
  [Hn]: "renderList",
  [$u]: "renderSlot",
  [Uu]: "createSlots",
  [ii]: "toDisplayString",
  [Or]: "mergeProps",
  [Gn]: "normalizeClass",
  [Xn]: "normalizeStyle",
  [is]: "normalizeProps",
  [fs]: "guardReactiveProps",
  [Jn]: "toHandlers",
  [dn]: "camelize",
  [jd]: "capitalize",
  [mn]: "toHandlerKey",
  [Ws]: "setBlockTracking",
  [Vd]: "pushScopeId",
  [zd]: "popScopeId",
  [Kn]: "withCtx",
  [ns]: "unref",
  [Hs]: "isRef",
  [Yn]: "withMemo",
  [qu]: "isMemoSame"
};
function ju(t) {
  Object.getOwnPropertySymbols(t).forEach((e) => {
    ot[e] = t[e];
  });
}
const Hg = {
  HTML: 0,
  0: "HTML",
  SVG: 1,
  1: "SVG",
  MATH_ML: 2,
  2: "MATH_ML"
}, Gg = {
  ROOT: 0,
  0: "ROOT",
  ELEMENT: 1,
  1: "ELEMENT",
  TEXT: 2,
  2: "TEXT",
  COMMENT: 3,
  3: "COMMENT",
  SIMPLE_EXPRESSION: 4,
  4: "SIMPLE_EXPRESSION",
  INTERPOLATION: 5,
  5: "INTERPOLATION",
  ATTRIBUTE: 6,
  6: "ATTRIBUTE",
  DIRECTIVE: 7,
  7: "DIRECTIVE",
  COMPOUND_EXPRESSION: 8,
  8: "COMPOUND_EXPRESSION",
  IF: 9,
  9: "IF",
  IF_BRANCH: 10,
  10: "IF_BRANCH",
  FOR: 11,
  11: "FOR",
  TEXT_CALL: 12,
  12: "TEXT_CALL",
  VNODE_CALL: 13,
  13: "VNODE_CALL",
  JS_CALL_EXPRESSION: 14,
  14: "JS_CALL_EXPRESSION",
  JS_OBJECT_EXPRESSION: 15,
  15: "JS_OBJECT_EXPRESSION",
  JS_PROPERTY: 16,
  16: "JS_PROPERTY",
  JS_ARRAY_EXPRESSION: 17,
  17: "JS_ARRAY_EXPRESSION",
  JS_FUNCTION_EXPRESSION: 18,
  18: "JS_FUNCTION_EXPRESSION",
  JS_CONDITIONAL_EXPRESSION: 19,
  19: "JS_CONDITIONAL_EXPRESSION",
  JS_CACHE_EXPRESSION: 20,
  20: "JS_CACHE_EXPRESSION",
  JS_BLOCK_STATEMENT: 21,
  21: "JS_BLOCK_STATEMENT",
  JS_TEMPLATE_LITERAL: 22,
  22: "JS_TEMPLATE_LITERAL",
  JS_IF_STATEMENT: 23,
  23: "JS_IF_STATEMENT",
  JS_ASSIGNMENT_EXPRESSION: 24,
  24: "JS_ASSIGNMENT_EXPRESSION",
  JS_SEQUENCE_EXPRESSION: 25,
  25: "JS_SEQUENCE_EXPRESSION",
  JS_RETURN_STATEMENT: 26,
  26: "JS_RETURN_STATEMENT"
}, Xg = {
  ELEMENT: 0,
  0: "ELEMENT",
  COMPONENT: 1,
  1: "COMPONENT",
  SLOT: 2,
  2: "SLOT",
  TEMPLATE: 3,
  3: "TEMPLATE"
}, Jg = {
  NOT_CONSTANT: 0,
  0: "NOT_CONSTANT",
  CAN_SKIP_PATCH: 1,
  1: "CAN_SKIP_PATCH",
  CAN_CACHE: 2,
  2: "CAN_CACHE",
  CAN_STRINGIFY: 3,
  3: "CAN_STRINGIFY"
}, Le = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function Dr(t, e = "") {
  return {
    type: 0,
    source: e,
    children: t,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: Le
  };
}
function as(t, e, r, i, n, u, l, h = !1, c = !1, p = !1, d = Le) {
  return t && (h ? (t.helper(cr), t.helper(Lr(t.inSSR, p))) : t.helper(kr(t.inSSR, p)), l && t.helper(Wn)), {
    type: 13,
    tag: e,
    props: r,
    children: i,
    patchFlag: n,
    dynamicProps: u,
    directives: l,
    isBlock: h,
    disableTracking: c,
    isComponent: p,
    loc: d
  };
}
function Gt(t, e = Le) {
  return {
    type: 17,
    loc: e,
    elements: t
  };
}
function lt(t, e = Le) {
  return {
    type: 15,
    loc: e,
    properties: t
  };
}
function Pe(t, e) {
  return {
    type: 16,
    loc: Le,
    key: Se(t) ? te(t, !0) : t,
    value: e
  };
}
function te(t, e = !1, r = Le, i = 0) {
  return {
    type: 4,
    loc: r,
    content: t,
    isStatic: e,
    constType: e ? 3 : i
  };
}
function yn(t, e) {
  return {
    type: 5,
    loc: e,
    content: Se(t) ? te(t, !1, e) : t
  };
}
function je(t, e = Le) {
  return {
    type: 8,
    loc: e,
    children: t
  };
}
function pe(t, e = [], r = Le) {
  return {
    type: 14,
    loc: r,
    callee: t,
    arguments: e
  };
}
function St(t, e = void 0, r = !1, i = !1, n = Le) {
  return {
    type: 18,
    params: t,
    returns: e,
    newline: r,
    isSlot: i,
    loc: n
  };
}
function Ct(t, e, r, i = !0) {
  return {
    type: 19,
    test: t,
    consequent: e,
    alternate: r,
    newline: i,
    loc: Le
  };
}
function Wd(t, e, r = !1, i = !1) {
  return {
    type: 20,
    index: t,
    value: e,
    needPauseTracking: r,
    inVOnce: i,
    needArraySpread: !1,
    loc: Le
  };
}
function ni(t) {
  return {
    type: 21,
    body: t,
    loc: Le
  };
}
function Vu(t) {
  return {
    type: 22,
    elements: t,
    loc: Le
  };
}
function gn(t, e, r) {
  return {
    type: 23,
    test: t,
    consequent: e,
    alternate: r,
    loc: Le
  };
}
function en(t, e) {
  return {
    type: 24,
    left: t,
    right: e,
    loc: Le
  };
}
function Hd(t) {
  return {
    type: 25,
    expressions: t,
    loc: Le
  };
}
function Gd(t) {
  return {
    type: 26,
    returns: t,
    loc: Le
  };
}
function kr(t, e) {
  return t || e ? ri : qn;
}
function Lr(t, e) {
  return t || e ? Fu : Bu;
}
function Qn(t, { helper: e, removeHelper: r, inSSR: i }) {
  t.isBlock || (t.isBlock = !0, r(kr(i, t.isComponent)), e(cr), e(Lr(i, t.isComponent)));
}
var Xd = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t) => t.charCodeAt(0))
), Kg = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t) => t.charCodeAt(0))
), za;
const Yg = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), tu = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (za = String.fromCodePoint) !== null && za !== void 0 ? za : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function Qg(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = Yg.get(t)) !== null && e !== void 0 ? e : t;
}
var Ve;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(Ve || (Ve = {}));
const Zg = 32;
var or;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(or || (or = {}));
function ru(t) {
  return t >= Ve.ZERO && t <= Ve.NINE;
}
function eb(t) {
  return t >= Ve.UPPER_A && t <= Ve.UPPER_F || t >= Ve.LOWER_A && t <= Ve.LOWER_F;
}
function tb(t) {
  return t >= Ve.UPPER_A && t <= Ve.UPPER_Z || t >= Ve.LOWER_A && t <= Ve.LOWER_Z || ru(t);
}
function rb(t) {
  return t === Ve.EQUALS || tb(t);
}
var qe;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(qe || (qe = {}));
var Lt;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Lt || (Lt = {}));
class Jd {
  constructor(e, r, i) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = i, this.state = qe.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Lt.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = qe.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case qe.EntityStart:
        return e.charCodeAt(r) === Ve.NUM ? (this.state = qe.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = qe.NamedEntity, this.stateNamedEntity(e, r));
      case qe.NumericStart:
        return this.stateNumericStart(e, r);
      case qe.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case qe.NumericHex:
        return this.stateNumericHex(e, r);
      case qe.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | Zg) === Ve.LOWER_X ? (this.state = qe.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = qe.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, i, n) {
    if (r !== i) {
      const u = i - r;
      this.result = this.result * Math.pow(n, u) + parseInt(e.substr(r, u), n), this.consumed += u;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const i = r;
    for (; r < e.length; ) {
      const n = e.charCodeAt(r);
      if (ru(n) || eb(n))
        r += 1;
      else
        return this.addToNumericResult(e, i, r, 16), this.emitNumericEntity(n, 3);
    }
    return this.addToNumericResult(e, i, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const i = r;
    for (; r < e.length; ) {
      const n = e.charCodeAt(r);
      if (ru(n))
        r += 1;
      else
        return this.addToNumericResult(e, i, r, 10), this.emitNumericEntity(n, 2);
    }
    return this.addToNumericResult(e, i, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var i;
    if (this.consumed <= r)
      return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === Ve.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Lt.Strict)
      return 0;
    return this.emitCodePoint(Qg(this.result), this.consumed), this.errors && (e !== Ve.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: i } = this;
    let n = i[this.treeIndex], u = (n & or.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const l = e.charCodeAt(r);
      if (this.treeIndex = sb(i, n, this.treeIndex + Math.max(1, u), l), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Lt.Attribute && // We shouldn't have consumed any characters after the entity,
        (u === 0 || // And there should be no invalid characters.
        rb(l)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (n = i[this.treeIndex], u = (n & or.VALUE_LENGTH) >> 14, u !== 0) {
        if (l === Ve.SEMI)
          return this.emitNamedEntityData(this.treeIndex, u, this.consumed + this.excess);
        this.decodeMode !== Lt.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: i } = this, n = (i[r] & or.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, n, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, i) {
    const { decodeTree: n } = this;
    return this.emitCodePoint(r === 1 ? n[e] & ~or.VALUE_LENGTH : n[e + 1], i), r === 3 && this.emitCodePoint(n[e + 2], i), i;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case qe.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Lt.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case qe.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case qe.NumericHex:
        return this.emitNumericEntity(0, 3);
      case qe.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case qe.EntityStart:
        return 0;
    }
  }
}
function Kd(t) {
  let e = "";
  const r = new Jd(t, (i) => e += tu(i));
  return function(n, u) {
    let l = 0, h = 0;
    for (; (h = n.indexOf("&", h)) >= 0; ) {
      e += n.slice(l, h), r.startEntity(u);
      const p = r.write(
        n,
        // Skip the "&"
        h + 1
      );
      if (p < 0) {
        l = h + r.end();
        break;
      }
      l = h + p, h = p === 0 ? l + 1 : l;
    }
    const c = e + n.slice(l);
    return e = "", c;
  };
}
function sb(t, e, r, i) {
  const n = (e & or.BRANCH_LENGTH) >> 7, u = e & or.JUMP_TABLE;
  if (n === 0)
    return u !== 0 && i === u ? r : -1;
  if (u) {
    const c = i - u;
    return c < 0 || c >= n ? -1 : t[r + c] - 1;
  }
  let l = r, h = l + n - 1;
  for (; l <= h; ) {
    const c = l + h >>> 1, p = t[c];
    if (p < i)
      l = c + 1;
    else if (p > i)
      h = c - 1;
    else
      return t[c + n];
  }
  return -1;
}
const ib = Kd(Xd);
Kd(Kg);
function nb(t, e = Lt.Legacy) {
  return ib(t, e);
}
const ph = new Uint8Array([123, 123]), dh = new Uint8Array([125, 125]);
function mh(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function gt(t) {
  return t === 32 || t === 10 || t === 9 || t === 12 || t === 13;
}
function sr(t) {
  return t === 47 || t === 62 || gt(t);
}
function bn(t) {
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}
const We = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class ab {
  constructor(e, r) {
    this.stack = e, this.cbs = r, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = ph, this.delimiterClose = dh, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new Jd(
      Xd,
      (i, n) => this.emitCodePoint(i, n)
    );
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = ph, this.delimiterClose = dh;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(e) {
    let r = 1, i = e + 1;
    for (let n = this.newlines.length - 1; n >= 0; n--) {
      const u = this.newlines[n];
      if (e > u) {
        r = n + 2, i = e - u;
        break;
      }
    }
    return {
      column: i,
      line: r,
      offset: e
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(e) {
    e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : e === 38 ? this.startEntity() : !this.inVPre && e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e));
  }
  stateInterpolationOpen(e) {
    if (e === this.delimiterOpen[this.delimiterIndex])
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const r = this.index + 1 - this.delimiterOpen.length;
        r > this.sectionStart && this.cbs.ontext(this.sectionStart, r), this.state = 3, this.sectionStart = r;
      } else
        this.delimiterIndex++;
    else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e));
  }
  stateInterpolation(e) {
    e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e));
  }
  stateInterpolationClose(e) {
    e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e));
  }
  stateSpecialStartSequence(e) {
    const r = this.sequenceIndex === this.currentSequence.length;
    if (!(r ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      sr(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.inRCDATA = !1;
    else if (!r) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === 62 || gt(e)) {
        const r = this.index - this.currentSequence.length;
        if (this.sectionStart < r) {
          const i = this.index;
          this.index = r, this.cbs.ontext(this.sectionStart, r), this.index = i;
        }
        this.sectionStart = r + 2, this.stateInClosingTagName(e), this.inRCDATA = !1;
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === We.TitleEnd || this.currentSequence === We.TextareaEnd && !this.inSFCRoot ? e === 38 ? this.startEntity() : !this.inVPre && e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === 60);
  }
  stateCDATASequence(e) {
    e === We.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === We.Cdata.length && (this.state = 28, this.currentSequence = We.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length; ) {
      const r = this.buffer.charCodeAt(this.index);
      if (r === 10 && this.newlines.push(this.index), r === e)
        return !0;
    }
    return this.index = this.buffer.length - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === We.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  startSpecial(e, r) {
    this.enterRCDATA(e, r), this.state = 31;
  }
  enterRCDATA(e, r) {
    this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = r;
  }
  stateBeforeTagName(e) {
    e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : mh(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : e === 116 ? this.state = 30 : this.state = e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e));
  }
  stateInTagName(e) {
    sr(e) && this.handleTagName(e);
  }
  stateInSFCRootTagName(e) {
    if (sr(e)) {
      const r = this.buffer.slice(this.sectionStart, this.index);
      r !== "template" && this.enterRCDATA(bn("</" + r), 0), this.handleTagName(e);
    }
  }
  handleTagName(e) {
    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e);
  }
  stateBeforeClosingTagName(e) {
    gt(e) || (e === 62 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = mh(e) ? 9 : 27, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === 62 || gt(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    e === 62 && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeAttrName(e) {
    e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? (this.state = 7, this.peek() !== 62 && this.cbs.onerr(22, this.index)) : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : gt(e) || (e === 61 && this.cbs.onerr(
      19,
      this.index
    ), this.handleAttrStart(e));
  }
  handleAttrStart(e) {
    e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : gt(e) || (this.state = 11, this.stateBeforeAttrName(e));
  }
  stateInAttrName(e) {
    e === 61 || sr(e) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : (e === 34 || e === 39 || e === 60) && this.cbs.onerr(
      17,
      this.index
    );
  }
  stateInDirName(e) {
    e === 61 || sr(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDirArg(e) {
    e === 61 || sr(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDynamicDirArg(e) {
    e === 93 ? this.state = 14 : (e === 61 || sr(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e), this.cbs.onerr(
      27,
      this.index
    ));
  }
  stateInDirModifier(e) {
    e === 61 || sr(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
  }
  handleAttrNameEnd(e) {
    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e);
  }
  stateAfterAttrName(e) {
    e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : gt(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));
  }
  stateBeforeAttrValue(e) {
    e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : gt(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e));
  }
  handleInAttrValue(e, r) {
    e === r ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(
      r === 34 ? 3 : 2,
      this.index + 1
    ), this.state = 11) : e === 38 && this.startEntity();
  }
  stateInAttrValueDoubleQuotes(e) {
    this.handleInAttrValue(e, 34);
  }
  stateInAttrValueSingleQuotes(e) {
    this.handleInAttrValue(e, 39);
  }
  stateInAttrValueNoQuotes(e) {
    gt(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : e === 34 || e === 39 || e === 60 || e === 61 || e === 96 ? this.cbs.onerr(
      18,
      this.index
    ) : e === 38 && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23;
  }
  stateInDeclaration(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === 45 ? (this.state = 28, this.currentSequence = We.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
  }
  stateInSpecialComment(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    e === We.ScriptEnd[3] ? this.startSpecial(We.ScriptEnd, 4) : e === We.StyleEnd[3] ? this.startSpecial(We.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    e === We.TitleEnd[3] ? this.startSpecial(We.TitleEnd, 4) : e === We.TextareaEnd[3] ? this.startSpecial(We.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(
      this.baseState === 1 || this.baseState === 32 ? Lt.Legacy : Lt.Attribute
    );
  }
  stateInEntity() {
    {
      const e = this.entityDecoder.write(this.buffer, this.index);
      e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
    }
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(e) {
    for (this.buffer = e; this.index < this.buffer.length; ) {
      const r = this.buffer.charCodeAt(this.index);
      switch (r === 10 && this.state !== 33 && this.newlines.push(this.index), this.state) {
        case 1: {
          this.stateText(r);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(r);
          break;
        }
        case 3: {
          this.stateInterpolation(r);
          break;
        }
        case 4: {
          this.stateInterpolationClose(r);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(r);
          break;
        }
        case 32: {
          this.stateInRCDATA(r);
          break;
        }
        case 26: {
          this.stateCDATASequence(r);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(r);
          break;
        }
        case 12: {
          this.stateInAttrName(r);
          break;
        }
        case 13: {
          this.stateInDirName(r);
          break;
        }
        case 14: {
          this.stateInDirArg(r);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(r);
          break;
        }
        case 16: {
          this.stateInDirModifier(r);
          break;
        }
        case 28: {
          this.stateInCommentLike(r);
          break;
        }
        case 27: {
          this.stateInSpecialComment(r);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(r);
          break;
        }
        case 6: {
          this.stateInTagName(r);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(r);
          break;
        }
        case 9: {
          this.stateInClosingTagName(r);
          break;
        }
        case 5: {
          this.stateBeforeTagName(r);
          break;
        }
        case 17: {
          this.stateAfterAttrName(r);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(r);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(r);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(r);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(r);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(r);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(r);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(r);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(r);
          break;
        }
        case 23: {
          this.stateInDeclaration(r);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(r);
          break;
        }
        case 25: {
          this.stateBeforeComment(r);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(r);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup(), this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === 19 || this.state === 20 || this.state === 21) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  finish() {
    this.state === 33 && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length;
    this.sectionStart >= e || (this.state === 28 ? this.currentSequence === We.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, r) {
    this.baseState !== 1 && this.baseState !== 32 ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.onattribentity(
      tu(e),
      this.entityStart,
      this.sectionStart
    )) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.ontextentity(
      tu(e),
      this.entityStart,
      this.sectionStart
    ));
  }
}
const ob = {
  COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT",
  COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC",
  COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER",
  COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE",
  COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE",
  COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE",
  COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE",
  COMPILER_FILTERS: "COMPILER_FILTERS"
}, ub = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (t) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${t}.sync\` should be changed to \`v-model:${t}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTERS: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function su(t, { compatConfig: e }) {
  const r = e && e[t];
  return t === "MODE" ? r || 3 : r;
}
function lb(t, e) {
  const r = su("MODE", e), i = su(t, e);
  return r === 3 ? i === !0 : i !== !1;
}
function cb(t, e, r, ...i) {
  const n = lb(t, e);
  return n && Yd(t, e, r, ...i), n;
}
function Yd(t, e, r, ...i) {
  if (su(t, e) === "suppress-warning")
    return;
  const { message: u, link: l } = ub[t], h = `(deprecation ${t}) ${typeof u == "function" ? u(...i) : u}${l ? `
  Details: ${l}` : ""}`, c = new SyntaxError(h);
  c.code = t, r && (c.loc = r), e.onWarn(c);
}
function zu(t) {
  throw t;
}
function Qd(t) {
  console.warn(`[Vue warn] ${t.message}`);
}
function Te(t, e, r, i) {
  const n = (r || Wu)[t] + (i || ""), u = new SyntaxError(String(n));
  return u.code = t, u.loc = e, u;
}
const hb = {
  ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
  0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  CDATA_IN_HTML_CONTENT: 1,
  1: "CDATA_IN_HTML_CONTENT",
  DUPLICATE_ATTRIBUTE: 2,
  2: "DUPLICATE_ATTRIBUTE",
  END_TAG_WITH_ATTRIBUTES: 3,
  3: "END_TAG_WITH_ATTRIBUTES",
  END_TAG_WITH_TRAILING_SOLIDUS: 4,
  4: "END_TAG_WITH_TRAILING_SOLIDUS",
  EOF_BEFORE_TAG_NAME: 5,
  5: "EOF_BEFORE_TAG_NAME",
  EOF_IN_CDATA: 6,
  6: "EOF_IN_CDATA",
  EOF_IN_COMMENT: 7,
  7: "EOF_IN_COMMENT",
  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
  8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  EOF_IN_TAG: 9,
  9: "EOF_IN_TAG",
  INCORRECTLY_CLOSED_COMMENT: 10,
  10: "INCORRECTLY_CLOSED_COMMENT",
  INCORRECTLY_OPENED_COMMENT: 11,
  11: "INCORRECTLY_OPENED_COMMENT",
  INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
  12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  MISSING_ATTRIBUTE_VALUE: 13,
  13: "MISSING_ATTRIBUTE_VALUE",
  MISSING_END_TAG_NAME: 14,
  14: "MISSING_END_TAG_NAME",
  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
  15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  NESTED_COMMENT: 16,
  16: "NESTED_COMMENT",
  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
  17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
  18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
  19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  UNEXPECTED_NULL_CHARACTER: 20,
  20: "UNEXPECTED_NULL_CHARACTER",
  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
  21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  UNEXPECTED_SOLIDUS_IN_TAG: 22,
  22: "UNEXPECTED_SOLIDUS_IN_TAG",
  X_INVALID_END_TAG: 23,
  23: "X_INVALID_END_TAG",
  X_MISSING_END_TAG: 24,
  24: "X_MISSING_END_TAG",
  X_MISSING_INTERPOLATION_END: 25,
  25: "X_MISSING_INTERPOLATION_END",
  X_MISSING_DIRECTIVE_NAME: 26,
  26: "X_MISSING_DIRECTIVE_NAME",
  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
  27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  X_V_IF_NO_EXPRESSION: 28,
  28: "X_V_IF_NO_EXPRESSION",
  X_V_IF_SAME_KEY: 29,
  29: "X_V_IF_SAME_KEY",
  X_V_ELSE_NO_ADJACENT_IF: 30,
  30: "X_V_ELSE_NO_ADJACENT_IF",
  X_V_FOR_NO_EXPRESSION: 31,
  31: "X_V_FOR_NO_EXPRESSION",
  X_V_FOR_MALFORMED_EXPRESSION: 32,
  32: "X_V_FOR_MALFORMED_EXPRESSION",
  X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
  33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  X_V_BIND_NO_EXPRESSION: 34,
  34: "X_V_BIND_NO_EXPRESSION",
  X_V_ON_NO_EXPRESSION: 35,
  35: "X_V_ON_NO_EXPRESSION",
  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
  36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  X_V_SLOT_MIXED_SLOT_USAGE: 37,
  37: "X_V_SLOT_MIXED_SLOT_USAGE",
  X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
  38: "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
  39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  X_V_SLOT_MISPLACED: 40,
  40: "X_V_SLOT_MISPLACED",
  X_V_MODEL_NO_EXPRESSION: 41,
  41: "X_V_MODEL_NO_EXPRESSION",
  X_V_MODEL_MALFORMED_EXPRESSION: 42,
  42: "X_V_MODEL_MALFORMED_EXPRESSION",
  X_V_MODEL_ON_SCOPE_VARIABLE: 43,
  43: "X_V_MODEL_ON_SCOPE_VARIABLE",
  X_V_MODEL_ON_PROPS: 44,
  44: "X_V_MODEL_ON_PROPS",
  X_INVALID_EXPRESSION: 45,
  45: "X_INVALID_EXPRESSION",
  X_KEEP_ALIVE_INVALID_CHILDREN: 46,
  46: "X_KEEP_ALIVE_INVALID_CHILDREN",
  X_PREFIX_ID_NOT_SUPPORTED: 47,
  47: "X_PREFIX_ID_NOT_SUPPORTED",
  X_MODULE_MODE_NOT_SUPPORTED: 48,
  48: "X_MODULE_MODE_NOT_SUPPORTED",
  X_CACHE_HANDLER_NOT_SUPPORTED: 49,
  49: "X_CACHE_HANDLER_NOT_SUPPORTED",
  X_SCOPE_ID_NOT_SUPPORTED: 50,
  50: "X_SCOPE_ID_NOT_SUPPORTED",
  X_VNODE_HOOKS: 51,
  51: "X_VNODE_HOOKS",
  X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
  52: "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  __EXTEND_POINT__: 53,
  53: "__EXTEND_POINT__"
}, Wu = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  52: "v-bind with same-name shorthand only allows static argument.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // just to fulfill types
  53: ""
};
function Zn(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function ea(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function i() {
      var n = !1;
      try {
        n = this instanceof i;
      } catch {
      }
      return n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(r, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return t[i];
      }
    });
  }), r;
}
var Hr = {}, yh;
function fb() {
  if (yh) return Hr;
  yh = 1, Object.defineProperty(Hr, "__esModule", {
    value: !0
  });
  function t(T, a) {
    if (T == null) return {};
    var s = {};
    for (var o in T) if ({}.hasOwnProperty.call(T, o)) {
      if (a.indexOf(o) !== -1) continue;
      s[o] = T[o];
    }
    return s;
  }
  class e {
    constructor(a, s, o) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = a, this.column = s, this.index = o;
    }
  }
  class r {
    constructor(a, s) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = a, this.end = s;
    }
  }
  function i(T, a) {
    const {
      line: s,
      column: o,
      index: f
    } = T;
    return new e(s, o + a, f + a);
  }
  const n = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var u = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: n
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: n
    }
  };
  const l = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, h = (T) => T.type === "UpdateExpression" ? l.UpdateExpression[`${T.prefix}`] : l[T.type];
  var c = {
    AccessorIsGenerator: ({
      kind: T
    }) => `A ${T}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind: T
    }) => `Missing initializer in ${T} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName: T
    }) => `\`${T}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName: T,
      exportName: a
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${T}' as '${a}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type: T
    }) => `'${T === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type: T
    }) => `Unsyntactic ${T === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: ({
      importName: T
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${T}" as foo }\`?`,
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix: T
    }) => `Expected number in radix ${T}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord: T
    }) => `Escape sequence in keyword ${T}.`,
    InvalidIdentifier: ({
      identifierName: T
    }) => `Invalid identifier ${T}.`,
    InvalidLhs: ({
      ancestor: T
    }) => `Invalid left-hand side in ${h(T)}.`,
    InvalidLhsBinding: ({
      ancestor: T
    }) => `Binding invalid left-hand side in ${h(T)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor: T
    }) => `Invalid optional chaining in the left-hand side of ${h(T)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected: T
    }) => `Unexpected character '${T}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName: T
    }) => `Private name #${T} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName: T
    }) => `Label '${T}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin: T
    }) => `This experimental syntax requires enabling the parser plugin: ${T.map((a) => JSON.stringify(a)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin: T
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${T.map((a) => JSON.stringify(a)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key: T
    }) => `Duplicate key "${T}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode: T
    }) => `An export name cannot include a lone surrogate, found '\\u${T.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName: T
    }) => `Export '${T}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName: T
    }) => `Private names are only allowed in property accesses (\`obj.#${T}\`) or in \`in\` expressions (\`#${T} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName: T
    }) => `Duplicate private name #${T}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword: T
    }) => `Unexpected keyword '${T}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord: T
    }) => `Unexpected reserved word '${T}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected: T,
      unexpected: a
    }) => `Unexpected token${a ? ` '${a}'.` : ""}${T ? `, expected "${T}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
    UnexpectedVoidPattern: "Unexpected void binding.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target: T,
      onlyValidPropertyName: a
    }) => `The only valid meta property for ${T} is ${T}.${a}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName: T
    }) => `Identifier '${T}' has already been declared.`,
    VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
    VoidPatternInitializer: "A void binding may not have an initializer.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, p = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName: T
    }) => `Assigning to '${T}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName: T
    }) => `Binding '${T}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, d = {
    ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
    ParseExpressionExpectsEOF: ({
      unexpected: T
    }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(T)}\`.`
  };
  const m = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var y = Object.assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token: T
    }) => `Invalid topic token ${T}. In order to use ${T} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${T}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type: T
    }) => `Hack-style pipe body cannot be an unparenthesized ${h({
      type: T
    })}; please wrap it in parentheses.`
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  });
  const g = ["message"];
  function E(T, a, s) {
    Object.defineProperty(T, a, {
      enumerable: !1,
      configurable: !0,
      value: s
    });
  }
  function S({
    toMessage: T,
    code: a,
    reasonCode: s,
    syntaxPlugin: o
  }) {
    const f = s === "MissingPlugin" || s === "MissingOneOfPlugins";
    {
      const b = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      b[s] && (s = b[s]);
    }
    return function b(w, C) {
      const D = new SyntaxError();
      return D.code = a, D.reasonCode = s, D.loc = w, D.pos = w.index, D.syntaxPlugin = o, f && (D.missingPlugin = C.missingPlugin), E(D, "clone", function($ = {}) {
        var q;
        const {
          line: J,
          column: ee,
          index: oe
        } = (q = $.loc) != null ? q : w;
        return b(new e(J, ee, oe), Object.assign({}, C, $.details));
      }), E(D, "details", C), Object.defineProperty(D, "message", {
        configurable: !0,
        get() {
          const F = `${T(C)} (${w.line}:${w.column})`;
          return this.message = F, F;
        },
        set(F) {
          Object.defineProperty(this, "message", {
            value: F,
            writable: !0
          });
        }
      }), D;
    };
  }
  function x(T, a) {
    if (Array.isArray(T))
      return (o) => x(o, T[0]);
    const s = {};
    for (const o of Object.keys(T)) {
      const f = T[o], b = typeof f == "string" ? {
        message: () => f
      } : typeof f == "function" ? {
        message: f
      } : f, {
        message: w
      } = b, C = t(b, g), D = typeof w == "string" ? () => w : w;
      s[o] = S(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: o,
        toMessage: D
      }, a ? {
        syntaxPlugin: a
      } : {}, C));
    }
    return s;
  }
  const v = Object.assign({}, x(u), x(c), x(p), x(d), x`pipelineOperator`(y));
  function P() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  function A(T) {
    const a = P();
    if (T == null)
      return a;
    if (T.annexB != null && T.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (const s of Object.keys(a))
      T[s] != null && (a[s] = T[s]);
    if (a.startLine === 1)
      T.startIndex == null && a.startColumn > 0 ? a.startIndex = a.startColumn : T.startColumn == null && a.startIndex > 0 && (a.startColumn = a.startIndex);
    else if ((T.startColumn == null || T.startIndex == null) && T.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    if (a.sourceType === "commonjs") {
      if (T.allowAwaitOutsideFunction != null)
        throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
      if (T.allowReturnOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
      if (T.allowNewTargetOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
    }
    return a;
  }
  const {
    defineProperty: N
  } = Object, _ = (T, a) => {
    T && N(T, a, {
      enumerable: !1,
      value: T[a]
    });
  };
  function R(T) {
    return _(T.loc.start, "index"), _(T.loc.end, "index"), T;
  }
  var M = (T) => class extends T {
    parse() {
      const s = R(super.parse());
      return this.optionFlags & 256 && (s.tokens = s.tokens.map(R)), s;
    }
    parseRegExpLiteral({
      pattern: s,
      flags: o
    }) {
      let f = null;
      try {
        f = new RegExp(s, o);
      } catch {
      }
      const b = this.estreeParseLiteral(f);
      return b.regex = {
        pattern: s,
        flags: o
      }, b;
    }
    parseBigIntLiteral(s) {
      let o;
      try {
        o = BigInt(s);
      } catch {
        o = null;
      }
      const f = this.estreeParseLiteral(o);
      return f.bigint = String(f.value || s), f;
    }
    parseDecimalLiteral(s) {
      const f = this.estreeParseLiteral(null);
      return f.decimal = String(f.value || s), f;
    }
    estreeParseLiteral(s) {
      return this.parseLiteral(s, "Literal");
    }
    parseStringLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNumericLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    estreeParseChainExpression(s, o) {
      const f = this.startNodeAtNode(s);
      return f.expression = s, this.finishNodeAt(f, "ChainExpression", o);
    }
    directiveToStmt(s) {
      const o = s.value;
      delete s.value, this.castNodeTo(o, "Literal"), o.raw = o.extra.raw, o.value = o.extra.expressionValue;
      const f = this.castNodeTo(s, "ExpressionStatement");
      return f.expression = o, f.directive = o.extra.rawValue, delete o.extra, f;
    }
    fillOptionalPropertiesForTSESLint(s) {
    }
    cloneEstreeStringLiteral(s) {
      const {
        start: o,
        end: f,
        loc: b,
        range: w,
        raw: C,
        value: D
      } = s, F = Object.create(s.constructor.prototype);
      return F.type = "Literal", F.start = o, F.end = f, F.loc = b, F.range = w, F.raw = C, F.value = D, F;
    }
    initFunction(s, o) {
      super.initFunction(s, o), s.expression = !1;
    }
    checkDeclaration(s) {
      s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
    }
    getObjectOrClassMethodParams(s) {
      return s.value.params;
    }
    isValidDirective(s) {
      var o;
      return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((o = s.expression.extra) != null && o.parenthesized);
    }
    parseBlockBody(s, o, f, b, w) {
      super.parseBlockBody(s, o, f, b, w);
      const C = s.directives.map((D) => this.directiveToStmt(D));
      s.body = C.concat(s.body), delete s.directives;
    }
    parsePrivateName() {
      const s = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
    }
    convertPrivateNameToPrivateIdentifier(s) {
      const o = super.getPrivateNameSV(s);
      return s = s, delete s.id, s.name = o, this.castNodeTo(s, "PrivateIdentifier");
    }
    isPrivateName(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
    }
    getPrivateNameSV(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
    }
    parseLiteral(s, o) {
      const f = super.parseLiteral(s, o);
      return f.raw = f.extra.raw, delete f.extra, f;
    }
    parseFunctionBody(s, o, f = !1) {
      super.parseFunctionBody(s, o, f), s.expression = s.body.type !== "BlockStatement";
    }
    parseMethod(s, o, f, b, w, C, D = !1) {
      let F = this.startNode();
      F.kind = s.kind, F = super.parseMethod(F, o, f, b, w, C, D), delete F.kind;
      const {
        typeParameters: $
      } = s;
      $ && (delete s.typeParameters, F.typeParameters = $, this.resetStartLocationFromNode(F, $));
      const q = this.castNodeTo(F, "FunctionExpression");
      return s.value = q, C === "ClassPrivateMethod" && (s.computed = !1), C === "ObjectMethod" ? (s.kind === "method" && (s.kind = "init"), s.shorthand = !1, this.finishNode(s, "Property")) : this.finishNode(s, "MethodDefinition");
    }
    nameIsConstructor(s) {
      return s.type === "Literal" ? s.value === "constructor" : super.nameIsConstructor(s);
    }
    parseClassProperty(...s) {
      const o = super.parseClassProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(o, "PropertyDefinition"), o;
    }
    parseClassPrivateProperty(...s) {
      const o = super.parseClassPrivateProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(o, "PropertyDefinition"), o.computed = !1), o;
    }
    parseClassAccessorProperty(s) {
      const o = super.parseClassAccessorProperty(s);
      return this.getPluginOption("estree", "classFeatures") && (o.abstract && this.hasPlugin("typescript") ? (delete o.abstract, this.castNodeTo(o, "TSAbstractAccessorProperty")) : this.castNodeTo(o, "AccessorProperty")), o;
    }
    parseObjectProperty(s, o, f, b) {
      const w = super.parseObjectProperty(s, o, f, b);
      return w && (w.kind = "init", this.castNodeTo(w, "Property")), w;
    }
    finishObjectProperty(s) {
      return s.kind = "init", this.finishNode(s, "Property");
    }
    isValidLVal(s, o, f) {
      return s === "Property" ? "value" : super.isValidLVal(s, o, f);
    }
    isAssignable(s, o) {
      return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, o) : super.isAssignable(s, o);
    }
    toAssignable(s, o = !1) {
      if (s != null && this.isObjectProperty(s)) {
        const {
          key: f,
          value: b
        } = s;
        this.isPrivateName(f) && this.classScope.usePrivateName(this.getPrivateNameSV(f), f.loc.start), this.toAssignable(b, o);
      } else
        super.toAssignable(s, o);
    }
    toAssignableObjectExpressionProp(s, o, f) {
      s.type === "Property" && (s.kind === "get" || s.kind === "set") ? this.raise(v.PatternHasAccessor, s.key) : s.type === "Property" && s.method ? this.raise(v.PatternHasMethod, s.key) : super.toAssignableObjectExpressionProp(s, o, f);
    }
    finishCallExpression(s, o) {
      const f = super.finishCallExpression(s, o);
      if (f.callee.type === "Import") {
        var b, w;
        this.castNodeTo(f, "ImportExpression"), f.source = f.arguments[0], f.options = (b = f.arguments[1]) != null ? b : null, f.attributes = (w = f.arguments[1]) != null ? w : null, delete f.arguments, delete f.callee;
      } else f.type === "OptionalCallExpression" ? this.castNodeTo(f, "CallExpression") : f.optional = !1;
      return f;
    }
    toReferencedArguments(s) {
      s.type !== "ImportExpression" && super.toReferencedArguments(s);
    }
    parseExport(s, o) {
      const f = this.state.lastTokStartLoc, b = super.parseExport(s, o);
      switch (b.type) {
        case "ExportAllDeclaration":
          b.exported = null;
          break;
        case "ExportNamedDeclaration":
          b.specifiers.length === 1 && b.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(b, "ExportAllDeclaration"), b.exported = b.specifiers[0].exported, delete b.specifiers);
        case "ExportDefaultDeclaration":
          {
            var w;
            const {
              declaration: C
            } = b;
            (C == null ? void 0 : C.type) === "ClassDeclaration" && ((w = C.decorators) == null ? void 0 : w.length) > 0 && C.start === b.start && this.resetStartLocation(b, f);
          }
          break;
      }
      return b;
    }
    stopParseSubscript(s, o) {
      const f = super.stopParseSubscript(s, o);
      return o.optionalChainMember ? this.estreeParseChainExpression(f, s.loc.end) : f;
    }
    parseMember(s, o, f, b, w) {
      const C = super.parseMember(s, o, f, b, w);
      return C.type === "OptionalMemberExpression" ? this.castNodeTo(C, "MemberExpression") : C.optional = !1, C;
    }
    isOptionalMemberExpression(s) {
      return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
    }
    hasPropertyAsPrivateName(s) {
      return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
    }
    isObjectProperty(s) {
      return s.type === "Property" && s.kind === "init" && !s.method;
    }
    isObjectMethod(s) {
      return s.type === "Property" && (s.method || s.kind === "get" || s.kind === "set");
    }
    castNodeTo(s, o) {
      const f = super.castNodeTo(s, o);
      return this.fillOptionalPropertiesForTSESLint(f), f;
    }
    cloneIdentifier(s) {
      const o = super.cloneIdentifier(s);
      return this.fillOptionalPropertiesForTSESLint(o), o;
    }
    cloneStringLiteral(s) {
      return s.type === "Literal" ? this.cloneEstreeStringLiteral(s) : super.cloneStringLiteral(s);
    }
    finishNodeAt(s, o, f) {
      return R(super.finishNodeAt(s, o, f));
    }
    finishNode(s, o) {
      const f = super.finishNode(s, o);
      return this.fillOptionalPropertiesForTSESLint(f), f;
    }
    resetStartLocation(s, o) {
      super.resetStartLocation(s, o), R(s);
    }
    resetEndLocation(s, o = this.state.lastTokEndLoc) {
      super.resetEndLocation(s, o), R(s);
    }
  };
  class O {
    constructor(a, s) {
      this.token = void 0, this.preserveSpace = void 0, this.token = a, this.preserveSpace = !!s;
    }
  }
  const I = {
    brace: new O("{"),
    j_oTag: new O("<tag"),
    j_cTag: new O("</tag"),
    j_expr: new O("<tag>...</tag>", !0)
  };
  I.template = new O("`", !0);
  const k = !0, L = !0, V = !0, K = !0, re = !0, z = !0;
  class se {
    constructor(a, s = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = a, this.keyword = s.keyword, this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop, this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.updateContext = null;
    }
  }
  const he = /* @__PURE__ */ new Map();
  function ne(T, a = {}) {
    a.keyword = T;
    const s = B(T, a);
    return he.set(T, s), s;
  }
  function ge(T, a) {
    return B(T, {
      beforeExpr: k,
      binop: a
    });
  }
  let be = -1;
  const Y = [], ie = [], H = [], j = [], U = [], G = [];
  function B(T, a = {}) {
    var s, o, f, b;
    return ++be, ie.push(T), H.push((s = a.binop) != null ? s : -1), j.push((o = a.beforeExpr) != null ? o : !1), U.push((f = a.startsExpr) != null ? f : !1), G.push((b = a.prefix) != null ? b : !1), Y.push(new se(T, a)), be;
  }
  function W(T, a = {}) {
    var s, o, f, b;
    return ++be, he.set(T, be), ie.push(T), H.push((s = a.binop) != null ? s : -1), j.push((o = a.beforeExpr) != null ? o : !1), U.push((f = a.startsExpr) != null ? f : !1), G.push((b = a.prefix) != null ? b : !1), Y.push(new se("name", a)), be;
  }
  const ce = {
    bracketL: B("[", {
      beforeExpr: k,
      startsExpr: L
    }),
    bracketHashL: B("#[", {
      beforeExpr: k,
      startsExpr: L
    }),
    bracketBarL: B("[|", {
      beforeExpr: k,
      startsExpr: L
    }),
    bracketR: B("]"),
    bracketBarR: B("|]"),
    braceL: B("{", {
      beforeExpr: k,
      startsExpr: L
    }),
    braceBarL: B("{|", {
      beforeExpr: k,
      startsExpr: L
    }),
    braceHashL: B("#{", {
      beforeExpr: k,
      startsExpr: L
    }),
    braceR: B("}"),
    braceBarR: B("|}"),
    parenL: B("(", {
      beforeExpr: k,
      startsExpr: L
    }),
    parenR: B(")"),
    comma: B(",", {
      beforeExpr: k
    }),
    semi: B(";", {
      beforeExpr: k
    }),
    colon: B(":", {
      beforeExpr: k
    }),
    doubleColon: B("::", {
      beforeExpr: k
    }),
    dot: B("."),
    question: B("?", {
      beforeExpr: k
    }),
    questionDot: B("?."),
    arrow: B("=>", {
      beforeExpr: k
    }),
    template: B("template"),
    ellipsis: B("...", {
      beforeExpr: k
    }),
    backQuote: B("`", {
      startsExpr: L
    }),
    dollarBraceL: B("${", {
      beforeExpr: k,
      startsExpr: L
    }),
    templateTail: B("...`", {
      startsExpr: L
    }),
    templateNonTail: B("...${", {
      beforeExpr: k,
      startsExpr: L
    }),
    at: B("@"),
    hash: B("#", {
      startsExpr: L
    }),
    interpreterDirective: B("#!..."),
    eq: B("=", {
      beforeExpr: k,
      isAssign: K
    }),
    assign: B("_=", {
      beforeExpr: k,
      isAssign: K
    }),
    slashAssign: B("_=", {
      beforeExpr: k,
      isAssign: K
    }),
    xorAssign: B("_=", {
      beforeExpr: k,
      isAssign: K
    }),
    moduloAssign: B("_=", {
      beforeExpr: k,
      isAssign: K
    }),
    incDec: B("++/--", {
      prefix: re,
      postfix: z,
      startsExpr: L
    }),
    bang: B("!", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    tilde: B("~", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    doubleCaret: B("^^", {
      startsExpr: L
    }),
    doubleAt: B("@@", {
      startsExpr: L
    }),
    pipeline: ge("|>", 0),
    nullishCoalescing: ge("??", 1),
    logicalOR: ge("||", 1),
    logicalAND: ge("&&", 2),
    bitwiseOR: ge("|", 3),
    bitwiseXOR: ge("^", 4),
    bitwiseAND: ge("&", 5),
    equality: ge("==/!=/===/!==", 6),
    lt: ge("</>/<=/>=", 7),
    gt: ge("</>/<=/>=", 7),
    relational: ge("</>/<=/>=", 7),
    bitShift: ge("<</>>/>>>", 8),
    bitShiftL: ge("<</>>/>>>", 8),
    bitShiftR: ge("<</>>/>>>", 8),
    plusMin: B("+/-", {
      beforeExpr: k,
      binop: 9,
      prefix: re,
      startsExpr: L
    }),
    modulo: B("%", {
      binop: 10,
      startsExpr: L
    }),
    star: B("*", {
      binop: 10
    }),
    slash: ge("/", 10),
    exponent: B("**", {
      beforeExpr: k,
      binop: 11,
      rightAssociative: !0
    }),
    _in: ne("in", {
      beforeExpr: k,
      binop: 7
    }),
    _instanceof: ne("instanceof", {
      beforeExpr: k,
      binop: 7
    }),
    _break: ne("break"),
    _case: ne("case", {
      beforeExpr: k
    }),
    _catch: ne("catch"),
    _continue: ne("continue"),
    _debugger: ne("debugger"),
    _default: ne("default", {
      beforeExpr: k
    }),
    _else: ne("else", {
      beforeExpr: k
    }),
    _finally: ne("finally"),
    _function: ne("function", {
      startsExpr: L
    }),
    _if: ne("if"),
    _return: ne("return", {
      beforeExpr: k
    }),
    _switch: ne("switch"),
    _throw: ne("throw", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    _try: ne("try"),
    _var: ne("var"),
    _const: ne("const"),
    _with: ne("with"),
    _new: ne("new", {
      beforeExpr: k,
      startsExpr: L
    }),
    _this: ne("this", {
      startsExpr: L
    }),
    _super: ne("super", {
      startsExpr: L
    }),
    _class: ne("class", {
      startsExpr: L
    }),
    _extends: ne("extends", {
      beforeExpr: k
    }),
    _export: ne("export"),
    _import: ne("import", {
      startsExpr: L
    }),
    _null: ne("null", {
      startsExpr: L
    }),
    _true: ne("true", {
      startsExpr: L
    }),
    _false: ne("false", {
      startsExpr: L
    }),
    _typeof: ne("typeof", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    _void: ne("void", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    _delete: ne("delete", {
      beforeExpr: k,
      prefix: re,
      startsExpr: L
    }),
    _do: ne("do", {
      isLoop: V,
      beforeExpr: k
    }),
    _for: ne("for", {
      isLoop: V
    }),
    _while: ne("while", {
      isLoop: V
    }),
    _as: W("as", {
      startsExpr: L
    }),
    _assert: W("assert", {
      startsExpr: L
    }),
    _async: W("async", {
      startsExpr: L
    }),
    _await: W("await", {
      startsExpr: L
    }),
    _defer: W("defer", {
      startsExpr: L
    }),
    _from: W("from", {
      startsExpr: L
    }),
    _get: W("get", {
      startsExpr: L
    }),
    _let: W("let", {
      startsExpr: L
    }),
    _meta: W("meta", {
      startsExpr: L
    }),
    _of: W("of", {
      startsExpr: L
    }),
    _sent: W("sent", {
      startsExpr: L
    }),
    _set: W("set", {
      startsExpr: L
    }),
    _source: W("source", {
      startsExpr: L
    }),
    _static: W("static", {
      startsExpr: L
    }),
    _using: W("using", {
      startsExpr: L
    }),
    _yield: W("yield", {
      startsExpr: L
    }),
    _asserts: W("asserts", {
      startsExpr: L
    }),
    _checks: W("checks", {
      startsExpr: L
    }),
    _exports: W("exports", {
      startsExpr: L
    }),
    _global: W("global", {
      startsExpr: L
    }),
    _implements: W("implements", {
      startsExpr: L
    }),
    _intrinsic: W("intrinsic", {
      startsExpr: L
    }),
    _infer: W("infer", {
      startsExpr: L
    }),
    _is: W("is", {
      startsExpr: L
    }),
    _mixins: W("mixins", {
      startsExpr: L
    }),
    _proto: W("proto", {
      startsExpr: L
    }),
    _require: W("require", {
      startsExpr: L
    }),
    _satisfies: W("satisfies", {
      startsExpr: L
    }),
    _keyof: W("keyof", {
      startsExpr: L
    }),
    _readonly: W("readonly", {
      startsExpr: L
    }),
    _unique: W("unique", {
      startsExpr: L
    }),
    _abstract: W("abstract", {
      startsExpr: L
    }),
    _declare: W("declare", {
      startsExpr: L
    }),
    _enum: W("enum", {
      startsExpr: L
    }),
    _module: W("module", {
      startsExpr: L
    }),
    _namespace: W("namespace", {
      startsExpr: L
    }),
    _interface: W("interface", {
      startsExpr: L
    }),
    _type: W("type", {
      startsExpr: L
    }),
    _opaque: W("opaque", {
      startsExpr: L
    }),
    name: B("name", {
      startsExpr: L
    }),
    placeholder: B("%%", {
      startsExpr: L
    }),
    string: B("string", {
      startsExpr: L
    }),
    num: B("num", {
      startsExpr: L
    }),
    bigint: B("bigint", {
      startsExpr: L
    }),
    decimal: B("decimal", {
      startsExpr: L
    }),
    regexp: B("regexp", {
      startsExpr: L
    }),
    privateName: B("#name", {
      startsExpr: L
    }),
    eof: B("eof"),
    jsxName: B("jsxName"),
    jsxText: B("jsxText", {
      beforeExpr: k
    }),
    jsxTagStart: B("jsxTagStart", {
      startsExpr: L
    }),
    jsxTagEnd: B("jsxTagEnd")
  };
  function Q(T) {
    return T >= 93 && T <= 133;
  }
  function Z(T) {
    return T <= 92;
  }
  function le(T) {
    return T >= 58 && T <= 133;
  }
  function ve(T) {
    return T >= 58 && T <= 137;
  }
  function de(T) {
    return j[T];
  }
  function we(T) {
    return U[T];
  }
  function it(T) {
    return T >= 29 && T <= 33;
  }
  function dt(T) {
    return T >= 129 && T <= 131;
  }
  function tt(T) {
    return T >= 90 && T <= 92;
  }
  function Be(T) {
    return T >= 58 && T <= 92;
  }
  function mt(T) {
    return T >= 39 && T <= 59;
  }
  function yt(T) {
    return T === 34;
  }
  function Nt(T) {
    return G[T];
  }
  function $r(T) {
    return T >= 121 && T <= 123;
  }
  function Ur(T) {
    return T >= 124 && T <= 130;
  }
  function nt(T) {
    return ie[T];
  }
  function qr(T) {
    return H[T];
  }
  function Ia(T) {
    return T === 57;
  }
  function jr(T) {
    return T >= 24 && T <= 25;
  }
  function Tt(T) {
    return Y[T];
  }
  Y[8].updateContext = (T) => {
    T.pop();
  }, Y[5].updateContext = Y[7].updateContext = Y[23].updateContext = (T) => {
    T.push(I.brace);
  }, Y[22].updateContext = (T) => {
    T[T.length - 1] === I.template ? T.pop() : T.push(I.template);
  }, Y[143].updateContext = (T) => {
    T.push(I.j_expr, I.j_oTag);
  };
  let Ss = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", fi = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const ry = new RegExp("[" + Ss + "]"), sy = new RegExp("[" + Ss + fi + "]");
  Ss = fi = null;
  const fc = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], iy = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Na(T, a) {
    let s = 65536;
    for (let o = 0, f = a.length; o < f; o += 2) {
      if (s += a[o], s > T) return !1;
      if (s += a[o + 1], s >= T) return !0;
    }
    return !1;
  }
  function jt(T) {
    return T < 65 ? T === 36 : T <= 90 ? !0 : T < 97 ? T === 95 : T <= 122 ? !0 : T <= 65535 ? T >= 170 && ry.test(String.fromCharCode(T)) : Na(T, fc);
  }
  function Vr(T) {
    return T < 48 ? T === 36 : T < 58 ? !0 : T < 65 ? !1 : T <= 90 ? !0 : T < 97 ? T === 95 : T <= 122 ? !0 : T <= 65535 ? T >= 170 && sy.test(String.fromCharCode(T)) : Na(T, fc) || Na(T, iy);
  }
  const Oa = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, ny = new Set(Oa.keyword), ay = new Set(Oa.strict), oy = new Set(Oa.strictBind);
  function pc(T, a) {
    return a && T === "await" || T === "enum";
  }
  function dc(T, a) {
    return pc(T, a) || ay.has(T);
  }
  function mc(T) {
    return oy.has(T);
  }
  function yc(T, a) {
    return dc(T, a) || mc(T);
  }
  function uy(T) {
    return ny.has(T);
  }
  function ly(T, a, s) {
    return T === 64 && a === 64 && jt(s);
  }
  const cy = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function hy(T) {
    return cy.has(T);
  }
  class ka {
    constructor(a) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = a;
    }
  }
  class La {
    constructor(a, s) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = a, this.inModule = s;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get allowNewTarget() {
      return (this.currentThisScopeFlags() & 512) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const a = this.currentThisScopeFlags();
      return (a & 64) > 0 && (a & 2) === 0;
    }
    get inStaticBlock() {
      for (let a = this.scopeStack.length - 1; ; a--) {
        const {
          flags: s
        } = this.scopeStack[a];
        if (s & 128)
          return !0;
        if (s & 1731)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get inBareCaseStatement() {
      return (this.currentScope().flags & 256) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(a) {
      return new ka(a);
    }
    enter(a) {
      this.scopeStack.push(this.createScope(a));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(a) {
      return !!(a.flags & 130 || !this.parser.inModule && a.flags & 1);
    }
    declareName(a, s, o) {
      let f = this.currentScope();
      if (s & 8 || s & 16) {
        this.checkRedeclarationInScope(f, a, s, o);
        let b = f.names.get(a) || 0;
        s & 16 ? b = b | 4 : (f.firstLexicalName || (f.firstLexicalName = a), b = b | 2), f.names.set(a, b), s & 8 && this.maybeExportDefined(f, a);
      } else if (s & 4)
        for (let b = this.scopeStack.length - 1; b >= 0 && (f = this.scopeStack[b], this.checkRedeclarationInScope(f, a, s, o), f.names.set(a, (f.names.get(a) || 0) | 1), this.maybeExportDefined(f, a), !(f.flags & 1667)); --b)
          ;
      this.parser.inModule && f.flags & 1 && this.undefinedExports.delete(a);
    }
    maybeExportDefined(a, s) {
      this.parser.inModule && a.flags & 1 && this.undefinedExports.delete(s);
    }
    checkRedeclarationInScope(a, s, o, f) {
      this.isRedeclaredInScope(a, s, o) && this.parser.raise(v.VarRedeclaration, f, {
        identifierName: s
      });
    }
    isRedeclaredInScope(a, s, o) {
      if (!(o & 1)) return !1;
      if (o & 8)
        return a.names.has(s);
      const f = a.names.get(s);
      return o & 16 ? (f & 2) > 0 || !this.treatFunctionsAsVarInScope(a) && (f & 1) > 0 : (f & 2) > 0 && !(a.flags & 8 && a.firstLexicalName === s) || !this.treatFunctionsAsVarInScope(a) && (f & 4) > 0;
    }
    checkLocalExport(a) {
      const {
        name: s
      } = a;
      this.scopeStack[0].names.has(s) || this.undefinedExports.set(s, a.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let a = this.scopeStack.length - 1; ; a--) {
        const {
          flags: s
        } = this.scopeStack[a];
        if (s & 1667)
          return s;
      }
    }
    currentThisScopeFlags() {
      for (let a = this.scopeStack.length - 1; ; a--) {
        const {
          flags: s
        } = this.scopeStack[a];
        if (s & 1731 && !(s & 4))
          return s;
      }
    }
  }
  class fy extends ka {
    constructor(...a) {
      super(...a), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class py extends La {
    createScope(a) {
      return new fy(a);
    }
    declareName(a, s, o) {
      const f = this.currentScope();
      if (s & 2048) {
        this.checkRedeclarationInScope(f, a, s, o), this.maybeExportDefined(f, a), f.declareFunctions.add(a);
        return;
      }
      super.declareName(a, s, o);
    }
    isRedeclaredInScope(a, s, o) {
      if (super.isRedeclaredInScope(a, s, o)) return !0;
      if (o & 2048 && !a.declareFunctions.has(s)) {
        const f = a.names.get(s);
        return (f & 4) > 0 || (f & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(a) {
      this.scopeStack[0].declareFunctions.has(a.name) || super.checkLocalExport(a);
    }
  }
  const dy = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), fe = x`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType: T
    }) => `Cannot overwrite reserved type ${T}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName: T,
      enumName: a
    }) => `Boolean enum members need to be initialized. Use either \`${T} = true,\` or \`${T} = false,\` in enum \`${a}\`.`,
    EnumDuplicateMemberName: ({
      memberName: T,
      enumName: a
    }) => `Enum member names need to be unique, but the name \`${T}\` has already been used before in enum \`${a}\`.`,
    EnumInconsistentMemberValues: ({
      enumName: T
    }) => `Enum \`${T}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType: T,
      enumName: a
    }) => `Enum type \`${T}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName: T
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${T}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName: T,
      memberName: a,
      explicitType: s
    }) => `Enum \`${T}\` has type \`${s}\`, so the initializer of \`${a}\` needs to be a ${s} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName: T,
      memberName: a
    }) => `Symbol enum members cannot be initialized. Use \`${a},\` in enum \`${T}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName: T,
      memberName: a
    }) => `The enum member initializer for \`${a}\` needs to be a literal (either a boolean, number, or string) in enum \`${T}\`.`,
    EnumInvalidMemberName: ({
      enumName: T,
      memberName: a,
      suggestion: s
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${a}\`, consider using \`${s}\`, in enum \`${T}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName: T,
      memberName: a
    }) => `Number enum members need to be initialized, e.g. \`${a} = 1\` in enum \`${T}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName: T
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${T}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType: T
    }) => `Unexpected reserved type ${T}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind: T,
      suggestion: a
    }) => `\`declare export ${T}\` is not supported. Use \`${a}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function my(T) {
    return T.type === "DeclareExportAllDeclaration" || T.type === "DeclareExportDeclaration" && (!T.declaration || T.declaration.type !== "TypeAlias" && T.declaration.type !== "InterfaceDeclaration");
  }
  function gc(T) {
    return T.importKind === "type" || T.importKind === "typeof";
  }
  const yy = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function gy(T, a) {
    const s = [], o = [];
    for (let f = 0; f < T.length; f++)
      (a(T[f], f, T) ? s : o).push(T[f]);
    return [s, o];
  }
  const by = /\*?\s*@((?:no)?flow)\b/;
  var Sy = (T) => class extends T {
    constructor(...s) {
      super(...s), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return py;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(s, o) {
      s !== 134 && s !== 13 && s !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(s, o);
    }
    addComment(s) {
      if (this.flowPragma === void 0) {
        const o = by.exec(s.value);
        if (o) if (o[1] === "flow")
          this.flowPragma = "flow";
        else if (o[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(s);
    }
    flowParseTypeInitialiser(s) {
      const o = this.state.inType;
      this.state.inType = !0, this.expect(s || 14);
      const f = this.flowParseType();
      return this.state.inType = o, f;
    }
    flowParsePredicate() {
      const s = this.startNode(), o = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > o.index + 1 && this.raise(fe.UnexpectedSpaceBetweenModuloChecks, o), this.eat(10) ? (s.value = super.parseExpression(), this.expect(11), this.finishNode(s, "DeclaredPredicate")) : this.finishNode(s, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const s = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let o = null, f = null;
      return this.match(54) ? (this.state.inType = s, f = this.flowParsePredicate()) : (o = this.flowParseType(), this.state.inType = s, this.match(54) && (f = this.flowParsePredicate())), [o, f];
    }
    flowParseDeclareClass(s) {
      return this.next(), this.flowParseInterfaceish(s, !0), this.finishNode(s, "DeclareClass");
    }
    flowParseDeclareFunction(s) {
      this.next();
      const o = s.id = this.parseIdentifier(), f = this.startNode(), b = this.startNode();
      this.match(47) ? f.typeParameters = this.flowParseTypeParameterDeclaration() : f.typeParameters = null, this.expect(10);
      const w = this.flowParseFunctionTypeParams();
      return f.params = w.params, f.rest = w.rest, f.this = w._this, this.expect(11), [f.returnType, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), b.typeAnnotation = this.finishNode(f, "FunctionTypeAnnotation"), o.typeAnnotation = this.finishNode(b, "TypeAnnotation"), this.resetEndLocation(o), this.semicolon(), this.scope.declareName(s.id.name, 2048, s.id.loc.start), this.finishNode(s, "DeclareFunction");
    }
    flowParseDeclare(s, o) {
      if (this.match(80))
        return this.flowParseDeclareClass(s);
      if (this.match(68))
        return this.flowParseDeclareFunction(s);
      if (this.match(74))
        return this.flowParseDeclareVariable(s);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(s) : (o && this.raise(fe.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(s));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(s);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(s);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(s);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(s, o);
      this.unexpected();
    }
    flowParseDeclareVariable(s) {
      return this.next(), s.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(s.id.name, 5, s.id.loc.start), this.semicolon(), this.finishNode(s, "DeclareVariable");
    }
    flowParseDeclareModule(s) {
      this.scope.enter(0), this.match(134) ? s.id = super.parseExprAtom() : s.id = this.parseIdentifier();
      const o = s.body = this.startNode(), f = o.body = [];
      for (this.expect(5); !this.match(8); ) {
        let C = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(fe.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(C)) : (this.expectContextual(125, fe.UnsupportedStatementInDeclareModule), C = this.flowParseDeclare(C, !0)), f.push(C);
      }
      this.scope.exit(), this.expect(8), this.finishNode(o, "BlockStatement");
      let b = null, w = !1;
      return f.forEach((C) => {
        my(C) ? (b === "CommonJS" && this.raise(fe.AmbiguousDeclareModuleKind, C), b = "ES") : C.type === "DeclareModuleExports" && (w && this.raise(fe.DuplicateDeclareModuleExports, C), b === "ES" && this.raise(fe.AmbiguousDeclareModuleKind, C), b = "CommonJS", w = !0);
      }), s.kind = b || "CommonJS", this.finishNode(s, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(s, o) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? s.declaration = this.flowParseDeclare(this.startNode()) : (s.declaration = this.flowParseType(), this.semicolon()), s.default = !0, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !o) {
        const f = this.state.value;
        throw this.raise(fe.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: f,
          suggestion: yy[f]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return s.declaration = this.flowParseDeclare(this.startNode()), s.default = !1, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return s = this.parseExport(s, null), s.type === "ExportNamedDeclaration" ? (s.default = !1, delete s.exportKind, this.castNodeTo(s, "DeclareExportDeclaration")) : this.castNodeTo(s, "DeclareExportAllDeclaration");
      this.unexpected();
    }
    flowParseDeclareModuleExports(s) {
      return this.next(), this.expectContextual(111), s.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(s, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(s) {
      this.next();
      const o = this.flowParseTypeAlias(s);
      return this.castNodeTo(o, "DeclareTypeAlias"), o;
    }
    flowParseDeclareOpaqueType(s) {
      this.next();
      const o = this.flowParseOpaqueType(s, !0);
      return this.castNodeTo(o, "DeclareOpaqueType"), o;
    }
    flowParseDeclareInterface(s) {
      return this.next(), this.flowParseInterfaceish(s, !1), this.finishNode(s, "DeclareInterface");
    }
    flowParseInterfaceish(s, o) {
      if (s.id = this.flowParseRestrictedIdentifier(!o, !0), this.scope.declareName(s.id.name, o ? 17 : 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (!o && this.eat(12));
      if (o) {
        if (s.implements = [], s.mixins = [], this.eatContextual(117))
          do
            s.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            s.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      s.body = this.flowParseObjectType({
        allowStatic: o,
        allowExact: !1,
        allowSpread: !1,
        allowProto: o,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      const s = this.startNode();
      return s.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, this.finishNode(s, "InterfaceExtends");
    }
    flowParseInterface(s) {
      return this.flowParseInterfaceish(s, !1), this.finishNode(s, "InterfaceDeclaration");
    }
    checkNotUnderscore(s) {
      s === "_" && this.raise(fe.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(s, o, f) {
      dy.has(s) && this.raise(f ? fe.AssignReservedType : fe.UnexpectedReservedType, o, {
        reservedType: s
      });
    }
    flowParseRestrictedIdentifier(s, o) {
      return this.checkReservedType(this.state.value, this.state.startLoc, o), this.parseIdentifier(s);
    }
    flowParseTypeAlias(s) {
      return s.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(s, "TypeAlias");
    }
    flowParseOpaqueType(s, o) {
      return this.expectContextual(130), s.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.supertype = null, this.match(14) && (s.supertype = this.flowParseTypeInitialiser(14)), s.impltype = null, o || (s.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(s, "OpaqueType");
    }
    flowParseTypeParameter(s = !1) {
      const o = this.state.startLoc, f = this.startNode(), b = this.flowParseVariance(), w = this.flowParseTypeAnnotatableIdentifier();
      return f.name = w.name, f.variance = b, f.bound = w.typeAnnotation, this.match(29) ? (this.eat(29), f.default = this.flowParseType()) : s && this.raise(fe.MissingTypeParamDefault, o), this.finishNode(f, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const s = this.state.inType, o = this.startNode();
      o.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let f = !1;
      do {
        const b = this.flowParseTypeParameter(f);
        o.params.push(b), b.default && (f = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = s, this.finishNode(o, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(s) {
      if (this.curContext() !== I.brace) {
        const o = this.state.context;
        this.state.context = [o[0]];
        try {
          return s();
        } finally {
          this.state.context = o;
        }
      } else
        return s();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      const s = this.startNode(), o = this.state.inType;
      return this.state.inType = !0, s.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        const f = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          s.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = f;
      }), this.state.inType = o, !this.state.inType && this.curContext() === I.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      const s = this.startNode(), o = this.state.inType;
      for (s.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        s.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = o, this.finishNode(s, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const s = this.startNode();
      if (this.expectContextual(129), s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return s.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(s, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(s, o, f) {
      return s.static = o, this.lookahead().type === 14 ? (s.id = this.flowParseObjectPropertyKey(), s.key = this.flowParseTypeInitialiser()) : (s.id = null, s.key = this.flowParseType()), this.expect(3), s.value = this.flowParseTypeInitialiser(), s.variance = f, this.finishNode(s, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(s, o) {
      return s.static = o, s.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (s.method = !0, s.optional = !1, s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start))) : (s.method = !1, this.eat(17) && (s.optional = !0), s.value = this.flowParseTypeInitialiser()), this.finishNode(s, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(s) {
      for (s.params = [], s.rest = null, s.typeParameters = null, s.this = null, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (s.this = this.flowParseFunctionTypeParam(!0), s.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        s.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), s.returnType = this.flowParseTypeInitialiser(), this.finishNode(s, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(s, o) {
      const f = this.startNode();
      return s.static = o, s.value = this.flowParseObjectTypeMethodish(f), this.finishNode(s, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: s,
      allowExact: o,
      allowSpread: f,
      allowProto: b,
      allowInexact: w
    }) {
      const C = this.state.inType;
      this.state.inType = !0;
      const D = this.startNode();
      D.callProperties = [], D.properties = [], D.indexers = [], D.internalSlots = [];
      let F, $, q = !1;
      for (o && this.match(6) ? (this.expect(6), F = 9, $ = !0) : (this.expect(5), F = 8, $ = !1), D.exact = $; !this.match(F); ) {
        let ee = !1, oe = null, me = null;
        const Re = this.startNode();
        if (b && this.isContextual(118)) {
          const _e = this.lookahead();
          _e.type !== 14 && _e.type !== 17 && (this.next(), oe = this.state.startLoc, s = !1);
        }
        if (s && this.isContextual(106)) {
          const _e = this.lookahead();
          _e.type !== 14 && _e.type !== 17 && (this.next(), ee = !0);
        }
        const ye = this.flowParseVariance();
        if (this.eat(0))
          oe != null && this.unexpected(oe), this.eat(0) ? (ye && this.unexpected(ye.loc.start), D.internalSlots.push(this.flowParseObjectTypeInternalSlot(Re, ee))) : D.indexers.push(this.flowParseObjectTypeIndexer(Re, ee, ye));
        else if (this.match(10) || this.match(47))
          oe != null && this.unexpected(oe), ye && this.unexpected(ye.loc.start), D.callProperties.push(this.flowParseObjectTypeCallProperty(Re, ee));
        else {
          let _e = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const rr = this.lookahead();
            ve(rr.type) && (_e = this.state.value, this.next());
          }
          const gr = this.flowParseObjectTypeProperty(Re, ee, oe, ye, _e, f, w ?? !$);
          gr === null ? (q = !0, me = this.state.lastTokStartLoc) : D.properties.push(gr);
        }
        this.flowObjectTypeSemicolon(), me && !this.match(8) && !this.match(9) && this.raise(fe.UnexpectedExplicitInexactInObject, me);
      }
      this.expect(F), f && (D.inexact = q);
      const J = this.finishNode(D, "ObjectTypeAnnotation");
      return this.state.inType = C, J;
    }
    flowParseObjectTypeProperty(s, o, f, b, w, C, D) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (C ? D || this.raise(fe.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(fe.InexactInsideNonObject, this.state.lastTokStartLoc), b && this.raise(fe.InexactVariance, b), null) : (C || this.raise(fe.UnexpectedSpreadType, this.state.lastTokStartLoc), f != null && this.unexpected(f), b && this.raise(fe.SpreadVariance, b), s.argument = this.flowParseType(), this.finishNode(s, "ObjectTypeSpreadProperty"));
      {
        s.key = this.flowParseObjectPropertyKey(), s.static = o, s.proto = f != null, s.kind = w;
        let F = !1;
        return this.match(47) || this.match(10) ? (s.method = !0, f != null && this.unexpected(f), b && this.unexpected(b.loc.start), s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start)), (w === "get" || w === "set") && this.flowCheckGetterSetterParams(s), !C && s.key.name === "constructor" && s.value.this && this.raise(fe.ThisParamBannedInConstructor, s.value.this)) : (w !== "init" && this.unexpected(), s.method = !1, this.eat(17) && (F = !0), s.value = this.flowParseTypeInitialiser(), s.variance = b), s.optional = F, this.finishNode(s, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(s) {
      const o = s.kind === "get" ? 0 : 1, f = s.value.params.length + (s.value.rest ? 1 : 0);
      s.value.this && this.raise(s.kind === "get" ? fe.GetterMayNotHaveThisParam : fe.SetterMayNotHaveThisParam, s.value.this), f !== o && this.raise(s.kind === "get" ? v.BadGetterArity : v.BadSetterArity, s), s.kind === "set" && s.value.rest && this.raise(v.BadSetterRestParameter, s);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(s, o) {
      s ?? (s = this.state.startLoc);
      let f = o || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        const b = this.startNodeAt(s);
        b.qualification = f, b.id = this.flowParseRestrictedIdentifier(!0), f = this.finishNode(b, "QualifiedTypeIdentifier");
      }
      return f;
    }
    flowParseGenericType(s, o) {
      const f = this.startNodeAt(s);
      return f.typeParameters = null, f.id = this.flowParseQualifiedTypeIdentifier(s, o), this.match(47) && (f.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(f, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const s = this.startNode();
      return this.expect(87), s.argument = this.flowParsePrimaryType(), this.finishNode(s, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const s = this.startNode();
      for (s.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (s.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(s, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(s) {
      let o = null, f = !1, b = null;
      const w = this.startNode(), C = this.lookahead(), D = this.state.type === 78;
      return C.type === 14 || C.type === 17 ? (D && !s && this.raise(fe.ThisParamMustBeFirst, w), o = this.parseIdentifier(D), this.eat(17) && (f = !0, D && this.raise(fe.ThisParamMayNotBeOptional, w)), b = this.flowParseTypeInitialiser()) : b = this.flowParseType(), w.name = o, w.optional = f, w.typeAnnotation = b, this.finishNode(w, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(s) {
      const o = this.startNodeAt(s.loc.start);
      return o.name = null, o.optional = !1, o.typeAnnotation = s, this.finishNode(o, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(s = []) {
      let o = null, f = null;
      for (this.match(78) && (f = this.flowParseFunctionTypeParam(!0), f.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        s.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (o = this.flowParseFunctionTypeParam(!1)), {
        params: s,
        rest: o,
        _this: f
      };
    }
    flowIdentToTypeAnnotation(s, o, f) {
      switch (f.name) {
        case "any":
          return this.finishNode(o, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(o, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(o, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(o, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(o, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(o, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(o, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(f.name), this.flowParseGenericType(s, f);
      }
    }
    flowParsePrimaryType() {
      const s = this.state.startLoc, o = this.startNode();
      let f, b, w = !1;
      const C = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, b = this.flowParseTupleType(), this.state.noAnonFunctionType = C, b;
        case 47: {
          const D = this.startNode();
          return D.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), f = this.flowParseFunctionTypeParams(), D.params = f.params, D.rest = f.rest, D.this = f._this, this.expect(11), this.expect(19), D.returnType = this.flowParseType(), this.finishNode(D, "FunctionTypeAnnotation");
        }
        case 10: {
          const D = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (Q(this.state.type) || this.match(78)) {
              const F = this.lookahead().type;
              w = F !== 17 && F !== 14;
            } else
              w = !0;
          if (w) {
            if (this.state.noAnonFunctionType = !1, b = this.flowParseType(), this.state.noAnonFunctionType = C, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), b;
            this.eat(12);
          }
          return b ? f = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(b)]) : f = this.flowParseFunctionTypeParams(), D.params = f.params, D.rest = f.rest, D.this = f._this, this.expect(11), this.expect(19), D.returnType = this.flowParseType(), D.typeParameters = null, this.finishNode(D, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return o.value = this.match(85), this.next(), this.finishNode(o, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", o);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", o);
            throw this.raise(fe.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(o, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(o, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(o, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(o, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Be(this.state.type)) {
            const D = nt(this.state.type);
            return this.next(), super.createIdentifier(o, D);
          } else if (Q(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, o, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const s = this.state.startLoc;
      let o = this.flowParsePrimaryType(), f = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const b = this.startNodeAt(s), w = this.eat(18);
        f = f || w, this.expect(0), !w && this.match(3) ? (b.elementType = o, this.next(), o = this.finishNode(b, "ArrayTypeAnnotation")) : (b.objectType = o, b.indexType = this.flowParseType(), this.expect(3), f ? (b.optional = w, o = this.finishNode(b, "OptionalIndexedAccessType")) : o = this.finishNode(b, "IndexedAccessType"));
      }
      return o;
    }
    flowParsePrefixType() {
      const s = this.startNode();
      return this.eat(17) ? (s.typeAnnotation = this.flowParsePrefixType(), this.finishNode(s, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const s = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const o = this.startNodeAt(s.loc.start);
        return o.params = [this.reinterpretTypeAsFunctionTypeParam(s)], o.rest = null, o.this = null, o.returnType = this.flowParseType(), o.typeParameters = null, this.finishNode(o, "FunctionTypeAnnotation");
      }
      return s;
    }
    flowParseIntersectionType() {
      const s = this.startNode();
      this.eat(45);
      const o = this.flowParseAnonFunctionWithoutParens();
      for (s.types = [o]; this.eat(45); )
        s.types.push(this.flowParseAnonFunctionWithoutParens());
      return s.types.length === 1 ? o : this.finishNode(s, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const s = this.startNode();
      this.eat(43);
      const o = this.flowParseIntersectionType();
      for (s.types = [o]; this.eat(43); )
        s.types.push(this.flowParseIntersectionType());
      return s.types.length === 1 ? o : this.finishNode(s, "UnionTypeAnnotation");
    }
    flowParseType() {
      const s = this.state.inType;
      this.state.inType = !0;
      const o = this.flowParseUnionType();
      return this.state.inType = s, o;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const s = this.state.startLoc, o = this.parseIdentifier();
        return this.flowParseGenericType(s, o);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const s = this.startNode();
      return s.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(s, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(s) {
      const o = s ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (o.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(o)), o;
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    flowParseVariance() {
      let s = null;
      return this.match(53) ? (s = this.startNode(), this.state.value === "+" ? s.kind = "plus" : s.kind = "minus", this.next(), this.finishNode(s, "Variance")) : s;
    }
    parseFunctionBody(s, o, f = !1) {
      if (o) {
        this.forwardNoArrowParamsConversionAt(s, () => super.parseFunctionBody(s, !0, f));
        return;
      }
      super.parseFunctionBody(s, !1, f);
    }
    parseFunctionBodyAndFinish(s, o, f = !1) {
      if (this.match(14)) {
        const b = this.startNode();
        [b.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), s.returnType = b.typeAnnotation ? this.finishNode(b, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(s, o, f);
    }
    parseStatementLike(s) {
      if (this.state.strict && this.isContextual(129)) {
        const f = this.lookahead();
        if (le(f.type)) {
          const b = this.startNode();
          return this.next(), this.flowParseInterface(b);
        }
      } else if (this.isContextual(126)) {
        const f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      }
      const o = super.parseStatementLike(s);
      return this.flowPragma === void 0 && !this.isValidDirective(o) && (this.flowPragma = null), o;
    }
    parseExpressionStatement(s, o, f) {
      if (o.type === "Identifier") {
        if (o.name === "declare") {
          if (this.match(80) || Q(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(s);
        } else if (Q(this.state.type)) {
          if (o.name === "interface")
            return this.flowParseInterface(s);
          if (o.name === "type")
            return this.flowParseTypeAlias(s);
          if (o.name === "opaque")
            return this.flowParseOpaqueType(s, !1);
        }
      }
      return super.parseExpressionStatement(s, o, f);
    }
    shouldParseExportDeclaration() {
      const {
        type: s
      } = this.state;
      return s === 126 || dt(s) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: s
      } = this.state;
      return s === 126 || dt(s) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        const s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(s, o, f) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        const J = this.lookaheadCharCode();
        if (J === 44 || J === 61 || J === 58 || J === 41)
          return this.setOptionalParametersError(f), s;
      }
      this.expect(17);
      const b = this.state.clone(), w = this.state.noArrowAt, C = this.startNodeAt(o);
      let {
        consequent: D,
        failed: F
      } = this.tryParseConditionalConsequent(), [$, q] = this.getArrowLikeExpressions(D);
      if (F || q.length > 0) {
        const J = [...w];
        if (q.length > 0) {
          this.state = b, this.state.noArrowAt = J;
          for (let ee = 0; ee < q.length; ee++)
            J.push(q[ee].start);
          ({
            consequent: D,
            failed: F
          } = this.tryParseConditionalConsequent()), [$, q] = this.getArrowLikeExpressions(D);
        }
        F && $.length > 1 && this.raise(fe.AmbiguousConditionalArrow, b.startLoc), F && $.length === 1 && (this.state = b, J.push($[0].start), this.state.noArrowAt = J, {
          consequent: D,
          failed: F
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(D, !0), this.state.noArrowAt = w, this.expect(14), C.test = s, C.consequent = D, C.alternate = this.forwardNoArrowParamsConversionAt(C, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(C, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const s = this.parseMaybeAssignAllowIn(), o = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: s,
        failed: o
      };
    }
    getArrowLikeExpressions(s, o) {
      const f = [s], b = [];
      for (; f.length !== 0; ) {
        const w = f.pop();
        w.type === "ArrowFunctionExpression" && w.body.type !== "BlockStatement" ? (w.typeParameters || !w.returnType ? this.finishArrowValidation(w) : b.push(w), f.push(w.body)) : w.type === "ConditionalExpression" && (f.push(w.consequent), f.push(w.alternate));
      }
      return o ? (b.forEach((w) => this.finishArrowValidation(w)), [b, []]) : gy(b, (w) => w.params.every((C) => this.isAssignable(C, !0)));
    }
    finishArrowValidation(s) {
      var o;
      this.toAssignableList(s.params, (o = s.extra) == null ? void 0 : o.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(s, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(s, o) {
      let f;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), f = o(), this.state.noArrowParamsConversionAt.pop()) : f = o(), f;
    }
    parseParenItem(s, o) {
      const f = super.parseParenItem(s, o);
      if (this.eat(17) && (f.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        const b = this.startNodeAt(o);
        return b.expression = f, b.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(b, "TypeCastExpression");
      }
      return f;
    }
    assertModuleNodeAllowed(s) {
      s.type === "ImportDeclaration" && (s.importKind === "type" || s.importKind === "typeof") || s.type === "ExportNamedDeclaration" && s.exportKind === "type" || s.type === "ExportAllDeclaration" && s.exportKind === "type" || super.assertModuleNodeAllowed(s);
    }
    parseExportDeclaration(s) {
      if (this.isContextual(130)) {
        s.exportKind = "type";
        const o = this.startNode();
        return this.next(), this.match(5) ? (s.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(s), null) : this.flowParseTypeAlias(o);
      } else if (this.isContextual(131)) {
        s.exportKind = "type";
        const o = this.startNode();
        return this.next(), this.flowParseOpaqueType(o, !1);
      } else if (this.isContextual(129)) {
        s.exportKind = "type";
        const o = this.startNode();
        return this.next(), this.flowParseInterface(o);
      } else if (this.isContextual(126)) {
        s.exportKind = "value";
        const o = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(o);
      } else
        return super.parseExportDeclaration(s);
    }
    eatExportStar(s) {
      return super.eatExportStar(s) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (s.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(s) {
      const {
        startLoc: o
      } = this.state, f = super.maybeParseExportNamespaceSpecifier(s);
      return f && s.exportKind === "type" && this.unexpected(o), f;
    }
    parseClassId(s, o, f) {
      super.parseClassId(s, o, f), this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(s, o, f) {
      const {
        startLoc: b
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(s, o))
          return;
        o.declare = !0;
      }
      super.parseClassMember(s, o, f), o.declare && (o.type !== "ClassProperty" && o.type !== "ClassPrivateProperty" && o.type !== "PropertyDefinition" ? this.raise(fe.DeclareClassElement, b) : o.value && this.raise(fe.DeclareClassFieldInitializer, o.value));
    }
    isIterator(s) {
      return s === "iterator" || s === "asyncIterator";
    }
    readIterator() {
      const s = super.readWord1(), o = "@@" + s;
      (!this.isIterator(s) || !this.state.inType) && this.raise(v.InvalidIdentifier, this.state.curPosition(), {
        identifierName: o
      }), this.finishToken(132, o);
    }
    getTokenFromCode(s) {
      const o = this.input.charCodeAt(this.state.pos + 1);
      s === 123 && o === 124 ? this.finishOp(6, 2) : this.state.inType && (s === 62 || s === 60) ? this.finishOp(s === 62 ? 48 : 47, 1) : this.state.inType && s === 63 ? o === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : ly(s, o, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(s);
    }
    isAssignable(s, o) {
      return s.type === "TypeCastExpression" ? this.isAssignable(s.expression, o) : super.isAssignable(s, o);
    }
    toAssignable(s, o = !1) {
      !o && s.type === "AssignmentExpression" && s.left.type === "TypeCastExpression" && (s.left = this.typeCastToParameter(s.left)), super.toAssignable(s, o);
    }
    toAssignableList(s, o, f) {
      for (let b = 0; b < s.length; b++) {
        const w = s[b];
        (w == null ? void 0 : w.type) === "TypeCastExpression" && (s[b] = this.typeCastToParameter(w));
      }
      super.toAssignableList(s, o, f);
    }
    toReferencedList(s, o) {
      for (let b = 0; b < s.length; b++) {
        var f;
        const w = s[b];
        w && w.type === "TypeCastExpression" && !((f = w.extra) != null && f.parenthesized) && (s.length > 1 || !o) && this.raise(fe.TypeCastInPattern, w.typeAnnotation);
      }
      return s;
    }
    parseArrayLike(s, o, f, b) {
      const w = super.parseArrayLike(s, o, f, b);
      return o && !this.state.maybeInArrowParameters && this.toReferencedList(w.elements), w;
    }
    isValidLVal(s, o, f) {
      return s === "TypeCastExpression" || super.isValidLVal(s, o, f);
    }
    parseClassProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(s) {
      return !this.match(14) && super.isNonstaticConstructor(s);
    }
    pushClassMethod(s, o, f, b, w, C) {
      if (o.variance && this.unexpected(o.variance.loc.start), delete o.variance, this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(s, o, f, b, w, C), o.params && w) {
        const D = o.params;
        D.length > 0 && this.isThisParam(D[0]) && this.raise(fe.ThisParamBannedInConstructor, o);
      } else if (o.type === "MethodDefinition" && w && o.value.params) {
        const D = o.value.params;
        D.length > 0 && this.isThisParam(D[0]) && this.raise(fe.ThisParamBannedInConstructor, o);
      }
    }
    pushClassPrivateMethod(s, o, f, b) {
      o.variance && this.unexpected(o.variance.loc.start), delete o.variance, this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(s, o, f, b);
    }
    parseClassSuper(s) {
      if (super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
        this.next();
        const o = s.implements = [];
        do {
          const f = this.startNode();
          f.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? f.typeParameters = this.flowParseTypeParameterInstantiation() : f.typeParameters = null, o.push(this.finishNode(f, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(s) {
      super.checkGetterSetterParams(s);
      const o = this.getObjectOrClassMethodParams(s);
      if (o.length > 0) {
        const f = o[0];
        this.isThisParam(f) && s.kind === "get" ? this.raise(fe.GetterMayNotHaveThisParam, f) : this.isThisParam(f) && this.raise(fe.SetterMayNotHaveThisParam, f);
      }
    }
    parsePropertyNamePrefixOperator(s) {
      s.variance = this.flowParseVariance();
    }
    parseObjPropValue(s, o, f, b, w, C, D) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance;
      let F;
      this.match(47) && !C && (F = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const $ = super.parseObjPropValue(s, o, f, b, w, C, D);
      return F && (($.value || $).typeParameters = F), $;
    }
    parseFunctionParamType(s) {
      return this.eat(17) && (s.type !== "Identifier" && this.raise(fe.PatternIsOptional, s), this.isThisParam(s) && this.raise(fe.ThisParamMayNotBeOptional, s), s.optional = !0), this.match(14) ? s.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(s) && this.raise(fe.ThisParamAnnotationRequired, s), this.match(29) && this.isThisParam(s) && this.raise(fe.ThisParamNoDefault, s), this.resetEndLocation(s), s;
    }
    parseMaybeDefault(s, o) {
      const f = super.parseMaybeDefault(s, o);
      return f.type === "AssignmentPattern" && f.typeAnnotation && f.right.start < f.typeAnnotation.start && this.raise(fe.TypeBeforeInitializer, f.typeAnnotation), f;
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(fe.ImportReflectionHasImportType, s.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(s, o, f) {
      o.local = gc(s) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), s.specifiers.push(this.finishImportSpecifier(o, f));
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        if (!s) return !0;
        const o = this.lookaheadCharCode();
        return o === 123 || o === 42;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, o, f, b) {
      if (super.applyImportPhase(s, o, f, b), o) {
        if (!f && this.match(65))
          return;
        s.exportKind = f === "type" ? f : "value";
      } else
        f === "type" && this.match(55) && this.unexpected(), s.importKind = f === "type" || f === "typeof" ? f : "value";
    }
    parseImportSpecifier(s, o, f, b, w) {
      const C = s.imported;
      let D = null;
      C.type === "Identifier" && (C.name === "type" ? D = "type" : C.name === "typeof" && (D = "typeof"));
      let F = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const q = this.parseIdentifier(!0);
        D !== null && !le(this.state.type) ? (s.imported = q, s.importKind = D, s.local = this.cloneIdentifier(q)) : (s.imported = C, s.importKind = null, s.local = this.parseIdentifier());
      } else {
        if (D !== null && le(this.state.type))
          s.imported = this.parseIdentifier(!0), s.importKind = D;
        else {
          if (o)
            throw this.raise(v.ImportBindingIsString, s, {
              importName: C.value
            });
          s.imported = C, s.importKind = null;
        }
        this.eatContextual(93) ? s.local = this.parseIdentifier() : (F = !0, s.local = this.cloneIdentifier(s.imported));
      }
      const $ = gc(s);
      return f && $ && this.raise(fe.ImportTypeShorthandOnlyInPureImport, s), (f || $) && this.checkReservedType(s.local.name, s.local.loc.start, !0), F && !f && !$ && this.checkReservedWord(s.local.name, s.loc.start, !0, !0), this.finishImportSpecifier(s, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(s, o) {
      const f = s.kind;
      f !== "get" && f !== "set" && this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(s, o);
    }
    parseVarId(s, o) {
      super.parseVarId(s, o), this.match(14) && (s.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, o) {
      if (this.match(14)) {
        const f = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, s.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = f;
      }
      return super.parseAsyncArrowFromCallExpression(s, o);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(s, o) {
      var f;
      let b = null, w;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (b = this.state.clone(), w = this.tryParse(() => super.parseMaybeAssign(s, o), b), !w.error) return w.node;
        const {
          context: F
        } = this.state, $ = F[F.length - 1];
        ($ === I.j_oTag || $ === I.j_expr) && F.pop();
      }
      if ((f = w) != null && f.error || this.match(47)) {
        var C, D;
        b = b || this.state.clone();
        let F;
        const $ = this.tryParse((J) => {
          var ee;
          F = this.flowParseTypeParameterDeclaration();
          const oe = this.forwardNoArrowParamsConversionAt(F, () => {
            const Re = super.parseMaybeAssign(s, o);
            return this.resetStartLocationFromNode(Re, F), Re;
          });
          (ee = oe.extra) != null && ee.parenthesized && J();
          const me = this.maybeUnwrapTypeCastExpression(oe);
          return me.type !== "ArrowFunctionExpression" && J(), me.typeParameters = F, this.resetStartLocationFromNode(me, F), oe;
        }, b);
        let q = null;
        if ($.node && this.maybeUnwrapTypeCastExpression($.node).type === "ArrowFunctionExpression") {
          if (!$.error && !$.aborted)
            return $.node.async && this.raise(fe.UnexpectedTypeParameterBeforeAsyncArrowFunction, F), $.node;
          q = $.node;
        }
        if ((C = w) != null && C.node)
          return this.state = w.failState, w.node;
        if (q)
          return this.state = $.failState, q;
        throw (D = w) != null && D.thrown ? w.error : $.thrown ? $.error : this.raise(fe.UnexpectedTokenAfterTypeParameter, F);
      }
      return super.parseMaybeAssign(s, o);
    }
    parseArrow(s) {
      if (this.match(14)) {
        const o = this.tryParse(() => {
          const f = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const b = this.startNode();
          return [b.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = f, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), b;
        });
        if (o.thrown) return null;
        o.error && (this.state = o.failState), s.returnType = o.node.typeAnnotation ? this.finishNode(o.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(s);
    }
    shouldParseArrow(s) {
      return this.match(14) || super.shouldParseArrow(s);
    }
    setArrowFunctionParameters(s, o) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? s.params = o : super.setArrowFunctionParameters(s, o);
    }
    checkParams(s, o, f, b = !0) {
      if (!(f && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)))) {
        for (let w = 0; w < s.params.length; w++)
          this.isThisParam(s.params[w]) && w > 0 && this.raise(fe.ThisParamMustBeFirst, s.params[w]);
        super.checkParams(s, o, f, b);
      }
    }
    parseParenAndDistinguishExpression(s) {
      return super.parseParenAndDistinguishExpression(s && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(s, o, f) {
      if (s.type === "Identifier" && s.name === "async" && this.state.noArrowAt.includes(o.index)) {
        this.next();
        const b = this.startNodeAt(o);
        b.callee = s, b.arguments = super.parseCallExpressionArguments(), s = this.finishNode(b, "CallExpression");
      } else if (s.type === "Identifier" && s.name === "async" && this.match(47)) {
        const b = this.state.clone(), w = this.tryParse((D) => this.parseAsyncArrowWithTypeParameters(o) || D(), b);
        if (!w.error && !w.aborted) return w.node;
        const C = this.tryParse(() => super.parseSubscripts(s, o, f), b);
        if (C.node && !C.error) return C.node;
        if (w.node)
          return this.state = w.failState, w.node;
        if (C.node)
          return this.state = C.failState, C.node;
        throw w.error || C.error;
      }
      return super.parseSubscripts(s, o, f);
    }
    parseSubscript(s, o, f, b) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (b.optionalChainMember = !0, f)
          return b.stop = !0, s;
        this.next();
        const w = this.startNodeAt(o);
        return w.callee = s, w.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), w.arguments = this.parseCallExpressionArguments(), w.optional = !0, this.finishCallExpression(w, !0);
      } else if (!f && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        const w = this.startNodeAt(o);
        w.callee = s;
        const C = this.tryParse(() => (w.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), w.arguments = super.parseCallExpressionArguments(), b.optionalChainMember && (w.optional = !1), this.finishCallExpression(w, b.optionalChainMember)));
        if (C.node)
          return C.error && (this.state = C.failState), C.node;
      }
      return super.parseSubscript(s, o, f, b);
    }
    parseNewCallee(s) {
      super.parseNewCallee(s);
      let o = null;
      this.shouldParseTypes() && this.match(47) && (o = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), s.typeArguments = o;
    }
    parseAsyncArrowWithTypeParameters(s) {
      const o = this.startNodeAt(s);
      if (this.parseFunctionParams(o, !1), !!this.parseArrow(o))
        return super.parseArrowExpression(o, void 0, !0);
    }
    readToken_mult_modulo(s) {
      const o = this.input.charCodeAt(this.state.pos + 1);
      if (s === 42 && o === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(s);
    }
    readToken_pipe_amp(s) {
      const o = this.input.charCodeAt(this.state.pos + 1);
      if (s === 124 && o === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(s);
    }
    parseTopLevel(s, o) {
      const f = super.parseTopLevel(s, o);
      return this.state.hasFlowComment && this.raise(fe.UnterminatedFlowComment, this.state.curPosition()), f;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(fe.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const s = this.skipFlowComment();
        s && (this.state.pos += s, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos: s
      } = this.state;
      let o = 2;
      for (; [32, 9].includes(this.input.charCodeAt(s + o)); )
        o++;
      const f = this.input.charCodeAt(o + s), b = this.input.charCodeAt(o + s + 1);
      return f === 58 && b === 58 ? o + 2 : this.input.slice(o + s, o + s + 12) === "flow-include" ? o + 12 : f === 58 && b !== 58 ? o : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(v.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(s, {
      enumName: o,
      memberName: f
    }) {
      this.raise(fe.EnumBooleanMemberNotInitialized, s, {
        memberName: f,
        enumName: o
      });
    }
    flowEnumErrorInvalidMemberInitializer(s, o) {
      return this.raise(o.explicitType ? o.explicitType === "symbol" ? fe.EnumInvalidMemberInitializerSymbolType : fe.EnumInvalidMemberInitializerPrimaryType : fe.EnumInvalidMemberInitializerUnknownType, s, o);
    }
    flowEnumErrorNumberMemberNotInitialized(s, o) {
      this.raise(fe.EnumNumberMemberNotInitialized, s, o);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(s, o) {
      this.raise(fe.EnumStringMemberInconsistentlyInitialized, s, o);
    }
    flowEnumMemberInit() {
      const s = this.state.startLoc, o = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          const f = this.parseNumericLiteral(this.state.value);
          return o() ? {
            type: "number",
            loc: f.loc.start,
            value: f
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 134: {
          const f = this.parseStringLiteral(this.state.value);
          return o() ? {
            type: "string",
            loc: f.loc.start,
            value: f
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 85:
        case 86: {
          const f = this.parseBooleanLiteral(this.match(85));
          return o() ? {
            type: "boolean",
            loc: f.loc.start,
            value: f
          } : {
            type: "invalid",
            loc: s
          };
        }
        default:
          return {
            type: "invalid",
            loc: s
          };
      }
    }
    flowEnumMemberRaw() {
      const s = this.state.startLoc, o = this.parseIdentifier(!0), f = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: s
      };
      return {
        id: o,
        init: f
      };
    }
    flowEnumCheckExplicitTypeMismatch(s, o, f) {
      const {
        explicitType: b
      } = o;
      b !== null && b !== f && this.flowEnumErrorInvalidMemberInitializer(s, o);
    }
    flowEnumMembers({
      enumName: s,
      explicitType: o
    }) {
      const f = /* @__PURE__ */ new Set(), b = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let w = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          w = !0;
          break;
        }
        const C = this.startNode(), {
          id: D,
          init: F
        } = this.flowEnumMemberRaw(), $ = D.name;
        if ($ === "")
          continue;
        /^[a-z]/.test($) && this.raise(fe.EnumInvalidMemberName, D, {
          memberName: $,
          suggestion: $[0].toUpperCase() + $.slice(1),
          enumName: s
        }), f.has($) && this.raise(fe.EnumDuplicateMemberName, D, {
          memberName: $,
          enumName: s
        }), f.add($);
        const q = {
          enumName: s,
          explicitType: o,
          memberName: $
        };
        switch (C.id = D, F.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(F.loc, q, "boolean"), C.init = F.value, b.booleanMembers.push(this.finishNode(C, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(F.loc, q, "number"), C.init = F.value, b.numberMembers.push(this.finishNode(C, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(F.loc, q, "string"), C.init = F.value, b.stringMembers.push(this.finishNode(C, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(F.loc, q);
          case "none":
            switch (o) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(F.loc, q);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(F.loc, q);
                break;
              default:
                b.defaultedMembers.push(this.finishNode(C, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: b,
        hasUnknownMembers: w
      };
    }
    flowEnumStringMembers(s, o, {
      enumName: f
    }) {
      if (s.length === 0)
        return o;
      if (o.length === 0)
        return s;
      if (o.length > s.length) {
        for (const b of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(b, {
            enumName: f
          });
        return o;
      } else {
        for (const b of o)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(b, {
            enumName: f
          });
        return s;
      }
    }
    flowEnumParseExplicitType({
      enumName: s
    }) {
      if (!this.eatContextual(102)) return null;
      if (!Q(this.state.type))
        throw this.raise(fe.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: s
        });
      const {
        value: o
      } = this.state;
      return this.next(), o !== "boolean" && o !== "number" && o !== "string" && o !== "symbol" && this.raise(fe.EnumInvalidExplicitType, this.state.startLoc, {
        enumName: s,
        invalidEnumType: o
      }), o;
    }
    flowEnumBody(s, o) {
      const f = o.name, b = o.loc.start, w = this.flowEnumParseExplicitType({
        enumName: f
      });
      this.expect(5);
      const {
        members: C,
        hasUnknownMembers: D
      } = this.flowEnumMembers({
        enumName: f,
        explicitType: w
      });
      switch (s.hasUnknownMembers = D, w) {
        case "boolean":
          return s.explicitType = !0, s.members = C.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
        case "number":
          return s.explicitType = !0, s.members = C.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
        case "string":
          return s.explicitType = !0, s.members = this.flowEnumStringMembers(C.stringMembers, C.defaultedMembers, {
            enumName: f
          }), this.expect(8), this.finishNode(s, "EnumStringBody");
        case "symbol":
          return s.members = C.defaultedMembers, this.expect(8), this.finishNode(s, "EnumSymbolBody");
        default: {
          const F = () => (s.members = [], this.expect(8), this.finishNode(s, "EnumStringBody"));
          s.explicitType = !1;
          const $ = C.booleanMembers.length, q = C.numberMembers.length, J = C.stringMembers.length, ee = C.defaultedMembers.length;
          if (!$ && !q && !J && !ee)
            return F();
          if (!$ && !q)
            return s.members = this.flowEnumStringMembers(C.stringMembers, C.defaultedMembers, {
              enumName: f
            }), this.expect(8), this.finishNode(s, "EnumStringBody");
          if (!q && !J && $ >= ee) {
            for (const oe of C.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(oe.loc.start, {
                enumName: f,
                memberName: oe.id.name
              });
            return s.members = C.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
          } else if (!$ && !J && q >= ee) {
            for (const oe of C.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(oe.loc.start, {
                enumName: f,
                memberName: oe.id.name
              });
            return s.members = C.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
          } else
            return this.raise(fe.EnumInconsistentMemberValues, b, {
              enumName: f
            }), F();
        }
      }
    }
    flowParseEnumDeclaration(s) {
      const o = this.parseIdentifier();
      return s.id = o, s.body = this.flowEnumBody(this.startNode(), o), this.finishNode(s, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(s) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (s.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(s);
    }
    isLookaheadToken_lt() {
      const s = this.nextTokenStart();
      if (this.input.charCodeAt(s) === 60) {
        const o = this.input.charCodeAt(s + 1);
        return o !== 60 && o !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      const {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    maybeUnwrapTypeCastExpression(s) {
      return s.type === "TypeCastExpression" ? s.expression : s;
    }
  };
  const vy = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, xy = /\r\n|[\r\n\u2028\u2029]/, pi = new RegExp(xy.source, "g");
  function zr(T) {
    switch (T) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  function bc(T, a, s) {
    for (let o = a; o < s; o++)
      if (zr(T.charCodeAt(o)))
        return !0;
    return !1;
  }
  const Ra = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Da = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function Ey(T) {
    switch (T) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  const yr = x`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName: T
    }) => `Expected corresponding JSX closing tag for <${T}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected: T,
      HTMLEntity: a
    }) => `Unexpected token \`${T}\`. Did you mean \`${a}\` or \`{'${T}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Zt(T) {
    return T ? T.type === "JSXOpeningFragment" || T.type === "JSXClosingFragment" : !1;
  }
  function Wr(T) {
    if (T.type === "JSXIdentifier")
      return T.name;
    if (T.type === "JSXNamespacedName")
      return T.namespace.name + ":" + T.name.name;
    if (T.type === "JSXMemberExpression")
      return Wr(T.object) + "." + Wr(T.property);
    throw new Error("Node had unexpected type: " + T.type);
  }
  var Ty = (T) => class extends T {
    jsxReadToken() {
      let s = "", o = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(yr.UnterminatedJsxContent, this.state.startLoc);
        const f = this.input.charCodeAt(this.state.pos);
        switch (f) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              f === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(f);
              return;
            }
            s += this.input.slice(o, this.state.pos), this.finishToken(142, s);
            return;
          case 38:
            s += this.input.slice(o, this.state.pos), s += this.jsxReadEntity(), o = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            zr(f) ? (s += this.input.slice(o, this.state.pos), s += this.jsxReadNewLine(!0), o = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(s) {
      const o = this.input.charCodeAt(this.state.pos);
      let f;
      return ++this.state.pos, o === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, f = s ? `
` : `\r
`) : f = String.fromCharCode(o), ++this.state.curLine, this.state.lineStart = this.state.pos, f;
    }
    jsxReadString(s) {
      let o = "", f = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(v.UnterminatedString, this.state.startLoc);
        const b = this.input.charCodeAt(this.state.pos);
        if (b === s) break;
        b === 38 ? (o += this.input.slice(f, this.state.pos), o += this.jsxReadEntity(), f = this.state.pos) : zr(b) ? (o += this.input.slice(f, this.state.pos), o += this.jsxReadNewLine(!1), f = this.state.pos) : ++this.state.pos;
      }
      o += this.input.slice(f, this.state.pos++), this.finishToken(134, o);
    }
    jsxReadEntity() {
      const s = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let o = 10;
        this.codePointAtPos(this.state.pos) === 120 && (o = 16, ++this.state.pos);
        const f = this.readInt(o, void 0, !1, "bail");
        if (f !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(f);
      } else {
        let o = 0, f = !1;
        for (; o++ < 10 && this.state.pos < this.length && !(f = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (f) {
          const b = this.input.slice(s, this.state.pos), w = vy[b];
          if (++this.state.pos, w)
            return w;
        }
      }
      return this.state.pos = s, "&";
    }
    jsxReadWord() {
      let s;
      const o = this.state.pos;
      do
        s = this.input.charCodeAt(++this.state.pos);
      while (Vr(s) || s === 45);
      this.finishToken(141, this.input.slice(o, this.state.pos));
    }
    jsxParseIdentifier() {
      const s = this.startNode();
      return this.match(141) ? s.name = this.state.value : Be(this.state.type) ? s.name = nt(this.state.type) : this.unexpected(), this.next(), this.finishNode(s, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const s = this.state.startLoc, o = this.jsxParseIdentifier();
      if (!this.eat(14)) return o;
      const f = this.startNodeAt(s);
      return f.namespace = o, f.name = this.jsxParseIdentifier(), this.finishNode(f, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const s = this.state.startLoc;
      let o = this.jsxParseNamespacedName();
      if (o.type === "JSXNamespacedName")
        return o;
      for (; this.eat(16); ) {
        const f = this.startNodeAt(s);
        f.object = o, f.property = this.jsxParseIdentifier(), o = this.finishNode(f, "JSXMemberExpression");
      }
      return o;
    }
    jsxParseAttributeValue() {
      let s;
      switch (this.state.type) {
        case 5:
          return s = this.startNode(), this.setContext(I.brace), this.next(), s = this.jsxParseExpressionContainer(s, I.j_oTag), s.expression.type === "JSXEmptyExpression" && this.raise(yr.AttributeIsEmpty, s), s;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(yr.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const s = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(s, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(s) {
      return this.next(), s.expression = this.parseExpression(), this.setContext(I.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(s, o) {
      if (this.match(8))
        s.expression = this.jsxParseEmptyExpression();
      else {
        const f = this.parseExpression();
        s.expression = f;
      }
      return this.setContext(o), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const s = this.startNode();
      return this.match(5) ? (this.setContext(I.brace), this.next(), this.expect(21), s.argument = this.parseMaybeAssignAllowIn(), this.setContext(I.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadAttribute")) : (s.name = this.jsxParseNamespacedName(), s.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(s, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(s) {
      const o = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(o, "JSXOpeningFragment") : (o.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(o));
    }
    jsxParseOpeningElementAfterName(s) {
      const o = [];
      for (; !this.match(56) && !this.match(144); )
        o.push(this.jsxParseAttribute());
      return s.attributes = o, s.selfClosing = this.eat(56), this.expect(144), this.finishNode(s, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(s) {
      const o = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(o, "JSXClosingFragment") : (o.name = this.jsxParseElementName(), this.expect(144), this.finishNode(o, "JSXClosingElement"));
    }
    jsxParseElementAt(s) {
      const o = this.startNodeAt(s), f = [], b = this.jsxParseOpeningElementAt(s);
      let w = null;
      if (!b.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (s = this.state.startLoc, this.next(), this.eat(56)) {
                w = this.jsxParseClosingElementAt(s);
                break e;
              }
              f.push(this.jsxParseElementAt(s));
              break;
            case 142:
              f.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              const C = this.startNode();
              this.setContext(I.brace), this.next(), this.match(21) ? f.push(this.jsxParseSpreadChild(C)) : f.push(this.jsxParseExpressionContainer(C, I.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Zt(b) && !Zt(w) && w !== null ? this.raise(yr.MissingClosingTagFragment, w) : !Zt(b) && Zt(w) ? this.raise(yr.MissingClosingTagElement, w, {
          openingTagName: Wr(b.name)
        }) : !Zt(b) && !Zt(w) && Wr(w.name) !== Wr(b.name) && this.raise(yr.MissingClosingTagElement, w, {
          openingTagName: Wr(b.name)
        });
      }
      if (Zt(b) ? (o.openingFragment = b, o.closingFragment = w) : (o.openingElement = b, o.closingElement = w), o.children = f, this.match(47))
        throw this.raise(yr.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Zt(b) ? this.finishNode(o, "JSXFragment") : this.finishNode(o, "JSXElement");
    }
    jsxParseElement() {
      const s = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(s);
    }
    setContext(s) {
      const {
        context: o
      } = this.state;
      o[o.length - 1] = s;
    }
    parseExprAtom(s) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(s);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(s) {
      const o = this.curContext();
      if (o === I.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (o === I.j_oTag || o === I.j_cTag) {
        if (jt(s)) {
          this.jsxReadWord();
          return;
        }
        if (s === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((s === 34 || s === 39) && o === I.j_oTag) {
          this.jsxReadString(s);
          return;
        }
      }
      if (s === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(s);
    }
    updateContext(s) {
      const {
        context: o,
        type: f
      } = this.state;
      if (f === 56 && s === 143)
        o.splice(-2, 2, I.j_cTag), this.state.canStartJSXElement = !1;
      else if (f === 143)
        o.push(I.j_oTag);
      else if (f === 144) {
        const b = o[o.length - 1];
        b === I.j_oTag && s === 56 || b === I.j_cTag ? (o.pop(), this.state.canStartJSXElement = o[o.length - 1] === I.j_expr) : (this.setContext(I.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = de(f);
    }
  };
  class wy extends ka {
    constructor(...a) {
      super(...a), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class Py extends La {
    constructor(...a) {
      super(...a), this.importsStack = [];
    }
    createScope(a) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new wy(a);
    }
    enter(a) {
      a === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(a);
    }
    exit() {
      const a = super.exit();
      return a === 1024 && this.importsStack.pop(), a;
    }
    hasImport(a, s) {
      const o = this.importsStack.length;
      if (this.importsStack[o - 1].has(a))
        return !0;
      if (!s && o > 1) {
        for (let f = 0; f < o - 1; f++)
          if (this.importsStack[f].has(a)) return !0;
      }
      return !1;
    }
    declareName(a, s, o) {
      if (s & 4096) {
        this.hasImport(a, !0) && this.parser.raise(v.VarRedeclaration, o, {
          identifierName: a
        }), this.importsStack[this.importsStack.length - 1].add(a);
        return;
      }
      const f = this.currentScope();
      let b = f.tsNames.get(a) || 0;
      if (s & 1024) {
        this.maybeExportDefined(f, a), f.tsNames.set(a, b | 16);
        return;
      }
      super.declareName(a, s, o), s & 2 && (s & 1 || (this.checkRedeclarationInScope(f, a, s, o), this.maybeExportDefined(f, a)), b = b | 1), s & 256 && (b = b | 2), s & 512 && (b = b | 4), s & 128 && (b = b | 8), b && f.tsNames.set(a, b);
    }
    isRedeclaredInScope(a, s, o) {
      const f = a.tsNames.get(s);
      if ((f & 2) > 0) {
        if (o & 256) {
          const b = !!(o & 512), w = (f & 4) > 0;
          return b !== w;
        }
        return !0;
      }
      return o & 128 && (f & 8) > 0 ? a.names.get(s) & 2 ? !!(o & 1) : !1 : o & 2 && (f & 1) > 0 ? !0 : super.isRedeclaredInScope(a, s, o);
    }
    checkLocalExport(a) {
      const {
        name: s
      } = a;
      if (this.hasImport(s)) return;
      const o = this.scopeStack.length;
      for (let f = o - 1; f >= 0; f--) {
        const w = this.scopeStack[f].tsNames.get(s);
        if ((w & 1) > 0 || (w & 16) > 0)
          return;
      }
      super.checkLocalExport(a);
    }
  }
  class _y {
    constructor() {
      this.stacks = [];
    }
    enter(a) {
      this.stacks.push(a);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }
  function di(T, a) {
    return (T ? 2 : 0) | (a ? 1 : 0);
  }
  class Ay {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(a) {
      return a + this.startIndex;
    }
    offsetToSourcePos(a) {
      return a - this.startIndex;
    }
    hasPlugin(a) {
      if (typeof a == "string")
        return this.plugins.has(a);
      {
        const [s, o] = a;
        if (!this.hasPlugin(s))
          return !1;
        const f = this.plugins.get(s);
        for (const b of Object.keys(o))
          if ((f == null ? void 0 : f[b]) !== o[b])
            return !1;
        return !0;
      }
    }
    getPluginOption(a, s) {
      var o;
      return (o = this.plugins.get(a)) == null ? void 0 : o[s];
    }
  }
  function Sc(T, a) {
    T.trailingComments === void 0 ? T.trailingComments = a : T.trailingComments.unshift(...a);
  }
  function Cy(T, a) {
    T.leadingComments === void 0 ? T.leadingComments = a : T.leadingComments.unshift(...a);
  }
  function vs(T, a) {
    T.innerComments === void 0 ? T.innerComments = a : T.innerComments.unshift(...a);
  }
  function er(T, a, s) {
    let o = null, f = a.length;
    for (; o === null && f > 0; )
      o = a[--f];
    o === null || o.start > s.start ? vs(T, s.comments) : Sc(o, s.comments);
  }
  class Iy extends Ay {
    addComment(a) {
      this.filename && (a.loc.filename = this.filename);
      const {
        commentsLen: s
      } = this.state;
      this.comments.length !== s && (this.comments.length = s), this.comments.push(a), this.state.commentsLen++;
    }
    processComment(a) {
      const {
        commentStack: s
      } = this.state, o = s.length;
      if (o === 0) return;
      let f = o - 1;
      const b = s[f];
      b.start === a.end && (b.leadingNode = a, f--);
      const {
        start: w
      } = a;
      for (; f >= 0; f--) {
        const C = s[f], D = C.end;
        if (D > w)
          C.containingNode = a, this.finalizeComment(C), s.splice(f, 1);
        else {
          D === w && (C.trailingNode = a);
          break;
        }
      }
    }
    finalizeComment(a) {
      var s;
      const {
        comments: o
      } = a;
      if (a.leadingNode !== null || a.trailingNode !== null)
        a.leadingNode !== null && Sc(a.leadingNode, o), a.trailingNode !== null && Cy(a.trailingNode, o);
      else {
        const {
          containingNode: f,
          start: b
        } = a;
        if (this.input.charCodeAt(this.offsetToSourcePos(b) - 1) === 44)
          switch (f.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              er(f, f.properties, a);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              er(f, f.arguments, a);
              break;
            case "ImportExpression":
              er(f, [f.source, (s = f.options) != null ? s : null], a);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              er(f, f.params, a);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              er(f, f.elements, a);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              er(f, f.specifiers, a);
              break;
            case "TSEnumDeclaration":
              er(f, f.members, a);
              break;
            case "TSEnumBody":
              er(f, f.members, a);
              break;
            default:
              vs(f, o);
          }
        else
          vs(f, o);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: a
      } = this.state;
      for (let s = a.length - 1; s >= 0; s--)
        this.finalizeComment(a[s]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(a) {
      const {
        commentStack: s
      } = this.state, {
        length: o
      } = s;
      if (o === 0) return;
      const f = s[o - 1];
      f.leadingNode === a && (f.leadingNode = null);
    }
    takeSurroundingComments(a, s, o) {
      const {
        commentStack: f
      } = this.state, b = f.length;
      if (b === 0) return;
      let w = b - 1;
      for (; w >= 0; w--) {
        const C = f[w], D = C.end;
        if (C.start === o)
          C.leadingNode = a;
        else if (D === s)
          C.trailingNode = a;
        else if (D < s)
          break;
      }
    }
  }
  class Ma {
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [I.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(a) {
      a ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: a,
      sourceType: s,
      startIndex: o,
      startLine: f,
      startColumn: b
    }) {
      this.strict = a === !1 ? !1 : a === !0 ? !0 : s === "module", this.startIndex = o, this.curLine = f, this.lineStart = -b, this.startLoc = this.endLoc = new e(f, b, o);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(a) {
      a ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(a) {
      a ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(a) {
      a ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(a) {
      a ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(a) {
      a ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(a) {
      a ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(a) {
      a ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(a) {
      a ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(a) {
      a ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(a) {
      a ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(a) {
      a ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(a) {
      a ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new e(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      const a = new Ma();
      return a.flags = this.flags, a.startIndex = this.startIndex, a.curLine = this.curLine, a.lineStart = this.lineStart, a.startLoc = this.startLoc, a.endLoc = this.endLoc, a.errors = this.errors.slice(), a.potentialArrowAt = this.potentialArrowAt, a.noArrowAt = this.noArrowAt.slice(), a.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), a.topicContext = this.topicContext, a.labels = this.labels.slice(), a.commentsLen = this.commentsLen, a.commentStack = this.commentStack.slice(), a.pos = this.pos, a.type = this.type, a.value = this.value, a.start = this.start, a.end = this.end, a.lastTokEndLoc = this.lastTokEndLoc, a.lastTokStartLoc = this.lastTokStartLoc, a.context = this.context.slice(), a.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, a.strictErrors = this.strictErrors, a.tokensLength = this.tokensLength, a;
    }
  }
  var Ny = function(a) {
    return a >= 48 && a <= 57;
  };
  const vc = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, mi = {
    bin: (T) => T === 48 || T === 49,
    oct: (T) => T >= 48 && T <= 55,
    dec: (T) => T >= 48 && T <= 57,
    hex: (T) => T >= 48 && T <= 57 || T >= 65 && T <= 70 || T >= 97 && T <= 102
  };
  function xc(T, a, s, o, f, b) {
    const w = s, C = o, D = f;
    let F = "", $ = null, q = s;
    const {
      length: J
    } = a;
    for (; ; ) {
      if (s >= J) {
        b.unterminated(w, C, D), F += a.slice(q, s);
        break;
      }
      const ee = a.charCodeAt(s);
      if (Oy(T, ee, a, s)) {
        F += a.slice(q, s);
        break;
      }
      if (ee === 92) {
        F += a.slice(q, s);
        const oe = ky(a, s, o, f, T === "template", b);
        oe.ch === null && !$ ? $ = {
          pos: s,
          lineStart: o,
          curLine: f
        } : F += oe.ch, {
          pos: s,
          lineStart: o,
          curLine: f
        } = oe, q = s;
      } else ee === 8232 || ee === 8233 ? (++s, ++f, o = s) : ee === 10 || ee === 13 ? T === "template" ? (F += a.slice(q, s) + `
`, ++s, ee === 13 && a.charCodeAt(s) === 10 && ++s, ++f, q = o = s) : b.unterminated(w, C, D) : ++s;
    }
    return {
      pos: s,
      str: F,
      firstInvalidLoc: $,
      lineStart: o,
      curLine: f,
      containsInvalid: !!$
    };
  }
  function Oy(T, a, s, o) {
    return T === "template" ? a === 96 || a === 36 && s.charCodeAt(o + 1) === 123 : a === (T === "double" ? 34 : 39);
  }
  function ky(T, a, s, o, f, b) {
    const w = !f;
    a++;
    const C = (F) => ({
      pos: a,
      ch: F,
      lineStart: s,
      curLine: o
    }), D = T.charCodeAt(a++);
    switch (D) {
      case 110:
        return C(`
`);
      case 114:
        return C("\r");
      case 120: {
        let F;
        return {
          code: F,
          pos: a
        } = Fa(T, a, s, o, 2, !1, w, b), C(F === null ? null : String.fromCharCode(F));
      }
      case 117: {
        let F;
        return {
          code: F,
          pos: a
        } = Tc(T, a, s, o, w, b), C(F === null ? null : String.fromCodePoint(F));
      }
      case 116:
        return C("	");
      case 98:
        return C("\b");
      case 118:
        return C("\v");
      case 102:
        return C("\f");
      case 13:
        T.charCodeAt(a) === 10 && ++a;
      case 10:
        s = a, ++o;
      case 8232:
      case 8233:
        return C("");
      case 56:
      case 57:
        if (f)
          return C(null);
        b.strictNumericEscape(a - 1, s, o);
      default:
        if (D >= 48 && D <= 55) {
          const F = a - 1;
          let q = /^[0-7]+/.exec(T.slice(F, a + 2))[0], J = parseInt(q, 8);
          J > 255 && (q = q.slice(0, -1), J = parseInt(q, 8)), a += q.length - 1;
          const ee = T.charCodeAt(a);
          if (q !== "0" || ee === 56 || ee === 57) {
            if (f)
              return C(null);
            b.strictNumericEscape(F, s, o);
          }
          return C(String.fromCharCode(J));
        }
        return C(String.fromCharCode(D));
    }
  }
  function Fa(T, a, s, o, f, b, w, C) {
    const D = a;
    let F;
    return {
      n: F,
      pos: a
    } = Ec(T, a, s, o, 16, f, b, !1, C, !w), F === null && (w ? C.invalidEscapeSequence(D, s, o) : a = D - 1), {
      code: F,
      pos: a
    };
  }
  function Ec(T, a, s, o, f, b, w, C, D, F) {
    const $ = a, q = f === 16 ? vc.hex : vc.decBinOct, J = f === 16 ? mi.hex : f === 10 ? mi.dec : f === 8 ? mi.oct : mi.bin;
    let ee = !1, oe = 0;
    for (let me = 0, Re = b ?? 1 / 0; me < Re; ++me) {
      const ye = T.charCodeAt(a);
      let _e;
      if (ye === 95 && C !== "bail") {
        const gr = T.charCodeAt(a - 1), rr = T.charCodeAt(a + 1);
        if (C) {
          if (Number.isNaN(rr) || !J(rr) || q.has(gr) || q.has(rr)) {
            if (F) return {
              n: null,
              pos: a
            };
            D.unexpectedNumericSeparator(a, s, o);
          }
        } else {
          if (F) return {
            n: null,
            pos: a
          };
          D.numericSeparatorInEscapeSequence(a, s, o);
        }
        ++a;
        continue;
      }
      if (ye >= 97 ? _e = ye - 97 + 10 : ye >= 65 ? _e = ye - 65 + 10 : Ny(ye) ? _e = ye - 48 : _e = 1 / 0, _e >= f) {
        if (_e <= 9 && F)
          return {
            n: null,
            pos: a
          };
        if (_e <= 9 && D.invalidDigit(a, s, o, f))
          _e = 0;
        else if (w)
          _e = 0, ee = !0;
        else
          break;
      }
      ++a, oe = oe * f + _e;
    }
    return a === $ || b != null && a - $ !== b || ee ? {
      n: null,
      pos: a
    } : {
      n: oe,
      pos: a
    };
  }
  function Tc(T, a, s, o, f, b) {
    const w = T.charCodeAt(a);
    let C;
    if (w === 123) {
      if (++a, {
        code: C,
        pos: a
      } = Fa(T, a, s, o, T.indexOf("}", a) - a, !0, f, b), ++a, C !== null && C > 1114111)
        if (f)
          b.invalidCodePoint(a, s, o);
        else
          return {
            code: null,
            pos: a
          };
    } else
      ({
        code: C,
        pos: a
      } = Fa(T, a, s, o, 4, !1, f, b));
    return {
      code: C,
      pos: a
    };
  }
  function xs(T, a, s) {
    return new e(s, T - a, T);
  }
  const Ly = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class tr {
    constructor(a) {
      const s = a.startIndex || 0;
      this.type = a.type, this.value = a.value, this.start = s + a.start, this.end = s + a.end, this.loc = new r(a.startLoc, a.endLoc);
    }
  }
  class Ry extends Iy {
    constructor(a, s) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: (o, f, b, w) => this.optionFlags & 2048 ? (this.raise(v.InvalidDigit, xs(o, f, b), {
          radix: w
        }), !0) : !1,
        numericSeparatorInEscapeSequence: this.errorBuilder(v.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(v.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(v.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(v.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (o, f, b) => {
          this.recordStrictModeErrors(v.StrictNumericEscape, xs(o, f, b));
        },
        unterminated: (o, f, b) => {
          throw this.raise(v.UnterminatedString, xs(o - 1, f, b));
        }
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(v.StrictNumericEscape),
        unterminated: (o, f, b) => {
          throw this.raise(v.UnterminatedTemplate, xs(o, f, b));
        }
      }), this.state = new Ma(), this.state.init(a), this.input = s, this.length = s.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(a) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(a), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new tr(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(a) {
      return this.match(a) ? (this.next(), !0) : !1;
    }
    match(a) {
      return this.state.type === a;
    }
    createLookaheadState(a) {
      return {
        pos: a.pos,
        value: null,
        type: a.type,
        start: a.start,
        end: a.end,
        context: [this.curContext()],
        inType: a.inType,
        startLoc: a.startLoc,
        lastTokEndLoc: a.lastTokEndLoc,
        curLine: a.curLine,
        lineStart: a.lineStart,
        curPosition: a.curPosition
      };
    }
    lookahead() {
      const a = this.state;
      this.state = this.createLookaheadState(a), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const s = this.state;
      return this.state = a, s;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(a) {
      return Ra.lastIndex = a, Ra.test(this.input) ? Ra.lastIndex : a;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(a) {
      return this.input.charCodeAt(this.nextTokenStartSince(a));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(a) {
      return Da.lastIndex = a, Da.test(this.input) ? Da.lastIndex : a;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(a) {
      let s = this.input.charCodeAt(a);
      if ((s & 64512) === 55296 && ++a < this.input.length) {
        const o = this.input.charCodeAt(a);
        (o & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (o & 1023));
      }
      return s;
    }
    setStrict(a) {
      this.state.strict = a, a && (this.state.strictErrors.forEach(([s, o]) => this.raise(s, o)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(a) {
      let s;
      this.isLookahead || (s = this.state.curPosition());
      const o = this.state.pos, f = this.input.indexOf(a, o + 2);
      if (f === -1)
        throw this.raise(v.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = f + a.length, pi.lastIndex = o + 2; pi.test(this.input) && pi.lastIndex <= f; )
        ++this.state.curLine, this.state.lineStart = pi.lastIndex;
      if (this.isLookahead) return;
      const b = {
        type: "CommentBlock",
        value: this.input.slice(o + 2, f),
        start: this.sourceToOffsetPos(o),
        end: this.sourceToOffsetPos(f + a.length),
        loc: new r(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(b), b;
    }
    skipLineComment(a) {
      const s = this.state.pos;
      let o;
      this.isLookahead || (o = this.state.curPosition());
      let f = this.input.charCodeAt(this.state.pos += a);
      if (this.state.pos < this.length)
        for (; !zr(f) && ++this.state.pos < this.length; )
          f = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const b = this.state.pos, C = {
        type: "CommentLine",
        value: this.input.slice(s + a, b),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(b),
        loc: new r(o, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(C), C;
    }
    skipSpace() {
      const a = this.state.pos, s = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        const o = this.input.charCodeAt(this.state.pos);
        switch (o) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const f = this.skipBlockComment("*/");
                f !== void 0 && (this.addComment(f), s == null || s.push(f));
                break;
              }
              case 47: {
                const f = this.skipLineComment(2);
                f !== void 0 && (this.addComment(f), s == null || s.push(f));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Ey(o))
              ++this.state.pos;
            else if (o === 45 && !this.inModule && this.optionFlags & 8192) {
              const f = this.state.pos;
              if (this.input.charCodeAt(f + 1) === 45 && this.input.charCodeAt(f + 2) === 62 && (a === 0 || this.state.lineStart > a)) {
                const b = this.skipLineComment(3);
                b !== void 0 && (this.addComment(b), s == null || s.push(b));
              } else
                break e;
            } else if (o === 60 && !this.inModule && this.optionFlags & 8192) {
              const f = this.state.pos;
              if (this.input.charCodeAt(f + 1) === 33 && this.input.charCodeAt(f + 2) === 45 && this.input.charCodeAt(f + 3) === 45) {
                const b = this.skipLineComment(4);
                b !== void 0 && (this.addComment(b), s == null || s.push(b));
              } else
                break e;
            } else
              break e;
        }
      }
      if ((s == null ? void 0 : s.length) > 0) {
        const o = this.state.pos, f = {
          start: this.sourceToOffsetPos(a),
          end: this.sourceToOffsetPos(o),
          comments: s,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(f);
      }
    }
    finishToken(a, s) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const o = this.state.type;
      this.state.type = a, this.state.value = s, this.isLookahead || this.updateContext(o);
    }
    replaceToken(a) {
      this.state.type = a, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const a = this.state.pos + 1, s = this.codePointAtPos(a);
      if (s >= 48 && s <= 57)
        throw this.raise(v.UnexpectedDigitAfterHash, this.state.curPosition());
      if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(s === 123 ? v.RecordExpressionHashIncorrectStartSyntaxType : v.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
      } else jt(s) ? (++this.state.pos, this.finishToken(139, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const a = this.input.charCodeAt(this.state.pos + 1);
      if (a >= 48 && a <= 57) {
        this.readNumber(!0);
        return;
      }
      a === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let a = this.input.charCodeAt(this.state.pos + 1);
      if (a !== 33) return !1;
      const s = this.state.pos;
      for (this.state.pos += 1; !zr(a) && ++this.state.pos < this.length; )
        a = this.input.charCodeAt(this.state.pos);
      const o = this.input.slice(s + 2, this.state.pos);
      return this.finishToken(28, o), !0;
    }
    readToken_mult_modulo(a) {
      let s = a === 42 ? 55 : 54, o = 1, f = this.input.charCodeAt(this.state.pos + 1);
      a === 42 && f === 42 && (o++, f = this.input.charCodeAt(this.state.pos + 2), s = 57), f === 61 && !this.state.inType && (o++, s = a === 37 ? 33 : 30), this.finishOp(s, o);
    }
    readToken_pipe_amp(a) {
      const s = this.input.charCodeAt(this.state.pos + 1);
      if (s === a) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(a === 124 ? 41 : 42, 2);
        return;
      }
      if (a === 124) {
        if (s === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(v.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(v.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (s === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(a === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const a = this.input.charCodeAt(this.state.pos + 1);
      a === 61 && !this.state.inType ? this.finishOp(32, 2) : a === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(a) {
      const s = this.input.charCodeAt(this.state.pos + 1);
      if (s === a) {
        this.finishOp(34, 2);
        return;
      }
      s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: a
      } = this.state, s = this.input.charCodeAt(a + 1);
      if (s === 60) {
        if (this.input.charCodeAt(a + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: a
      } = this.state, s = this.input.charCodeAt(a + 1);
      if (s === 62) {
        const o = this.input.charCodeAt(a + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(a + o) === 61) {
          this.finishOp(30, o + 1);
          return;
        }
        this.finishOp(52, o);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(a) {
      const s = this.input.charCodeAt(this.state.pos + 1);
      if (s === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (a === 61 && s === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(a === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const a = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
      a === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : a === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(a) {
      switch (a) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(v.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(v.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const s = this.input.charCodeAt(this.state.pos + 1);
          if (s === 120 || s === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (s === 111 || s === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (s === 98 || s === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(a);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(a);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(a);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(a);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(a);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (jt(a)) {
            this.readWord(a);
            return;
          }
      }
      throw this.raise(v.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(a)
      });
    }
    finishOp(a, s) {
      const o = this.input.slice(this.state.pos, this.state.pos + s);
      this.state.pos += s, this.finishToken(a, o);
    }
    readRegexp() {
      const a = this.state.startLoc, s = this.state.start + 1;
      let o, f, {
        pos: b
      } = this.state;
      for (; ; ++b) {
        if (b >= this.length)
          throw this.raise(v.UnterminatedRegExp, i(a, 1));
        const F = this.input.charCodeAt(b);
        if (zr(F))
          throw this.raise(v.UnterminatedRegExp, i(a, 1));
        if (o)
          o = !1;
        else {
          if (F === 91)
            f = !0;
          else if (F === 93 && f)
            f = !1;
          else if (F === 47 && !f)
            break;
          o = F === 92;
        }
      }
      const w = this.input.slice(s, b);
      ++b;
      let C = "";
      const D = () => i(a, b + 2 - s);
      for (; b < this.length; ) {
        const F = this.codePointAtPos(b), $ = String.fromCharCode(F);
        if (Ly.has(F))
          F === 118 ? C.includes("u") && this.raise(v.IncompatibleRegExpUVFlags, D()) : F === 117 && C.includes("v") && this.raise(v.IncompatibleRegExpUVFlags, D()), C.includes($) && this.raise(v.DuplicateRegExpFlags, D());
        else if (Vr(F) || F === 92)
          this.raise(v.MalformedRegExpFlags, D());
        else
          break;
        ++b, C += $;
      }
      this.state.pos = b, this.finishToken(138, {
        pattern: w,
        flags: C
      });
    }
    readInt(a, s, o = !1, f = !0) {
      const {
        n: b,
        pos: w
      } = Ec(this.input, this.state.pos, this.state.lineStart, this.state.curLine, a, s, o, f, this.errorHandlers_readInt, !1);
      return this.state.pos = w, b;
    }
    readRadixNumber(a) {
      const s = this.state.pos, o = this.state.curPosition();
      let f = !1;
      this.state.pos += 2;
      const b = this.readInt(a);
      b == null && this.raise(v.InvalidDigit, i(o, 2), {
        radix: a
      });
      const w = this.input.charCodeAt(this.state.pos);
      if (w === 110)
        ++this.state.pos, f = !0;
      else if (w === 109)
        throw this.raise(v.InvalidDecimal, o);
      if (jt(this.codePointAtPos(this.state.pos)))
        throw this.raise(v.NumberIdentifier, this.state.curPosition());
      if (f) {
        const C = this.input.slice(s, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, C);
        return;
      }
      this.finishToken(135, b);
    }
    readNumber(a) {
      const s = this.state.pos, o = this.state.curPosition();
      let f = !1, b = !1, w = !1, C = !1;
      !a && this.readInt(10) === null && this.raise(v.InvalidNumber, this.state.curPosition());
      const D = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
      if (D) {
        const ee = this.input.slice(s, this.state.pos);
        if (this.recordStrictModeErrors(v.StrictOctalLiteral, o), !this.state.strict) {
          const oe = ee.indexOf("_");
          oe > 0 && this.raise(v.ZeroDigitNumericSeparator, i(o, oe));
        }
        C = D && !/[89]/.test(ee);
      }
      let F = this.input.charCodeAt(this.state.pos);
      if (F === 46 && !C && (++this.state.pos, this.readInt(10), f = !0, F = this.input.charCodeAt(this.state.pos)), (F === 69 || F === 101) && !C && (F = this.input.charCodeAt(++this.state.pos), (F === 43 || F === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(v.InvalidOrMissingExponent, o), f = !0, w = !0, F = this.input.charCodeAt(this.state.pos)), F === 110 && ((f || D) && this.raise(v.InvalidBigIntLiteral, o), ++this.state.pos, b = !0), F === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (w || D) && this.raise(v.InvalidDecimal, o), ++this.state.pos;
        var $ = !0;
      }
      if (jt(this.codePointAtPos(this.state.pos)))
        throw this.raise(v.NumberIdentifier, this.state.curPosition());
      const q = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
      if (b) {
        this.finishToken(136, q);
        return;
      }
      if ($) {
        this.finishToken(137, q);
        return;
      }
      const J = C ? parseInt(q, 8) : parseFloat(q);
      this.finishToken(135, J);
    }
    readCodePoint(a) {
      const {
        code: s,
        pos: o
      } = Tc(this.input, this.state.pos, this.state.lineStart, this.state.curLine, a, this.errorHandlers_readCodePoint);
      return this.state.pos = o, s;
    }
    readString(a) {
      const {
        str: s,
        pos: o,
        curLine: f,
        lineStart: b
      } = xc(a === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = o + 1, this.state.lineStart = b, this.state.curLine = f, this.finishToken(134, s);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const a = this.input[this.state.pos], {
        str: s,
        firstInvalidLoc: o,
        pos: f,
        curLine: b,
        lineStart: w
      } = xc("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = f + 1, this.state.lineStart = w, this.state.curLine = b, o && (this.state.firstInvalidTemplateEscapePos = new e(o.curLine, o.pos - o.lineStart, this.sourceToOffsetPos(o.pos))), this.input.codePointAt(f) === 96 ? this.finishToken(24, o ? null : a + s + "`") : (this.state.pos++, this.finishToken(25, o ? null : a + s + "${"));
    }
    recordStrictModeErrors(a, s) {
      const o = s.index;
      this.state.strict && !this.state.strictErrors.has(o) ? this.raise(a, s) : this.state.strictErrors.set(o, [a, s]);
    }
    readWord1(a) {
      this.state.containsEsc = !1;
      let s = "";
      const o = this.state.pos;
      let f = this.state.pos;
      for (a !== void 0 && (this.state.pos += a <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const b = this.codePointAtPos(this.state.pos);
        if (Vr(b))
          this.state.pos += b <= 65535 ? 1 : 2;
        else if (b === 92) {
          this.state.containsEsc = !0, s += this.input.slice(f, this.state.pos);
          const w = this.state.curPosition(), C = this.state.pos === o ? jt : Vr;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(v.MissingUnicodeEscape, this.state.curPosition()), f = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const D = this.readCodePoint(!0);
          D !== null && (C(D) || this.raise(v.EscapedCharNotAnIdentifier, w), s += String.fromCodePoint(D)), f = this.state.pos;
        } else
          break;
      }
      return s + this.input.slice(f, this.state.pos);
    }
    readWord(a) {
      const s = this.readWord1(a), o = he.get(s);
      o !== void 0 ? this.finishToken(o, nt(o)) : this.finishToken(132, s);
    }
    checkKeywordEscapes() {
      const {
        type: a
      } = this.state;
      Be(a) && this.state.containsEsc && this.raise(v.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: nt(a)
      });
    }
    raise(a, s, o = {}) {
      const f = s instanceof e ? s : s.loc.start, b = a(f, o);
      if (!(this.optionFlags & 2048)) throw b;
      return this.isLookahead || this.state.errors.push(b), b;
    }
    raiseOverwrite(a, s, o = {}) {
      const f = s instanceof e ? s : s.loc.start, b = f.index, w = this.state.errors;
      for (let C = w.length - 1; C >= 0; C--) {
        const D = w[C];
        if (D.loc.index === b)
          return w[C] = a(f, o);
        if (D.loc.index < b) break;
      }
      return this.raise(a, s, o);
    }
    updateContext(a) {
    }
    unexpected(a, s) {
      throw this.raise(v.UnexpectedToken, a ?? this.state.startLoc, {
        expected: s ? nt(s) : null
      });
    }
    expectPlugin(a, s) {
      if (this.hasPlugin(a))
        return !0;
      throw this.raise(v.MissingPlugin, s ?? this.state.startLoc, {
        missingPlugin: [a]
      });
    }
    expectOnePlugin(a) {
      if (!a.some((s) => this.hasPlugin(s)))
        throw this.raise(v.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: a
        });
    }
    errorBuilder(a) {
      return (s, o, f) => {
        this.raise(a, xs(s, o, f));
      };
    }
  }
  class Dy {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class My {
    constructor(a) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = a;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Dy());
    }
    exit() {
      const a = this.stack.pop(), s = this.current();
      for (const [o, f] of Array.from(a.undefinedPrivateNames))
        s ? s.undefinedPrivateNames.has(o) || s.undefinedPrivateNames.set(o, f) : this.parser.raise(v.InvalidPrivateFieldResolution, f, {
          identifierName: o
        });
    }
    declarePrivateName(a, s, o) {
      const {
        privateNames: f,
        loneAccessors: b,
        undefinedPrivateNames: w
      } = this.current();
      let C = f.has(a);
      if (s & 3) {
        const D = C && b.get(a);
        if (D) {
          const F = D & 4, $ = s & 4, q = D & 3, J = s & 3;
          C = q === J || F !== $, C || b.delete(a);
        } else C || b.set(a, s);
      }
      C && this.parser.raise(v.PrivateNameRedeclaration, o, {
        identifierName: a
      }), f.add(a), w.delete(a);
    }
    usePrivateName(a, s) {
      let o;
      for (o of this.stack)
        if (o.privateNames.has(a)) return;
      o ? o.undefinedPrivateNames.set(a, s) : this.parser.raise(v.InvalidPrivateFieldResolution, s, {
        identifierName: a
      });
    }
  }
  class yi {
    constructor(a = 0) {
      this.type = a;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class wc extends yi {
    constructor(a) {
      super(a), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(a, s) {
      const o = s.index;
      this.declarationErrors.set(o, [a, s]);
    }
    clearDeclarationError(a) {
      this.declarationErrors.delete(a);
    }
    iterateErrors(a) {
      this.declarationErrors.forEach(a);
    }
  }
  class Fy {
    constructor(a) {
      this.parser = void 0, this.stack = [new yi()], this.parser = a;
    }
    enter(a) {
      this.stack.push(a);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(a, s) {
      const o = s.loc.start, {
        stack: f
      } = this;
      let b = f.length - 1, w = f[b];
      for (; !w.isCertainlyParameterDeclaration(); ) {
        if (w.canBeArrowParameterDeclaration())
          w.recordDeclarationError(a, o);
        else
          return;
        w = f[--b];
      }
      this.parser.raise(a, o);
    }
    recordArrowParameterBindingError(a, s) {
      const {
        stack: o
      } = this, f = o[o.length - 1], b = s.loc.start;
      if (f.isCertainlyParameterDeclaration())
        this.parser.raise(a, b);
      else if (f.canBeArrowParameterDeclaration())
        f.recordDeclarationError(a, b);
      else
        return;
    }
    recordAsyncArrowParametersError(a) {
      const {
        stack: s
      } = this;
      let o = s.length - 1, f = s[o];
      for (; f.canBeArrowParameterDeclaration(); )
        f.type === 2 && f.recordDeclarationError(v.AwaitBindingIdentifier, a), f = s[--o];
    }
    validateAsPattern() {
      const {
        stack: a
      } = this, s = a[a.length - 1];
      s.canBeArrowParameterDeclaration() && s.iterateErrors(([o, f]) => {
        this.parser.raise(o, f);
        let b = a.length - 2, w = a[b];
        for (; w.canBeArrowParameterDeclaration(); )
          w.clearDeclarationError(f.index), w = a[--b];
      });
    }
  }
  function By() {
    return new yi(3);
  }
  function $y() {
    return new wc(1);
  }
  function Uy() {
    return new wc(2);
  }
  function Pc() {
    return new yi();
  }
  class qy extends Ry {
    addExtra(a, s, o, f = !0) {
      if (!a) return;
      let {
        extra: b
      } = a;
      b == null && (b = {}, a.extra = b), f ? b[s] = o : Object.defineProperty(b, s, {
        enumerable: f,
        value: o
      });
    }
    isContextual(a) {
      return this.state.type === a && !this.state.containsEsc;
    }
    isUnparsedContextual(a, s) {
      if (this.input.startsWith(s, a)) {
        const o = this.input.charCodeAt(a + s.length);
        return !(Vr(o) || (o & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(a) {
      const s = this.nextTokenStart();
      return this.isUnparsedContextual(s, a);
    }
    eatContextual(a) {
      return this.isContextual(a) ? (this.next(), !0) : !1;
    }
    expectContextual(a, s) {
      if (!this.eatContextual(a)) {
        if (s != null)
          throw this.raise(s, this.state.startLoc);
        this.unexpected(null, a);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return bc(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return bc(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(a = !0) {
      (a ? this.isLineTerminator() : this.eat(13)) || this.raise(v.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(a, s) {
      this.eat(a) || this.unexpected(s, a);
    }
    tryParse(a, s = this.state.clone()) {
      const o = {
        node: null
      };
      try {
        const f = a((b = null) => {
          throw o.node = b, o;
        });
        if (this.state.errors.length > s.errors.length) {
          const b = this.state;
          return this.state = s, this.state.tokensLength = b.tokensLength, {
            node: f,
            error: b.errors[s.errors.length],
            thrown: !1,
            aborted: !1,
            failState: b
          };
        }
        return {
          node: f,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (f) {
        const b = this.state;
        if (this.state = s, f instanceof SyntaxError)
          return {
            node: null,
            error: f,
            thrown: !0,
            aborted: !1,
            failState: b
          };
        if (f === o)
          return {
            node: o.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: b
          };
        throw f;
      }
    }
    checkExpressionErrors(a, s) {
      if (!a) return !1;
      const {
        shorthandAssignLoc: o,
        doubleProtoLoc: f,
        privateKeyLoc: b,
        optionalParametersLoc: w,
        voidPatternLoc: C
      } = a, D = !!o || !!f || !!w || !!b || !!C;
      if (!s)
        return D;
      o != null && this.raise(v.InvalidCoverInitializedName, o), f != null && this.raise(v.DuplicateProto, f), b != null && this.raise(v.UnexpectedPrivateField, b), w != null && this.unexpected(w), C != null && this.raise(v.InvalidCoverDiscardElement, C);
    }
    isLiteralPropertyName() {
      return ve(this.state.type);
    }
    isPrivateName(a) {
      return a.type === "PrivateName";
    }
    getPrivateNameSV(a) {
      return a.id.name;
    }
    hasPropertyAsPrivateName(a) {
      return (a.type === "MemberExpression" || a.type === "OptionalMemberExpression") && this.isPrivateName(a.property);
    }
    isObjectProperty(a) {
      return a.type === "ObjectProperty";
    }
    isObjectMethod(a) {
      return a.type === "ObjectMethod";
    }
    initializeScopes(a = this.options.sourceType === "module") {
      const s = this.state.labels;
      this.state.labels = [];
      const o = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const f = this.inModule;
      this.inModule = a;
      const b = this.scope, w = this.getScopeHandler();
      this.scope = new w(this, a);
      const C = this.prodParam;
      this.prodParam = new _y();
      const D = this.classScope;
      this.classScope = new My(this);
      const F = this.expressionScope;
      return this.expressionScope = new Fy(this), () => {
        this.state.labels = s, this.exportedIdentifiers = o, this.inModule = f, this.scope = b, this.prodParam = C, this.classScope = D, this.expressionScope = F;
      };
    }
    enterInitialScopes() {
      let a = 0;
      (this.inModule || this.optionFlags & 1) && (a |= 2), this.optionFlags & 32 && (a |= 1);
      const s = !this.inModule && this.options.sourceType === "commonjs";
      (s || this.optionFlags & 2) && (a |= 4), this.prodParam.enter(a);
      let o = s ? 514 : 1;
      this.optionFlags & 4 && (o |= 512), this.scope.enter(o);
    }
    checkDestructuringPrivate(a) {
      const {
        privateKeyLoc: s
      } = a;
      s !== null && this.expectPlugin("destructuringPrivate", s);
    }
  }
  class gi {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc = null;
    }
  }
  class bi {
    constructor(a, s, o) {
      this.type = "", this.start = s, this.end = 0, this.loc = new r(o), (a == null ? void 0 : a.optionFlags) & 128 && (this.range = [s, 0]), a != null && a.filename && (this.loc.filename = a.filename);
    }
  }
  const Ba = bi.prototype;
  Ba.__clone = function() {
    const T = new bi(void 0, this.start, this.loc.start), a = Object.keys(this);
    for (let s = 0, o = a.length; s < o; s++) {
      const f = a[s];
      f !== "leadingComments" && f !== "trailingComments" && f !== "innerComments" && (T[f] = this[f]);
    }
    return T;
  };
  class jy extends qy {
    startNode() {
      const a = this.state.startLoc;
      return new bi(this, a.index, a);
    }
    startNodeAt(a) {
      return new bi(this, a.index, a);
    }
    startNodeAtNode(a) {
      return this.startNodeAt(a.loc.start);
    }
    finishNode(a, s) {
      return this.finishNodeAt(a, s, this.state.lastTokEndLoc);
    }
    finishNodeAt(a, s, o) {
      return a.type = s, a.end = o.index, a.loc.end = o, this.optionFlags & 128 && (a.range[1] = o.index), this.optionFlags & 4096 && this.processComment(a), a;
    }
    resetStartLocation(a, s) {
      a.start = s.index, a.loc.start = s, this.optionFlags & 128 && (a.range[0] = s.index);
    }
    resetEndLocation(a, s = this.state.lastTokEndLoc) {
      a.end = s.index, a.loc.end = s, this.optionFlags & 128 && (a.range[1] = s.index);
    }
    resetStartLocationFromNode(a, s) {
      this.resetStartLocation(a, s.loc.start);
    }
    castNodeTo(a, s) {
      return a.type = s, a;
    }
    cloneIdentifier(a) {
      const {
        type: s,
        start: o,
        end: f,
        loc: b,
        range: w,
        name: C
      } = a, D = Object.create(Ba);
      return D.type = s, D.start = o, D.end = f, D.loc = b, D.range = w, D.name = C, a.extra && (D.extra = a.extra), D;
    }
    cloneStringLiteral(a) {
      const {
        type: s,
        start: o,
        end: f,
        loc: b,
        range: w,
        extra: C
      } = a, D = Object.create(Ba);
      return D.type = s, D.start = o, D.end = f, D.loc = b, D.range = w, D.extra = C, D.value = a.value, D;
    }
  }
  const _c = (T) => T.type === "ParenthesizedExpression" ? _c(T.expression) : T;
  class Vy extends jy {
    toAssignable(a, s = !1) {
      var o, f;
      let b;
      switch ((a.type === "ParenthesizedExpression" || (o = a.extra) != null && o.parenthesized) && (b = _c(a), s ? b.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(v.InvalidParenthesizedAssignment, a) : b.type !== "MemberExpression" && !this.isOptionalMemberExpression(b) && this.raise(v.InvalidParenthesizedAssignment, a) : this.raise(v.InvalidParenthesizedAssignment, a)), a.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(a, "ObjectPattern");
          for (let C = 0, D = a.properties.length, F = D - 1; C < D; C++) {
            var w;
            const $ = a.properties[C], q = C === F;
            this.toAssignableObjectExpressionProp($, q, s), q && $.type === "RestElement" && (w = a.extra) != null && w.trailingCommaLoc && this.raise(v.RestTrailingComma, a.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const {
            key: C,
            value: D
          } = a;
          this.isPrivateName(C) && this.classScope.usePrivateName(this.getPrivateNameSV(C), C.loc.start), this.toAssignable(D, s);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          this.castNodeTo(a, "ArrayPattern"), this.toAssignableList(a.elements, (f = a.extra) == null ? void 0 : f.trailingCommaLoc, s);
          break;
        case "AssignmentExpression":
          a.operator !== "=" && this.raise(v.MissingEqInAssignment, a.left.loc.end), this.castNodeTo(a, "AssignmentPattern"), delete a.operator, a.left.type === "VoidPattern" && this.raise(v.VoidPatternInitializer, a.left), this.toAssignable(a.left, s);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(b, s);
          break;
      }
    }
    toAssignableObjectExpressionProp(a, s, o) {
      if (a.type === "ObjectMethod")
        this.raise(a.kind === "get" || a.kind === "set" ? v.PatternHasAccessor : v.PatternHasMethod, a.key);
      else if (a.type === "SpreadElement") {
        this.castNodeTo(a, "RestElement");
        const f = a.argument;
        this.checkToRestConversion(f, !1), this.toAssignable(f, o), s || this.raise(v.RestTrailingComma, a);
      } else
        this.toAssignable(a, o);
    }
    toAssignableList(a, s, o) {
      const f = a.length - 1;
      for (let b = 0; b <= f; b++) {
        const w = a[b];
        w && (this.toAssignableListItem(a, b, o), w.type === "RestElement" && (b < f ? this.raise(v.RestTrailingComma, w) : s && this.raise(v.RestTrailingComma, s)));
      }
    }
    toAssignableListItem(a, s, o) {
      const f = a[s];
      if (f.type === "SpreadElement") {
        this.castNodeTo(f, "RestElement");
        const b = f.argument;
        this.checkToRestConversion(b, !0), this.toAssignable(b, o);
      } else
        this.toAssignable(f, o);
    }
    isAssignable(a, s) {
      switch (a.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return !0;
        case "ObjectExpression": {
          const o = a.properties.length - 1;
          return a.properties.every((f, b) => f.type !== "ObjectMethod" && (b === o || f.type !== "SpreadElement") && this.isAssignable(f));
        }
        case "ObjectProperty":
          return this.isAssignable(a.value);
        case "SpreadElement":
          return this.isAssignable(a.argument);
        case "ArrayExpression":
          return a.elements.every((o) => o === null || this.isAssignable(o));
        case "AssignmentExpression":
          return a.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(a.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !s;
        default:
          return !1;
      }
    }
    toReferencedList(a, s) {
      return a;
    }
    toReferencedListDeep(a, s) {
      this.toReferencedList(a, s);
      for (const o of a)
        (o == null ? void 0 : o.type) === "ArrayExpression" && this.toReferencedListDeep(o.elements);
    }
    parseSpread(a) {
      const s = this.startNode();
      return this.next(), s.argument = this.parseMaybeAssignAllowIn(a, void 0), this.finishNode(s, "SpreadElement");
    }
    parseRestBinding() {
      const a = this.startNode();
      this.next();
      const s = this.parseBindingAtom();
      return s.type === "VoidPattern" && this.raise(v.UnexpectedVoidPattern, s), a.argument = s, this.finishNode(a, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const a = this.startNode();
          return this.next(), a.elements = this.parseBindingList(3, 93, 1), this.finishNode(a, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    }
    parseBindingList(a, s, o) {
      const f = o & 1, b = [];
      let w = !0;
      for (; !this.eat(a); )
        if (w ? w = !1 : this.expect(12), f && this.match(12))
          b.push(null);
        else {
          if (this.eat(a))
            break;
          if (this.match(21)) {
            let C = this.parseRestBinding();
            if ((this.hasPlugin("flow") || o & 2) && (C = this.parseFunctionParamType(C)), b.push(C), !this.checkCommaAfterRest(s)) {
              this.expect(a);
              break;
            }
          } else {
            const C = [];
            if (o & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(v.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
                C.push(this.parseDecorator());
            b.push(this.parseBindingElement(o, C));
          }
        }
      return b;
    }
    parseBindingRestProperty(a) {
      return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (a.argument = this.parseVoidPattern(null), this.raise(v.UnexpectedVoidPattern, a.argument)) : a.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(a, "RestElement");
    }
    parseBindingProperty() {
      const {
        type: a,
        startLoc: s
      } = this.state;
      if (a === 21)
        return this.parseBindingRestProperty(this.startNode());
      const o = this.startNode();
      return a === 139 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(this.state.value, s), o.key = this.parsePrivateName()) : this.parsePropertyName(o), o.method = !1, this.parseObjPropValue(o, s, !1, !1, !0, !1);
    }
    parseBindingElement(a, s) {
      const o = this.parseMaybeDefault();
      return (this.hasPlugin("flow") || a & 2) && this.parseFunctionParamType(o), s.length && (o.decorators = s, this.resetStartLocationFromNode(o, s[0])), this.parseMaybeDefault(o.loc.start, o);
    }
    parseFunctionParamType(a) {
      return a;
    }
    parseMaybeDefault(a, s) {
      if (a ?? (a = this.state.startLoc), s = s ?? this.parseBindingAtom(), !this.eat(29)) return s;
      const o = this.startNodeAt(a);
      return s.type === "VoidPattern" && this.raise(v.VoidPatternInitializer, s), o.left = s, o.right = this.parseMaybeAssignAllowIn(), this.finishNode(o, "AssignmentPattern");
    }
    isValidLVal(a, s, o) {
      switch (a) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return !0;
      }
      return !1;
    }
    isOptionalMemberExpression(a) {
      return a.type === "OptionalMemberExpression";
    }
    checkLVal(a, s, o = 64, f = !1, b = !1, w = !1) {
      var C;
      const D = a.type;
      if (this.isObjectMethod(a)) return;
      const F = this.isOptionalMemberExpression(a);
      if (F || D === "MemberExpression") {
        F && (this.expectPlugin("optionalChainingAssign", a.loc.start), s.type !== "AssignmentExpression" && this.raise(v.InvalidLhsOptionalChaining, a, {
          ancestor: s
        })), o !== 64 && this.raise(v.InvalidPropertyBindingPattern, a);
        return;
      }
      if (D === "Identifier") {
        this.checkIdentifier(a, o, b);
        const {
          name: me
        } = a;
        f && (f.has(me) ? this.raise(v.ParamDupe, a) : f.add(me));
        return;
      } else D === "VoidPattern" && s.type === "CatchClause" && this.raise(v.VoidPatternCatchClauseParam, a);
      const $ = this.isValidLVal(D, !(w || (C = a.extra) != null && C.parenthesized) && s.type === "AssignmentExpression", o);
      if ($ === !0) return;
      if ($ === !1) {
        const me = o === 64 ? v.InvalidLhs : v.InvalidLhsBinding;
        this.raise(me, a, {
          ancestor: s
        });
        return;
      }
      let q, J;
      typeof $ == "string" ? (q = $, J = D === "ParenthesizedExpression") : [q, J] = $;
      const ee = D === "ArrayPattern" || D === "ObjectPattern" ? {
        type: D
      } : s, oe = a[q];
      if (Array.isArray(oe))
        for (const me of oe)
          me && this.checkLVal(me, ee, o, f, b, J);
      else oe && this.checkLVal(oe, ee, o, f, b, J);
    }
    checkIdentifier(a, s, o = !1) {
      this.state.strict && (o ? yc(a.name, this.inModule) : mc(a.name)) && (s === 64 ? this.raise(v.StrictEvalArguments, a, {
        referenceName: a.name
      }) : this.raise(v.StrictEvalArgumentsBinding, a, {
        bindingName: a.name
      })), s & 8192 && a.name === "let" && this.raise(v.LetInLexicalBinding, a), s & 64 || this.declareNameFromIdentifier(a, s);
    }
    declareNameFromIdentifier(a, s) {
      this.scope.declareName(a.name, s, a.loc.start);
    }
    checkToRestConversion(a, s) {
      switch (a.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(a.expression, s);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (s) break;
        default:
          this.raise(v.InvalidRestAssignmentPattern, a);
      }
    }
    checkCommaAfterRest(a) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === a ? v.RestTrailingComma : v.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }
  function zy(T) {
    if (T == null)
      throw new Error(`Unexpected ${T} value.`);
    return T;
  }
  function Ac(T) {
    if (!T)
      throw new Error("Assert fail");
  }
  const ae = x`typescript`({
    AbstractMethodHasImplementation: ({
      methodName: T
    }) => `Method '${T}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName: T
    }) => `Property '${T}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind: T
    }) => `'declare' is not allowed in ${T}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier: T
    }) => `Accessibility modifier already seen: '${T}'.`,
    DuplicateModifier: ({
      modifier: T
    }) => `Duplicate modifier: '${T}'.`,
    EmptyHeritageClauseType: ({
      token: T
    }) => `'${T}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers: T
    }) => `'${T[0]}' modifier cannot be used with '${T[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier: T
    }) => `Index signatures cannot have an accessibility modifier ('${T}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: ({
      token: T
    }) => `'${T}' list can only include identifiers or qualified-names with optional type arguments.`,
    InvalidModifierOnAwaitUsingDeclaration: (T) => `'${T}' modifier cannot appear on an await using declaration.`,
    InvalidModifierOnTypeMember: ({
      modifier: T
    }) => `'${T}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier: T
    }) => `'${T}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier: T
    }) => `'${T}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifierOnUsingDeclaration: (T) => `'${T}' modifier cannot appear on a using declaration.`,
    InvalidModifiersOrder: ({
      orderedModifiers: T
    }) => `'${T[0]}' modifier must precede '${T[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier: T
    }) => `Private elements cannot have an accessibility modifier ('${T}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName: T
    }) => `Single type parameter ${T} should have a trailing comma. Example usage: <${T},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type: T
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${T}.`,
    UsingDeclarationInAmbientContext: (T) => `'${T}' declarations are not allowed in ambient contexts.`
  });
  function Wy(T) {
    switch (T) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Cc(T) {
    return T === "private" || T === "public" || T === "protected";
  }
  function Hy(T) {
    return T === "in" || T === "out";
  }
  var Gy = (T) => class extends T {
    constructor(...s) {
      super(...s), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ae.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ae.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ae.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Py;
    }
    tsIsIdentifier() {
      return Q(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(s, o, f) {
      if (!Q(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      const b = this.state.value;
      if (s.includes(b)) {
        if (f && this.match(106) || o && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return b;
      }
    }
    tsParseModifiers({
      allowedModifiers: s,
      disallowedModifiers: o,
      stopOnStartOfClassStaticBlock: f,
      errorTemplate: b = ae.InvalidModifierOnTypeMember
    }, w) {
      const C = (F, $, q, J) => {
        $ === q && w[J] && this.raise(ae.InvalidModifiersOrder, F, {
          orderedModifiers: [q, J]
        });
      }, D = (F, $, q, J) => {
        (w[q] && $ === J || w[J] && $ === q) && this.raise(ae.IncompatibleModifiers, F, {
          modifiers: [q, J]
        });
      };
      for (; ; ) {
        const {
          startLoc: F
        } = this.state, $ = this.tsParseModifier(s.concat(o ?? []), f, w.static);
        if (!$) break;
        Cc($) ? w.accessibility ? this.raise(ae.DuplicateAccessibilityModifier, F, {
          modifier: $
        }) : (C(F, $, $, "override"), C(F, $, $, "static"), C(F, $, $, "readonly"), w.accessibility = $) : Hy($) ? (w[$] && this.raise(ae.DuplicateModifier, F, {
          modifier: $
        }), w[$] = !0, C(F, $, "in", "out")) : (hasOwnProperty.call(w, $) ? this.raise(ae.DuplicateModifier, F, {
          modifier: $
        }) : (C(F, $, "static", "readonly"), C(F, $, "static", "override"), C(F, $, "override", "readonly"), C(F, $, "abstract", "override"), D(F, $, "declare", "override"), D(F, $, "static", "abstract")), w[$] = !0), o != null && o.includes($) && this.raise(b, F, {
          modifier: $
        });
      }
    }
    tsIsListTerminator(s) {
      switch (s) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(s, o) {
      const f = [];
      for (; !this.tsIsListTerminator(s); )
        f.push(o());
      return f;
    }
    tsParseDelimitedList(s, o, f) {
      return zy(this.tsParseDelimitedListWorker(s, o, !0, f));
    }
    tsParseDelimitedListWorker(s, o, f, b) {
      const w = [];
      let C = -1;
      for (; !this.tsIsListTerminator(s); ) {
        C = -1;
        const D = o();
        if (D == null)
          return;
        if (w.push(D), this.eat(12)) {
          C = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(s))
          break;
        f && this.expect(12);
        return;
      }
      return b && (b.value = C), w;
    }
    tsParseBracketedList(s, o, f, b, w) {
      b || (f ? this.expect(0) : this.expect(47));
      const C = this.tsParseDelimitedList(s, o, w);
      return f ? this.expect(3) : this.expect(48), C;
    }
    tsParseImportType() {
      const s = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? s.argument = this.parseStringLiteral(this.state.value) : (this.raise(ae.UnsupportedImportTypeArgument, this.state.startLoc), s.argument = super.parseExprAtom()), this.eat(12) ? s.options = this.tsParseImportTypeOptions() : s.options = null, this.expect(11), this.eat(16) && (s.qualifier = this.tsParseEntityName(3)), this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSImportType");
    }
    tsParseImportTypeOptions() {
      const s = this.startNode();
      this.expect(5);
      const o = this.startNode();
      return this.isContextual(76) ? (o.method = !1, o.key = this.parseIdentifier(!0), o.computed = !1, o.shorthand = !1) : this.unexpected(null, 76), this.expect(14), o.value = this.tsParseImportTypeWithPropertyValue(), s.properties = [this.finishObjectProperty(o)], this.expect(8), this.finishNode(s, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      const s = this.startNode(), o = [];
      for (this.expect(5); !this.match(8); ) {
        const f = this.state.type;
        Q(f) || f === 134 ? o.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
      }
      return s.properties = o, this.next(), this.finishNode(s, "ObjectExpression");
    }
    tsParseEntityName(s) {
      let o;
      if (s & 1 && this.match(78))
        if (s & 2)
          o = this.parseIdentifier(!0);
        else {
          const f = this.startNode();
          this.next(), o = this.finishNode(f, "ThisExpression");
        }
      else
        o = this.parseIdentifier(!!(s & 1));
      for (; this.eat(16); ) {
        const f = this.startNodeAtNode(o);
        f.left = o, f.right = this.parseIdentifier(!!(s & 1)), o = this.finishNode(f, "TSQualifiedName");
      }
      return o;
    }
    tsParseTypeReference() {
      const s = this.startNode();
      return s.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeReference");
    }
    tsParseThisTypePredicate(s) {
      this.next();
      const o = this.startNodeAtNode(s);
      return o.parameterName = s, o.typeAnnotation = this.tsParseTypeAnnotation(!1), o.asserts = !1, this.finishNode(o, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const s = this.startNode();
      return this.next(), this.finishNode(s, "TSThisType");
    }
    tsParseTypeQuery() {
      const s = this.startNode();
      return this.expect(87), this.match(83) ? s.exprName = this.tsParseImportType() : s.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeQuery");
    }
    tsParseTypeParameter(s) {
      const o = this.startNode();
      return s(o), o.name = this.tsParseTypeParameterName(), o.constraint = this.tsEatThenParseType(81), o.default = this.tsEatThenParseType(29), this.finishNode(o, "TSTypeParameter");
    }
    tsTryParseTypeParameters(s) {
      if (this.match(47))
        return this.tsParseTypeParameters(s);
    }
    tsParseTypeParameters(s) {
      const o = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      const f = {
        value: -1
      };
      return o.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, s), !1, !0, f), o.params.length === 0 && this.raise(ae.EmptyTypeParameters, o), f.value !== -1 && this.addExtra(o, "trailingComma", f.value), this.finishNode(o, "TSTypeParameterDeclaration");
    }
    tsFillSignature(s, o) {
      const f = s === 19, b = "parameters", w = "typeAnnotation";
      o.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), o[b] = this.tsParseBindingListForSignature(), f ? o[w] = this.tsParseTypeOrTypePredicateAnnotation(s) : this.match(s) && (o[w] = this.tsParseTypeOrTypePredicateAnnotation(s));
    }
    tsParseBindingListForSignature() {
      const s = super.parseBindingList(11, 41, 2);
      for (const o of s) {
        const {
          type: f
        } = o;
        (f === "AssignmentPattern" || f === "TSParameterProperty") && this.raise(ae.UnsupportedSignatureParameterKind, o, {
          type: f
        });
      }
      return s;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(s, o) {
      return this.tsFillSignature(14, o), this.tsParseTypeMemberSemicolon(), this.finishNode(o, s);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Q(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(s) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const o = this.parseIdentifier();
      o.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(o), this.expect(3), s.parameters = [o];
      const f = this.tsTryParseTypeAnnotation();
      return f && (s.typeAnnotation = f), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(s, o) {
      if (this.eat(17) && (s.optional = !0), this.match(10) || this.match(47)) {
        o && this.raise(ae.ReadonlyForMethodSignature, s);
        const f = s;
        f.kind && this.match(47) && this.raise(ae.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon();
        const b = "parameters", w = "typeAnnotation";
        if (f.kind === "get")
          f[b].length > 0 && (this.raise(v.BadGetterArity, this.state.curPosition()), this.isThisParam(f[b][0]) && this.raise(ae.AccessorCannotDeclareThisParameter, this.state.curPosition()));
        else if (f.kind === "set") {
          if (f[b].length !== 1)
            this.raise(v.BadSetterArity, this.state.curPosition());
          else {
            const C = f[b][0];
            this.isThisParam(C) && this.raise(ae.AccessorCannotDeclareThisParameter, this.state.curPosition()), C.type === "Identifier" && C.optional && this.raise(ae.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), C.type === "RestElement" && this.raise(ae.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          f[w] && this.raise(ae.SetAccessorCannotHaveReturnType, f[w]);
        } else
          f.kind = "method";
        return this.finishNode(f, "TSMethodSignature");
      } else {
        const f = s;
        o && (f.readonly = !0);
        const b = this.tsTryParseTypeAnnotation();
        return b && (f.typeAnnotation = b), this.tsParseTypeMemberSemicolon(), this.finishNode(f, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const s = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", s);
      if (this.match(77)) {
        const f = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", s) : (s.key = this.createIdentifier(f, "new"), this.tsParsePropertyOrMethodSignature(s, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, s);
      const o = this.tsTryParseIndexSignature(s);
      return o || (super.parsePropertyName(s), !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") && this.tsTokenCanFollowModifier() && (s.kind = s.key.name, super.parsePropertyName(s), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(s, !!s.readonly));
    }
    tsParseTypeLiteral() {
      const s = this.startNode();
      return s.members = this.tsParseObjectTypeMembers(), this.finishNode(s, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const s = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), s;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      const s = this.startNode();
      this.expect(5), this.match(53) ? (s.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (s.readonly = !0), this.expect(0);
      {
        const o = this.startNode();
        o.name = this.tsParseTypeParameterName(), o.constraint = this.tsExpectThenParseType(58), s.typeParameter = this.finishNode(o, "TSTypeParameter");
      }
      return s.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (s.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (s.optional = !0), s.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(s, "TSMappedType");
    }
    tsParseTupleType() {
      const s = this.startNode();
      s.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let o = !1;
      return s.elementTypes.forEach((f) => {
        const {
          type: b
        } = f;
        o && b !== "TSRestType" && b !== "TSOptionalType" && !(b === "TSNamedTupleMember" && f.optional) && this.raise(ae.OptionalTypeBeforeRequired, f), o || (o = b === "TSNamedTupleMember" && f.optional || b === "TSOptionalType");
      }), this.finishNode(s, "TSTupleType");
    }
    tsParseTupleElementType() {
      const s = this.state.startLoc, o = this.eat(21), {
        startLoc: f
      } = this.state;
      let b, w, C, D;
      const $ = le(this.state.type) ? this.lookaheadCharCode() : null;
      if ($ === 58)
        b = !0, C = !1, w = this.parseIdentifier(!0), this.expect(14), D = this.tsParseType();
      else if ($ === 63) {
        C = !0;
        const q = this.state.value, J = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (b = !0, w = this.createIdentifier(this.startNodeAt(f), q), this.expect(17), this.expect(14), D = this.tsParseType()) : (b = !1, D = J, this.expect(17));
      } else
        D = this.tsParseType(), C = this.eat(17), b = this.eat(14);
      if (b) {
        let q;
        w ? (q = this.startNodeAt(f), q.optional = C, q.label = w, q.elementType = D, this.eat(17) && (q.optional = !0, this.raise(ae.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (q = this.startNodeAt(f), q.optional = C, this.raise(ae.InvalidTupleMemberLabel, D), q.label = D, q.elementType = this.tsParseType()), D = this.finishNode(q, "TSNamedTupleMember");
      } else if (C) {
        const q = this.startNodeAt(f);
        q.typeAnnotation = D, D = this.finishNode(q, "TSOptionalType");
      }
      if (o) {
        const q = this.startNodeAt(s);
        q.typeAnnotation = D, D = this.finishNode(q, "TSRestType");
      }
      return D;
    }
    tsParseParenthesizedType() {
      const s = this.startNode();
      return this.expect(10), s.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(s, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(s, o) {
      const f = this.startNode();
      return s === "TSConstructorType" && (f.abstract = !!o, o && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, f)), this.finishNode(f, s);
    }
    tsParseLiteralTypeNode() {
      const s = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          s.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(s, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        const s = this.startNode();
        return s.literal = super.parseTemplate(!1), this.finishNode(s, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const s = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(s) : s;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const s = this.startNode(), o = this.lookahead();
            return o.type !== 135 && o.type !== 136 && this.unexpected(), s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: s
          } = this.state;
          if (Q(s) || s === 88 || s === 84) {
            const o = s === 88 ? "TSVoidKeyword" : s === 84 ? "TSNullKeyword" : Wy(this.state.value);
            if (o !== void 0 && this.lookaheadCharCode() !== 46) {
              const f = this.startNode();
              return this.next(), this.finishNode(f, o);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      const {
        startLoc: s
      } = this.state;
      let o = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const f = this.startNodeAt(s);
          f.elementType = o, this.expect(3), o = this.finishNode(f, "TSArrayType");
        } else {
          const f = this.startNodeAt(s);
          f.objectType = o, f.indexType = this.tsParseType(), this.expect(3), o = this.finishNode(f, "TSIndexedAccessType");
        }
      return o;
    }
    tsParseTypeOperator() {
      const s = this.startNode(), o = this.state.value;
      return this.next(), s.operator = o, s.typeAnnotation = this.tsParseTypeOperatorOrHigher(), o === "readonly" && this.tsCheckTypeAnnotationForReadOnly(s), this.finishNode(s, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(s) {
      switch (s.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ae.UnexpectedReadonly, s);
      }
    }
    tsParseInferType() {
      const s = this.startNode();
      this.expectContextual(115);
      const o = this.startNode();
      return o.name = this.tsParseTypeParameterName(), o.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), s.typeParameter = this.finishNode(o, "TSTypeParameter"), this.finishNode(s, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const s = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return s;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return $r(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(s, o, f) {
      const b = this.startNode(), w = this.eat(f), C = [];
      do
        C.push(o());
      while (this.eat(f));
      return C.length === 1 && !w ? C[0] : (b.types = C, this.finishNode(b, s));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Q(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        const {
          errors: s
        } = this.state, o = s.length;
        try {
          return this.parseObjectLike(8, !0), s.length === o;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: s
        } = this.state, o = s.length;
        try {
          return super.parseBindingList(3, 93, 1), s.length === o;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(s) {
      return this.tsInType(() => {
        const o = this.startNode();
        this.expect(s);
        const f = this.startNode(), b = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (b && this.match(78)) {
          let D = this.tsParseThisTypeOrThisTypePredicate();
          return D.type === "TSThisType" ? (f.parameterName = D, f.asserts = !0, f.typeAnnotation = null, D = this.finishNode(f, "TSTypePredicate")) : (this.resetStartLocationFromNode(D, f), D.asserts = !0), o.typeAnnotation = D, this.finishNode(o, "TSTypeAnnotation");
        }
        const w = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!w)
          return b ? (f.parameterName = this.parseIdentifier(), f.asserts = b, f.typeAnnotation = null, o.typeAnnotation = this.finishNode(f, "TSTypePredicate"), this.finishNode(o, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, o);
        const C = this.tsParseTypeAnnotation(!1);
        return f.parameterName = w, f.typeAnnotation = C, f.asserts = b, o.typeAnnotation = this.finishNode(f, "TSTypePredicate"), this.finishNode(o, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const s = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), s;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      const s = this.state.containsEsc;
      return this.next(), !Q(this.state.type) && !this.match(78) ? !1 : (s && this.raise(v.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(s = !0, o = this.startNode()) {
      return this.tsInType(() => {
        s && this.expect(14), o.typeAnnotation = this.tsParseType();
      }), this.finishNode(o, "TSTypeAnnotation");
    }
    tsParseType() {
      Ac(this.state.inType);
      const s = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return s;
      const o = this.startNodeAtNode(s);
      return o.checkType = s, o.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), o.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), o.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(o, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ae.ReservedTypeAssertion, this.state.startLoc);
      const s = this.startNode();
      return s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), s.expression = this.parseMaybeUnary(), this.finishNode(s, "TSTypeAssertion");
    }
    tsParseHeritageClause(s) {
      const o = this.state.startLoc, f = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          const b = this.startNode();
          return b.expression = this.tsParseEntityName(3), this.match(47) && (b.typeParameters = this.tsParseTypeArguments()), this.finishNode(b, "TSExpressionWithTypeArguments");
        }
      });
      return f.length || this.raise(ae.EmptyHeritageClauseType, o, {
        token: s
      }), f;
    }
    tsParseInterfaceDeclaration(s, o = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), o.declare && (s.declare = !0), Q(this.state.type) ? (s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 130)) : (s.id = null, this.raise(ae.MissingInterfaceName, this.state.startLoc)), s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (s.extends = this.tsParseHeritageClause("extends"));
      const f = this.startNode();
      return f.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), s.body = this.finishNode(f, "TSInterfaceBody"), this.finishNode(s, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(s) {
      return s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 2), s.typeAnnotation = this.tsInType(() => {
        if (s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
          const o = this.startNode();
          return this.next(), this.finishNode(o, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(s, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(s) {
      if (this.curContext() !== I.brace) {
        const o = this.state.context;
        this.state.context = [o[0]];
        try {
          return s();
        } finally {
          this.state.context = o;
        }
      } else
        return s();
    }
    tsInType(s) {
      const o = this.state.inType;
      this.state.inType = !0;
      try {
        return s();
      } finally {
        this.state.inType = o;
      }
    }
    tsInDisallowConditionalTypesContext(s) {
      const o = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = o;
      }
    }
    tsInAllowConditionalTypesContext(s) {
      const o = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = o;
      }
    }
    tsEatThenParseType(s) {
      if (this.match(s))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(s) {
      return this.tsInType(() => (this.expect(s), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const s = this.startNode();
      return s.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (s.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(s, "TSEnumMember");
    }
    tsParseEnumDeclaration(s, o = {}) {
      return o.const && (s.const = !0), o.declare && (s.declare = !0), this.expectContextual(126), s.id = this.parseIdentifier(), this.checkIdentifier(s.id, s.const ? 8971 : 8459), this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(s, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      const s = this.startNode();
      return this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(s, "TSEnumBody");
    }
    tsParseModuleBlock() {
      const s = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(s.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(s, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(s, o = !1) {
      if (s.id = this.parseIdentifier(), o || this.checkIdentifier(s.id, 1024), this.eat(16)) {
        const f = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(f, !0), s.body = f;
      } else
        this.scope.enter(1024), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(s, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(s) {
      return this.isContextual(112) ? (s.kind = "global", s.global = !0, s.id = this.parseIdentifier()) : this.match(134) ? (s.kind = "module", s.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(s, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(s, o, f) {
      s.isExport = f || !1, s.id = o || this.parseIdentifier(), this.checkIdentifier(s.id, 4096), this.expect(29);
      const b = this.tsParseModuleReference();
      return s.importKind === "type" && b.type !== "TSExternalModuleReference" && this.raise(ae.ImportAliasHasImportType, b), s.moduleReference = b, this.semicolon(), this.finishNode(s, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      const s = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), s.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExternalModuleReference");
    }
    tsLookAhead(s) {
      const o = this.state.clone(), f = s();
      return this.state = o, f;
    }
    tsTryParseAndCatch(s) {
      const o = this.tryParse((f) => s() || f());
      if (!(o.aborted || !o.node))
        return o.error && (this.state = o.failState), o.node;
    }
    tsTryParse(s) {
      const o = this.state.clone(), f = s();
      if (f !== void 0 && f !== !1)
        return f;
      this.state = o;
    }
    tsTryParseDeclare(s) {
      if (this.isLineTerminator())
        return;
      const o = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (o) {
          case 68:
            return s.declare = !0, super.parseFunctionStatement(s, !1, !1);
          case 80:
            return s.declare = !0, this.parseClass(s, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(s, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(s);
          case 100:
            if (this.state.containsEsc)
              return;
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (s.declare = !0, this.parseVarStatement(s, this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(s, {
              const: !0,
              declare: !0
            }));
          case 107:
            if (this.isUsing())
              return this.raise(ae.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), s.declare = !0, this.parseVarStatement(s, "using", !0);
            break;
          case 96:
            if (this.isAwaitUsing())
              return this.raise(ae.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), s.declare = !0, this.next(), this.parseVarStatement(s, "await using", !0);
            break;
          case 129: {
            const f = this.tsParseInterfaceDeclaration(s, {
              declare: !0
            });
            if (f) return f;
          }
          default:
            if (Q(o))
              return this.tsParseDeclaration(s, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(s, o, f) {
      switch (o.name) {
        case "declare": {
          const b = this.tsTryParseDeclare(s);
          return b && (b.declare = !0), b;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(1024), this.prodParam.enter(0);
            const b = s;
            return b.kind = "global", s.global = !0, b.id = o, b.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(b, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(s, o.name, !1, f);
      }
    }
    tsParseDeclaration(s, o, f, b) {
      switch (o) {
        case "abstract":
          if (this.tsCheckLineTerminator(f) && (this.match(80) || Q(this.state.type)))
            return this.tsParseAbstractDeclaration(s, b);
          break;
        case "module":
          if (this.tsCheckLineTerminator(f)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(s);
            if (Q(this.state.type))
              return s.kind = "module", this.tsParseModuleOrNamespaceDeclaration(s);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(f) && Q(this.state.type))
            return s.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(s);
          break;
        case "type":
          if (this.tsCheckLineTerminator(f) && Q(this.state.type))
            return this.tsParseTypeAliasDeclaration(s);
          break;
      }
    }
    tsCheckLineTerminator(s) {
      return s ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(s) {
      if (!this.match(47)) return;
      const o = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const f = this.tsTryParseAndCatch(() => {
        const b = this.startNodeAt(s);
        return b.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(b), b.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), b;
      });
      if (this.state.maybeInArrowParameters = o, !!f)
        return super.parseArrowExpression(f, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const s = this.startNode();
      return s.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), s.params.length === 0 ? this.raise(ae.EmptyTypeArguments, s) : !this.state.inType && this.curContext() === I.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Ur(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(s, o) {
      const f = o.length ? o[0].loc.start : this.state.startLoc, b = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, b);
      const w = b.accessibility, C = b.override, D = b.readonly;
      !(s & 4) && (w || D || C) && this.raise(ae.UnexpectedParameterModifier, f);
      const F = this.parseMaybeDefault();
      s & 2 && this.parseFunctionParamType(F);
      const $ = this.parseMaybeDefault(F.loc.start, F);
      if (w || D || C) {
        const q = this.startNodeAt(f);
        return o.length && (q.decorators = o), w && (q.accessibility = w), D && (q.readonly = D), C && (q.override = C), $.type !== "Identifier" && $.type !== "AssignmentPattern" && this.raise(ae.UnsupportedParameterPropertyKind, q), q.parameter = $, this.finishNode(q, "TSParameterProperty");
      }
      return o.length && (F.decorators = o), $;
    }
    isSimpleParameter(s) {
      return s.type === "TSParameterProperty" && super.isSimpleParameter(s.parameter) || super.isSimpleParameter(s);
    }
    tsDisallowOptionalPattern(s) {
      for (const o of s.params)
        o.type !== "Identifier" && o.optional && !this.state.isAmbientContext && this.raise(ae.PatternIsOptional, o);
    }
    setArrowFunctionParameters(s, o, f) {
      super.setArrowFunctionParameters(s, o, f), this.tsDisallowOptionalPattern(s);
    }
    parseFunctionBodyAndFinish(s, o, f = !1) {
      this.match(14) && (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const b = o === "FunctionDeclaration" ? "TSDeclareFunction" : o === "ClassMethod" || o === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return b && !this.match(5) && this.isLineTerminator() ? this.finishNode(s, b) : b === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ae.DeclareFunctionHasImplementation, s), s.declare) ? super.parseFunctionBodyAndFinish(s, b, f) : (this.tsDisallowOptionalPattern(s), super.parseFunctionBodyAndFinish(s, o, f));
    }
    registerFunctionStatementId(s) {
      !s.body && s.id ? this.checkIdentifier(s.id, 1024) : super.registerFunctionStatementId(s);
    }
    tsCheckForInvalidTypeCasts(s) {
      s.forEach((o) => {
        (o == null ? void 0 : o.type) === "TSTypeCastExpression" && this.raise(ae.UnexpectedTypeAnnotation, o.typeAnnotation);
      });
    }
    toReferencedList(s, o) {
      return this.tsCheckForInvalidTypeCasts(s), s;
    }
    parseArrayLike(s, o, f, b) {
      const w = super.parseArrayLike(s, o, f, b);
      return w.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(w.elements), w;
    }
    parseSubscript(s, o, f, b) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const C = this.startNodeAt(o);
        return C.expression = s, this.finishNode(C, "TSNonNullExpression");
      }
      let w = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (f)
          return b.stop = !0, s;
        b.optionalChainMember = w = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let C;
        const D = this.tsTryParseAndCatch(() => {
          if (!f && this.atPossibleAsyncArrow(s)) {
            const J = this.tsTryParseGenericAsyncArrowFunction(o);
            if (J)
              return J;
          }
          const F = this.tsParseTypeArgumentsInExpression();
          if (!F) return;
          if (w && !this.match(10)) {
            C = this.state.curPosition();
            return;
          }
          if (jr(this.state.type)) {
            const J = super.parseTaggedTemplateExpression(s, o, b);
            return J.typeParameters = F, J;
          }
          if (!f && this.eat(10)) {
            const J = this.startNodeAt(o);
            return J.callee = s, J.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(J.arguments), J.typeParameters = F, b.optionalChainMember && (J.optional = w), this.finishCallExpression(J, b.optionalChainMember);
          }
          const $ = this.state.type;
          if ($ === 48 || $ === 52 || $ !== 10 && we($) && !this.hasPrecedingLineBreak())
            return;
          const q = this.startNodeAt(o);
          return q.expression = s, q.typeParameters = F, this.finishNode(q, "TSInstantiationExpression");
        });
        if (C && this.unexpected(C, 10), D)
          return D.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ae.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (D.expression = super.stopParseSubscript(s, b))), D;
      }
      return super.parseSubscript(s, o, f, b);
    }
    parseNewCallee(s) {
      var o;
      super.parseNewCallee(s);
      const {
        callee: f
      } = s;
      f.type === "TSInstantiationExpression" && !((o = f.extra) != null && o.parenthesized) && (s.typeParameters = f.typeParameters, s.callee = f.expression);
    }
    parseExprOp(s, o, f) {
      let b;
      if (qr(58) > f && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (b = this.isContextual(120)))) {
        const w = this.startNodeAt(o);
        return w.expression = s, w.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (b && this.raise(v.UnexpectedKeyword, this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(w, b ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(w, o, f);
      }
      return super.parseExprOp(s, o, f);
    }
    checkReservedWord(s, o, f, b) {
      this.state.isAmbientContext || super.checkReservedWord(s, o, f, b);
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(ae.ImportReflectionHasImportType, s.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        const o = this.lookaheadCharCode();
        return s ? o === 123 || o === 42 : o !== 61;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, o, f, b) {
      super.applyImportPhase(s, o, f, b), o ? s.exportKind = f === "type" ? "type" : "value" : s.importKind = f === "type" || f === "typeof" ? f : "value";
    }
    parseImport(s) {
      if (this.match(134))
        return s.importKind = "value", super.parseImport(s);
      let o;
      if (Q(this.state.type) && this.lookaheadCharCode() === 61)
        return s.importKind = "value", this.tsParseImportEqualsDeclaration(s);
      if (this.isContextual(130)) {
        const f = this.parseMaybeImportPhase(s, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(s, f);
        o = super.parseImportSpecifiersAndAfter(s, f);
      } else
        o = super.parseImport(s);
      return o.importKind === "type" && o.specifiers.length > 1 && o.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ae.TypeImportCannotSpecifyDefaultAndNamed, o), o;
    }
    parseExport(s, o) {
      if (this.match(83)) {
        const f = s;
        this.next();
        let b = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? b = this.parseMaybeImportPhase(f, !1) : f.importKind = "value", this.tsParseImportEqualsDeclaration(f, b, !0);
      } else if (this.eat(29)) {
        const f = s;
        return f.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(f, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const f = s;
        return this.expectContextual(128), f.id = this.parseIdentifier(), this.semicolon(), this.finishNode(f, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(s, o);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const s = this.startNode();
        return this.next(), s.abstract = !0, this.parseClass(s, !0, !0);
      }
      if (this.match(129)) {
        const s = this.tsParseInterfaceDeclaration(this.startNode());
        if (s) return s;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(s, o, f = !1) {
      const {
        isAmbientContext: b
      } = this.state, w = super.parseVarStatement(s, o, f || b);
      if (!b) return w;
      if (!s.declare && (o === "using" || o === "await using"))
        return this.raiseOverwrite(ae.UsingDeclarationInAmbientContext, s, o), w;
      for (const {
        id: C,
        init: D
      } of w.declarations)
        D && (o === "var" || o === "let" || C.typeAnnotation ? this.raise(ae.InitializerNotAllowedInAmbientContext, D) : Jy(D, this.hasPlugin("estree")) || this.raise(ae.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, D));
      return w;
    }
    parseStatementContent(s, o) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const f = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(f, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const f = this.tsParseInterfaceDeclaration(this.startNode());
        if (f) return f;
      }
      return super.parseStatementContent(s, o);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(s, o) {
      return o.some((f) => Cc(f) ? s.accessibility === f : !!s[f]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(s, o, f) {
      const b = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: b,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ae.InvalidModifierOnTypeParameterPositions
      }, o);
      const w = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(o, b) && this.raise(ae.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(s, o)) : this.parseClassMemberWithIsStatic(s, o, f, !!o.static);
      };
      o.declare ? this.tsInAmbientContext(w) : w();
    }
    parseClassMemberWithIsStatic(s, o, f, b) {
      const w = this.tsTryParseIndexSignature(o);
      if (w) {
        s.body.push(w), o.abstract && this.raise(ae.IndexSignatureHasAbstract, o), o.accessibility && this.raise(ae.IndexSignatureHasAccessibility, o, {
          modifier: o.accessibility
        }), o.declare && this.raise(ae.IndexSignatureHasDeclare, o), o.override && this.raise(ae.IndexSignatureHasOverride, o);
        return;
      }
      !this.state.inAbstractClass && o.abstract && this.raise(ae.NonAbstractClassHasAbstractMethod, o), o.override && (f.hadSuperClass || this.raise(ae.OverrideNotInSubClass, o)), super.parseClassMemberWithIsStatic(s, o, f, b);
    }
    parsePostMemberNameModifiers(s) {
      this.eat(17) && (s.optional = !0), s.readonly && this.match(10) && this.raise(ae.ClassMethodHasReadonly, s), s.declare && this.match(10) && this.raise(ae.ClassMethodHasDeclare, s);
    }
    parseExpressionStatement(s, o, f) {
      return (o.type === "Identifier" ? this.tsParseExpressionStatement(s, o, f) : void 0) || super.parseExpressionStatement(s, o, f);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(s, o, f) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        const b = this.lookaheadCharCode();
        if (b === 44 || b === 61 || b === 58 || b === 41)
          return this.setOptionalParametersError(f), s;
      }
      return super.parseConditional(s, o, f);
    }
    parseParenItem(s, o) {
      const f = super.parseParenItem(s, o);
      if (this.eat(17) && (f.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        const b = this.startNodeAt(o);
        return b.expression = s, b.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(b, "TSTypeCastExpression");
      }
      return s;
    }
    parseExportDeclaration(s) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(s));
      const o = this.state.startLoc, f = this.eatContextual(125);
      if (f && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ae.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const w = Q(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(s);
      return w ? ((w.type === "TSInterfaceDeclaration" || w.type === "TSTypeAliasDeclaration" || f) && (s.exportKind = "type"), f && w.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(w, o), w.declare = !0), w) : null;
    }
    parseClassId(s, o, f, b) {
      if ((!o || f) && this.isContextual(113))
        return;
      super.parseClassId(s, o, f, s.declare ? 1024 : 8331);
      const w = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      w && (s.typeParameters = w);
    }
    parseClassPropertyAnnotation(s) {
      s.optional || (this.eat(35) ? s.definite = !0 : this.eat(17) && (s.optional = !0));
      const o = this.tsTryParseTypeAnnotation();
      o && (s.typeAnnotation = o);
    }
    parseClassProperty(s) {
      if (this.parseClassPropertyAnnotation(s), this.state.isAmbientContext && !(s.readonly && !s.typeAnnotation) && this.match(29) && this.raise(ae.DeclareClassFieldHasInitializer, this.state.startLoc), s.abstract && this.match(29)) {
        const {
          key: o
        } = s;
        this.raise(ae.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: o.type === "Identifier" && !s.computed ? o.name : `[${this.input.slice(this.offsetToSourcePos(o.start), this.offsetToSourcePos(o.end))}]`
        });
      }
      return super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return s.abstract && this.raise(ae.PrivateElementHasAbstract, s), s.accessibility && this.raise(ae.PrivateElementHasAccessibility, s, {
        modifier: s.accessibility
      }), this.parseClassPropertyAnnotation(s), super.parseClassPrivateProperty(s);
    }
    parseClassAccessorProperty(s) {
      return this.parseClassPropertyAnnotation(s), s.optional && this.raise(ae.AccessorCannotBeOptional, s), super.parseClassAccessorProperty(s);
    }
    pushClassMethod(s, o, f, b, w, C) {
      const D = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      D && w && this.raise(ae.ConstructorHasTypeParameters, D);
      const {
        declare: F = !1,
        kind: $
      } = o;
      F && ($ === "get" || $ === "set") && this.raise(ae.DeclareAccessor, o, {
        kind: $
      }), D && (o.typeParameters = D), super.pushClassMethod(s, o, f, b, w, C);
    }
    pushClassPrivateMethod(s, o, f, b) {
      const w = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      w && (o.typeParameters = w), super.pushClassPrivateMethod(s, o, f, b);
    }
    declareClassPrivateMethodInScope(s, o) {
      s.type !== "TSDeclareMethod" && (s.type === "MethodDefinition" && s.value.body == null || super.declareClassPrivateMethodInScope(s, o));
    }
    parseClassSuper(s) {
      super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (s.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(s, o, f, b, w, C, D) {
      const F = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return F && (s.typeParameters = F), super.parseObjPropValue(s, o, f, b, w, C, D);
    }
    parseFunctionParams(s, o) {
      const f = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      f && (s.typeParameters = f), super.parseFunctionParams(s, o);
    }
    parseVarId(s, o) {
      super.parseVarId(s, o), s.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (s.definite = !0);
      const f = this.tsTryParseTypeAnnotation();
      f && (s.id.typeAnnotation = f, this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, o) {
      return this.match(14) && (s.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(s, o);
    }
    parseMaybeAssign(s, o) {
      var f, b, w, C, D;
      let F, $, q;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (F = this.state.clone(), $ = this.tryParse(() => super.parseMaybeAssign(s, o), F), !$.error) return $.node;
        const {
          context: oe
        } = this.state, me = oe[oe.length - 1];
        (me === I.j_oTag || me === I.j_expr) && oe.pop();
      }
      if (!((f = $) != null && f.error) && !this.match(47))
        return super.parseMaybeAssign(s, o);
      (!F || F === this.state) && (F = this.state.clone());
      let J;
      const ee = this.tryParse((oe) => {
        var me, Re;
        J = this.tsParseTypeParameters(this.tsParseConstModifier);
        const ye = super.parseMaybeAssign(s, o);
        return (ye.type !== "ArrowFunctionExpression" || (me = ye.extra) != null && me.parenthesized) && oe(), ((Re = J) == null ? void 0 : Re.params.length) !== 0 && this.resetStartLocationFromNode(ye, J), ye.typeParameters = J, ye;
      }, F);
      if (!ee.error && !ee.aborted)
        return J && this.reportReservedArrowTypeParam(J), ee.node;
      if (!$ && (Ac(!this.hasPlugin("jsx")), q = this.tryParse(() => super.parseMaybeAssign(s, o), F), !q.error))
        return q.node;
      if ((b = $) != null && b.node)
        return this.state = $.failState, $.node;
      if (ee.node)
        return this.state = ee.failState, J && this.reportReservedArrowTypeParam(J), ee.node;
      if ((w = q) != null && w.node)
        return this.state = q.failState, q.node;
      throw ((C = $) == null ? void 0 : C.error) || ee.error || ((D = q) == null ? void 0 : D.error);
    }
    reportReservedArrowTypeParam(s) {
      var o;
      s.params.length === 1 && !s.params[0].constraint && !((o = s.extra) != null && o.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ae.ReservedArrowTypeParam, s);
    }
    parseMaybeUnary(s, o) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(s, o);
    }
    parseArrow(s) {
      if (this.match(14)) {
        const o = this.tryParse((f) => {
          const b = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && f(), b;
        });
        if (o.aborted) return;
        o.thrown || (o.error && (this.state = o.failState), s.returnType = o.node);
      }
      return super.parseArrow(s);
    }
    parseFunctionParamType(s) {
      this.eat(17) && (s.optional = !0);
      const o = this.tsTryParseTypeAnnotation();
      return o && (s.typeAnnotation = o), this.resetEndLocation(s), s;
    }
    isAssignable(s, o) {
      switch (s.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(s.expression, o);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(s, o);
      }
    }
    toAssignable(s, o = !1) {
      switch (s.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(s, o);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          o ? this.expressionScope.recordArrowParameterBindingError(ae.UnexpectedTypeCastInParameter, s) : this.raise(ae.UnexpectedTypeCastInParameter, s), this.toAssignable(s.expression, o);
          break;
        case "AssignmentExpression":
          !o && s.left.type === "TSTypeCastExpression" && (s.left = this.typeCastToParameter(s.left));
        default:
          super.toAssignable(s, o);
      }
    }
    toAssignableParenthesizedExpression(s, o) {
      switch (s.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(s.expression, o);
          break;
        default:
          super.toAssignable(s, o);
      }
    }
    checkToRestConversion(s, o) {
      switch (s.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(s.expression, !1);
          break;
        default:
          super.checkToRestConversion(s, o);
      }
    }
    isValidLVal(s, o, f) {
      switch (s) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (f !== 64 || !o) && ["expression", !0];
        default:
          return super.isValidLVal(s, o, f);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(s, o) {
      if (this.match(47) || this.match(51)) {
        const f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const b = super.parseMaybeDecoratorArguments(s, o);
          return b.typeParameters = f, b;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(s, o);
    }
    checkCommaAfterRest(s) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === s ? (this.next(), !1) : super.checkCommaAfterRest(s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(s, o) {
      const f = super.parseMaybeDefault(s, o);
      return f.type === "AssignmentPattern" && f.typeAnnotation && f.right.start < f.typeAnnotation.start && this.raise(ae.TypeAnnotationAfterAssign, f.typeAnnotation), f;
    }
    getTokenFromCode(s) {
      if (this.state.inType) {
        if (s === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (s === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(s);
    }
    reScan_lt_gt() {
      const {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    toAssignableListItem(s, o, f) {
      const b = s[o];
      b.type === "TSTypeCastExpression" && (s[o] = this.typeCastToParameter(b)), super.toAssignableListItem(s, o, f);
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    shouldParseArrow(s) {
      return this.match(14) ? s.every((o) => this.isAssignable(o, !0)) : super.shouldParseArrow(s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(s) {
      if (this.match(47) || this.match(51)) {
        const o = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        o && (s.typeParameters = o);
      }
      return super.jsxParseOpeningElementAfterName(s);
    }
    getGetterSetterExpectedParamCount(s) {
      const o = super.getGetterSetterExpectedParamCount(s), b = this.getObjectOrClassMethodParams(s)[0];
      return b && this.isThisParam(b) ? o + 1 : o;
    }
    parseCatchClauseParam() {
      const s = super.parseCatchClauseParam(), o = this.tsTryParseTypeAnnotation();
      return o && (s.typeAnnotation = o, this.resetEndLocation(s)), s;
    }
    tsInAmbientContext(s) {
      const {
        isAmbientContext: o,
        strict: f
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return s();
      } finally {
        this.state.isAmbientContext = o, this.state.strict = f;
      }
    }
    parseClass(s, o, f) {
      const b = this.state.inAbstractClass;
      this.state.inAbstractClass = !!s.abstract;
      try {
        return super.parseClass(s, o, f);
      } finally {
        this.state.inAbstractClass = b;
      }
    }
    tsParseAbstractDeclaration(s, o) {
      if (this.match(80))
        return s.abstract = !0, this.maybeTakeDecorators(o, this.parseClass(s, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return s.abstract = !0, this.raise(ae.NonClassMethodPropertyHasAbstractModifier, s), this.tsParseInterfaceDeclaration(s);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(s, o, f, b, w, C, D) {
      const F = super.parseMethod(s, o, f, b, w, C, D);
      if ((F.abstract || F.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? F.value : F).body) {
        const {
          key: J
        } = F;
        this.raise(ae.AbstractMethodHasImplementation, F, {
          methodName: J.type === "Identifier" && !F.computed ? J.name : `[${this.input.slice(this.offsetToSourcePos(J.start), this.offsetToSourcePos(J.end))}]`
        });
      }
      return F;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(s, o, f, b) {
      return !o && b ? (this.parseTypeOnlyImportExportSpecifier(s, !1, f), this.finishNode(s, "ExportSpecifier")) : (s.exportKind = "value", super.parseExportSpecifier(s, o, f, b));
    }
    parseImportSpecifier(s, o, f, b, w) {
      return !o && b ? (this.parseTypeOnlyImportExportSpecifier(s, !0, f), this.finishNode(s, "ImportSpecifier")) : (s.importKind = "value", super.parseImportSpecifier(s, o, f, b, f ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(s, o, f) {
      const b = o ? "imported" : "local", w = o ? "local" : "exported";
      let C = s[b], D, F = !1, $ = !0;
      const q = C.loc.start;
      if (this.isContextual(93)) {
        const ee = this.parseIdentifier();
        if (this.isContextual(93)) {
          const oe = this.parseIdentifier();
          le(this.state.type) ? (F = !0, C = ee, D = o ? this.parseIdentifier() : this.parseModuleExportName(), $ = !1) : (D = oe, $ = !1);
        } else le(this.state.type) ? ($ = !1, D = o ? this.parseIdentifier() : this.parseModuleExportName()) : (F = !0, C = ee);
      } else le(this.state.type) && (F = !0, o ? (C = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(C.name, C.loc.start, !0, !0)) : C = this.parseModuleExportName());
      F && f && this.raise(o ? ae.TypeModifierIsUsedInTypeImports : ae.TypeModifierIsUsedInTypeExports, q), s[b] = C, s[w] = D;
      const J = o ? "importKind" : "exportKind";
      s[J] = F ? "type" : "value", $ && this.eatContextual(93) && (s[w] = o ? this.parseIdentifier() : this.parseModuleExportName()), s[w] || (s[w] = this.cloneIdentifier(s[b])), o && this.checkIdentifier(s[w], F ? 4098 : 4096);
    }
    fillOptionalPropertiesForTSESLint(s) {
      var o, f, b, w, C, D, F, $, q, J, ee, oe, me, Re, ye, _e, gr, rr, Fc, Bc, $c, Uc, qc, jc, Vc, zc, Wc, Hc, Gc, Xc, Jc, Kc, Yc, Qc, Zc, eh, th, rh, sh, ih, nh, ah, oh, uh, lh, ch;
      switch (s.type) {
        case "ExpressionStatement":
          (o = s.directive) != null || (s.directive = void 0);
          return;
        case "RestElement":
          s.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          (f = s.decorators) != null || (s.decorators = []), (b = s.optional) != null || (s.optional = !1), (w = s.typeAnnotation) != null || (s.typeAnnotation = void 0);
          return;
        case "TSParameterProperty":
          (C = s.accessibility) != null || (s.accessibility = void 0), (D = s.decorators) != null || (s.decorators = []), (F = s.override) != null || (s.override = !1), ($ = s.readonly) != null || (s.readonly = !1), (q = s.static) != null || (s.static = !1);
          return;
        case "TSEmptyBodyFunctionExpression":
          s.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          (J = s.declare) != null || (s.declare = !1), (ee = s.returnType) != null || (s.returnType = void 0), (oe = s.typeParameters) != null || (s.typeParameters = void 0);
          return;
        case "Property":
          (me = s.optional) != null || (s.optional = !1);
          return;
        case "TSMethodSignature":
        case "TSPropertySignature":
          (Re = s.optional) != null || (s.optional = !1);
        case "TSIndexSignature":
          (ye = s.accessibility) != null || (s.accessibility = void 0), (_e = s.readonly) != null || (s.readonly = !1), (gr = s.static) != null || (s.static = !1);
          return;
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          (rr = s.declare) != null || (s.declare = !1), (Fc = s.definite) != null || (s.definite = !1), (Bc = s.readonly) != null || (s.readonly = !1), ($c = s.typeAnnotation) != null || (s.typeAnnotation = void 0);
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          (Uc = s.accessibility) != null || (s.accessibility = void 0), (qc = s.decorators) != null || (s.decorators = []), (jc = s.override) != null || (s.override = !1), (Vc = s.optional) != null || (s.optional = !1);
          return;
        case "ClassExpression":
          (zc = s.id) != null || (s.id = null);
        case "ClassDeclaration":
          (Wc = s.abstract) != null || (s.abstract = !1), (Hc = s.declare) != null || (s.declare = !1), (Gc = s.decorators) != null || (s.decorators = []), (Xc = s.implements) != null || (s.implements = []), (Jc = s.superTypeArguments) != null || (s.superTypeArguments = void 0), (Kc = s.typeParameters) != null || (s.typeParameters = void 0);
          return;
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          (Yc = s.declare) != null || (s.declare = !1);
          return;
        case "VariableDeclarator":
          (Qc = s.definite) != null || (s.definite = !1);
          return;
        case "TSEnumDeclaration":
          (Zc = s.const) != null || (s.const = !1), (eh = s.declare) != null || (s.declare = !1);
          return;
        case "TSEnumMember":
          (th = s.computed) != null || (s.computed = !1);
          return;
        case "TSImportType":
          (rh = s.qualifier) != null || (s.qualifier = null), (sh = s.options) != null || (s.options = null);
          return;
        case "TSInterfaceDeclaration":
          (ih = s.declare) != null || (s.declare = !1), (nh = s.extends) != null || (s.extends = []);
          return;
        case "TSModuleDeclaration":
          (ah = s.declare) != null || (s.declare = !1), (oh = s.global) != null || (s.global = s.kind === "global");
          return;
        case "TSTypeParameter":
          (uh = s.const) != null || (s.const = !1), (lh = s.in) != null || (s.in = !1), (ch = s.out) != null || (s.out = !1);
          return;
      }
    }
  };
  function Xy(T) {
    if (T.type !== "MemberExpression") return !1;
    const {
      computed: a,
      property: s
    } = T;
    return a && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? !1 : Nc(T.object);
  }
  function Jy(T, a) {
    var s;
    const {
      type: o
    } = T;
    if ((s = T.extra) != null && s.parenthesized)
      return !1;
    if (a) {
      if (o === "Literal") {
        const {
          value: f
        } = T;
        if (typeof f == "string" || typeof f == "boolean")
          return !0;
      }
    } else if (o === "StringLiteral" || o === "BooleanLiteral")
      return !0;
    return !!(Ic(T, a) || Ky(T, a) || o === "TemplateLiteral" && T.expressions.length === 0 || Xy(T));
  }
  function Ic(T, a) {
    return a ? T.type === "Literal" && (typeof T.value == "number" || "bigint" in T) : T.type === "NumericLiteral" || T.type === "BigIntLiteral";
  }
  function Ky(T, a) {
    if (T.type === "UnaryExpression") {
      const {
        operator: s,
        argument: o
      } = T;
      if (s === "-" && Ic(o, a))
        return !0;
    }
    return !1;
  }
  function Nc(T) {
    return T.type === "Identifier" ? !0 : T.type !== "MemberExpression" || T.computed ? !1 : Nc(T.object);
  }
  const Oc = x`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var Yy = (T) => class extends T {
    parsePlaceholder(s) {
      if (this.match(133)) {
        const o = this.startNode();
        return this.next(), this.assertNoSpace(), o.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(o, s);
      }
    }
    finishPlaceholder(s, o) {
      let f = s;
      return (!f.expectedNode || !f.type) && (f = this.finishNode(f, "Placeholder")), f.expectedNode = o, f;
    }
    getTokenFromCode(s) {
      s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(s);
    }
    parseExprAtom(s) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(s);
    }
    parseIdentifier(s) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(s);
    }
    checkReservedWord(s, o, f, b) {
      s !== void 0 && super.checkReservedWord(s, o, f, b);
    }
    cloneIdentifier(s) {
      const o = super.cloneIdentifier(s);
      return o.type === "Placeholder" && (o.expectedNode = s.expectedNode), o;
    }
    cloneStringLiteral(s) {
      return s.type === "Placeholder" ? this.cloneIdentifier(s) : super.cloneStringLiteral(s);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(s, o, f) {
      return s === "Placeholder" || super.isValidLVal(s, o, f);
    }
    toAssignable(s, o) {
      s && s.type === "Placeholder" && s.expectedNode === "Expression" ? s.expectedNode = "Pattern" : super.toAssignable(s, o);
    }
    chStartsBindingIdentifier(s, o) {
      if (super.chStartsBindingIdentifier(s, o))
        return !0;
      const f = this.nextTokenStart();
      return this.input.charCodeAt(f) === 37 && this.input.charCodeAt(f + 1) === 37;
    }
    verifyBreakContinue(s, o) {
      s.label && s.label.type === "Placeholder" || super.verifyBreakContinue(s, o);
    }
    parseExpressionStatement(s, o) {
      var f;
      if (o.type !== "Placeholder" || (f = o.extra) != null && f.parenthesized)
        return super.parseExpressionStatement(s, o);
      if (this.match(14)) {
        const w = s;
        return w.label = this.finishPlaceholder(o, "Identifier"), this.next(), w.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(w, "LabeledStatement");
      }
      this.semicolon();
      const b = s;
      return b.name = o.name, this.finishPlaceholder(b, "Statement");
    }
    parseBlock(s, o, f) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(s, o, f);
    }
    parseFunctionId(s) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(s);
    }
    parseClass(s, o, f) {
      const b = o ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const w = this.state.strict, C = this.parsePlaceholder("Identifier");
      if (C)
        if (this.match(81) || this.match(133) || this.match(5))
          s.id = C;
        else {
          if (f || !o)
            return s.id = null, s.body = this.finishPlaceholder(C, "ClassBody"), this.finishNode(s, b);
          throw this.raise(Oc.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(s, o, f);
      return super.parseClassSuper(s), s.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!s.superClass, w), this.finishNode(s, b);
    }
    parseExport(s, o) {
      const f = this.parsePlaceholder("Identifier");
      if (!f) return super.parseExport(s, o);
      const b = s;
      if (!this.isContextual(98) && !this.match(12))
        return b.specifiers = [], b.source = null, b.declaration = this.finishPlaceholder(f, "Declaration"), this.finishNode(b, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const w = this.startNode();
      return w.exported = f, b.specifiers = [this.finishNode(w, "ExportDefaultSpecifier")], super.parseExport(b, o);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const s = this.nextTokenStart();
        if (this.isUnparsedContextual(s, "from") && this.input.startsWith(nt(133), this.nextTokenStartSince(s + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(s, o) {
      var f;
      return (f = s.specifiers) != null && f.length ? !0 : super.maybeParseExportDefaultSpecifier(s, o);
    }
    checkExport(s) {
      const {
        specifiers: o
      } = s;
      o != null && o.length && (s.specifiers = o.filter((f) => f.exported.type === "Placeholder")), super.checkExport(s), s.specifiers = o;
    }
    parseImport(s) {
      const o = this.parsePlaceholder("Identifier");
      if (!o) return super.parseImport(s);
      if (s.specifiers = [], !this.isContextual(98) && !this.match(12))
        return s.source = this.finishPlaceholder(o, "StringLiteral"), this.semicolon(), this.finishNode(s, "ImportDeclaration");
      const f = this.startNodeAtNode(o);
      return f.local = o, s.specifiers.push(this.finishNode(f, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(s) || this.parseNamedImportSpecifiers(s)), this.expectContextual(98), s.source = this.parseImportSource(), this.semicolon(), this.finishNode(s, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Oc.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, Qy = (T) => class extends T {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const s = this.state.startLoc, o = this.startNode();
        if (this.next(), Q(this.state.type)) {
          const f = this.parseIdentifierName(), b = this.createIdentifier(o, f);
          if (this.castNodeTo(b, "V8IntrinsicIdentifier"), this.match(10))
            return b;
        }
        this.unexpected(s);
      }
    }
    parseExprAtom(s) {
      return this.parseV8Intrinsic() || super.parseExprAtom(s);
    }
  };
  const kc = ["minimal", "fsharp", "hack", "smart"], Lc = ["^^", "@@", "^", "%", "#"];
  function Zy(T) {
    if (T.has("decorators")) {
      if (T.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const o = T.get("decorators").decoratorsBeforeExport;
      if (o != null && typeof o != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      const f = T.get("decorators").allowCallParenthesized;
      if (f != null && typeof f != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (T.has("flow") && T.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (T.has("placeholders") && T.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (T.has("pipelineOperator")) {
      var a;
      const o = T.get("pipelineOperator").proposal;
      if (!kc.includes(o)) {
        const f = kc.map((b) => `"${b}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${f}.`);
      }
      if (o === "hack") {
        if (T.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (T.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const f = T.get("pipelineOperator").topicToken;
        if (!Lc.includes(f)) {
          const b = Lc.map((w) => `"${w}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${b}.`);
        }
        {
          var s;
          if (f === "#" && ((s = T.get("recordAndTuple")) == null ? void 0 : s.syntaxType) === "hash")
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", T.get("recordAndTuple")])}\`.`);
        }
      } else if (o === "smart" && ((a = T.get("recordAndTuple")) == null ? void 0 : a.syntaxType) === "hash")
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", T.get("recordAndTuple")])}\`.`);
    }
    if (T.has("moduleAttributes")) {
      if (T.has("deprecatedImportAssert") || T.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (T.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (T.has("importAssertions") && T.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!T.has("deprecatedImportAssert") && T.has("importAttributes") && T.get("importAttributes").deprecatedAssertSyntax && T.set("deprecatedImportAssert", {}), T.has("recordAndTuple")) {
      const o = T.get("recordAndTuple").syntaxType;
      if (o != null) {
        const f = ["hash", "bar"];
        if (!f.includes(o))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + f.map((b) => `'${b}'`).join(", "));
      }
    }
    if (T.has("asyncDoExpressions") && !T.has("doExpressions")) {
      const o = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw o.missingPlugins = "doExpressions", o;
    }
    if (T.has("optionalChainingAssign") && T.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    if (T.has("discardBinding") && T.get("discardBinding").syntaxType !== "void")
      throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
  }
  const Rc = {
    estree: M,
    jsx: Ty,
    flow: Sy,
    typescript: Gy,
    v8intrinsic: Qy,
    placeholders: Yy
  }, eg = Object.keys(Rc);
  class tg extends Vy {
    checkProto(a, s, o, f) {
      if (a.type === "SpreadElement" || this.isObjectMethod(a) || a.computed || a.shorthand)
        return o;
      const b = a.key;
      return (b.type === "Identifier" ? b.name : b.value) === "__proto__" ? s ? (this.raise(v.RecordNoProto, b), !0) : (o && (f ? f.doubleProtoLoc === null && (f.doubleProtoLoc = b.loc.start) : this.raise(v.DuplicateProto, b)), !0) : o;
    }
    shouldExitDescending(a, s) {
      return a.type === "ArrowFunctionExpression" && this.offsetToSourcePos(a.start) === s;
    }
    getExpression() {
      if (this.enterInitialScopes(), this.nextToken(), this.match(140))
        throw this.raise(v.ParseExpressionEmptyInput, this.state.startLoc);
      const a = this.parseExpression();
      if (!this.match(140))
        throw this.raise(v.ParseExpressionExpectsEOF, this.state.startLoc, {
          unexpected: this.input.codePointAt(this.state.start)
        });
      return this.finalizeRemainingComments(), a.comments = this.comments, a.errors = this.state.errors, this.optionFlags & 256 && (a.tokens = this.tokens), a;
    }
    parseExpression(a, s) {
      return a ? this.disallowInAnd(() => this.parseExpressionBase(s)) : this.allowInAnd(() => this.parseExpressionBase(s));
    }
    parseExpressionBase(a) {
      const s = this.state.startLoc, o = this.parseMaybeAssign(a);
      if (this.match(12)) {
        const f = this.startNodeAt(s);
        for (f.expressions = [o]; this.eat(12); )
          f.expressions.push(this.parseMaybeAssign(a));
        return this.toReferencedList(f.expressions), this.finishNode(f, "SequenceExpression");
      }
      return o;
    }
    parseMaybeAssignDisallowIn(a, s) {
      return this.disallowInAnd(() => this.parseMaybeAssign(a, s));
    }
    parseMaybeAssignAllowIn(a, s) {
      return this.allowInAnd(() => this.parseMaybeAssign(a, s));
    }
    setOptionalParametersError(a) {
      a.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(a, s) {
      const o = this.state.startLoc, f = this.isContextual(108);
      if (f && this.prodParam.hasYield) {
        this.next();
        let D = this.parseYield(o);
        return s && (D = s.call(this, D, o)), D;
      }
      let b;
      a ? b = !1 : (a = new gi(), b = !0);
      const {
        type: w
      } = this.state;
      (w === 10 || Q(w)) && (this.state.potentialArrowAt = this.state.start);
      let C = this.parseMaybeConditional(a);
      if (s && (C = s.call(this, C, o)), it(this.state.type)) {
        const D = this.startNodeAt(o), F = this.state.value;
        if (D.operator = F, this.match(29)) {
          this.toAssignable(C, !0), D.left = C;
          const $ = o.index;
          a.doubleProtoLoc != null && a.doubleProtoLoc.index >= $ && (a.doubleProtoLoc = null), a.shorthandAssignLoc != null && a.shorthandAssignLoc.index >= $ && (a.shorthandAssignLoc = null), a.privateKeyLoc != null && a.privateKeyLoc.index >= $ && (this.checkDestructuringPrivate(a), a.privateKeyLoc = null), a.voidPatternLoc != null && a.voidPatternLoc.index >= $ && (a.voidPatternLoc = null);
        } else
          D.left = C;
        return this.next(), D.right = this.parseMaybeAssign(), this.checkLVal(C, this.finishNode(D, "AssignmentExpression")), D;
      } else b && this.checkExpressionErrors(a, !0);
      if (f) {
        const {
          type: D
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? we(D) : we(D) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(v.YieldNotInGeneratorFunction, o), this.parseYield(o);
      }
      return C;
    }
    parseMaybeConditional(a) {
      const s = this.state.startLoc, o = this.state.potentialArrowAt, f = this.parseExprOps(a);
      return this.shouldExitDescending(f, o) ? f : this.parseConditional(f, s, a);
    }
    parseConditional(a, s, o) {
      if (this.eat(17)) {
        const f = this.startNodeAt(s);
        return f.test = a, f.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), f.alternate = this.parseMaybeAssign(), this.finishNode(f, "ConditionalExpression");
      }
      return a;
    }
    parseMaybeUnaryOrPrivate(a) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(a);
    }
    parseExprOps(a) {
      const s = this.state.startLoc, o = this.state.potentialArrowAt, f = this.parseMaybeUnaryOrPrivate(a);
      return this.shouldExitDescending(f, o) ? f : this.parseExprOp(f, s, -1);
    }
    parseExprOp(a, s, o) {
      if (this.isPrivateName(a)) {
        const b = this.getPrivateNameSV(a);
        (o >= qr(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(v.PrivateInExpectedIn, a, {
          identifierName: b
        }), this.classScope.usePrivateName(b, a.loc.start);
      }
      const f = this.state.type;
      if (mt(f) && (this.prodParam.hasIn || !this.match(58))) {
        let b = qr(f);
        if (b > o) {
          if (f === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return a;
            this.checkPipelineAtInfixOperator(a, s);
          }
          const w = this.startNodeAt(s);
          w.left = a, w.operator = this.state.value;
          const C = f === 41 || f === 42, D = f === 40;
          if (D && (b = qr(42)), this.next(), f === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(v.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          w.right = this.parseExprOpRightExpr(f, b);
          const F = this.finishNode(w, C || D ? "LogicalExpression" : "BinaryExpression"), $ = this.state.type;
          if (D && ($ === 41 || $ === 42) || C && $ === 40)
            throw this.raise(v.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(F, s, o);
        }
      }
      return a;
    }
    parseExprOpRightExpr(a, s) {
      const o = this.state.startLoc;
      switch (a) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(s));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(v.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(a, s), o);
            });
        default:
          return this.parseExprOpBaseRightExpr(a, s);
      }
    }
    parseExprOpBaseRightExpr(a, s) {
      const o = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), o, Ia(a) ? s - 1 : s);
    }
    parseHackPipeBody() {
      var a;
      const {
        startLoc: s
      } = this.state, o = this.parseMaybeAssign();
      return m.has(o.type) && !((a = o.extra) != null && a.parenthesized) && this.raise(v.PipeUnparenthesizedBody, s, {
        type: o.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipeTopicUnused, s), o;
    }
    checkExponentialAfterUnary(a) {
      this.match(57) && this.raise(v.UnexpectedTokenUnaryExponentiation, a.argument);
    }
    parseMaybeUnary(a, s) {
      const o = this.state.startLoc, f = this.isContextual(96);
      if (f && this.recordAwaitIfAllowed()) {
        this.next();
        const D = this.parseAwait(o);
        return s || this.checkExponentialAfterUnary(D), D;
      }
      const b = this.match(34), w = this.startNode();
      if (Nt(this.state.type)) {
        w.operator = this.state.value, w.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        const D = this.match(89);
        if (this.next(), w.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(a, !0), this.state.strict && D) {
          const F = w.argument;
          F.type === "Identifier" ? this.raise(v.StrictDelete, w) : this.hasPropertyAsPrivateName(F) && this.raise(v.DeletePrivateField, w);
        }
        if (!b)
          return s || this.checkExponentialAfterUnary(w), this.finishNode(w, "UnaryExpression");
      }
      const C = this.parseUpdate(w, b, a);
      if (f) {
        const {
          type: D
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? we(D) : we(D) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(v.AwaitNotInAsyncContext, o), this.parseAwait(o);
      }
      return C;
    }
    parseUpdate(a, s, o) {
      if (s) {
        const w = a;
        return this.checkLVal(w.argument, this.finishNode(w, "UpdateExpression")), a;
      }
      const f = this.state.startLoc;
      let b = this.parseExprSubscripts(o);
      if (this.checkExpressionErrors(o, !1)) return b;
      for (; yt(this.state.type) && !this.canInsertSemicolon(); ) {
        const w = this.startNodeAt(f);
        w.operator = this.state.value, w.prefix = !1, w.argument = b, this.next(), this.checkLVal(b, b = this.finishNode(w, "UpdateExpression"));
      }
      return b;
    }
    parseExprSubscripts(a) {
      const s = this.state.startLoc, o = this.state.potentialArrowAt, f = this.parseExprAtom(a);
      return this.shouldExitDescending(f, o) ? f : this.parseSubscripts(f, s);
    }
    parseSubscripts(a, s, o) {
      const f = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(a),
        stop: !1
      };
      do
        a = this.parseSubscript(a, s, o, f), f.maybeAsyncArrow = !1;
      while (!f.stop);
      return a;
    }
    parseSubscript(a, s, o, f) {
      const {
        type: b
      } = this.state;
      if (!o && b === 15)
        return this.parseBind(a, s, o, f);
      if (jr(b))
        return this.parseTaggedTemplateExpression(a, s, f);
      let w = !1;
      if (b === 18) {
        if (o && (this.raise(v.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return this.stopParseSubscript(a, f);
        f.optionalChainMember = w = !0, this.next();
      }
      if (!o && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(a, s, f, w);
      {
        const C = this.eat(0);
        return C || w || this.eat(16) ? this.parseMember(a, s, f, C, w) : this.stopParseSubscript(a, f);
      }
    }
    stopParseSubscript(a, s) {
      return s.stop = !0, a;
    }
    parseMember(a, s, o, f, b) {
      const w = this.startNodeAt(s);
      return w.object = a, w.computed = f, f ? (w.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (a.type === "Super" && this.raise(v.SuperPrivateField, s), this.classScope.usePrivateName(this.state.value, this.state.startLoc), w.property = this.parsePrivateName()) : w.property = this.parseIdentifier(!0), o.optionalChainMember ? (w.optional = b, this.finishNode(w, "OptionalMemberExpression")) : this.finishNode(w, "MemberExpression");
    }
    parseBind(a, s, o, f) {
      const b = this.startNodeAt(s);
      return b.object = a, this.next(), b.callee = this.parseNoCallExpr(), f.stop = !0, this.parseSubscripts(this.finishNode(b, "BindExpression"), s, o);
    }
    parseCoverCallAndAsyncArrowHead(a, s, o, f) {
      const b = this.state.maybeInArrowParameters;
      let w = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const C = this.startNodeAt(s);
      C.callee = a;
      const {
        maybeAsyncArrow: D,
        optionalChainMember: F
      } = o;
      D && (this.expressionScope.enter(Uy()), w = new gi()), F && (C.optional = f), f ? C.arguments = this.parseCallExpressionArguments() : C.arguments = this.parseCallExpressionArguments(a.type !== "Super", C, w);
      let $ = this.finishCallExpression(C, F);
      return D && this.shouldParseAsyncArrow() && !f ? (o.stop = !0, this.checkDestructuringPrivate(w), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), $ = this.parseAsyncArrowFromCallExpression(this.startNodeAt(s), $)) : (D && (this.checkExpressionErrors(w, !0), this.expressionScope.exit()), this.toReferencedArguments($)), this.state.maybeInArrowParameters = b, $;
    }
    toReferencedArguments(a, s) {
      this.toReferencedListDeep(a.arguments, s);
    }
    parseTaggedTemplateExpression(a, s, o) {
      const f = this.startNodeAt(s);
      return f.tag = a, f.quasi = this.parseTemplate(!0), o.optionalChainMember && this.raise(v.OptionalChainingNoTemplate, s), this.finishNode(f, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(a) {
      return a.type === "Identifier" && a.name === "async" && this.state.lastTokEndLoc.index === a.end && !this.canInsertSemicolon() && a.end - a.start === 5 && this.offsetToSourcePos(a.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(a, s) {
      if (a.callee.type === "Import")
        if (a.arguments.length === 0 || a.arguments.length > 2)
          this.raise(v.ImportCallArity, a);
        else
          for (const o of a.arguments)
            o.type === "SpreadElement" && this.raise(v.ImportCallSpreadArgument, o);
      return this.finishNode(a, s ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(a, s, o) {
      const f = [];
      let b = !0;
      const w = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
        if (b)
          b = !1;
        else if (this.expect(12), this.match(11)) {
          s && this.addTrailingCommaExtraToNode(s), this.next();
          break;
        }
        f.push(this.parseExprListItem(11, !1, o, a));
      }
      return this.state.inFSharpPipelineDirectBody = w, f;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(a, s) {
      var o;
      return this.resetPreviousNodeTrailingComments(s), this.expect(19), this.parseArrowExpression(a, s.arguments, !0, (o = s.extra) == null ? void 0 : o.trailingCommaLoc), s.innerComments && vs(a, s.innerComments), s.callee.trailingComments && vs(a, s.callee.trailingComments), a;
    }
    parseNoCallExpr() {
      const a = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), a, !0);
    }
    parseExprAtom(a) {
      let s, o = null;
      const {
        type: f
      } = this.state;
      switch (f) {
        case 79:
          return this.parseSuper();
        case 83:
          return s = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(s) : this.match(10) ? this.optionFlags & 512 ? this.parseImportCall(s) : this.finishNode(s, "Import") : (this.raise(v.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(s, "Import"));
        case 78:
          return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const b = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(b);
        }
        case 0:
          return this.parseArrayLike(3, !0, !1, a);
        case 5:
          return this.parseObjectLike(8, !1, !1, a);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          o = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(o, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          s = this.startNode(), this.next(), s.object = null;
          const b = s.callee = this.parseNoCallExpr();
          if (b.type === "MemberExpression")
            return this.finishNode(s, "BindExpression");
          throw this.raise(v.UnsupportedBind, b);
        }
        case 139:
          return this.raise(v.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const b = this.getPluginOption("pipelineOperator", "proposal");
          if (b)
            return this.parseTopicReference(b);
          this.unexpected();
          break;
        }
        case 47: {
          const b = this.input.codePointAt(this.nextTokenStart());
          jt(b) || b === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          {
            if (f === 137)
              return this.parseDecimalLiteral(this.state.value);
            if (f === 2 || f === 1)
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
            if (f === 6 || f === 7)
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
          }
          if (Q(f)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            const b = this.state.potentialArrowAt === this.state.start, w = this.state.containsEsc, C = this.parseIdentifier();
            if (!w && C.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: D
              } = this.state;
              if (D === 68)
                return this.resetPreviousNodeTrailingComments(C), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(C));
              if (Q(D))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(C)) : C;
              if (D === 90)
                return this.resetPreviousNodeTrailingComments(C), this.parseDo(this.startNodeAtNode(C), !0);
            }
            return b && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(C), [C], !1)) : C;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(a, s) {
      const o = this.getPluginOption("pipelineOperator", "proposal");
      if (o)
        return this.state.type = a, this.state.value = s, this.state.pos--, this.state.end--, this.state.endLoc = i(this.state.endLoc, -1), this.parseTopicReference(o);
      this.unexpected();
    }
    parseTopicReference(a) {
      const s = this.startNode(), o = this.state.startLoc, f = this.state.type;
      return this.next(), this.finishTopicReference(s, o, a, f);
    }
    finishTopicReference(a, s, o, f) {
      if (this.testTopicReferenceConfiguration(o, s, f))
        return o === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(v.PipeTopicUnbound, s), this.registerTopicReference(), this.finishNode(a, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(v.PrimaryTopicNotAllowed, s), this.registerTopicReference(), this.finishNode(a, "PipelinePrimaryTopicReference"));
      throw this.raise(v.PipeTopicUnconfiguredToken, s, {
        token: nt(f)
      });
    }
    testTopicReferenceConfiguration(a, s, o) {
      switch (a) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: nt(o)
          }]);
        case "smart":
          return o === 27;
        default:
          throw this.raise(v.PipeTopicRequiresHackPipes, s);
      }
    }
    parseAsyncArrowUnaryFunction(a) {
      this.prodParam.enter(di(!0, this.prodParam.hasYield));
      const s = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(v.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(a, s, !0);
    }
    parseDo(a, s) {
      this.expectPlugin("doExpressions"), s && this.expectPlugin("asyncDoExpressions"), a.async = s, this.next();
      const o = this.state.labels;
      return this.state.labels = [], s ? (this.prodParam.enter(2), a.body = this.parseBlock(), this.prodParam.exit()) : a.body = this.parseBlock(), this.state.labels = o, this.finishNode(a, "DoExpression");
    }
    parseSuper() {
      const a = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(v.SuperNotAllowed, a) : !this.scope.allowSuper && !(this.optionFlags & 16) && this.raise(v.UnexpectedSuper, a), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(v.UnsupportedSuper, a), this.finishNode(a, "Super");
    }
    parsePrivateName() {
      const a = this.startNode(), s = this.startNodeAt(i(this.state.startLoc, 1)), o = this.state.value;
      return this.next(), a.id = this.createIdentifier(s, o), this.finishNode(a, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const a = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const s = this.createIdentifier(this.startNodeAtNode(a), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(a, s, "sent");
      }
      return this.parseFunction(a);
    }
    parseMetaProperty(a, s, o) {
      a.meta = s;
      const f = this.state.containsEsc;
      return a.property = this.parseIdentifier(!0), (a.property.name !== o || f) && this.raise(v.UnsupportedMetaProperty, a.property, {
        target: s.name,
        onlyValidPropertyName: o
      }), this.finishNode(a, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(a) {
      if (this.next(), this.isContextual(105) || this.isContextual(97)) {
        const s = this.isContextual(105);
        return this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), a.phase = s ? "source" : "defer", this.parseImportCall(a);
      } else {
        const s = this.createIdentifierAt(this.startNodeAtNode(a), "import", this.state.lastTokStartLoc);
        return this.isContextual(101) && (this.inModule || this.raise(v.ImportMetaOutsideModule, s), this.sawUnambiguousESM = !0), this.parseMetaProperty(a, s, "meta");
      }
    }
    parseLiteralAtNode(a, s, o) {
      return this.addExtra(o, "rawValue", a), this.addExtra(o, "raw", this.input.slice(this.offsetToSourcePos(o.start), this.state.end)), o.value = a, this.next(), this.finishNode(o, s);
    }
    parseLiteral(a, s) {
      const o = this.startNode();
      return this.parseLiteralAtNode(a, s, o);
    }
    parseStringLiteral(a) {
      return this.parseLiteral(a, "StringLiteral");
    }
    parseNumericLiteral(a) {
      return this.parseLiteral(a, "NumericLiteral");
    }
    parseBigIntLiteral(a) {
      return this.parseLiteral(a, "BigIntLiteral");
    }
    parseDecimalLiteral(a) {
      return this.parseLiteral(a, "DecimalLiteral");
    }
    parseRegExpLiteral(a) {
      const s = this.startNode();
      return this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.pattern = a.pattern, s.flags = a.flags, this.next(), this.finishNode(s, "RegExpLiteral");
    }
    parseBooleanLiteral(a) {
      const s = this.startNode();
      return s.value = a, this.next(), this.finishNode(s, "BooleanLiteral");
    }
    parseNullLiteral() {
      const a = this.startNode();
      return this.next(), this.finishNode(a, "NullLiteral");
    }
    parseParenAndDistinguishExpression(a) {
      const s = this.state.startLoc;
      let o;
      this.next(), this.expressionScope.enter($y());
      const f = this.state.maybeInArrowParameters, b = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const w = this.state.startLoc, C = [], D = new gi();
      let F = !0, $, q;
      for (; !this.match(11); ) {
        if (F)
          F = !1;
        else if (this.expect(12, D.optionalParametersLoc === null ? null : D.optionalParametersLoc), this.match(11)) {
          q = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const oe = this.state.startLoc;
          if ($ = this.state.startLoc, C.push(this.parseParenItem(this.parseRestBinding(), oe)), !this.checkCommaAfterRest(41))
            break;
        } else
          C.push(this.parseMaybeAssignAllowInOrVoidPattern(11, D, this.parseParenItem));
      }
      const J = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = f, this.state.inFSharpPipelineDirectBody = b;
      let ee = this.startNodeAt(s);
      return a && this.shouldParseArrow(C) && (ee = this.parseArrow(ee)) ? (this.checkDestructuringPrivate(D), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(ee, C, !1), ee) : (this.expressionScope.exit(), C.length || this.unexpected(this.state.lastTokStartLoc), q && this.unexpected(q), $ && this.unexpected($), this.checkExpressionErrors(D, !0), this.toReferencedListDeep(C, !0), C.length > 1 ? (o = this.startNodeAt(w), o.expressions = C, this.finishNode(o, "SequenceExpression"), this.resetEndLocation(o, J)) : o = C[0], this.wrapParenthesis(s, o));
    }
    wrapParenthesis(a, s) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", a.index), this.takeSurroundingComments(s, a.index, this.state.lastTokEndLoc.index), s;
      const o = this.startNodeAt(a);
      return o.expression = s, this.finishNode(o, "ParenthesizedExpression");
    }
    shouldParseArrow(a) {
      return !this.canInsertSemicolon();
    }
    parseArrow(a) {
      if (this.eat(19))
        return a;
    }
    parseParenItem(a, s) {
      return a;
    }
    parseNewOrNewTarget() {
      const a = this.startNode();
      if (this.next(), this.match(16)) {
        const s = this.createIdentifier(this.startNodeAtNode(a), "new");
        this.next();
        const o = this.parseMetaProperty(a, s, "target");
        return this.scope.allowNewTarget || this.raise(v.UnexpectedNewTarget, o), o;
      }
      return this.parseNew(a);
    }
    parseNew(a) {
      if (this.parseNewCallee(a), this.eat(10)) {
        const s = this.parseExprList(11);
        this.toReferencedList(s), a.arguments = s;
      } else
        a.arguments = [];
      return this.finishNode(a, "NewExpression");
    }
    parseNewCallee(a) {
      const s = this.match(83), o = this.parseNoCallExpr();
      a.callee = o, s && (o.type === "Import" || o.type === "ImportExpression") && this.raise(v.ImportCallNotNewExpression, o);
    }
    parseTemplateElement(a) {
      const {
        start: s,
        startLoc: o,
        end: f,
        value: b
      } = this.state, w = s + 1, C = this.startNodeAt(i(o, 1));
      b === null && (a || this.raise(v.InvalidEscapeSequenceTemplate, i(this.state.firstInvalidTemplateEscapePos, 1)));
      const D = this.match(24), F = D ? -1 : -2, $ = f + F;
      C.value = {
        raw: this.input.slice(w, $).replace(/\r\n?/g, `
`),
        cooked: b === null ? null : b.slice(1, F)
      }, C.tail = D, this.next();
      const q = this.finishNode(C, "TemplateElement");
      return this.resetEndLocation(q, i(this.state.lastTokEndLoc, F)), q;
    }
    parseTemplate(a) {
      const s = this.startNode();
      let o = this.parseTemplateElement(a);
      const f = [o], b = [];
      for (; !o.tail; )
        b.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), f.push(o = this.parseTemplateElement(a));
      return s.expressions = b, s.quasis = f, this.finishNode(s, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(a, s, o, f) {
      o && this.expectPlugin("recordAndTuple");
      const b = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let w = !1, C = !0;
      const D = this.startNode();
      for (D.properties = [], this.next(); !this.match(a); ) {
        if (C)
          C = !1;
        else if (this.expect(12), this.match(a)) {
          this.addTrailingCommaExtraToNode(D);
          break;
        }
        let $;
        s ? $ = this.parseBindingProperty() : ($ = this.parsePropertyDefinition(f), w = this.checkProto($, o, w, f)), o && !this.isObjectProperty($) && $.type !== "SpreadElement" && this.raise(v.InvalidRecordProperty, $), $.shorthand && this.addExtra($, "shorthand", !0), D.properties.push($);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = b;
      let F = "ObjectExpression";
      return s ? F = "ObjectPattern" : o && (F = "RecordExpression"), this.finishNode(D, F);
    }
    addTrailingCommaExtraToNode(a) {
      this.addExtra(a, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(a, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(a) {
      return !a.computed && a.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(a) {
      let s = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(v.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          s.push(this.parseDecorator());
      const o = this.startNode();
      let f = !1, b = !1, w;
      if (this.match(21))
        return s.length && this.unexpected(), this.parseSpread();
      s.length && (o.decorators = s, s = []), o.method = !1, a && (w = this.state.startLoc);
      let C = this.eat(55);
      this.parsePropertyNamePrefixOperator(o);
      const D = this.state.containsEsc;
      if (this.parsePropertyName(o, a), !C && !D && this.maybeAsyncOrAccessorProp(o)) {
        const {
          key: F
        } = o, $ = F.name;
        $ === "async" && !this.hasPrecedingLineBreak() && (f = !0, this.resetPreviousNodeTrailingComments(F), C = this.eat(55), this.parsePropertyName(o)), ($ === "get" || $ === "set") && (b = !0, this.resetPreviousNodeTrailingComments(F), o.kind = $, this.match(55) && (C = !0, this.raise(v.AccessorIsGenerator, this.state.curPosition(), {
          kind: $
        }), this.next()), this.parsePropertyName(o));
      }
      return this.parseObjPropValue(o, w, C, f, !1, b, a);
    }
    getGetterSetterExpectedParamCount(a) {
      return a.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(a) {
      return a.params;
    }
    checkGetterSetterParams(a) {
      var s;
      const o = this.getGetterSetterExpectedParamCount(a), f = this.getObjectOrClassMethodParams(a);
      f.length !== o && this.raise(a.kind === "get" ? v.BadGetterArity : v.BadSetterArity, a), a.kind === "set" && ((s = f[f.length - 1]) == null ? void 0 : s.type) === "RestElement" && this.raise(v.BadSetterRestParameter, a);
    }
    parseObjectMethod(a, s, o, f, b) {
      if (b) {
        const w = this.parseMethod(a, s, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(w), w;
      }
      if (o || s || this.match(10))
        return f && this.unexpected(), a.kind = "method", a.method = !0, this.parseMethod(a, s, o, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(a, s, o, f) {
      if (a.shorthand = !1, this.eat(14))
        return a.value = o ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, f), this.finishObjectProperty(a);
      if (!a.computed && a.key.type === "Identifier") {
        if (this.checkReservedWord(a.key.name, a.key.loc.start, !0, !1), o)
          a.value = this.parseMaybeDefault(s, this.cloneIdentifier(a.key));
        else if (this.match(29)) {
          const b = this.state.startLoc;
          f != null ? f.shorthandAssignLoc === null && (f.shorthandAssignLoc = b) : this.raise(v.InvalidCoverInitializedName, b), a.value = this.parseMaybeDefault(s, this.cloneIdentifier(a.key));
        } else
          a.value = this.cloneIdentifier(a.key);
        return a.shorthand = !0, this.finishObjectProperty(a);
      }
    }
    finishObjectProperty(a) {
      return this.finishNode(a, "ObjectProperty");
    }
    parseObjPropValue(a, s, o, f, b, w, C) {
      const D = this.parseObjectMethod(a, o, f, b, w) || this.parseObjectProperty(a, s, b, C);
      return D || this.unexpected(), D;
    }
    parsePropertyName(a, s) {
      if (this.eat(0))
        a.computed = !0, a.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: o,
          value: f
        } = this.state;
        let b;
        if (le(o))
          b = this.parseIdentifier(!0);
        else
          switch (o) {
            case 135:
              b = this.parseNumericLiteral(f);
              break;
            case 134:
              b = this.parseStringLiteral(f);
              break;
            case 136:
              b = this.parseBigIntLiteral(f);
              break;
            case 139: {
              const w = this.state.startLoc;
              s != null ? s.privateKeyLoc === null && (s.privateKeyLoc = w) : this.raise(v.UnexpectedPrivateField, w), b = this.parsePrivateName();
              break;
            }
            default:
              if (o === 137) {
                b = this.parseDecimalLiteral(f);
                break;
              }
              this.unexpected();
          }
        a.key = b, o !== 139 && (a.computed = !1);
      }
    }
    initFunction(a, s) {
      a.id = null, a.generator = !1, a.async = s;
    }
    parseMethod(a, s, o, f, b, w, C = !1) {
      this.initFunction(a, o), a.generator = s, this.scope.enter(530 | (C ? 576 : 0) | (b ? 32 : 0)), this.prodParam.enter(di(o, a.generator)), this.parseFunctionParams(a, f);
      const D = this.parseFunctionBodyAndFinish(a, w, !0);
      return this.prodParam.exit(), this.scope.exit(), D;
    }
    parseArrayLike(a, s, o, f) {
      o && this.expectPlugin("recordAndTuple");
      const b = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const w = this.startNode();
      return this.next(), w.elements = this.parseExprList(a, !o, f, w), this.state.inFSharpPipelineDirectBody = b, this.finishNode(w, o ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(a, s, o, f) {
      this.scope.enter(518);
      let b = di(o, !1);
      !this.match(5) && this.prodParam.hasIn && (b |= 8), this.prodParam.enter(b), this.initFunction(a, o);
      const w = this.state.maybeInArrowParameters;
      return s && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(a, s, f)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(a, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = w, this.finishNode(a, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(a, s, o) {
      this.toAssignableList(s, o, !1), a.params = s;
    }
    parseFunctionBodyAndFinish(a, s, o = !1) {
      return this.parseFunctionBody(a, !1, o), this.finishNode(a, s);
    }
    parseFunctionBody(a, s, o = !1) {
      const f = s && !this.match(5);
      if (this.expressionScope.enter(Pc()), f)
        a.body = this.parseMaybeAssign(), this.checkParams(a, !1, s, !1);
      else {
        const b = this.state.strict, w = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), a.body = this.parseBlock(!0, !1, (C) => {
          const D = !this.isSimpleParamList(a.params);
          C && D && this.raise(v.IllegalLanguageModeDirective, (a.kind === "method" || a.kind === "constructor") && a.key ? a.key.loc.end : a);
          const F = !b && this.state.strict;
          this.checkParams(a, !this.state.strict && !s && !o && !D, s, F), this.state.strict && a.id && this.checkIdentifier(a.id, 65, F);
        }), this.prodParam.exit(), this.state.labels = w;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(a) {
      return a.type === "Identifier";
    }
    isSimpleParamList(a) {
      for (let s = 0, o = a.length; s < o; s++)
        if (!this.isSimpleParameter(a[s])) return !1;
      return !0;
    }
    checkParams(a, s, o, f = !0) {
      const b = !s && /* @__PURE__ */ new Set(), w = {
        type: "FormalParameters"
      };
      for (const C of a.params)
        this.checkLVal(C, w, 5, b, f);
    }
    parseExprList(a, s, o, f) {
      const b = [];
      let w = !0;
      for (; !this.eat(a); ) {
        if (w)
          w = !1;
        else if (this.expect(12), this.match(a)) {
          f && this.addTrailingCommaExtraToNode(f), this.next();
          break;
        }
        b.push(this.parseExprListItem(a, s, o));
      }
      return b;
    }
    parseExprListItem(a, s, o, f) {
      let b;
      if (this.match(12))
        s || this.raise(v.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), b = null;
      else if (this.match(21)) {
        const w = this.state.startLoc;
        b = this.parseParenItem(this.parseSpread(o), w);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), f || this.raise(v.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const w = this.startNode();
        this.next(), b = this.finishNode(w, "ArgumentPlaceholder");
      } else
        b = this.parseMaybeAssignAllowInOrVoidPattern(a, o, this.parseParenItem);
      return b;
    }
    parseIdentifier(a) {
      const s = this.startNode(), o = this.parseIdentifierName(a);
      return this.createIdentifier(s, o);
    }
    createIdentifier(a, s) {
      return a.name = s, a.loc.identifierName = s, this.finishNode(a, "Identifier");
    }
    createIdentifierAt(a, s, o) {
      return a.name = s, a.loc.identifierName = s, this.finishNodeAt(a, "Identifier", o);
    }
    parseIdentifierName(a) {
      let s;
      const {
        startLoc: o,
        type: f
      } = this.state;
      le(f) ? s = this.state.value : this.unexpected();
      const b = Z(f);
      return a ? b && this.replaceToken(132) : this.checkReservedWord(s, o, b, !1), this.next(), s;
    }
    checkReservedWord(a, s, o, f) {
      if (a.length > 10 || !hy(a))
        return;
      if (o && uy(a)) {
        this.raise(v.UnexpectedKeyword, s, {
          keyword: a
        });
        return;
      }
      if ((this.state.strict ? f ? yc : dc : pc)(a, this.inModule)) {
        this.raise(v.UnexpectedReservedWord, s, {
          reservedWord: a
        });
        return;
      } else if (a === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(v.YieldBindingIdentifier, s);
          return;
        }
      } else if (a === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(v.AwaitBindingIdentifier, s);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(v.AwaitBindingIdentifierInStaticBlock, s);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(s);
      } else if (a === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(v.ArgumentsInClass, s);
        return;
      }
    }
    recordAwaitIfAllowed() {
      const a = this.prodParam.hasAwait;
      return a && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), a;
    }
    parseAwait(a) {
      const s = this.startNodeAt(a);
      return this.expressionScope.recordParameterInitializerError(v.AwaitExpressionFormalParameter, s), this.eat(55) && this.raise(v.ObsoleteAwaitStar, s), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, !0)), this.finishNode(s, "AwaitExpression");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      const {
        type: a
      } = this.state;
      return a === 53 || a === 10 || a === 0 || jr(a) || a === 102 && !this.state.containsEsc || a === 138 || a === 56 || this.hasPlugin("v8intrinsic") && a === 54;
    }
    parseYield(a) {
      const s = this.startNodeAt(a);
      this.expressionScope.recordParameterInitializerError(v.YieldInParameter, s);
      let o = !1, f = null;
      if (!this.hasPrecedingLineBreak())
        switch (o = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!o) break;
          default:
            f = this.parseMaybeAssign();
        }
      return s.delegate = o, s.argument = f, this.finishNode(s, "YieldExpression");
    }
    parseImportCall(a) {
      if (this.next(), a.source = this.parseMaybeAssignAllowIn(), a.options = null, this.eat(12)) {
        if (this.match(11))
          this.addTrailingCommaExtraToNode(a.source);
        else if (a.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(a.options), !this.match(11))) {
          do
            this.parseMaybeAssignAllowIn();
          while (this.eat(12) && !this.match(11));
          this.raise(v.ImportCallArity, a);
        }
      }
      return this.expect(11), this.finishNode(a, "ImportExpression");
    }
    checkPipelineAtInfixOperator(a, s) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && a.type === "SequenceExpression" && this.raise(v.PipelineHeadSequenceExpression, s);
    }
    parseSmartPipelineBodyInStyle(a, s) {
      if (this.isSimpleReference(a)) {
        const o = this.startNodeAt(s);
        return o.callee = a, this.finishNode(o, "PipelineBareFunction");
      } else {
        const o = this.startNodeAt(s);
        return this.checkSmartPipeTopicBodyEarlyErrors(s), o.expression = a, this.finishNode(o, "PipelineTopicExpression");
      }
    }
    isSimpleReference(a) {
      switch (a.type) {
        case "MemberExpression":
          return !a.computed && this.isSimpleReference(a.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(a) {
      if (this.match(19))
        throw this.raise(v.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipelineTopicUnused, a);
    }
    withTopicBindingContext(a) {
      const s = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return a();
      } finally {
        this.state.topicContext = s;
      }
    }
    withSmartMixTopicForbiddingContext(a) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const s = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return a();
        } finally {
          this.state.topicContext = s;
        }
      } else
        return a();
    }
    withSoloAwaitPermittingContext(a) {
      const s = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return a();
      } finally {
        this.state.soloAwait = s;
      }
    }
    allowInAnd(a) {
      const s = this.prodParam.currentFlags();
      if (8 & ~s) {
        this.prodParam.enter(s | 8);
        try {
          return a();
        } finally {
          this.prodParam.exit();
        }
      }
      return a();
    }
    disallowInAnd(a) {
      const s = this.prodParam.currentFlags();
      if (8 & s) {
        this.prodParam.enter(s & -9);
        try {
          return a();
        } finally {
          this.prodParam.exit();
        }
      }
      return a();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(a) {
      const s = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const f = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, a);
      return this.state.inFSharpPipelineDirectBody = o, f;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const a = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const s = this.startNodeAt(this.state.endLoc);
      this.next();
      const o = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        a.body = this.parseProgram(s, 8, "module");
      } finally {
        o();
      }
      return this.finishNode(a, "ModuleExpression");
    }
    parseVoidPattern(a) {
      this.expectPlugin("discardBinding");
      const s = this.startNode();
      return a != null && (a.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(s, "VoidPattern");
    }
    parseMaybeAssignAllowInOrVoidPattern(a, s, o) {
      if (s != null && this.match(88)) {
        const f = this.lookaheadCharCode();
        if (f === 44 || f === (a === 3 ? 93 : a === 8 ? 125 : 41) || f === 61)
          return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(s));
      }
      return this.parseMaybeAssignAllowIn(s, o);
    }
    parsePropertyNamePrefixOperator(a) {
    }
  }
  const $a = {
    kind: 1
  }, rg = {
    kind: 2
  }, sg = /[\uD800-\uDFFF]/u, Ua = /in(?:stanceof)?/y;
  function ig(T, a, s) {
    for (let o = 0; o < T.length; o++) {
      const f = T[o], {
        type: b
      } = f;
      if (typeof b == "number") {
        {
          if (b === 139) {
            const {
              loc: w,
              start: C,
              value: D,
              end: F
            } = f, $ = C + 1, q = i(w.start, 1);
            T.splice(o, 1, new tr({
              type: Tt(27),
              value: "#",
              start: C,
              end: $,
              startLoc: w.start,
              endLoc: q
            }), new tr({
              type: Tt(132),
              value: D,
              start: $,
              end: F,
              startLoc: q,
              endLoc: w.end
            })), o++;
            continue;
          }
          if (jr(b)) {
            const {
              loc: w,
              start: C,
              value: D,
              end: F
            } = f, $ = C + 1, q = i(w.start, 1);
            let J;
            a.charCodeAt(C - s) === 96 ? J = new tr({
              type: Tt(22),
              value: "`",
              start: C,
              end: $,
              startLoc: w.start,
              endLoc: q
            }) : J = new tr({
              type: Tt(8),
              value: "}",
              start: C,
              end: $,
              startLoc: w.start,
              endLoc: q
            });
            let ee, oe, me, Re;
            b === 24 ? (oe = F - 1, me = i(w.end, -1), ee = D === null ? null : D.slice(1, -1), Re = new tr({
              type: Tt(22),
              value: "`",
              start: oe,
              end: F,
              startLoc: me,
              endLoc: w.end
            })) : (oe = F - 2, me = i(w.end, -2), ee = D === null ? null : D.slice(1, -2), Re = new tr({
              type: Tt(23),
              value: "${",
              start: oe,
              end: F,
              startLoc: me,
              endLoc: w.end
            })), T.splice(o, 1, J, new tr({
              type: Tt(20),
              value: ee,
              start: $,
              end: oe,
              startLoc: q,
              endLoc: me
            }), Re), o += 2;
            continue;
          }
        }
        f.type = Tt(b);
      }
    }
    return T;
  }
  class ng extends tg {
    parseTopLevel(a, s) {
      return a.program = this.parseProgram(s, 140, this.options.sourceType === "module" ? "module" : "script"), a.comments = this.comments, this.optionFlags & 256 && (a.tokens = ig(this.tokens, this.input, this.startIndex)), this.finishNode(a, "File");
    }
    parseProgram(a, s, o) {
      if (a.sourceType = o, a.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(a, !0, !0, s), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (const [b, w] of Array.from(this.scope.undefinedExports))
            this.raise(v.ModuleExportUndefined, w, {
              localName: b
            });
        this.addExtra(a, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let f;
      return s === 140 ? f = this.finishNode(a, "Program") : f = this.finishNodeAt(a, "Program", i(this.state.startLoc, -1)), f;
    }
    stmtToDirective(a) {
      const s = this.castNodeTo(a, "Directive"), o = this.castNodeTo(a.expression, "DirectiveLiteral"), f = o.value, b = this.input.slice(this.offsetToSourcePos(o.start), this.offsetToSourcePos(o.end)), w = o.value = b.slice(1, -1);
      return this.addExtra(o, "raw", b), this.addExtra(o, "rawValue", w), this.addExtra(o, "expressionValue", f), s.value = o, delete a.expression, s;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const a = this.startNode();
      return a.value = this.state.value, this.next(), this.finishNode(a, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    isUsing() {
      if (!this.isContextual(107))
        return !1;
      const a = this.nextTokenInLineStart(), s = this.codePointAtPos(a);
      return this.chStartsBindingIdentifier(s, a);
    }
    isForUsing() {
      if (!this.isContextual(107))
        return !1;
      const a = this.nextTokenInLineStart(), s = this.codePointAtPos(a);
      if (this.isUnparsedContextual(a, "of")) {
        const o = this.lookaheadCharCodeSince(a + 2);
        if (o !== 61 && o !== 58 && o !== 59)
          return !1;
      }
      return !!(this.chStartsBindingIdentifier(s, a) || this.isUnparsedContextual(a, "void"));
    }
    isAwaitUsing() {
      if (!this.isContextual(96))
        return !1;
      let a = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(a, "using")) {
        a = this.nextTokenInLineStartSince(a + 5);
        const s = this.codePointAtPos(a);
        if (this.chStartsBindingIdentifier(s, a))
          return !0;
      }
      return !1;
    }
    chStartsBindingIdentifier(a, s) {
      if (jt(a)) {
        if (Ua.lastIndex = s, Ua.test(this.input)) {
          const o = this.codePointAtPos(Ua.lastIndex);
          if (!Vr(o) && o !== 92)
            return !1;
        }
        return !0;
      } else return a === 92;
    }
    chStartsBindingPattern(a) {
      return a === 91 || a === 123;
    }
    hasFollowingBindingAtom() {
      const a = this.nextTokenStart(), s = this.codePointAtPos(a);
      return this.chStartsBindingPattern(s) || this.chStartsBindingIdentifier(s, a);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      const a = this.nextTokenInLineStart(), s = this.codePointAtPos(a);
      return s === 123 || this.chStartsBindingIdentifier(s, a);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(a = !1) {
      let s = 0;
      return this.options.annexB && !this.state.strict && (s |= 4, a && (s |= 8)), this.parseStatementLike(s);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(a) {
      let s = null;
      return this.match(26) && (s = this.parseDecorators(!0)), this.parseStatementContent(a, s);
    }
    parseStatementContent(a, s) {
      const o = this.state.type, f = this.startNode(), b = !!(a & 2), w = !!(a & 4), C = a & 1;
      switch (o) {
        case 60:
          return this.parseBreakContinueStatement(f, !0);
        case 63:
          return this.parseBreakContinueStatement(f, !1);
        case 64:
          return this.parseDebuggerStatement(f);
        case 90:
          return this.parseDoWhileStatement(f);
        case 91:
          return this.parseForStatement(f);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return w || this.raise(this.state.strict ? v.StrictFunction : this.options.annexB ? v.SloppyFunctionAnnexB : v.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(f, !1, !b && w);
        case 80:
          return b || this.unexpected(), this.parseClass(this.maybeTakeDecorators(s, f), !0);
        case 69:
          return this.parseIfStatement(f);
        case 70:
          return this.parseReturnStatement(f);
        case 71:
          return this.parseSwitchStatement(f);
        case 72:
          return this.parseThrowStatement(f);
        case 73:
          return this.parseTryStatement(f);
        case 96:
          if (this.isAwaitUsing())
            return this.allowsUsing() ? b ? this.recordAwaitIfAllowed() || this.raise(v.AwaitUsingNotInAsyncContext, f) : this.raise(v.UnexpectedLexicalDeclaration, f) : this.raise(v.UnexpectedUsingDeclaration, f), this.next(), this.parseVarStatement(f, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.allowsUsing() ? b || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(v.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(f, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          const $ = this.nextTokenStart(), q = this.codePointAtPos($);
          if (q !== 91 && (!b && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(q, $) && q !== 123))
            break;
        }
        case 75:
          b || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const $ = this.state.value;
          return this.parseVarStatement(f, $);
        }
        case 92:
          return this.parseWhileStatement(f);
        case 76:
          return this.parseWithStatement(f);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(f);
        case 83: {
          const $ = this.lookaheadCharCode();
          if ($ === 40 || $ === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !C && this.raise(v.UnexpectedImportExport, this.state.startLoc), this.next();
          let $;
          return o === 83 ? $ = this.parseImport(f) : $ = this.parseExport(f, s), this.assertModuleNodeAllowed($), $;
        }
        default:
          if (this.isAsyncFunction())
            return b || this.raise(v.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(f, !0, !b && w);
      }
      const D = this.state.value, F = this.parseExpression();
      return Q(o) && F.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(f, D, F, a) : this.parseExpressionStatement(f, F, s);
    }
    assertModuleNodeAllowed(a) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(v.ImportOutsideModule, a);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(a, s, o) {
      if (a) {
        var f;
        (f = s.decorators) != null && f.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(v.DecoratorsBeforeAfterExport, s.decorators[0]), s.decorators.unshift(...a)) : s.decorators = a, this.resetStartLocationFromNode(s, a[0]), o && this.resetStartLocationFromNode(o, s);
      }
      return s;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(a) {
      const s = [];
      do
        s.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        a || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(v.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(v.UnexpectedLeadingDecorator, this.state.startLoc);
      return s;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const a = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const s = this.state.startLoc;
        let o;
        if (this.match(10)) {
          const f = this.state.startLoc;
          this.next(), o = this.parseExpression(), this.expect(11), o = this.wrapParenthesis(f, o);
          const b = this.state.startLoc;
          a.expression = this.parseMaybeDecoratorArguments(o, f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && a.expression !== o && this.raise(v.DecoratorArgumentsOutsideParentheses, b);
        } else {
          for (o = this.parseIdentifier(!1); this.eat(16); ) {
            const f = this.startNodeAt(s);
            f.object = o, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), f.property = this.parsePrivateName()) : f.property = this.parseIdentifier(!0), f.computed = !1, o = this.finishNode(f, "MemberExpression");
          }
          a.expression = this.parseMaybeDecoratorArguments(o, s);
        }
      } else
        a.expression = this.parseExprSubscripts();
      return this.finishNode(a, "Decorator");
    }
    parseMaybeDecoratorArguments(a, s) {
      if (this.eat(10)) {
        const o = this.startNodeAt(s);
        return o.callee = a, o.arguments = this.parseCallExpressionArguments(), this.toReferencedList(o.arguments), this.finishNode(o, "CallExpression");
      }
      return a;
    }
    parseBreakContinueStatement(a, s) {
      return this.next(), this.isLineTerminator() ? a.label = null : (a.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(a, s), this.finishNode(a, s ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(a, s) {
      let o;
      for (o = 0; o < this.state.labels.length; ++o) {
        const f = this.state.labels[o];
        if ((a.label == null || f.name === a.label.name) && (f.kind != null && (s || f.kind === 1) || a.label && s))
          break;
      }
      if (o === this.state.labels.length) {
        const f = s ? "BreakStatement" : "ContinueStatement";
        this.raise(v.IllegalBreakContinue, a, {
          type: f
        });
      }
    }
    parseDebuggerStatement(a) {
      return this.next(), this.semicolon(), this.finishNode(a, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const a = this.parseExpression();
      return this.expect(11), a;
    }
    parseDoWhileStatement(a) {
      return this.next(), this.state.labels.push($a), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), a.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(a, "DoWhileStatement");
    }
    parseForStatement(a) {
      this.next(), this.state.labels.push($a);
      let s = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (s = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13))
        return s !== null && this.unexpected(s), this.parseFor(a, null);
      const o = this.isContextual(100);
      {
        const D = this.isAwaitUsing(), F = D || this.isForUsing(), $ = o && this.hasFollowingBindingAtom() || F;
        if (this.match(74) || this.match(75) || $) {
          const q = this.startNode();
          let J;
          D ? (J = "await using", this.recordAwaitIfAllowed() || this.raise(v.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : J = this.state.value, this.next(), this.parseVar(q, !0, J);
          const ee = this.finishNode(q, "VariableDeclaration"), oe = this.match(58);
          return oe && F && this.raise(v.ForInUsing, ee), (oe || this.isContextual(102)) && ee.declarations.length === 1 ? this.parseForIn(a, ee, s) : (s !== null && this.unexpected(s), this.parseFor(a, ee));
        }
      }
      const f = this.isContextual(95), b = new gi(), w = this.parseExpression(!0, b), C = this.isContextual(102);
      if (C && (o && this.raise(v.ForOfLet, w), s === null && f && w.type === "Identifier" && this.raise(v.ForOfAsync, w)), C || this.match(58)) {
        this.checkDestructuringPrivate(b), this.toAssignable(w, !0);
        const D = C ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(w, {
          type: D
        }), this.parseForIn(a, w, s);
      } else
        this.checkExpressionErrors(b, !0);
      return s !== null && this.unexpected(s), this.parseFor(a, w);
    }
    parseFunctionStatement(a, s, o) {
      return this.next(), this.parseFunction(a, 1 | (o ? 2 : 0) | (s ? 8 : 0));
    }
    parseIfStatement(a) {
      return this.next(), a.test = this.parseHeaderExpression(), a.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), a.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(a, "IfStatement");
    }
    parseReturnStatement(a) {
      return this.prodParam.hasReturn || this.raise(v.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? a.argument = null : (a.argument = this.parseExpression(), this.semicolon()), this.finishNode(a, "ReturnStatement");
    }
    parseSwitchStatement(a) {
      this.next(), a.discriminant = this.parseHeaderExpression();
      const s = a.cases = [];
      this.expect(5), this.state.labels.push(rg), this.scope.enter(256);
      let o;
      for (let f; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const b = this.match(61);
          o && this.finishNode(o, "SwitchCase"), s.push(o = this.startNode()), o.consequent = [], this.next(), b ? o.test = this.parseExpression() : (f && this.raise(v.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), f = !0, o.test = null), this.expect(14);
        } else
          o ? o.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), o && this.finishNode(o, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(a, "SwitchStatement");
    }
    parseThrowStatement(a) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(v.NewlineAfterThrow, this.state.lastTokEndLoc), a.argument = this.parseExpression(), this.semicolon(), this.finishNode(a, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const a = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && a.type === "Identifier" ? 8 : 0), this.checkLVal(a, {
        type: "CatchClause"
      }, 9), a;
    }
    parseTryStatement(a) {
      if (this.next(), a.block = this.parseBlock(), a.handler = null, this.match(62)) {
        const s = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), s.param = this.parseCatchClauseParam(), this.expect(11)) : (s.param = null, this.scope.enter(0)), s.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), a.handler = this.finishNode(s, "CatchClause");
      }
      return a.finalizer = this.eat(67) ? this.parseBlock() : null, !a.handler && !a.finalizer && this.raise(v.NoCatchOrFinally, a), this.finishNode(a, "TryStatement");
    }
    parseVarStatement(a, s, o = !1) {
      return this.next(), this.parseVar(a, !1, s, o), this.semicolon(), this.finishNode(a, "VariableDeclaration");
    }
    parseWhileStatement(a) {
      return this.next(), a.test = this.parseHeaderExpression(), this.state.labels.push($a), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(a, "WhileStatement");
    }
    parseWithStatement(a) {
      return this.state.strict && this.raise(v.StrictWith, this.state.startLoc), this.next(), a.object = this.parseHeaderExpression(), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(a, "WithStatement");
    }
    parseEmptyStatement(a) {
      return this.next(), this.finishNode(a, "EmptyStatement");
    }
    parseLabeledStatement(a, s, o, f) {
      for (const w of this.state.labels)
        w.name === s && this.raise(v.LabelRedeclaration, o, {
          labelName: s
        });
      const b = tt(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let w = this.state.labels.length - 1; w >= 0; w--) {
        const C = this.state.labels[w];
        if (C.statementStart === a.start)
          C.statementStart = this.sourceToOffsetPos(this.state.start), C.kind = b;
        else
          break;
      }
      return this.state.labels.push({
        name: s,
        kind: b,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), a.body = f & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), a.label = o, this.finishNode(a, "LabeledStatement");
    }
    parseExpressionStatement(a, s, o) {
      return a.expression = s, this.semicolon(), this.finishNode(a, "ExpressionStatement");
    }
    parseBlock(a = !1, s = !0, o) {
      const f = this.startNode();
      return a && this.state.strictErrors.clear(), this.expect(5), s && this.scope.enter(0), this.parseBlockBody(f, a, !1, 8, o), s && this.scope.exit(), this.finishNode(f, "BlockStatement");
    }
    isValidDirective(a) {
      return a.type === "ExpressionStatement" && a.expression.type === "StringLiteral" && !a.expression.extra.parenthesized;
    }
    parseBlockBody(a, s, o, f, b) {
      const w = a.body = [], C = a.directives = [];
      this.parseBlockOrModuleBlockBody(w, s ? C : void 0, o, f, b);
    }
    parseBlockOrModuleBlockBody(a, s, o, f, b) {
      const w = this.state.strict;
      let C = !1, D = !1;
      for (; !this.match(f); ) {
        const F = o ? this.parseModuleItem() : this.parseStatementListItem();
        if (s && !D) {
          if (this.isValidDirective(F)) {
            const $ = this.stmtToDirective(F);
            s.push($), !C && $.value.value === "use strict" && (C = !0, this.setStrict(!0));
            continue;
          }
          D = !0, this.state.strictErrors.clear();
        }
        a.push(F);
      }
      b == null || b.call(this, C), w || this.setStrict(!1), this.next();
    }
    parseFor(a, s) {
      return a.init = s, this.semicolon(!1), a.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), a.update = this.match(11) ? null : this.parseExpression(), this.expect(11), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(a, "ForStatement");
    }
    parseForIn(a, s, o) {
      const f = this.match(58);
      return this.next(), f ? o !== null && this.unexpected(o) : a.await = o !== null, s.type === "VariableDeclaration" && s.declarations[0].init != null && (!f || !this.options.annexB || this.state.strict || s.kind !== "var" || s.declarations[0].id.type !== "Identifier") && this.raise(v.ForInOfLoopInitializer, s, {
        type: f ? "ForInStatement" : "ForOfStatement"
      }), s.type === "AssignmentPattern" && this.raise(v.InvalidLhs, s, {
        ancestor: {
          type: "ForStatement"
        }
      }), a.left = s, a.right = f ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(a, f ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(a, s, o, f = !1) {
      const b = a.declarations = [];
      for (a.kind = o; ; ) {
        const w = this.startNode();
        if (this.parseVarId(w, o), w.init = this.eat(29) ? s ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, w.init === null && !f && (w.id.type !== "Identifier" && !(s && (this.match(58) || this.isContextual(102))) ? this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (o === "const" || o === "using" || o === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: o
        })), b.push(this.finishNode(w, "VariableDeclarator")), !this.eat(12)) break;
      }
      return a;
    }
    parseVarId(a, s) {
      const o = this.parseBindingAtom();
      s === "using" || s === "await using" ? (o.type === "ArrayPattern" || o.type === "ObjectPattern") && this.raise(v.UsingDeclarationHasBindingPattern, o.loc.start) : o.type === "VoidPattern" && this.raise(v.UnexpectedVoidPattern, o.loc.start), this.checkLVal(o, {
        type: "VariableDeclarator"
      }, s === "var" ? 5 : 8201), a.id = o;
    }
    parseAsyncFunctionExpression(a) {
      return this.parseFunction(a, 8);
    }
    parseFunction(a, s = 0) {
      const o = s & 2, f = !!(s & 1), b = f && !(s & 4), w = !!(s & 8);
      this.initFunction(a, w), this.match(55) && (o && this.raise(v.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), a.generator = !0), f && (a.id = this.parseFunctionId(b));
      const C = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(di(w, a.generator)), f || (a.id = this.parseFunctionId()), this.parseFunctionParams(a, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(a, f ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), f && !o && this.registerFunctionStatementId(a), this.state.maybeInArrowParameters = C, a;
    }
    parseFunctionId(a) {
      return a || Q(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(a, s) {
      this.expect(10), this.expressionScope.enter(By()), a.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(a) {
      a.id && this.scope.declareName(a.id.name, !this.options.annexB || this.state.strict || a.generator || a.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, a.id.loc.start);
    }
    parseClass(a, s, o) {
      this.next();
      const f = this.state.strict;
      return this.state.strict = !0, this.parseClassId(a, s, o), this.parseClassSuper(a), a.body = this.parseClassBody(!!a.superClass, f), this.finishNode(a, s ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(a) {
      return a.type === "Identifier" && a.name === "constructor" || a.type === "StringLiteral" && a.value === "constructor";
    }
    isNonstaticConstructor(a) {
      return !a.computed && !a.static && this.nameIsConstructor(a.key);
    }
    parseClassBody(a, s) {
      this.classScope.enter();
      const o = {
        hadConstructor: !1,
        hadSuperClass: a
      };
      let f = [];
      const b = this.startNode();
      if (b.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (f.length > 0)
              throw this.raise(v.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            f.push(this.parseDecorator());
            continue;
          }
          const w = this.startNode();
          f.length && (w.decorators = f, this.resetStartLocationFromNode(w, f[0]), f = []), this.parseClassMember(b, w, o), w.kind === "constructor" && w.decorators && w.decorators.length > 0 && this.raise(v.DecoratorConstructor, w);
        }
      }), this.state.strict = s, this.next(), f.length)
        throw this.raise(v.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(b, "ClassBody");
    }
    parseClassMemberFromModifier(a, s) {
      const o = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const f = s;
        return f.kind = "method", f.computed = !1, f.key = o, f.static = !1, this.pushClassMethod(a, f, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        const f = s;
        return f.computed = !1, f.key = o, f.static = !1, a.body.push(this.parseClassProperty(f)), !0;
      }
      return this.resetPreviousNodeTrailingComments(o), !1;
    }
    parseClassMember(a, s, o) {
      const f = this.isContextual(106);
      if (f) {
        if (this.parseClassMemberFromModifier(a, s))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(a, s);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(a, s, o, f);
    }
    parseClassMemberWithIsStatic(a, s, o, f) {
      const b = s, w = s, C = s, D = s, F = s, $ = b, q = b;
      if (s.static = f, this.parsePropertyNamePrefixOperator(s), this.eat(55)) {
        $.kind = "method";
        const ye = this.match(139);
        if (this.parseClassElementName($), this.parsePostMemberNameModifiers($), ye) {
          this.pushClassPrivateMethod(a, w, !0, !1);
          return;
        }
        this.isNonstaticConstructor(b) && this.raise(v.ConstructorIsGenerator, b.key), this.pushClassMethod(a, b, !0, !1, !1, !1);
        return;
      }
      const J = !this.state.containsEsc && Q(this.state.type), ee = this.parseClassElementName(s), oe = J ? ee.name : null, me = this.isPrivateName(ee), Re = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(q), this.isClassMethod()) {
        if ($.kind = "method", me) {
          this.pushClassPrivateMethod(a, w, !1, !1);
          return;
        }
        const ye = this.isNonstaticConstructor(b);
        let _e = !1;
        ye && (b.kind = "constructor", o.hadConstructor && !this.hasPlugin("typescript") && this.raise(v.DuplicateConstructor, ee), ye && this.hasPlugin("typescript") && s.override && this.raise(v.OverrideOnConstructor, ee), o.hadConstructor = !0, _e = o.hadSuperClass), this.pushClassMethod(a, b, !1, !1, ye, _e);
      } else if (this.isClassProperty())
        me ? this.pushClassPrivateProperty(a, D) : this.pushClassProperty(a, C);
      else if (oe === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(ee);
        const ye = this.eat(55);
        q.optional && this.unexpected(Re), $.kind = "method";
        const _e = this.match(139);
        this.parseClassElementName($), this.parsePostMemberNameModifiers(q), _e ? this.pushClassPrivateMethod(a, w, ye, !0) : (this.isNonstaticConstructor(b) && this.raise(v.ConstructorIsAsync, b.key), this.pushClassMethod(a, b, ye, !0, !1, !1));
      } else if ((oe === "get" || oe === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(ee), $.kind = oe;
        const ye = this.match(139);
        this.parseClassElementName(b), ye ? this.pushClassPrivateMethod(a, w, !1, !1) : (this.isNonstaticConstructor(b) && this.raise(v.ConstructorIsAccessor, b.key), this.pushClassMethod(a, b, !1, !1, !1, !1)), this.checkGetterSetterParams(b);
      } else if (oe === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(ee);
        const ye = this.match(139);
        this.parseClassElementName(C), this.pushClassAccessorProperty(a, F, ye);
      } else this.isLineTerminator() ? me ? this.pushClassPrivateProperty(a, D) : this.pushClassProperty(a, C) : this.unexpected();
    }
    parseClassElementName(a) {
      const {
        type: s,
        value: o
      } = this.state;
      if ((s === 132 || s === 134) && a.static && o === "prototype" && this.raise(v.StaticPrototype, this.state.startLoc), s === 139) {
        o === "constructor" && this.raise(v.ConstructorClassPrivateField, this.state.startLoc);
        const f = this.parsePrivateName();
        return a.key = f, f;
      }
      return this.parsePropertyName(a), a.key;
    }
    parseClassStaticBlock(a, s) {
      var o;
      this.scope.enter(720);
      const f = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const b = s.body = [];
      this.parseBlockOrModuleBlockBody(b, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = f, a.body.push(this.finishNode(s, "StaticBlock")), (o = s.decorators) != null && o.length && this.raise(v.DecoratorStaticBlock, s);
    }
    pushClassProperty(a, s) {
      !s.computed && this.nameIsConstructor(s.key) && this.raise(v.ConstructorClassField, s.key), a.body.push(this.parseClassProperty(s));
    }
    pushClassPrivateProperty(a, s) {
      const o = this.parseClassPrivateProperty(s);
      a.body.push(o), this.classScope.declarePrivateName(this.getPrivateNameSV(o.key), 0, o.key.loc.start);
    }
    pushClassAccessorProperty(a, s, o) {
      !o && !s.computed && this.nameIsConstructor(s.key) && this.raise(v.ConstructorClassField, s.key);
      const f = this.parseClassAccessorProperty(s);
      a.body.push(f), o && this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassMethod(a, s, o, f, b, w) {
      a.body.push(this.parseMethod(s, o, f, b, w, "ClassMethod", !0));
    }
    pushClassPrivateMethod(a, s, o, f) {
      const b = this.parseMethod(s, o, f, !1, !1, "ClassPrivateMethod", !0);
      a.body.push(b);
      const w = b.kind === "get" ? b.static ? 6 : 2 : b.kind === "set" ? b.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(b, w);
    }
    declareClassPrivateMethodInScope(a, s) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(a.key), s, a.key.loc.start);
    }
    parsePostMemberNameModifiers(a) {
    }
    parseClassPrivateProperty(a) {
      return this.parseInitializer(a), this.semicolon(), this.finishNode(a, "ClassPrivateProperty");
    }
    parseClassProperty(a) {
      return this.parseInitializer(a), this.semicolon(), this.finishNode(a, "ClassProperty");
    }
    parseClassAccessorProperty(a) {
      return this.parseInitializer(a), this.semicolon(), this.finishNode(a, "ClassAccessorProperty");
    }
    parseInitializer(a) {
      this.scope.enter(592), this.expressionScope.enter(Pc()), this.prodParam.enter(0), a.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(a, s, o, f = 8331) {
      if (Q(this.state.type))
        a.id = this.parseIdentifier(), s && this.declareNameFromIdentifier(a.id, f);
      else if (o || !s)
        a.id = null;
      else
        throw this.raise(v.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(a) {
      a.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(a, s) {
      const o = this.parseMaybeImportPhase(a, !0), f = this.maybeParseExportDefaultSpecifier(a, o), b = !f || this.eat(12), w = b && this.eatExportStar(a), C = w && this.maybeParseExportNamespaceSpecifier(a), D = b && (!C || this.eat(12)), F = f || w;
      if (w && !C) {
        if (f && this.unexpected(), s)
          throw this.raise(v.UnsupportedDecoratorExport, a);
        return this.parseExportFrom(a, !0), this.sawUnambiguousESM = !0, this.finishNode(a, "ExportAllDeclaration");
      }
      const $ = this.maybeParseExportNamedSpecifiers(a);
      f && b && !w && !$ && this.unexpected(null, 5), C && D && this.unexpected(null, 98);
      let q;
      if (F || $) {
        if (q = !1, s)
          throw this.raise(v.UnsupportedDecoratorExport, a);
        this.parseExportFrom(a, F);
      } else
        q = this.maybeParseExportDeclaration(a);
      if (F || $ || q) {
        var J;
        const ee = a;
        if (this.checkExport(ee, !0, !1, !!ee.source), ((J = ee.declaration) == null ? void 0 : J.type) === "ClassDeclaration")
          this.maybeTakeDecorators(s, ee.declaration, ee);
        else if (s)
          throw this.raise(v.UnsupportedDecoratorExport, a);
        return this.sawUnambiguousESM = !0, this.finishNode(ee, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const ee = a, oe = this.parseExportDefaultExpression();
        if (ee.declaration = oe, oe.type === "ClassDeclaration")
          this.maybeTakeDecorators(s, oe, ee);
        else if (s)
          throw this.raise(v.UnsupportedDecoratorExport, a);
        return this.checkExport(ee, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(ee, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(a) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(a, s) {
      if (s || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", s == null ? void 0 : s.loc.start);
        const o = s || this.parseIdentifier(!0), f = this.startNodeAtNode(o);
        return f.exported = o, a.specifiers = [this.finishNode(f, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(a) {
      if (this.isContextual(93)) {
        var s, o;
        (o = (s = a).specifiers) != null || (s.specifiers = []);
        const f = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), f.exported = this.parseModuleExportName(), a.specifiers.push(this.finishNode(f, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(a) {
      if (this.match(5)) {
        const s = a;
        s.specifiers || (s.specifiers = []);
        const o = s.exportKind === "type";
        return s.specifiers.push(...this.parseExportSpecifiers(o)), s.source = null, this.hasPlugin("importAssertions") ? s.assertions = [] : s.attributes = [], s.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(a) {
      return this.shouldParseExportDeclaration() ? (a.specifiers = [], a.source = null, this.hasPlugin("importAssertions") ? a.assertions = [] : a.attributes = [], a.declaration = this.parseExportDeclaration(a), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      const a = this.nextTokenInLineStart();
      return this.isUnparsedContextual(a, "function");
    }
    parseExportDefaultExpression() {
      const a = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(a, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(a, 13);
      if (this.match(80))
        return this.parseClass(a, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(v.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing())
        throw this.raise(v.UnsupportedDefaultExport, this.state.startLoc);
      const s = this.parseMaybeAssignAllowIn();
      return this.semicolon(), s;
    }
    parseExportDeclaration(a) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type: a
      } = this.state;
      if (Q(a)) {
        if (a === 95 && !this.state.containsEsc || a === 100)
          return !1;
        if ((a === 130 || a === 129) && !this.state.containsEsc) {
          const f = this.nextTokenStart(), b = this.input.charCodeAt(f);
          if (b === 123 || this.chStartsBindingIdentifier(b, f) && !this.input.startsWith("from", f))
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      const s = this.nextTokenStart(), o = this.isUnparsedContextual(s, "from");
      if (this.input.charCodeAt(s) === 44 || Q(this.state.type) && o)
        return !0;
      if (this.match(65) && o) {
        const f = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
        return f === 34 || f === 39;
      }
      return !1;
    }
    parseExportFrom(a, s) {
      this.eatContextual(98) ? (a.source = this.parseImportSource(), this.checkExport(a), this.maybeParseImportAttributes(a), this.checkJSONModuleImport(a)) : s && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: a
      } = this.state;
      return a === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(v.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() ? (this.raise(v.UsingDeclarationExport, this.state.startLoc), !0) : this.isAwaitUsing() ? (this.raise(v.UsingDeclarationExport, this.state.startLoc), !0) : a === 74 || a === 75 || a === 68 || a === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(a, s, o, f) {
      if (s) {
        var b;
        if (o) {
          if (this.checkDuplicateExports(a, "default"), this.hasPlugin("exportDefaultFrom")) {
            var w;
            const C = a.declaration;
            C.type === "Identifier" && C.name === "from" && C.end - C.start === 4 && !((w = C.extra) != null && w.parenthesized) && this.raise(v.ExportDefaultFromAsIdentifier, C);
          }
        } else if ((b = a.specifiers) != null && b.length)
          for (const C of a.specifiers) {
            const {
              exported: D
            } = C, F = D.type === "Identifier" ? D.name : D.value;
            if (this.checkDuplicateExports(C, F), !f && C.local) {
              const {
                local: $
              } = C;
              $.type !== "Identifier" ? this.raise(v.ExportBindingIsString, C, {
                localName: $.value,
                exportName: F
              }) : (this.checkReservedWord($.name, $.loc.start, !0, !1), this.scope.checkLocalExport($));
            }
          }
        else if (a.declaration) {
          const C = a.declaration;
          if (C.type === "FunctionDeclaration" || C.type === "ClassDeclaration") {
            const {
              id: D
            } = C;
            if (!D) throw new Error("Assertion failure");
            this.checkDuplicateExports(a, D.name);
          } else if (C.type === "VariableDeclaration")
            for (const D of C.declarations)
              this.checkDeclaration(D.id);
        }
      }
    }
    checkDeclaration(a) {
      if (a.type === "Identifier")
        this.checkDuplicateExports(a, a.name);
      else if (a.type === "ObjectPattern")
        for (const s of a.properties)
          this.checkDeclaration(s);
      else if (a.type === "ArrayPattern")
        for (const s of a.elements)
          s && this.checkDeclaration(s);
      else a.type === "ObjectProperty" ? this.checkDeclaration(a.value) : a.type === "RestElement" ? this.checkDeclaration(a.argument) : a.type === "AssignmentPattern" && this.checkDeclaration(a.left);
    }
    checkDuplicateExports(a, s) {
      this.exportedIdentifiers.has(s) && (s === "default" ? this.raise(v.DuplicateDefaultExport, a) : this.raise(v.DuplicateExport, a, {
        exportName: s
      })), this.exportedIdentifiers.add(s);
    }
    parseExportSpecifiers(a) {
      const s = [];
      let o = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.eat(8)) break;
        const f = this.isContextual(130), b = this.match(134), w = this.startNode();
        w.local = this.parseModuleExportName(), s.push(this.parseExportSpecifier(w, b, a, f));
      }
      return s;
    }
    parseExportSpecifier(a, s, o, f) {
      return this.eatContextual(93) ? a.exported = this.parseModuleExportName() : s ? a.exported = this.cloneStringLiteral(a.local) : a.exported || (a.exported = this.cloneIdentifier(a.local)), this.finishNode(a, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        const a = this.parseStringLiteral(this.state.value), s = sg.exec(a.value);
        return s && this.raise(v.ModuleExportNameHasLoneSurrogate, a, {
          surrogateCharCode: s[0].charCodeAt(0)
        }), a;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(a) {
      return a.assertions != null ? a.assertions.some(({
        key: s,
        value: o
      }) => o.value === "json" && (s.type === "Identifier" ? s.name === "type" : s.value === "type")) : !1;
    }
    checkImportReflection(a) {
      const {
        specifiers: s
      } = a, o = s.length === 1 ? s[0].type : null;
      if (a.phase === "source")
        o !== "ImportDefaultSpecifier" && this.raise(v.SourcePhaseImportRequiresDefault, s[0].loc.start);
      else if (a.phase === "defer")
        o !== "ImportNamespaceSpecifier" && this.raise(v.DeferImportRequiresNamespace, s[0].loc.start);
      else if (a.module) {
        var f;
        o !== "ImportDefaultSpecifier" && this.raise(v.ImportReflectionNotBinding, s[0].loc.start), ((f = a.assertions) == null ? void 0 : f.length) > 0 && this.raise(v.ImportReflectionHasAssertion, s[0].loc.start);
      }
    }
    checkJSONModuleImport(a) {
      if (this.isJSONModuleImport(a) && a.type !== "ExportAllDeclaration") {
        const {
          specifiers: s
        } = a;
        if (s != null) {
          const o = s.find((f) => {
            let b;
            if (f.type === "ExportSpecifier" ? b = f.local : f.type === "ImportSpecifier" && (b = f.imported), b !== void 0)
              return b.type === "Identifier" ? b.name !== "default" : b.value !== "default";
          });
          o !== void 0 && this.raise(v.ImportJSONBindingNotDefault, o.loc.start);
        }
      }
    }
    isPotentialImportPhase(a) {
      return a ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(a, s, o, f) {
      s || (o === "module" ? (this.expectPlugin("importReflection", f), a.module = !0) : this.hasPlugin("importReflection") && (a.module = !1), o === "source" ? (this.expectPlugin("sourcePhaseImports", f), a.phase = "source") : o === "defer" ? (this.expectPlugin("deferredImportEvaluation", f), a.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (a.phase = null));
    }
    parseMaybeImportPhase(a, s) {
      if (!this.isPotentialImportPhase(s))
        return this.applyImportPhase(a, s, null), null;
      const o = this.startNode(), f = this.parseIdentifierName(!0), {
        type: b
      } = this.state;
      return (le(b) ? b !== 98 || this.lookaheadCharCode() === 102 : b !== 12) ? (this.applyImportPhase(a, s, f, o.loc.start), null) : (this.applyImportPhase(a, s, null), this.createIdentifier(o, f));
    }
    isPrecedingIdImportPhase(a) {
      const {
        type: s
      } = this.state;
      return Q(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12;
    }
    parseImport(a) {
      return this.match(134) ? this.parseImportSourceAndAttributes(a) : this.parseImportSpecifiersAndAfter(a, this.parseMaybeImportPhase(a, !1));
    }
    parseImportSpecifiersAndAfter(a, s) {
      a.specifiers = [];
      const f = !this.maybeParseDefaultImportSpecifier(a, s) || this.eat(12), b = f && this.maybeParseStarImportSpecifier(a);
      return f && !b && this.parseNamedImportSpecifiers(a), this.expectContextual(98), this.parseImportSourceAndAttributes(a);
    }
    parseImportSourceAndAttributes(a) {
      var s;
      return (s = a.specifiers) != null || (a.specifiers = []), a.source = this.parseImportSource(), this.maybeParseImportAttributes(a), this.checkImportReflection(a), this.checkJSONModuleImport(a), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(a, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(a, s, o) {
      s.local = this.parseIdentifier(), a.specifiers.push(this.finishImportSpecifier(s, o));
    }
    finishImportSpecifier(a, s, o = 8201) {
      return this.checkLVal(a.local, {
        type: s
      }, o), this.finishNode(a, s);
    }
    parseImportAttributes() {
      this.expect(5);
      const a = [], s = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const o = this.startNode(), f = this.state.value;
        if (s.has(f) && this.raise(v.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: f
        }), s.add(f), this.match(134) ? o.key = this.parseStringLiteral(f) : o.key = this.parseIdentifier(!0), this.expect(14), !this.match(134))
          throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        o.value = this.parseStringLiteral(this.state.value), a.push(this.finishNode(o, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), a;
    }
    parseModuleAttributes() {
      const a = [], s = /* @__PURE__ */ new Set();
      do {
        const o = this.startNode();
        if (o.key = this.parseIdentifier(!0), o.key.name !== "type" && this.raise(v.ModuleAttributeDifferentFromType, o.key), s.has(o.key.name) && this.raise(v.ModuleAttributesWithDuplicateKeys, o.key, {
          key: o.key.name
        }), s.add(o.key.name), this.expect(14), !this.match(134))
          throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        o.value = this.parseStringLiteral(this.state.value), a.push(this.finishNode(o, "ImportAttribute"));
      } while (this.eat(12));
      return a;
    }
    maybeParseImportAttributes(a) {
      let s;
      var o = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (s = this.parseModuleAttributes(), this.addExtra(a, "deprecatedWithLegacySyntax", !0)) : s = this.parseImportAttributes(), o = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(v.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(a, "deprecatedAssertSyntax", !0), this.next(), s = this.parseImportAttributes()) : s = [];
      !o && this.hasPlugin("importAssertions") ? a.assertions = s : a.attributes = s;
    }
    maybeParseDefaultImportSpecifier(a, s) {
      if (s) {
        const o = this.startNodeAtNode(s);
        return o.local = s, a.specifiers.push(this.finishImportSpecifier(o, "ImportDefaultSpecifier")), !0;
      } else if (le(this.state.type))
        return this.parseImportSpecifierLocal(a, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(a) {
      if (this.match(55)) {
        const s = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(a, s, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(a) {
      let s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else {
          if (this.eat(14))
            throw this.raise(v.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const o = this.startNode(), f = this.match(134), b = this.isContextual(130);
        o.imported = this.parseModuleExportName();
        const w = this.parseImportSpecifier(o, f, a.importKind === "type" || a.importKind === "typeof", b, void 0);
        a.specifiers.push(w);
      }
    }
    parseImportSpecifier(a, s, o, f, b) {
      if (this.eatContextual(93))
        a.local = this.parseIdentifier();
      else {
        const {
          imported: w
        } = a;
        if (s)
          throw this.raise(v.ImportBindingIsString, a, {
            importName: w.value
          });
        this.checkReservedWord(w.name, a.loc.start, !0, !0), a.local || (a.local = this.cloneIdentifier(w));
      }
      return this.finishImportSpecifier(a, "ImportSpecifier", b);
    }
    isThisParam(a) {
      return a.type === "Identifier" && a.name === "this";
    }
  }
  class Dc extends ng {
    constructor(a, s, o) {
      a = A(a), super(a, s), this.options = a, this.initializeScopes(), this.plugins = o, this.filename = a.sourceFilename, this.startIndex = a.startIndex;
      let f = 0;
      a.allowAwaitOutsideFunction && (f |= 1), a.allowReturnOutsideFunction && (f |= 2), a.allowImportExportEverywhere && (f |= 8), a.allowSuperOutsideMethod && (f |= 16), a.allowUndeclaredExports && (f |= 64), a.allowNewTargetOutsideFunction && (f |= 4), a.allowYieldOutsideFunction && (f |= 32), a.ranges && (f |= 128), a.tokens && (f |= 256), a.createImportExpressions && (f |= 512), a.createParenthesizedExpressions && (f |= 1024), a.errorRecovery && (f |= 2048), a.attachComment && (f |= 4096), a.annexB && (f |= 8192), this.optionFlags = f;
    }
    getScopeHandler() {
      return La;
    }
    parse() {
      this.enterInitialScopes();
      const a = this.startNode(), s = this.startNode();
      return this.nextToken(), a.errors = null, this.parseTopLevel(a, s), a.errors = this.state.errors, a.comments.length = this.state.commentsLen, a;
    }
  }
  function ag(T, a) {
    var s;
    if (((s = a) == null ? void 0 : s.sourceType) === "unambiguous") {
      a = Object.assign({}, a);
      try {
        a.sourceType = "module";
        const o = Es(a, T), f = o.parse();
        if (o.sawUnambiguousESM)
          return f;
        if (o.ambiguousScriptDifferentAst)
          try {
            return a.sourceType = "script", Es(a, T).parse();
          } catch {
          }
        else
          f.program.sourceType = "script";
        return f;
      } catch (o) {
        try {
          return a.sourceType = "script", Es(a, T).parse();
        } catch {
        }
        throw o;
      }
    } else
      return Es(a, T).parse();
  }
  function og(T, a) {
    const s = Es(a, T);
    return s.options.strictMode && (s.state.strict = !0), s.getExpression();
  }
  function ug(T) {
    const a = {};
    for (const s of Object.keys(T))
      a[s] = Tt(T[s]);
    return a;
  }
  const lg = ug(ce);
  function Es(T, a) {
    let s = Dc;
    const o = /* @__PURE__ */ new Map();
    if (T != null && T.plugins) {
      for (const f of T.plugins) {
        let b, w;
        typeof f == "string" ? b = f : [b, w] = f, o.has(b) || o.set(b, w || {});
      }
      Zy(o), s = cg(o);
    }
    return new s(T, a, o);
  }
  const Mc = /* @__PURE__ */ new Map();
  function cg(T) {
    const a = [];
    for (const f of eg)
      T.has(f) && a.push(f);
    const s = a.join("|");
    let o = Mc.get(s);
    if (!o) {
      o = Dc;
      for (const f of a)
        o = Rc[f](o);
      Mc.set(s, o);
    }
    return o;
  }
  return Hr.parse = ag, Hr.parseExpression = og, Hr.tokTypes = lg, Hr;
}
var It = /* @__PURE__ */ fb();
class pb {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (e) => this.replacement = e
    };
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   * @param {BaseNode} node
   */
  replace(e, r, i, n) {
    e && (i !== null ? e[r][i] = n : e[r] = n);
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   */
  remove(e, r, i) {
    e && (i !== null ? e[r].splice(i, 1) : delete e[r]);
  }
}
class db extends pb {
  /**
   *
   * @param {SyncHandler} enter
   * @param {SyncHandler} leave
   */
  constructor(e, r) {
    super(), this.enter = e, this.leave = r;
  }
  /**
   *
   * @param {BaseNode} node
   * @param {BaseNode} parent
   * @param {string} [prop]
   * @param {number} [index]
   * @returns {BaseNode}
   */
  visit(e, r, i, n) {
    if (e) {
      if (this.enter) {
        const u = this.should_skip, l = this.should_remove, h = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, r, i, n), this.replacement && (e = this.replacement, this.replace(r, i, n, e)), this.should_remove && this.remove(r, i, n);
        const c = this.should_skip, p = this.should_remove;
        if (this.should_skip = u, this.should_remove = l, this.replacement = h, c) return e;
        if (p) return null;
      }
      for (const u in e) {
        const l = e[u];
        if (typeof l == "object")
          if (Array.isArray(l))
            for (let h = 0; h < l.length; h += 1)
              l[h] !== null && typeof l[h].type == "string" && (this.visit(l[h], e, u, h) || h--);
          else l !== null && typeof l.type == "string" && this.visit(l, e, u, null);
      }
      if (this.leave) {
        const u = this.replacement, l = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, r, i, n), this.replacement && (e = this.replacement, this.replace(r, i, n, e)), this.should_remove && this.remove(r, i, n);
        const h = this.should_remove;
        if (this.replacement = u, this.should_remove = l, h) return null;
      }
    }
    return e;
  }
}
function Hu(t, { enter: e, leave: r }) {
  return new db(e, r).visit(t, null);
}
function ta(t, e, r = !1, i = [], n = /* @__PURE__ */ Object.create(null)) {
  const u = t.type === "Program" ? t.body[0].type === "ExpressionStatement" && t.body[0].expression : t;
  Hu(t, {
    enter(l, h) {
      if (h && i.push(h), h && h.type.startsWith("TS") && !sa.includes(h.type))
        return this.skip();
      if (l.type === "Identifier") {
        const c = !!n[l.name], p = Gu(l, h, i);
        (r || p && !c) && e(l, h, i, p, c);
      } else if (l.type === "ObjectProperty" && // eslint-disable-next-line no-restricted-syntax
      (h == null ? void 0 : h.type) === "ObjectPattern")
        l.inPattern = !0;
      else if (ur(l))
        l.scopeIds ? l.scopeIds.forEach((c) => iu(c, n)) : Xu(
          l,
          (c) => Si(l, c, n)
        );
      else if (l.type === "BlockStatement")
        l.scopeIds ? l.scopeIds.forEach((c) => iu(c, n)) : e0(
          l,
          (c) => Si(l, c, n)
        );
      else if (l.type === "CatchClause" && l.param)
        for (const c of _t(l.param))
          Si(l, c, n);
      else t0(l) && r0(
        l,
        !1,
        (c) => Si(l, c, n)
      );
    },
    leave(l, h) {
      if (h && i.pop(), l !== u && l.scopeIds)
        for (const c of l.scopeIds)
          n[c]--, n[c] === 0 && delete n[c];
    }
  });
}
function Gu(t, e, r) {
  if (!e)
    return !0;
  if (t.name === "arguments")
    return !1;
  if (mb(t, e, r[r.length - 2]))
    return !0;
  switch (e.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return !0;
    case "ObjectProperty":
      return e.key !== t && Gs(e, r);
    case "ArrayPattern":
      return Gs(e, r);
  }
  return !1;
}
function Gs(t, e) {
  if (t && (t.type === "ObjectProperty" || t.type === "ArrayPattern")) {
    let r = e.length;
    for (; r--; ) {
      const i = e[r];
      if (i.type === "AssignmentExpression")
        return !0;
      if (i.type !== "ObjectProperty" && !i.type.endsWith("Pattern"))
        break;
    }
  }
  return !1;
}
function Zd(t) {
  let e = t.length;
  for (; e--; ) {
    const r = t[e];
    if (r.type === "NewExpression")
      return !0;
    if (r.type !== "MemberExpression")
      break;
  }
  return !1;
}
function Xu(t, e) {
  for (const r of t.params)
    for (const i of _t(r))
      e(i);
}
function e0(t, e) {
  for (const r of t.body)
    if (r.type === "VariableDeclaration") {
      if (r.declare) continue;
      for (const i of r.declarations)
        for (const n of _t(i.id))
          e(n);
    } else if (r.type === "FunctionDeclaration" || r.type === "ClassDeclaration") {
      if (r.declare || !r.id) continue;
      e(r.id);
    } else t0(r) && r0(r, !0, e);
}
function t0(t) {
  return t.type === "ForOfStatement" || t.type === "ForInStatement" || t.type === "ForStatement";
}
function r0(t, e, r) {
  const i = t.type === "ForStatement" ? t.init : t.left;
  if (i && i.type === "VariableDeclaration" && (i.kind === "var" ? e : !e))
    for (const n of i.declarations)
      for (const u of _t(n.id))
        r(u);
}
function _t(t, e = []) {
  switch (t.type) {
    case "Identifier":
      e.push(t);
      break;
    case "MemberExpression":
      let r = t;
      for (; r.type === "MemberExpression"; )
        r = r.object;
      e.push(r);
      break;
    case "ObjectPattern":
      for (const i of t.properties)
        i.type === "RestElement" ? _t(i.argument, e) : _t(i.value, e);
      break;
    case "ArrayPattern":
      t.elements.forEach((i) => {
        i && _t(i, e);
      });
      break;
    case "RestElement":
      _t(t.argument, e);
      break;
    case "AssignmentPattern":
      _t(t.left, e);
      break;
  }
  return e;
}
function iu(t, e) {
  t in e ? e[t]++ : e[t] = 1;
}
function Si(t, e, r) {
  const { name: i } = e;
  t.scopeIds && t.scopeIds.has(i) || (iu(i, r), (t.scopeIds || (t.scopeIds = /* @__PURE__ */ new Set())).add(i));
}
const ur = (t) => /Function(?:Expression|Declaration)$|Method$/.test(t.type), ra = (t) => t && (t.type === "ObjectProperty" || t.type === "ObjectMethod") && !t.computed, s0 = (t, e) => ra(e) && e.key === t;
function mb(t, e, r) {
  switch (e.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e.property === t ? !!e.computed : e.object === t;
    case "JSXMemberExpression":
      return e.object === t;
    case "VariableDeclarator":
      return e.init === t;
    case "ArrowFunctionExpression":
      return e.body === t;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return e.key === t ? !!e.computed : !1;
    case "ObjectProperty":
      return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
    case "ClassProperty":
      return e.key === t ? !!e.computed : !0;
    case "ClassPrivateProperty":
      return e.key !== t;
    case "ClassDeclaration":
    case "ClassExpression":
      return e.superClass === t;
    case "AssignmentExpression":
      return e.right === t;
    case "AssignmentPattern":
      return e.right === t;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return r != null && r.source ? !1 : e.local === t;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return e.key !== t;
    case "TSEnumMember":
      return e.id !== t;
    case "TSPropertySignature":
      return e.key === t ? !!e.computed : !0;
  }
  return !0;
}
const sa = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function vt(t) {
  return sa.includes(t.type) ? vt(t.expression) : t;
}
const He = (t) => t.type === 4 && t.isStatic;
function Ju(t) {
  switch (t) {
    case "Teleport":
    case "teleport":
      return _r;
    case "Suspense":
    case "suspense":
      return cs;
    case "KeepAlive":
    case "keep-alive":
      return Vs;
    case "BaseTransition":
    case "base-transition":
      return Mu;
  }
}
const yb = /^$|^\d|[^\$\w\xA0-\uFFFF]/, Kt = (t) => !yb.test(t), gb = /[A-Za-z_$\xA0-\uFFFF]/, bb = /[\.\?\w$\xA0-\uFFFF]/, Sb = /\s+[.[]\s*|\s*[.[]\s+/g, ia = (t) => t.type === 4 ? t.content : t.loc.source, vb = (t) => {
  const e = ia(t).trim().replace(Sb, (h) => h.trim());
  let r = 0, i = [], n = 0, u = 0, l = null;
  for (let h = 0; h < e.length; h++) {
    const c = e.charAt(h);
    switch (r) {
      case 0:
        if (c === "[")
          i.push(r), r = 1, n++;
        else if (c === "(")
          i.push(r), r = 2, u++;
        else if (!(h === 0 ? gb : bb).test(c))
          return !1;
        break;
      case 1:
        c === "'" || c === '"' || c === "`" ? (i.push(r), r = 3, l = c) : c === "[" ? n++ : c === "]" && (--n || (r = i.pop()));
        break;
      case 2:
        if (c === "'" || c === '"' || c === "`")
          i.push(r), r = 3, l = c;
        else if (c === "(")
          u++;
        else if (c === ")") {
          if (h === e.length - 1)
            return !1;
          --u || (r = i.pop());
        }
        break;
      case 3:
        c === l && (r = i.pop(), l = null);
        break;
    }
  }
  return !n && !u;
}, i0 = (t, e) => {
  try {
    let r = t.ast || It.parseExpression(ia(t), {
      plugins: e.expressionPlugins ? [...e.expressionPlugins, "typescript"] : ["typescript"]
    });
    return r = vt(r), r.type === "MemberExpression" || r.type === "OptionalMemberExpression" || r.type === "Identifier" && r.name !== "undefined";
  } catch {
    return !1;
  }
}, Ku = i0, xb = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, Eb = (t) => xb.test(ia(t)), n0 = (t, e) => {
  try {
    let r = t.ast || It.parseExpression(ia(t), {
      plugins: e.expressionPlugins ? [...e.expressionPlugins, "typescript"] : ["typescript"]
    });
    return r.type === "Program" && (r = r.body[0], r.type === "ExpressionStatement" && (r = r.expression)), r = vt(r), r.type === "FunctionExpression" || r.type === "ArrowFunctionExpression";
  } catch {
    return !1;
  }
}, a0 = n0;
function nu(t, e, r = e.length) {
  return Yu(
    {
      offset: t.offset,
      line: t.line,
      column: t.column
    },
    e,
    r
  );
}
function Yu(t, e, r = e.length) {
  let i = 0, n = -1;
  for (let u = 0; u < r; u++)
    e.charCodeAt(u) === 10 && (i++, n = u);
  return t.offset += r, t.line += i, t.column = n === -1 ? t.column + r : r - n, t;
}
function au(t, e) {
  if (!t)
    throw new Error(e || "unexpected compiler condition");
}
function Fe(t, e, r = !1) {
  for (let i = 0; i < t.props.length; i++) {
    const n = t.props[i];
    if (n.type === 7 && (r || n.exp) && (Se(e) ? n.name === e : e.test(n.name)))
      return n;
  }
}
function ht(t, e, r = !1, i = !1) {
  for (let n = 0; n < t.props.length; n++) {
    const u = t.props[n];
    if (u.type === 6) {
      if (r) continue;
      if (u.name === e && (u.value || i))
        return u;
    } else if (u.name === "bind" && (u.exp || i) && Mt(u.arg, e))
      return u;
  }
}
function Mt(t, e) {
  return !!(t && He(t) && t.content === e);
}
function na(t) {
  return t.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Rs(t) {
  return t.type === 5 || t.type === 2;
}
function ou(t) {
  return t.type === 7 && t.name === "pre";
}
function Qu(t) {
  return t.type === 7 && t.name === "slot";
}
function os(t) {
  return t.type === 1 && t.tagType === 3;
}
function us(t) {
  return t.type === 1 && t.tagType === 2;
}
const Tb = /* @__PURE__ */ new Set([is, fs]);
function o0(t, e = []) {
  if (t && !Se(t) && t.type === 14) {
    const r = t.callee;
    if (!Se(r) && Tb.has(r))
      return o0(
        t.arguments[0],
        e.concat(t)
      );
  }
  return [t, e];
}
function Xs(t, e, r) {
  let i, n = t.type === 13 ? t.props : t.arguments[2], u = [], l;
  if (n && !Se(n) && n.type === 14) {
    const h = o0(n);
    n = h[0], u = h[1], l = u[u.length - 1];
  }
  if (n == null || Se(n))
    i = lt([e]);
  else if (n.type === 14) {
    const h = n.arguments[0];
    !Se(h) && h.type === 15 ? gh(e, h) || h.properties.unshift(e) : n.callee === Jn ? i = pe(r.helper(Or), [
      lt([e]),
      n
    ]) : n.arguments.unshift(lt([e])), !i && (i = n);
  } else n.type === 15 ? (gh(e, n) || n.properties.unshift(e), i = n) : (i = pe(r.helper(Or), [
    lt([e]),
    n
  ]), l && l.callee === fs && (l = u[u.length - 2]));
  t.type === 13 ? l ? l.arguments[0] = i : t.props = i : l ? l.arguments[0] = i : t.arguments[2] = i;
}
function gh(t, e) {
  let r = !1;
  if (t.key.type === 4) {
    const i = t.key.content;
    r = e.properties.some(
      (n) => n.key.type === 4 && n.key.content === i
    );
  }
  return r;
}
function Js(t, e) {
  return `_${e}_${t.replace(/[^\w]/g, (r, i) => r === "-" ? "_" : t.charCodeAt(i).toString())}`;
}
function at(t, e) {
  if (!t || Object.keys(e).length === 0)
    return !1;
  switch (t.type) {
    case 1:
      for (let r = 0; r < t.props.length; r++) {
        const i = t.props[r];
        if (i.type === 7 && (at(i.arg, e) || at(i.exp, e)))
          return !0;
      }
      return t.children.some((r) => at(r, e));
    case 11:
      return at(t.source, e) ? !0 : t.children.some((r) => at(r, e));
    case 9:
      return t.branches.some((r) => at(r, e));
    case 10:
      return at(t.condition, e) ? !0 : t.children.some((r) => at(r, e));
    case 4:
      return !t.isStatic && Kt(t.content) && !!e[t.content];
    case 8:
      return t.children.some((r) => pr(r) && at(r, e));
    case 5:
    case 12:
      return at(t.content, e);
    case 2:
    case 3:
    case 20:
      return !1;
    default:
      return !1;
  }
}
function u0(t) {
  return t.type === 14 && t.callee === Yn ? t.arguments[1].returns : t;
}
const l0 = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/, c0 = {
  parseMode: "base",
  ns: 0,
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  isVoidTag: Os,
  isPreTag: Os,
  isIgnoreNewlineTag: Os,
  isCustomElement: Os,
  onError: zu,
  onWarn: Qd,
  comments: !0,
  prefixIdentifiers: !1
};
let Ie = c0, Sn = null, Xt = "", Qe = null, xe = null, xt = "", Vt = -1, Sr = -1, Zu = 0, ar = !1, uu = null;
const De = [], Ne = new ab(De, {
  onerr: rt,
  ontext(t, e) {
    vi(Je(t, e), t, e);
  },
  ontextentity(t, e, r) {
    vi(t, e, r);
  },
  oninterpolation(t, e) {
    if (ar)
      return vi(Je(t, e), t, e);
    let r = t + Ne.delimiterOpen.length, i = e - Ne.delimiterClose.length;
    for (; gt(Xt.charCodeAt(r)); )
      r++;
    for (; gt(Xt.charCodeAt(i - 1)); )
      i--;
    let n = Je(r, i);
    n.includes("&") && (n = nb(n)), lu({
      type: 5,
      content: rn(n, !1, Me(r, i)),
      loc: Me(t, e)
    });
  },
  onopentagname(t, e) {
    const r = Je(t, e);
    Qe = {
      type: 1,
      tag: r,
      ns: Ie.getNamespace(r, De[0], Ie.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: Me(t - 1, e),
      codegenNode: void 0
    };
  },
  onopentagend(t) {
    Sh(t);
  },
  onclosetag(t, e) {
    const r = Je(t, e);
    if (!Ie.isVoidTag(r)) {
      let i = !1;
      for (let n = 0; n < De.length; n++)
        if (De[n].tag.toLowerCase() === r.toLowerCase()) {
          i = !0, n > 0 && rt(24, De[0].loc.start.offset);
          for (let l = 0; l <= n; l++) {
            const h = De.shift();
            tn(h, e, l < n);
          }
          break;
        }
      i || rt(23, h0(t, 60));
    }
  },
  onselfclosingtag(t) {
    const e = Qe.tag;
    Qe.isSelfClosing = !0, Sh(t), De[0] && De[0].tag === e && tn(De.shift(), t);
  },
  onattribname(t, e) {
    xe = {
      type: 6,
      name: Je(t, e),
      nameLoc: Me(t, e),
      value: void 0,
      loc: Me(t)
    };
  },
  ondirname(t, e) {
    const r = Je(t, e), i = r === "." || r === ":" ? "bind" : r === "@" ? "on" : r === "#" ? "slot" : r.slice(2);
    if (!ar && i === "" && rt(26, t), ar || i === "")
      xe = {
        type: 6,
        name: r,
        nameLoc: Me(t, e),
        value: void 0,
        loc: Me(t)
      };
    else if (xe = {
      type: 7,
      name: i,
      rawName: r,
      exp: void 0,
      arg: void 0,
      modifiers: r === "." ? [te("prop")] : [],
      loc: Me(t)
    }, i === "pre") {
      ar = Ne.inVPre = !0, uu = Qe;
      const n = Qe.props;
      for (let u = 0; u < n.length; u++)
        n[u].type === 7 && (n[u] = Db(n[u]));
    }
  },
  ondirarg(t, e) {
    if (t === e) return;
    const r = Je(t, e);
    if (ar && !ou(xe))
      xe.name += r, Tr(xe.nameLoc, e);
    else {
      const i = r[0] !== "[";
      xe.arg = rn(
        i ? r : r.slice(1, -1),
        i,
        Me(t, e),
        i ? 3 : 0
      );
    }
  },
  ondirmodifier(t, e) {
    const r = Je(t, e);
    if (ar && !ou(xe))
      xe.name += "." + r, Tr(xe.nameLoc, e);
    else if (xe.name === "slot") {
      const i = xe.arg;
      i && (i.content += "." + r, Tr(i.loc, e));
    } else {
      const i = te(r, !0, Me(t, e));
      xe.modifiers.push(i);
    }
  },
  onattribdata(t, e) {
    xt += Je(t, e), Vt < 0 && (Vt = t), Sr = e;
  },
  onattribentity(t, e, r) {
    xt += t, Vt < 0 && (Vt = e), Sr = r;
  },
  onattribnameend(t) {
    const e = xe.loc.start.offset, r = Je(e, t);
    xe.type === 7 && (xe.rawName = r), Qe.props.some(
      (i) => (i.type === 7 ? i.rawName : i.name) === r
    ) && rt(2, e);
  },
  onattribend(t, e) {
    if (Qe && xe) {
      if (Tr(xe.loc, e), t !== 0)
        if (xe.type === 6)
          xe.name === "class" && (xt = p0(xt).trim()), t === 1 && !xt && rt(13, e), xe.value = {
            type: 2,
            content: xt,
            loc: t === 1 ? Me(Vt, Sr) : Me(Vt - 1, Sr + 1)
          }, Ne.inSFCRoot && Qe.tag === "template" && xe.name === "lang" && xt && xt !== "html" && Ne.enterRCDATA(bn("</template"), 0);
        else {
          let r = 0;
          xe.name === "for" ? r = 3 : xe.name === "slot" ? r = 1 : xe.name === "on" && xt.includes(";") && (r = 2), xe.exp = rn(
            xt,
            !1,
            Me(Vt, Sr),
            0,
            r
          ), xe.name === "for" && (xe.forParseResult = Pb(xe.exp));
        }
      (xe.type !== 7 || xe.name !== "pre") && Qe.props.push(xe);
    }
    xt = "", Vt = Sr = -1;
  },
  oncomment(t, e) {
    Ie.comments && lu({
      type: 3,
      content: Je(t, e),
      loc: Me(t - 4, e + 3)
    });
  },
  onend() {
    const t = Xt.length;
    if (Ne.state !== 1)
      switch (Ne.state) {
        case 5:
        case 8:
          rt(5, t);
          break;
        case 3:
        case 4:
          rt(
            25,
            Ne.sectionStart
          );
          break;
        case 28:
          Ne.currentSequence === We.CdataEnd ? rt(6, t) : rt(7, t);
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
          rt(9, t);
          break;
      }
    for (let e = 0; e < De.length; e++)
      tn(De[e], t - 1), rt(24, De[e].loc.start.offset);
  },
  oncdata(t, e) {
    De[0].ns !== 0 ? vi(Je(t, e), t, e) : rt(1, t - 9);
  },
  onprocessinginstruction(t) {
    (De[0] ? De[0].ns : Ie.ns) === 0 && rt(
      21,
      t - 1
    );
  }
}), bh = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, wb = /^\(|\)$/g;
function Pb(t) {
  const e = t.loc, r = t.content, i = r.match(l0);
  if (!i) return;
  const [, n, u] = i, l = (m, y, g = !1) => {
    const E = e.start.offset + y, S = E + m.length;
    return rn(
      m,
      !1,
      Me(E, S),
      0,
      g ? 1 : 0
      /* Normal */
    );
  }, h = {
    source: l(u.trim(), r.indexOf(u, n.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: !1
  };
  let c = n.trim().replace(wb, "").trim();
  const p = n.indexOf(c), d = c.match(bh);
  if (d) {
    c = c.replace(bh, "").trim();
    const m = d[1].trim();
    let y;
    if (m && (y = r.indexOf(m, p + c.length), h.key = l(m, y, !0)), d[2]) {
      const g = d[2].trim();
      g && (h.index = l(
        g,
        r.indexOf(
          g,
          h.key ? y + m.length : p + c.length
        ),
        !0
      ));
    }
  }
  return c && (h.value = l(c, p, !0)), h;
}
function Je(t, e) {
  return Xt.slice(t, e);
}
function Sh(t) {
  Ne.inSFCRoot && (Qe.innerLoc = Me(t + 1, t + 1)), lu(Qe);
  const { tag: e, ns: r } = Qe;
  r === 0 && Ie.isPreTag(e) && Zu++, Ie.isVoidTag(e) ? tn(Qe, t) : (De.unshift(Qe), (r === 1 || r === 2) && (Ne.inXML = !0)), Qe = null;
}
function vi(t, e, r) {
  const i = De[0] || Sn, n = i.children[i.children.length - 1];
  n && n.type === 2 ? (n.content += t, Tr(n.loc, r)) : i.children.push({
    type: 2,
    content: t,
    loc: Me(e, r)
  });
}
function tn(t, e, r = !1) {
  r ? Tr(t.loc, h0(e, 60)) : Tr(t.loc, _b(e, 62) + 1), Ne.inSFCRoot && (t.children.length ? t.innerLoc.end = Bt({}, t.children[t.children.length - 1].loc.end) : t.innerLoc.end = Bt({}, t.innerLoc.start), t.innerLoc.source = Je(
    t.innerLoc.start.offset,
    t.innerLoc.end.offset
  ));
  const { tag: i, ns: n, children: u } = t;
  if (ar || (i === "slot" ? t.tagType = 2 : Cb(t) ? t.tagType = 3 : Ib(t) && (t.tagType = 1)), Ne.inRCDATA || (t.children = f0(u)), n === 0 && Ie.isIgnoreNewlineTag(i)) {
    const l = u[0];
    l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
  }
  n === 0 && Ie.isPreTag(i) && Zu--, uu === t && (ar = Ne.inVPre = !1, uu = null), Ne.inXML && (De[0] ? De[0].ns : Ie.ns) === 0 && (Ne.inXML = !1);
}
function _b(t, e) {
  let r = t;
  for (; Xt.charCodeAt(r) !== e && r < Xt.length - 1; ) r++;
  return r;
}
function h0(t, e) {
  let r = t;
  for (; Xt.charCodeAt(r) !== e && r >= 0; ) r--;
  return r;
}
const Ab = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function Cb({ tag: t, props: e }) {
  if (t === "template") {
    for (let r = 0; r < e.length; r++)
      if (e[r].type === 7 && Ab.has(e[r].name))
        return !0;
  }
  return !1;
}
function Ib({ tag: t, props: e }) {
  if (Ie.isCustomElement(t))
    return !1;
  if (t === "component" || Nb(t.charCodeAt(0)) || Ju(t) || Ie.isBuiltInComponent && Ie.isBuiltInComponent(t) || Ie.isNativeTag && !Ie.isNativeTag(t))
    return !0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (i.type === 6 && i.name === "is" && i.value && i.value.content.startsWith("vue:"))
      return !0;
  }
  return !1;
}
function Nb(t) {
  return t > 64 && t < 91;
}
const Ob = /\r\n/g;
function f0(t) {
  const e = Ie.whitespace !== "preserve";
  let r = !1;
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    if (n.type === 2)
      if (Zu)
        n.content = n.content.replace(Ob, `
`);
      else if (kb(n.content)) {
        const u = t[i - 1] && t[i - 1].type, l = t[i + 1] && t[i + 1].type;
        !u || !l || e && (u === 3 && (l === 3 || l === 1) || u === 1 && (l === 3 || l === 1 && Lb(n.content))) ? (r = !0, t[i] = null) : n.content = " ";
      } else e && (n.content = p0(n.content));
  }
  return r ? t.filter(Boolean) : t;
}
function kb(t) {
  for (let e = 0; e < t.length; e++)
    if (!gt(t.charCodeAt(e)))
      return !1;
  return !0;
}
function Lb(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t.charCodeAt(e);
    if (r === 10 || r === 13)
      return !0;
  }
  return !1;
}
function p0(t) {
  let e = "", r = !1;
  for (let i = 0; i < t.length; i++)
    gt(t.charCodeAt(i)) ? r || (e += " ", r = !0) : (e += t[i], r = !1);
  return e;
}
function lu(t) {
  (De[0] || Sn).children.push(t);
}
function Me(t, e) {
  return {
    start: Ne.getPos(t),
    // @ts-expect-error allow late attachment
    end: e == null ? e : Ne.getPos(e),
    // @ts-expect-error allow late attachment
    source: e == null ? e : Je(t, e)
  };
}
function Rb(t) {
  return Me(t.start.offset, t.end.offset);
}
function Tr(t, e) {
  t.end = Ne.getPos(e), t.source = Je(t.start.offset, e);
}
function Db(t) {
  const e = {
    type: 6,
    name: t.rawName,
    nameLoc: Me(
      t.loc.start.offset,
      t.loc.start.offset + t.rawName.length
    ),
    value: void 0,
    loc: t.loc
  };
  if (t.exp) {
    const r = t.exp.loc;
    r.end.offset < t.loc.end.offset && (r.start.offset--, r.start.column--, r.end.offset++, r.end.column++), e.value = {
      type: 2,
      content: t.exp.content,
      loc: r
    };
  }
  return e;
}
function rn(t, e = !1, r, i = 0, n = 0) {
  const u = te(t, e, r, i);
  if (!e && Ie.prefixIdentifiers && n !== 3 && t.trim()) {
    if (Kt(t))
      return u.ast = null, u;
    try {
      const l = Ie.expressionPlugins, h = {
        plugins: l ? [...l, "typescript"] : ["typescript"]
      };
      n === 2 ? u.ast = It.parse(` ${t} `, h).program : n === 1 ? u.ast = It.parseExpression(`(${t})=>{}`, h) : u.ast = It.parseExpression(`(${t})`, h);
    } catch (l) {
      u.ast = !1, rt(45, r.start.offset, l.message);
    }
  }
  return u;
}
function rt(t, e, r) {
  Ie.onError(
    Te(t, Me(e, e), void 0, r)
  );
}
function Mb() {
  Ne.reset(), Qe = null, xe = null, xt = "", Vt = -1, Sr = -1, De.length = 0;
}
function aa(t, e) {
  if (Mb(), Xt = t, Ie = Bt({}, c0), e) {
    let n;
    for (n in e)
      e[n] != null && (Ie[n] = e[n]);
  }
  Ie.decodeEntities && console.warn(
    "[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds."
  ), Ne.mode = Ie.parseMode === "html" ? 1 : Ie.parseMode === "sfc" ? 2 : 0, Ne.inXML = Ie.ns === 1 || Ie.ns === 2;
  const r = e && e.delimiters;
  r && (Ne.delimiterOpen = bn(r[0]), Ne.delimiterClose = bn(r[1]));
  const i = Sn = Dr([], t);
  return Ne.parse(Xt), i.loc = Me(0, t.length), i.children = f0(i.children), Sn = null, i;
}
function Fb(t, e) {
  sn(
    t,
    void 0,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    !!d0(t)
  );
}
function d0(t) {
  const e = t.children.filter((r) => r.type !== 3);
  return e.length === 1 && e[0].type === 1 && !us(e[0]) ? e[0] : null;
}
function sn(t, e, r, i = !1, n = !1) {
  const { children: u } = t, l = [];
  for (let m = 0; m < u.length; m++) {
    const y = u[m];
    if (y.type === 1 && y.tagType === 0) {
      const g = i ? 0 : ct(y, r);
      if (g > 0) {
        if (g >= 2) {
          y.codegenNode.patchFlag = -1, l.push(y);
          continue;
        }
      } else {
        const E = y.codegenNode;
        if (E.type === 13) {
          const S = E.patchFlag;
          if ((S === void 0 || S === 512 || S === 1) && y0(y, r) >= 2) {
            const x = g0(y);
            x && (E.props = r.hoist(x));
          }
          E.dynamicProps && (E.dynamicProps = r.hoist(E.dynamicProps));
        }
      }
    } else if (y.type === 12 && (i ? 0 : ct(y, r)) >= 2) {
      y.codegenNode.type === 14 && y.codegenNode.arguments.length > 0 && y.codegenNode.arguments.push(
        `-1 /* ${Ls[-1]} */`
      ), l.push(y);
      continue;
    }
    if (y.type === 1) {
      const g = y.tagType === 1;
      g && r.scopes.vSlot++, sn(y, t, r, !1, n), g && r.scopes.vSlot--;
    } else if (y.type === 11)
      sn(y, t, r, y.children.length === 1, !0);
    else if (y.type === 9)
      for (let g = 0; g < y.branches.length; g++)
        sn(
          y.branches[g],
          t,
          r,
          y.branches[g].children.length === 1,
          n
        );
  }
  let h = !1;
  const c = [];
  if (l.length === u.length && t.type === 1) {
    if (t.tagType === 0 && t.codegenNode && t.codegenNode.type === 13 && $e(t.codegenNode.children))
      t.codegenNode.children = p(
        Gt(t.codegenNode.children)
      ), h = !0;
    else if (t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !$e(t.codegenNode.children) && t.codegenNode.children.type === 15) {
      const m = d(t.codegenNode, "default");
      m && (c.push(r.cached.length), m.returns = p(
        Gt(m.returns)
      ), h = !0);
    } else if (t.tagType === 3 && e && e.type === 1 && e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !$e(e.codegenNode.children) && e.codegenNode.children.type === 15) {
      const m = Fe(t, "slot", !0), y = m && m.arg && d(e.codegenNode, m.arg);
      y && (c.push(r.cached.length), y.returns = p(
        Gt(y.returns)
      ), h = !0);
    }
  }
  if (!h)
    for (const m of l)
      c.push(r.cached.length), m.codegenNode = r.cache(m.codegenNode);
  c.length && t.type === 1 && t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !$e(t.codegenNode.children) && t.codegenNode.children.type === 15 && t.codegenNode.children.properties.push(
    Pe(
      "__",
      te(JSON.stringify(c), !1)
    )
  );
  function p(m) {
    const y = r.cache(m);
    return n && r.hmr && (y.needArraySpread = !0), y;
  }
  function d(m, y) {
    if (m.children && !$e(m.children) && m.children.type === 15) {
      const g = m.children.properties.find(
        (E) => E.key === y || E.key.content === y
      );
      return g && g.value;
    }
  }
  l.length && r.transformHoist && r.transformHoist(u, r, t);
}
function ct(t, e) {
  const { constantCache: r } = e;
  switch (t.type) {
    case 1:
      if (t.tagType !== 0)
        return 0;
      const i = r.get(t);
      if (i !== void 0)
        return i;
      const n = t.codegenNode;
      if (n.type !== 13 || n.isBlock && t.tag !== "svg" && t.tag !== "foreignObject" && t.tag !== "math")
        return 0;
      if (n.patchFlag === void 0) {
        let l = 3;
        const h = y0(t, e);
        if (h === 0)
          return r.set(t, 0), 0;
        h < l && (l = h);
        for (let c = 0; c < t.children.length; c++) {
          const p = ct(t.children[c], e);
          if (p === 0)
            return r.set(t, 0), 0;
          p < l && (l = p);
        }
        if (l > 1)
          for (let c = 0; c < t.props.length; c++) {
            const p = t.props[c];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const d = ct(p.exp, e);
              if (d === 0)
                return r.set(t, 0), 0;
              d < l && (l = d);
            }
          }
        if (n.isBlock) {
          for (let c = 0; c < t.props.length; c++)
            if (t.props[c].type === 7)
              return r.set(t, 0), 0;
          e.removeHelper(cr), e.removeHelper(
            Lr(e.inSSR, n.isComponent)
          ), n.isBlock = !1, e.helper(kr(e.inSSR, n.isComponent));
        }
        return r.set(t, l), l;
      } else
        return r.set(t, 0), 0;
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return ct(t.content, e);
    case 4:
      return t.constType;
    case 8:
      let u = 3;
      for (let l = 0; l < t.children.length; l++) {
        const h = t.children[l];
        if (Se(h) || fr(h))
          continue;
        const c = ct(h, e);
        if (c === 0)
          return 0;
        c < u && (u = c);
      }
      return u;
    case 20:
      return 2;
    default:
      return 0;
  }
}
const Bb = /* @__PURE__ */ new Set([
  Gn,
  Xn,
  is,
  fs
]);
function m0(t, e) {
  if (t.type === 14 && !Se(t.callee) && Bb.has(t.callee)) {
    const r = t.arguments[0];
    if (r.type === 4)
      return ct(r, e);
    if (r.type === 14)
      return m0(r, e);
  }
  return 0;
}
function y0(t, e) {
  let r = 3;
  const i = g0(t);
  if (i && i.type === 15) {
    const { properties: n } = i;
    for (let u = 0; u < n.length; u++) {
      const { key: l, value: h } = n[u], c = ct(l, e);
      if (c === 0)
        return c;
      c < r && (r = c);
      let p;
      if (h.type === 4 ? p = ct(h, e) : h.type === 14 ? p = m0(h, e) : p = 0, p === 0)
        return p;
      p < r && (r = p);
    }
  }
  return r;
}
function g0(t) {
  const e = t.codegenNode;
  if (e.type === 13)
    return e.props;
}
function ai(t, {
  filename: e = "",
  prefixIdentifiers: r = !1,
  hoistStatic: i = !1,
  hmr: n = !1,
  cacheHandlers: u = !1,
  nodeTransforms: l = [],
  directiveTransforms: h = {},
  transformHoist: c = null,
  isBuiltInComponent: p = qa,
  isCustomElement: d = qa,
  expressionPlugins: m = [],
  scopeId: y = null,
  slotted: g = !0,
  ssr: E = !1,
  inSSR: S = !1,
  ssrCssVars: x = "",
  bindingMetadata: v = pg,
  inline: P = !1,
  isTS: A = !1,
  onError: N = zu,
  onWarn: _ = Qd,
  compatConfig: R
}) {
  const M = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), O = {
    // options
    filename: e,
    selfName: M && lr(ut(M[1])),
    prefixIdentifiers: r,
    hoistStatic: i,
    hmr: n,
    cacheHandlers: u,
    nodeTransforms: l,
    directiveTransforms: h,
    transformHoist: c,
    isBuiltInComponent: p,
    isCustomElement: d,
    expressionPlugins: m,
    scopeId: y,
    slotted: g,
    ssr: E,
    inSSR: S,
    ssrCssVars: x,
    bindingMetadata: v,
    inline: P,
    isTS: A,
    onError: N,
    onWarn: _,
    compatConfig: R,
    // state
    root: t,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: t,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(L) {
      const V = O.helpers.get(L) || 0;
      return O.helpers.set(L, V + 1), L;
    },
    removeHelper(L) {
      const V = O.helpers.get(L);
      if (V) {
        const K = V - 1;
        K ? O.helpers.set(L, K) : O.helpers.delete(L);
      }
    },
    helperString(L) {
      return `_${ot[O.helper(L)]}`;
    },
    replaceNode(L) {
      {
        if (!O.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!O.parent)
          throw new Error("Cannot replace root node.");
      }
      O.parent.children[O.childIndex] = O.currentNode = L;
    },
    removeNode(L) {
      if (!O.parent)
        throw new Error("Cannot remove root node.");
      const V = O.parent.children, K = L ? V.indexOf(L) : O.currentNode ? O.childIndex : -1;
      if (K < 0)
        throw new Error("node being removed is not a child of current parent");
      !L || L === O.currentNode ? (O.currentNode = null, O.onNodeRemoved()) : O.childIndex > K && (O.childIndex--, O.onNodeRemoved()), O.parent.children.splice(K, 1);
    },
    onNodeRemoved: qa,
    addIdentifiers(L) {
      Se(L) ? I(L) : L.identifiers ? L.identifiers.forEach(I) : L.type === 4 && I(L.content);
    },
    removeIdentifiers(L) {
      Se(L) ? k(L) : L.identifiers ? L.identifiers.forEach(k) : L.type === 4 && k(L.content);
    },
    hoist(L) {
      Se(L) && (L = te(L)), O.hoists.push(L);
      const V = te(
        `_hoisted_${O.hoists.length}`,
        !1,
        L.loc,
        2
      );
      return V.hoisted = L, V;
    },
    cache(L, V = !1, K = !1) {
      const re = Wd(
        O.cached.length,
        L,
        V,
        K
      );
      return O.cached.push(re), re;
    }
  };
  function I(L) {
    const { identifiers: V } = O;
    V[L] === void 0 && (V[L] = 0), V[L]++;
  }
  function k(L) {
    O.identifiers[L]--;
  }
  return O;
}
function el(t, e) {
  const r = ai(t, e);
  ps(t, r), e.hoistStatic && Fb(t, r), e.ssr || $b(t, r), t.helpers = /* @__PURE__ */ new Set([...r.helpers.keys()]), t.components = [...r.components], t.directives = [...r.directives], t.imports = r.imports, t.hoists = r.hoists, t.temps = r.temps, t.cached = r.cached, t.transformed = !0;
}
function $b(t, e) {
  const { helper: r } = e, { children: i } = t;
  if (i.length === 1) {
    const n = d0(t);
    if (n && n.codegenNode) {
      const u = n.codegenNode;
      u.type === 13 && Qn(u, e), t.codegenNode = u;
    } else
      t.codegenNode = i[0];
  } else if (i.length > 1) {
    let n = 64;
    i.filter((u) => u.type !== 3).length === 1 && (n |= 2048), t.codegenNode = as(
      e,
      r(ss),
      void 0,
      t.children,
      n,
      void 0,
      void 0,
      !0,
      void 0,
      !1
    );
  }
}
function Ub(t, e) {
  let r = 0;
  const i = () => {
    r--;
  };
  for (; r < t.children.length; r++) {
    const n = t.children[r];
    Se(n) || (e.grandParent = e.parent, e.parent = t, e.childIndex = r, e.onNodeRemoved = i, ps(n, e));
  }
}
function ps(t, e) {
  e.currentNode = t;
  const { nodeTransforms: r } = e, i = [];
  for (let u = 0; u < r.length; u++) {
    const l = r[u](t, e);
    if (l && ($e(l) ? i.push(...l) : i.push(l)), e.currentNode)
      t = e.currentNode;
    else
      return;
  }
  switch (t.type) {
    case 3:
      e.ssr || e.helper(hs);
      break;
    case 5:
      e.ssr || e.helper(ii);
      break;
    case 9:
      for (let u = 0; u < t.branches.length; u++)
        ps(t.branches[u], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      Ub(t, e);
      break;
  }
  e.currentNode = t;
  let n = i.length;
  for (; n--; )
    i[n]();
}
function oi(t, e) {
  const r = Se(t) ? (i) => i === t : (i) => t.test(i);
  return (i, n) => {
    if (i.type === 1) {
      const { props: u } = i;
      if (i.tagType === 3 && u.some(Qu))
        return;
      const l = [];
      for (let h = 0; h < u.length; h++) {
        const c = u[h];
        if (c.type === 7 && r(c.name)) {
          u.splice(h, 1), h--;
          const p = e(i, c, n);
          p && l.push(p);
        }
      }
      return l;
    }
  };
}
var Ts = {}, Wa = {}, xi = {}, Ei = {}, vh;
function qb() {
  if (vh) return Ei;
  vh = 1;
  var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Ei.encode = function(e) {
    if (0 <= e && e < t.length)
      return t[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  }, Ei.decode = function(e) {
    var r = 65, i = 90, n = 97, u = 122, l = 48, h = 57, c = 43, p = 47, d = 26, m = 52;
    return r <= e && e <= i ? e - r : n <= e && e <= u ? e - n + d : l <= e && e <= h ? e - l + m : e == c ? 62 : e == p ? 63 : -1;
  }, Ei;
}
var xh;
function b0() {
  if (xh) return xi;
  xh = 1;
  var t = /* @__PURE__ */ qb(), e = 5, r = 1 << e, i = r - 1, n = r;
  function u(h) {
    return h < 0 ? (-h << 1) + 1 : (h << 1) + 0;
  }
  function l(h) {
    var c = (h & 1) === 1, p = h >> 1;
    return c ? -p : p;
  }
  return xi.encode = function(c) {
    var p = "", d, m = u(c);
    do
      d = m & i, m >>>= e, m > 0 && (d |= n), p += t.encode(d);
    while (m > 0);
    return p;
  }, xi.decode = function(c, p, d) {
    var m = c.length, y = 0, g = 0, E, S;
    do {
      if (p >= m)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (S = t.decode(c.charCodeAt(p++)), S === -1)
        throw new Error("Invalid base64 digit: " + c.charAt(p - 1));
      E = !!(S & n), S &= i, y = y + (S << g), g += e;
    } while (E);
    d.value = l(y), d.rest = p;
  }, xi;
}
var Ha = {}, Eh;
function ui() {
  return Eh || (Eh = 1, function(t) {
    function e(O, I, k) {
      if (I in O)
        return O[I];
      if (arguments.length === 3)
        return k;
      throw new Error('"' + I + '" is a required argument.');
    }
    t.getArg = e;
    var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, i = /^data:.+\,.+$/;
    function n(O) {
      var I = O.match(r);
      return I ? {
        scheme: I[1],
        auth: I[2],
        host: I[3],
        port: I[4],
        path: I[5]
      } : null;
    }
    t.urlParse = n;
    function u(O) {
      var I = "";
      return O.scheme && (I += O.scheme + ":"), I += "//", O.auth && (I += O.auth + "@"), O.host && (I += O.host), O.port && (I += ":" + O.port), O.path && (I += O.path), I;
    }
    t.urlGenerate = u;
    var l = 32;
    function h(O) {
      var I = [];
      return function(k) {
        for (var L = 0; L < I.length; L++)
          if (I[L].input === k) {
            var V = I[0];
            return I[0] = I[L], I[L] = V, I[0].result;
          }
        var K = O(k);
        return I.unshift({
          input: k,
          result: K
        }), I.length > l && I.pop(), K;
      };
    }
    var c = h(function(I) {
      var k = I, L = n(I);
      if (L) {
        if (!L.path)
          return I;
        k = L.path;
      }
      for (var V = t.isAbsolute(k), K = [], re = 0, z = 0; ; )
        if (re = z, z = k.indexOf("/", re), z === -1) {
          K.push(k.slice(re));
          break;
        } else
          for (K.push(k.slice(re, z)); z < k.length && k[z] === "/"; )
            z++;
      for (var se, he = 0, z = K.length - 1; z >= 0; z--)
        se = K[z], se === "." ? K.splice(z, 1) : se === ".." ? he++ : he > 0 && (se === "" ? (K.splice(z + 1, he), he = 0) : (K.splice(z, 2), he--));
      return k = K.join("/"), k === "" && (k = V ? "/" : "."), L ? (L.path = k, u(L)) : k;
    });
    t.normalize = c;
    function p(O, I) {
      O === "" && (O = "."), I === "" && (I = ".");
      var k = n(I), L = n(O);
      if (L && (O = L.path || "/"), k && !k.scheme)
        return L && (k.scheme = L.scheme), u(k);
      if (k || I.match(i))
        return I;
      if (L && !L.host && !L.path)
        return L.host = I, u(L);
      var V = I.charAt(0) === "/" ? I : c(O.replace(/\/+$/, "") + "/" + I);
      return L ? (L.path = V, u(L)) : V;
    }
    t.join = p, t.isAbsolute = function(O) {
      return O.charAt(0) === "/" || r.test(O);
    };
    function d(O, I) {
      O === "" && (O = "."), O = O.replace(/\/$/, "");
      for (var k = 0; I.indexOf(O + "/") !== 0; ) {
        var L = O.lastIndexOf("/");
        if (L < 0 || (O = O.slice(0, L), O.match(/^([^\/]+:\/)?\/*$/)))
          return I;
        ++k;
      }
      return Array(k + 1).join("../") + I.substr(O.length + 1);
    }
    t.relative = d;
    var m = function() {
      var O = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in O);
    }();
    function y(O) {
      return O;
    }
    function g(O) {
      return S(O) ? "$" + O : O;
    }
    t.toSetString = m ? y : g;
    function E(O) {
      return S(O) ? O.slice(1) : O;
    }
    t.fromSetString = m ? y : E;
    function S(O) {
      if (!O)
        return !1;
      var I = O.length;
      if (I < 9 || O.charCodeAt(I - 1) !== 95 || O.charCodeAt(I - 2) !== 95 || O.charCodeAt(I - 3) !== 111 || O.charCodeAt(I - 4) !== 116 || O.charCodeAt(I - 5) !== 111 || O.charCodeAt(I - 6) !== 114 || O.charCodeAt(I - 7) !== 112 || O.charCodeAt(I - 8) !== 95 || O.charCodeAt(I - 9) !== 95)
        return !1;
      for (var k = I - 10; k >= 0; k--)
        if (O.charCodeAt(k) !== 36)
          return !1;
      return !0;
    }
    function x(O, I, k) {
      var L = N(O.source, I.source);
      return L !== 0 || (L = O.originalLine - I.originalLine, L !== 0) || (L = O.originalColumn - I.originalColumn, L !== 0 || k) || (L = O.generatedColumn - I.generatedColumn, L !== 0) || (L = O.generatedLine - I.generatedLine, L !== 0) ? L : N(O.name, I.name);
    }
    t.compareByOriginalPositions = x;
    function v(O, I, k) {
      var L;
      return L = O.originalLine - I.originalLine, L !== 0 || (L = O.originalColumn - I.originalColumn, L !== 0 || k) || (L = O.generatedColumn - I.generatedColumn, L !== 0) || (L = O.generatedLine - I.generatedLine, L !== 0) ? L : N(O.name, I.name);
    }
    t.compareByOriginalPositionsNoSource = v;
    function P(O, I, k) {
      var L = O.generatedLine - I.generatedLine;
      return L !== 0 || (L = O.generatedColumn - I.generatedColumn, L !== 0 || k) || (L = N(O.source, I.source), L !== 0) || (L = O.originalLine - I.originalLine, L !== 0) || (L = O.originalColumn - I.originalColumn, L !== 0) ? L : N(O.name, I.name);
    }
    t.compareByGeneratedPositionsDeflated = P;
    function A(O, I, k) {
      var L = O.generatedColumn - I.generatedColumn;
      return L !== 0 || k || (L = N(O.source, I.source), L !== 0) || (L = O.originalLine - I.originalLine, L !== 0) || (L = O.originalColumn - I.originalColumn, L !== 0) ? L : N(O.name, I.name);
    }
    t.compareByGeneratedPositionsDeflatedNoLine = A;
    function N(O, I) {
      return O === I ? 0 : O === null ? 1 : I === null ? -1 : O > I ? 1 : -1;
    }
    function _(O, I) {
      var k = O.generatedLine - I.generatedLine;
      return k !== 0 || (k = O.generatedColumn - I.generatedColumn, k !== 0) || (k = N(O.source, I.source), k !== 0) || (k = O.originalLine - I.originalLine, k !== 0) || (k = O.originalColumn - I.originalColumn, k !== 0) ? k : N(O.name, I.name);
    }
    t.compareByGeneratedPositionsInflated = _;
    function R(O) {
      return JSON.parse(O.replace(/^\)]}'[^\n]*\n/, ""));
    }
    t.parseSourceMapInput = R;
    function M(O, I, k) {
      if (I = I || "", O && (O[O.length - 1] !== "/" && I[0] !== "/" && (O += "/"), I = O + I), k) {
        var L = n(k);
        if (!L)
          throw new Error("sourceMapURL could not be parsed");
        if (L.path) {
          var V = L.path.lastIndexOf("/");
          V >= 0 && (L.path = L.path.substring(0, V + 1));
        }
        I = p(u(L), I);
      }
      return c(I);
    }
    t.computeSourceURL = M;
  }(Ha)), Ha;
}
var Ga = {}, Th;
function S0() {
  if (Th) return Ga;
  Th = 1;
  var t = /* @__PURE__ */ ui(), e = Object.prototype.hasOwnProperty, r = typeof Map < "u";
  function i() {
    this._array = [], this._set = r ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return i.fromArray = function(u, l) {
    for (var h = new i(), c = 0, p = u.length; c < p; c++)
      h.add(u[c], l);
    return h;
  }, i.prototype.size = function() {
    return r ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, i.prototype.add = function(u, l) {
    var h = r ? u : t.toSetString(u), c = r ? this.has(u) : e.call(this._set, h), p = this._array.length;
    (!c || l) && this._array.push(u), c || (r ? this._set.set(u, p) : this._set[h] = p);
  }, i.prototype.has = function(u) {
    if (r)
      return this._set.has(u);
    var l = t.toSetString(u);
    return e.call(this._set, l);
  }, i.prototype.indexOf = function(u) {
    if (r) {
      var l = this._set.get(u);
      if (l >= 0)
        return l;
    } else {
      var h = t.toSetString(u);
      if (e.call(this._set, h))
        return this._set[h];
    }
    throw new Error('"' + u + '" is not in the set.');
  }, i.prototype.at = function(u) {
    if (u >= 0 && u < this._array.length)
      return this._array[u];
    throw new Error("No element indexed by " + u);
  }, i.prototype.toArray = function() {
    return this._array.slice();
  }, Ga.ArraySet = i, Ga;
}
var Xa = {}, wh;
function jb() {
  if (wh) return Xa;
  wh = 1;
  var t = /* @__PURE__ */ ui();
  function e(i, n) {
    var u = i.generatedLine, l = n.generatedLine, h = i.generatedColumn, c = n.generatedColumn;
    return l > u || l == u && c >= h || t.compareByGeneratedPositionsInflated(i, n) <= 0;
  }
  function r() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return r.prototype.unsortedForEach = function(n, u) {
    this._array.forEach(n, u);
  }, r.prototype.add = function(n) {
    e(this._last, n) ? (this._last = n, this._array.push(n)) : (this._sorted = !1, this._array.push(n));
  }, r.prototype.toArray = function() {
    return this._sorted || (this._array.sort(t.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, Xa.MappingList = r, Xa;
}
var Ph;
function v0() {
  if (Ph) return Wa;
  Ph = 1;
  var t = /* @__PURE__ */ b0(), e = /* @__PURE__ */ ui(), r = S0().ArraySet, i = jb().MappingList;
  function n(u) {
    u || (u = {}), this._file = e.getArg(u, "file", null), this._sourceRoot = e.getArg(u, "sourceRoot", null), this._skipValidation = e.getArg(u, "skipValidation", !1), this._ignoreInvalidMapping = e.getArg(u, "ignoreInvalidMapping", !1), this._sources = new r(), this._names = new r(), this._mappings = new i(), this._sourcesContents = null;
  }
  return n.prototype._version = 3, n.fromSourceMap = function(l, h) {
    var c = l.sourceRoot, p = new n(Object.assign(h || {}, {
      file: l.file,
      sourceRoot: c
    }));
    return l.eachMapping(function(d) {
      var m = {
        generated: {
          line: d.generatedLine,
          column: d.generatedColumn
        }
      };
      d.source != null && (m.source = d.source, c != null && (m.source = e.relative(c, m.source)), m.original = {
        line: d.originalLine,
        column: d.originalColumn
      }, d.name != null && (m.name = d.name)), p.addMapping(m);
    }), l.sources.forEach(function(d) {
      var m = d;
      c !== null && (m = e.relative(c, d)), p._sources.has(m) || p._sources.add(m);
      var y = l.sourceContentFor(d);
      y != null && p.setSourceContent(d, y);
    }), p;
  }, n.prototype.addMapping = function(l) {
    var h = e.getArg(l, "generated"), c = e.getArg(l, "original", null), p = e.getArg(l, "source", null), d = e.getArg(l, "name", null);
    !this._skipValidation && this._validateMapping(h, c, p, d) === !1 || (p != null && (p = String(p), this._sources.has(p) || this._sources.add(p)), d != null && (d = String(d), this._names.has(d) || this._names.add(d)), this._mappings.add({
      generatedLine: h.line,
      generatedColumn: h.column,
      originalLine: c != null && c.line,
      originalColumn: c != null && c.column,
      source: p,
      name: d
    }));
  }, n.prototype.setSourceContent = function(l, h) {
    var c = l;
    this._sourceRoot != null && (c = e.relative(this._sourceRoot, c)), h != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[e.toSetString(c)] = h) : this._sourcesContents && (delete this._sourcesContents[e.toSetString(c)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, n.prototype.applySourceMap = function(l, h, c) {
    var p = h;
    if (h == null) {
      if (l.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      p = l.file;
    }
    var d = this._sourceRoot;
    d != null && (p = e.relative(d, p));
    var m = new r(), y = new r();
    this._mappings.unsortedForEach(function(g) {
      if (g.source === p && g.originalLine != null) {
        var E = l.originalPositionFor({
          line: g.originalLine,
          column: g.originalColumn
        });
        E.source != null && (g.source = E.source, c != null && (g.source = e.join(c, g.source)), d != null && (g.source = e.relative(d, g.source)), g.originalLine = E.line, g.originalColumn = E.column, E.name != null && (g.name = E.name));
      }
      var S = g.source;
      S != null && !m.has(S) && m.add(S);
      var x = g.name;
      x != null && !y.has(x) && y.add(x);
    }, this), this._sources = m, this._names = y, l.sources.forEach(function(g) {
      var E = l.sourceContentFor(g);
      E != null && (c != null && (g = e.join(c, g)), d != null && (g = e.relative(d, g)), this.setSourceContent(g, E));
    }, this);
  }, n.prototype._validateMapping = function(l, h, c, p) {
    if (h && typeof h.line != "number" && typeof h.column != "number") {
      var d = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping)
        return typeof console < "u" && console.warn && console.warn(d), !1;
      throw new Error(d);
    }
    if (!(l && "line" in l && "column" in l && l.line > 0 && l.column >= 0 && !h && !c && !p)) {
      if (l && "line" in l && "column" in l && h && "line" in h && "column" in h && l.line > 0 && l.column >= 0 && h.line > 0 && h.column >= 0 && c)
        return;
      var d = "Invalid mapping: " + JSON.stringify({
        generated: l,
        source: c,
        original: h,
        name: p
      });
      if (this._ignoreInvalidMapping)
        return typeof console < "u" && console.warn && console.warn(d), !1;
      throw new Error(d);
    }
  }, n.prototype._serializeMappings = function() {
    for (var l = 0, h = 1, c = 0, p = 0, d = 0, m = 0, y = "", g, E, S, x, v = this._mappings.toArray(), P = 0, A = v.length; P < A; P++) {
      if (E = v[P], g = "", E.generatedLine !== h)
        for (l = 0; E.generatedLine !== h; )
          g += ";", h++;
      else if (P > 0) {
        if (!e.compareByGeneratedPositionsInflated(E, v[P - 1]))
          continue;
        g += ",";
      }
      g += t.encode(E.generatedColumn - l), l = E.generatedColumn, E.source != null && (x = this._sources.indexOf(E.source), g += t.encode(x - m), m = x, g += t.encode(E.originalLine - 1 - p), p = E.originalLine - 1, g += t.encode(E.originalColumn - c), c = E.originalColumn, E.name != null && (S = this._names.indexOf(E.name), g += t.encode(S - d), d = S)), y += g;
    }
    return y;
  }, n.prototype._generateSourcesContent = function(l, h) {
    return l.map(function(c) {
      if (!this._sourcesContents)
        return null;
      h != null && (c = e.relative(h, c));
      var p = e.toSetString(c);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, p) ? this._sourcesContents[p] : null;
    }, this);
  }, n.prototype.toJSON = function() {
    var l = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (l.file = this._file), this._sourceRoot != null && (l.sourceRoot = this._sourceRoot), this._sourcesContents && (l.sourcesContent = this._generateSourcesContent(l.sources, l.sourceRoot)), l;
  }, n.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Wa.SourceMapGenerator = n, Wa;
}
var ws = {}, Ja = {}, _h;
function Vb() {
  return _h || (_h = 1, function(t) {
    t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2;
    function e(r, i, n, u, l, h) {
      var c = Math.floor((i - r) / 2) + r, p = l(n, u[c], !0);
      return p === 0 ? c : p > 0 ? i - c > 1 ? e(c, i, n, u, l, h) : h == t.LEAST_UPPER_BOUND ? i < u.length ? i : -1 : c : c - r > 1 ? e(r, c, n, u, l, h) : h == t.LEAST_UPPER_BOUND ? c : r < 0 ? -1 : r;
    }
    t.search = function(i, n, u, l) {
      if (n.length === 0)
        return -1;
      var h = e(
        -1,
        n.length,
        i,
        n,
        u,
        l || t.GREATEST_LOWER_BOUND
      );
      if (h < 0)
        return -1;
      for (; h - 1 >= 0 && u(n[h], n[h - 1], !0) === 0; )
        --h;
      return h;
    };
  }(Ja)), Ja;
}
var Ka = {}, Ah;
function zb() {
  if (Ah) return Ka;
  Ah = 1;
  function t(i) {
    function n(h, c, p) {
      var d = h[c];
      h[c] = h[p], h[p] = d;
    }
    function u(h, c) {
      return Math.round(h + Math.random() * (c - h));
    }
    function l(h, c, p, d) {
      if (p < d) {
        var m = u(p, d), y = p - 1;
        n(h, m, d);
        for (var g = h[d], E = p; E < d; E++)
          c(h[E], g, !1) <= 0 && (y += 1, n(h, y, E));
        n(h, y + 1, E);
        var S = y + 1;
        l(h, c, p, S - 1), l(h, c, S + 1, d);
      }
    }
    return l;
  }
  function e(i) {
    let n = t.toString();
    return new Function(`return ${n}`)()(i);
  }
  let r = /* @__PURE__ */ new WeakMap();
  return Ka.quickSort = function(i, n, u = 0) {
    let l = r.get(n);
    l === void 0 && (l = e(n), r.set(n, l)), l(i, n, u, i.length - 1);
  }, Ka;
}
var Ch;
function Wb() {
  if (Ch) return ws;
  Ch = 1;
  var t = /* @__PURE__ */ ui(), e = /* @__PURE__ */ Vb(), r = S0().ArraySet, i = /* @__PURE__ */ b0(), n = zb().quickSort;
  function u(m, y) {
    var g = m;
    return typeof m == "string" && (g = t.parseSourceMapInput(m)), g.sections != null ? new d(g, y) : new l(g, y);
  }
  u.fromSourceMap = function(m, y) {
    return l.fromSourceMap(m, y);
  }, u.prototype._version = 3, u.prototype.__generatedMappings = null, Object.defineProperty(u.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), u.prototype.__originalMappings = null, Object.defineProperty(u.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), u.prototype._charIsMappingSeparator = function(y, g) {
    var E = y.charAt(g);
    return E === ";" || E === ",";
  }, u.prototype._parseMappings = function(y, g) {
    throw new Error("Subclasses must implement _parseMappings");
  }, u.GENERATED_ORDER = 1, u.ORIGINAL_ORDER = 2, u.GREATEST_LOWER_BOUND = 1, u.LEAST_UPPER_BOUND = 2, u.prototype.eachMapping = function(y, g, E) {
    var S = g || null, x = E || u.GENERATED_ORDER, v;
    switch (x) {
      case u.GENERATED_ORDER:
        v = this._generatedMappings;
        break;
      case u.ORIGINAL_ORDER:
        v = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    for (var P = this.sourceRoot, A = y.bind(S), N = this._names, _ = this._sources, R = this._sourceMapURL, M = 0, O = v.length; M < O; M++) {
      var I = v[M], k = I.source === null ? null : _.at(I.source);
      k !== null && (k = t.computeSourceURL(P, k, R)), A({
        source: k,
        generatedLine: I.generatedLine,
        generatedColumn: I.generatedColumn,
        originalLine: I.originalLine,
        originalColumn: I.originalColumn,
        name: I.name === null ? null : N.at(I.name)
      });
    }
  }, u.prototype.allGeneratedPositionsFor = function(y) {
    var g = t.getArg(y, "line"), E = {
      source: t.getArg(y, "source"),
      originalLine: g,
      originalColumn: t.getArg(y, "column", 0)
    };
    if (E.source = this._findSourceIndex(E.source), E.source < 0)
      return [];
    var S = [], x = this._findMapping(
      E,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      e.LEAST_UPPER_BOUND
    );
    if (x >= 0) {
      var v = this._originalMappings[x];
      if (y.column === void 0)
        for (var P = v.originalLine; v && v.originalLine === P; )
          S.push({
            line: t.getArg(v, "generatedLine", null),
            column: t.getArg(v, "generatedColumn", null),
            lastColumn: t.getArg(v, "lastGeneratedColumn", null)
          }), v = this._originalMappings[++x];
      else
        for (var A = v.originalColumn; v && v.originalLine === g && v.originalColumn == A; )
          S.push({
            line: t.getArg(v, "generatedLine", null),
            column: t.getArg(v, "generatedColumn", null),
            lastColumn: t.getArg(v, "lastGeneratedColumn", null)
          }), v = this._originalMappings[++x];
    }
    return S;
  }, ws.SourceMapConsumer = u;
  function l(m, y) {
    var g = m;
    typeof m == "string" && (g = t.parseSourceMapInput(m));
    var E = t.getArg(g, "version"), S = t.getArg(g, "sources"), x = t.getArg(g, "names", []), v = t.getArg(g, "sourceRoot", null), P = t.getArg(g, "sourcesContent", null), A = t.getArg(g, "mappings"), N = t.getArg(g, "file", null);
    if (E != this._version)
      throw new Error("Unsupported version: " + E);
    v && (v = t.normalize(v)), S = S.map(String).map(t.normalize).map(function(_) {
      return v && t.isAbsolute(v) && t.isAbsolute(_) ? t.relative(v, _) : _;
    }), this._names = r.fromArray(x.map(String), !0), this._sources = r.fromArray(S, !0), this._absoluteSources = this._sources.toArray().map(function(_) {
      return t.computeSourceURL(v, _, y);
    }), this.sourceRoot = v, this.sourcesContent = P, this._mappings = A, this._sourceMapURL = y, this.file = N;
  }
  l.prototype = Object.create(u.prototype), l.prototype.consumer = u, l.prototype._findSourceIndex = function(m) {
    var y = m;
    if (this.sourceRoot != null && (y = t.relative(this.sourceRoot, y)), this._sources.has(y))
      return this._sources.indexOf(y);
    var g;
    for (g = 0; g < this._absoluteSources.length; ++g)
      if (this._absoluteSources[g] == m)
        return g;
    return -1;
  }, l.fromSourceMap = function(y, g) {
    var E = Object.create(l.prototype), S = E._names = r.fromArray(y._names.toArray(), !0), x = E._sources = r.fromArray(y._sources.toArray(), !0);
    E.sourceRoot = y._sourceRoot, E.sourcesContent = y._generateSourcesContent(
      E._sources.toArray(),
      E.sourceRoot
    ), E.file = y._file, E._sourceMapURL = g, E._absoluteSources = E._sources.toArray().map(function(O) {
      return t.computeSourceURL(E.sourceRoot, O, g);
    });
    for (var v = y._mappings.toArray().slice(), P = E.__generatedMappings = [], A = E.__originalMappings = [], N = 0, _ = v.length; N < _; N++) {
      var R = v[N], M = new h();
      M.generatedLine = R.generatedLine, M.generatedColumn = R.generatedColumn, R.source && (M.source = x.indexOf(R.source), M.originalLine = R.originalLine, M.originalColumn = R.originalColumn, R.name && (M.name = S.indexOf(R.name)), A.push(M)), P.push(M);
    }
    return n(E.__originalMappings, t.compareByOriginalPositions), E;
  }, l.prototype._version = 3, Object.defineProperty(l.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function h() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  const c = t.compareByGeneratedPositionsDeflatedNoLine;
  function p(m, y) {
    let g = m.length, E = m.length - y;
    if (!(E <= 1))
      if (E == 2) {
        let S = m[y], x = m[y + 1];
        c(S, x) > 0 && (m[y] = x, m[y + 1] = S);
      } else if (E < 20)
        for (let S = y; S < g; S++)
          for (let x = S; x > y; x--) {
            let v = m[x - 1], P = m[x];
            if (c(v, P) <= 0)
              break;
            m[x - 1] = P, m[x] = v;
          }
      else
        n(m, c, y);
  }
  l.prototype._parseMappings = function(y, g) {
    var E = 1, S = 0, x = 0, v = 0, P = 0, A = 0, N = y.length, _ = 0, R = {}, M = [], O = [], I, k, L, V;
    let K = 0;
    for (; _ < N; )
      if (y.charAt(_) === ";")
        E++, _++, S = 0, p(O, K), K = O.length;
      else if (y.charAt(_) === ",")
        _++;
      else {
        for (I = new h(), I.generatedLine = E, L = _; L < N && !this._charIsMappingSeparator(y, L); L++)
          ;
        for (y.slice(_, L), k = []; _ < L; )
          i.decode(y, _, R), V = R.value, _ = R.rest, k.push(V);
        if (k.length === 2)
          throw new Error("Found a source, but no line and column");
        if (k.length === 3)
          throw new Error("Found a source and line, but no column");
        if (I.generatedColumn = S + k[0], S = I.generatedColumn, k.length > 1 && (I.source = P + k[1], P += k[1], I.originalLine = x + k[2], x = I.originalLine, I.originalLine += 1, I.originalColumn = v + k[3], v = I.originalColumn, k.length > 4 && (I.name = A + k[4], A += k[4])), O.push(I), typeof I.originalLine == "number") {
          let z = I.source;
          for (; M.length <= z; )
            M.push(null);
          M[z] === null && (M[z] = []), M[z].push(I);
        }
      }
    p(O, K), this.__generatedMappings = O;
    for (var re = 0; re < M.length; re++)
      M[re] != null && n(M[re], t.compareByOriginalPositionsNoSource);
    this.__originalMappings = [].concat(...M);
  }, l.prototype._findMapping = function(y, g, E, S, x, v) {
    if (y[E] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + y[E]);
    if (y[S] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + y[S]);
    return e.search(y, g, x, v);
  }, l.prototype.computeColumnSpans = function() {
    for (var y = 0; y < this._generatedMappings.length; ++y) {
      var g = this._generatedMappings[y];
      if (y + 1 < this._generatedMappings.length) {
        var E = this._generatedMappings[y + 1];
        if (g.generatedLine === E.generatedLine) {
          g.lastGeneratedColumn = E.generatedColumn - 1;
          continue;
        }
      }
      g.lastGeneratedColumn = 1 / 0;
    }
  }, l.prototype.originalPositionFor = function(y) {
    var g = {
      generatedLine: t.getArg(y, "line"),
      generatedColumn: t.getArg(y, "column")
    }, E = this._findMapping(
      g,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      t.compareByGeneratedPositionsDeflated,
      t.getArg(y, "bias", u.GREATEST_LOWER_BOUND)
    );
    if (E >= 0) {
      var S = this._generatedMappings[E];
      if (S.generatedLine === g.generatedLine) {
        var x = t.getArg(S, "source", null);
        x !== null && (x = this._sources.at(x), x = t.computeSourceURL(this.sourceRoot, x, this._sourceMapURL));
        var v = t.getArg(S, "name", null);
        return v !== null && (v = this._names.at(v)), {
          source: x,
          line: t.getArg(S, "originalLine", null),
          column: t.getArg(S, "originalColumn", null),
          name: v
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, l.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(y) {
      return y == null;
    }) : !1;
  }, l.prototype.sourceContentFor = function(y, g) {
    if (!this.sourcesContent)
      return null;
    var E = this._findSourceIndex(y);
    if (E >= 0)
      return this.sourcesContent[E];
    var S = y;
    this.sourceRoot != null && (S = t.relative(this.sourceRoot, S));
    var x;
    if (this.sourceRoot != null && (x = t.urlParse(this.sourceRoot))) {
      var v = S.replace(/^file:\/\//, "");
      if (x.scheme == "file" && this._sources.has(v))
        return this.sourcesContent[this._sources.indexOf(v)];
      if ((!x.path || x.path == "/") && this._sources.has("/" + S))
        return this.sourcesContent[this._sources.indexOf("/" + S)];
    }
    if (g)
      return null;
    throw new Error('"' + S + '" is not in the SourceMap.');
  }, l.prototype.generatedPositionFor = function(y) {
    var g = t.getArg(y, "source");
    if (g = this._findSourceIndex(g), g < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var E = {
      source: g,
      originalLine: t.getArg(y, "line"),
      originalColumn: t.getArg(y, "column")
    }, S = this._findMapping(
      E,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      t.getArg(y, "bias", u.GREATEST_LOWER_BOUND)
    );
    if (S >= 0) {
      var x = this._originalMappings[S];
      if (x.source === E.source)
        return {
          line: t.getArg(x, "generatedLine", null),
          column: t.getArg(x, "generatedColumn", null),
          lastColumn: t.getArg(x, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, ws.BasicSourceMapConsumer = l;
  function d(m, y) {
    var g = m;
    typeof m == "string" && (g = t.parseSourceMapInput(m));
    var E = t.getArg(g, "version"), S = t.getArg(g, "sections");
    if (E != this._version)
      throw new Error("Unsupported version: " + E);
    this._sources = new r(), this._names = new r();
    var x = {
      line: -1,
      column: 0
    };
    this._sections = S.map(function(v) {
      if (v.url)
        throw new Error("Support for url field in sections not implemented.");
      var P = t.getArg(v, "offset"), A = t.getArg(P, "line"), N = t.getArg(P, "column");
      if (A < x.line || A === x.line && N < x.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return x = P, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: A + 1,
          generatedColumn: N + 1
        },
        consumer: new u(t.getArg(v, "map"), y)
      };
    });
  }
  return d.prototype = Object.create(u.prototype), d.prototype.constructor = u, d.prototype._version = 3, Object.defineProperty(d.prototype, "sources", {
    get: function() {
      for (var m = [], y = 0; y < this._sections.length; y++)
        for (var g = 0; g < this._sections[y].consumer.sources.length; g++)
          m.push(this._sections[y].consumer.sources[g]);
      return m;
    }
  }), d.prototype.originalPositionFor = function(y) {
    var g = {
      generatedLine: t.getArg(y, "line"),
      generatedColumn: t.getArg(y, "column")
    }, E = e.search(
      g,
      this._sections,
      function(x, v) {
        var P = x.generatedLine - v.generatedOffset.generatedLine;
        return P || x.generatedColumn - v.generatedOffset.generatedColumn;
      }
    ), S = this._sections[E];
    return S ? S.consumer.originalPositionFor({
      line: g.generatedLine - (S.generatedOffset.generatedLine - 1),
      column: g.generatedColumn - (S.generatedOffset.generatedLine === g.generatedLine ? S.generatedOffset.generatedColumn - 1 : 0),
      bias: y.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, d.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(y) {
      return y.consumer.hasContentsOfAllSources();
    });
  }, d.prototype.sourceContentFor = function(y, g) {
    for (var E = 0; E < this._sections.length; E++) {
      var S = this._sections[E], x = S.consumer.sourceContentFor(y, !0);
      if (x || x === "")
        return x;
    }
    if (g)
      return null;
    throw new Error('"' + y + '" is not in the SourceMap.');
  }, d.prototype.generatedPositionFor = function(y) {
    for (var g = 0; g < this._sections.length; g++) {
      var E = this._sections[g];
      if (E.consumer._findSourceIndex(t.getArg(y, "source")) !== -1) {
        var S = E.consumer.generatedPositionFor(y);
        if (S) {
          var x = {
            line: S.line + (E.generatedOffset.generatedLine - 1),
            column: S.column + (E.generatedOffset.generatedLine === S.line ? E.generatedOffset.generatedColumn - 1 : 0)
          };
          return x;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, d.prototype._parseMappings = function(y, g) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var E = 0; E < this._sections.length; E++)
      for (var S = this._sections[E], x = S.consumer._generatedMappings, v = 0; v < x.length; v++) {
        var P = x[v], A = S.consumer._sources.at(P.source);
        A !== null && (A = t.computeSourceURL(S.consumer.sourceRoot, A, this._sourceMapURL)), this._sources.add(A), A = this._sources.indexOf(A);
        var N = null;
        P.name && (N = S.consumer._names.at(P.name), this._names.add(N), N = this._names.indexOf(N));
        var _ = {
          source: A,
          generatedLine: P.generatedLine + (S.generatedOffset.generatedLine - 1),
          generatedColumn: P.generatedColumn + (S.generatedOffset.generatedLine === P.generatedLine ? S.generatedOffset.generatedColumn - 1 : 0),
          originalLine: P.originalLine,
          originalColumn: P.originalColumn,
          name: N
        };
        this.__generatedMappings.push(_), typeof _.originalLine == "number" && this.__originalMappings.push(_);
      }
    n(this.__generatedMappings, t.compareByGeneratedPositionsDeflated), n(this.__originalMappings, t.compareByOriginalPositions);
  }, ws.IndexedSourceMapConsumer = d, ws;
}
var Ya = {}, Ih;
function Hb() {
  if (Ih) return Ya;
  Ih = 1;
  var t = v0().SourceMapGenerator, e = /* @__PURE__ */ ui(), r = /(\r?\n)/, i = 10, n = "$$$isSourceNode$$$";
  function u(l, h, c, p, d) {
    this.children = [], this.sourceContents = {}, this.line = l ?? null, this.column = h ?? null, this.source = c ?? null, this.name = d ?? null, this[n] = !0, p != null && this.add(p);
  }
  return u.fromStringWithSourceMap = function(h, c, p) {
    var d = new u(), m = h.split(r), y = 0, g = function() {
      var P = N(), A = N() || "";
      return P + A;
      function N() {
        return y < m.length ? m[y++] : void 0;
      }
    }, E = 1, S = 0, x = null;
    return c.eachMapping(function(P) {
      if (x !== null)
        if (E < P.generatedLine)
          v(x, g()), E++, S = 0;
        else {
          var A = m[y] || "", N = A.substr(0, P.generatedColumn - S);
          m[y] = A.substr(P.generatedColumn - S), S = P.generatedColumn, v(x, N), x = P;
          return;
        }
      for (; E < P.generatedLine; )
        d.add(g()), E++;
      if (S < P.generatedColumn) {
        var A = m[y] || "";
        d.add(A.substr(0, P.generatedColumn)), m[y] = A.substr(P.generatedColumn), S = P.generatedColumn;
      }
      x = P;
    }, this), y < m.length && (x && v(x, g()), d.add(m.splice(y).join(""))), c.sources.forEach(function(P) {
      var A = c.sourceContentFor(P);
      A != null && (p != null && (P = e.join(p, P)), d.setSourceContent(P, A));
    }), d;
    function v(P, A) {
      if (P === null || P.source === void 0)
        d.add(A);
      else {
        var N = p ? e.join(p, P.source) : P.source;
        d.add(new u(
          P.originalLine,
          P.originalColumn,
          N,
          A,
          P.name
        ));
      }
    }
  }, u.prototype.add = function(h) {
    if (Array.isArray(h))
      h.forEach(function(c) {
        this.add(c);
      }, this);
    else if (h[n] || typeof h == "string")
      h && this.children.push(h);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + h
      );
    return this;
  }, u.prototype.prepend = function(h) {
    if (Array.isArray(h))
      for (var c = h.length - 1; c >= 0; c--)
        this.prepend(h[c]);
    else if (h[n] || typeof h == "string")
      this.children.unshift(h);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + h
      );
    return this;
  }, u.prototype.walk = function(h) {
    for (var c, p = 0, d = this.children.length; p < d; p++)
      c = this.children[p], c[n] ? c.walk(h) : c !== "" && h(c, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, u.prototype.join = function(h) {
    var c, p, d = this.children.length;
    if (d > 0) {
      for (c = [], p = 0; p < d - 1; p++)
        c.push(this.children[p]), c.push(h);
      c.push(this.children[p]), this.children = c;
    }
    return this;
  }, u.prototype.replaceRight = function(h, c) {
    var p = this.children[this.children.length - 1];
    return p[n] ? p.replaceRight(h, c) : typeof p == "string" ? this.children[this.children.length - 1] = p.replace(h, c) : this.children.push("".replace(h, c)), this;
  }, u.prototype.setSourceContent = function(h, c) {
    this.sourceContents[e.toSetString(h)] = c;
  }, u.prototype.walkSourceContents = function(h) {
    for (var c = 0, p = this.children.length; c < p; c++)
      this.children[c][n] && this.children[c].walkSourceContents(h);
    for (var d = Object.keys(this.sourceContents), c = 0, p = d.length; c < p; c++)
      h(e.fromSetString(d[c]), this.sourceContents[d[c]]);
  }, u.prototype.toString = function() {
    var h = "";
    return this.walk(function(c) {
      h += c;
    }), h;
  }, u.prototype.toStringWithSourceMap = function(h) {
    var c = {
      code: "",
      line: 1,
      column: 0
    }, p = new t(h), d = !1, m = null, y = null, g = null, E = null;
    return this.walk(function(S, x) {
      c.code += S, x.source !== null && x.line !== null && x.column !== null ? ((m !== x.source || y !== x.line || g !== x.column || E !== x.name) && p.addMapping({
        source: x.source,
        original: {
          line: x.line,
          column: x.column
        },
        generated: {
          line: c.line,
          column: c.column
        },
        name: x.name
      }), m = x.source, y = x.line, g = x.column, E = x.name, d = !0) : d && (p.addMapping({
        generated: {
          line: c.line,
          column: c.column
        }
      }), m = null, d = !1);
      for (var v = 0, P = S.length; v < P; v++)
        S.charCodeAt(v) === i ? (c.line++, c.column = 0, v + 1 === P ? (m = null, d = !1) : d && p.addMapping({
          source: x.source,
          original: {
            line: x.line,
            column: x.column
          },
          generated: {
            line: c.line,
            column: c.column
          },
          name: x.name
        })) : c.column++;
    }), this.walkSourceContents(function(S, x) {
      p.setSourceContent(S, x);
    }), { code: c.code, map: p };
  }, Ya.SourceNode = u, Ya;
}
var Nh;
function oa() {
  return Nh || (Nh = 1, Ts.SourceMapGenerator = v0().SourceMapGenerator, Ts.SourceMapConsumer = Wb().SourceMapConsumer, Ts.SourceNode = Hb().SourceNode), Ts;
}
var Ar = /* @__PURE__ */ oa();
const ua = "/*@__PURE__*/", nn = (t) => `${ot[t]}: _${ot[t]}`;
function Oh(t, {
  mode: e = "function",
  prefixIdentifiers: r = e === "module",
  sourceMap: i = !1,
  filename: n = "template.vue.html",
  scopeId: u = null,
  optimizeImports: l = !1,
  runtimeGlobalName: h = "Vue",
  runtimeModuleName: c = "vue",
  ssrRuntimeModuleName: p = "vue/server-renderer",
  ssr: d = !1,
  isTS: m = !1,
  inSSR: y = !1
}) {
  const g = {
    mode: e,
    prefixIdentifiers: r,
    sourceMap: i,
    filename: n,
    scopeId: u,
    optimizeImports: l,
    runtimeGlobalName: h,
    runtimeModuleName: c,
    ssrRuntimeModuleName: p,
    ssr: d,
    isTS: m,
    inSSR: y,
    source: t.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(x) {
      return `_${ot[x]}`;
    },
    push(x, v = -2, P) {
      if (g.code += x, g.map) {
        if (P) {
          let A;
          if (P.type === 4 && !P.isStatic) {
            const N = P.content.replace(/^_ctx\./, "");
            N !== P.content && Kt(N) && (A = N);
          }
          P.loc.source && S(P.loc.start, A);
        }
        v === -3 ? Yu(g, x) : (g.offset += x.length, v === -2 ? g.column += x.length : (v === -1 && (v = x.length - 1), g.line++, g.column = x.length - v)), P && P.loc !== Le && P.loc.source && S(P.loc.end);
      }
    },
    indent() {
      E(++g.indentLevel);
    },
    deindent(x = !1) {
      x ? --g.indentLevel : E(--g.indentLevel);
    },
    newline() {
      E(g.indentLevel);
    }
  };
  function E(x) {
    g.push(
      `
` + "  ".repeat(x),
      0
      /* Start */
    );
  }
  function S(x, v = null) {
    const { _names: P, _mappings: A } = g.map;
    v !== null && !P.has(v) && P.add(v), A.add({
      originalLine: x.line,
      originalColumn: x.column - 1,
      // source-map column is 0 based
      generatedLine: g.line,
      generatedColumn: g.column - 1,
      source: n,
      name: v
    });
  }
  return i && (g.map = new Ar.SourceMapGenerator(), g.map.setSourceContent(n, g.source), g.map._sources.add(n)), g;
}
function tl(t, e = {}) {
  const r = Oh(t, e);
  e.onContextCreated && e.onContextCreated(r);
  const {
    mode: i,
    push: n,
    prefixIdentifiers: u,
    indent: l,
    deindent: h,
    newline: c,
    scopeId: p,
    ssr: d
  } = r, m = Array.from(t.helpers), y = m.length > 0, g = !u && i !== "module", E = p != null && i === "module", S = !!e.inline, x = S ? Oh(t, e) : r;
  i === "module" ? Xb(t, x, E, S) : Gb(t, x);
  const v = d ? "ssrRender" : "render", P = d ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  e.bindingMetadata && !e.inline && P.push("$props", "$setup", "$data", "$options");
  const A = e.isTS ? P.map((N) => `${N}: any`).join(",") : P.join(", ");
  if (n(S ? `(${A}) => {` : `function ${v}(${A}) {`), l(), g && (n("with (_ctx) {"), l(), y && (n(
    `const { ${m.map(nn).join(", ")} } = _Vue
`,
    -1
    /* End */
  ), c())), t.components.length && (kh(t.components, "component", r), (t.directives.length || t.temps > 0) && c()), t.directives.length && (kh(t.directives, "directive", r), t.temps > 0 && c()), t.temps > 0) {
    n("let ");
    for (let N = 0; N < t.temps; N++)
      n(`${N > 0 ? ", " : ""}_temp${N}`);
  }
  return (t.components.length || t.directives.length || t.temps) && (n(
    `
`,
    0
    /* Start */
  ), c()), d || n("return "), t.codegenNode ? ke(t.codegenNode, r) : n("null"), g && (h(), n("}")), h(), n("}"), {
    ast: t,
    code: r.code,
    preamble: S ? x.code : "",
    map: r.map ? r.map.toJSON() : void 0
  };
}
function Gb(t, e) {
  const {
    ssr: r,
    prefixIdentifiers: i,
    push: n,
    newline: u,
    runtimeModuleName: l,
    runtimeGlobalName: h,
    ssrRuntimeModuleName: c
  } = e, p = r ? `require(${JSON.stringify(l)})` : h, d = Array.from(t.helpers);
  if (d.length > 0) {
    if (i)
      n(
        `const { ${d.map(nn).join(", ")} } = ${p}
`,
        -1
        /* End */
      );
    else if (n(
      `const _Vue = ${p}
`,
      -1
      /* End */
    ), t.hoists.length) {
      const m = [
        ri,
        qn,
        hs,
        jn,
        Vn
      ].filter((y) => d.includes(y)).map(nn).join(", ");
      n(
        `const { ${m} } = _Vue
`,
        -1
        /* End */
      );
    }
  }
  t.ssrHelpers && t.ssrHelpers.length && n(
    `const { ${t.ssrHelpers.map(nn).join(", ")} } = require("${c}")
`,
    -1
    /* End */
  ), x0(t.hoists, e), u(), n("return ");
}
function Xb(t, e, r, i) {
  const {
    push: n,
    newline: u,
    optimizeImports: l,
    runtimeModuleName: h,
    ssrRuntimeModuleName: c
  } = e;
  if (t.helpers.size) {
    const p = Array.from(t.helpers);
    l ? (n(
      `import { ${p.map((d) => ot[d]).join(", ")} } from ${JSON.stringify(h)}
`,
      -1
      /* End */
    ), n(
      `
// Binding optimization for webpack code-split
const ${p.map((d) => `_${ot[d]} = ${ot[d]}`).join(", ")}
`,
      -1
      /* End */
    )) : n(
      `import { ${p.map((d) => `${ot[d]} as _${ot[d]}`).join(", ")} } from ${JSON.stringify(h)}
`,
      -1
      /* End */
    );
  }
  t.ssrHelpers && t.ssrHelpers.length && n(
    `import { ${t.ssrHelpers.map((p) => `${ot[p]} as _${ot[p]}`).join(", ")} } from "${c}"
`,
    -1
    /* End */
  ), t.imports.length && (Jb(t.imports, e), u()), x0(t.hoists, e), u(), i || n("export ");
}
function kh(t, e, { helper: r, push: i, newline: n, isTS: u }) {
  const l = r(
    e === "component" ? zs : zn
  );
  for (let h = 0; h < t.length; h++) {
    let c = t[h];
    const p = c.endsWith("__self");
    p && (c = c.slice(0, -6)), i(
      `const ${Js(c, e)} = ${l}(${JSON.stringify(c)}${p ? ", true" : ""})${u ? "!" : ""}`
    ), h < t.length - 1 && n();
  }
}
function x0(t, e) {
  if (!t.length)
    return;
  e.pure = !0;
  const { push: r, newline: i } = e;
  i();
  for (let n = 0; n < t.length; n++) {
    const u = t[n];
    u && (r(`const _hoisted_${n + 1} = `), ke(u, e), i());
  }
  e.pure = !1;
}
function Jb(t, e) {
  t.length && t.forEach((r) => {
    e.push("import "), ke(r.exp, e), e.push(` from '${r.path}'`), e.newline();
  });
}
function Kb(t) {
  return Se(t) || t.type === 4 || t.type === 2 || t.type === 5 || t.type === 8;
}
function la(t, e) {
  const r = t.length > 3 || t.some((i) => $e(i) || !Kb(i));
  e.push("["), r && e.indent(), ds(t, e, r), r && e.deindent(), e.push("]");
}
function ds(t, e, r = !1, i = !0) {
  const { push: n, newline: u } = e;
  for (let l = 0; l < t.length; l++) {
    const h = t[l];
    Se(h) ? n(
      h,
      -3
      /* Unknown */
    ) : $e(h) ? la(h, e) : ke(h, e), l < t.length - 1 && (r ? (i && n(","), u()) : i && n(", "));
  }
}
function ke(t, e) {
  if (Se(t)) {
    e.push(
      t,
      -3
      /* Unknown */
    );
    return;
  }
  if (fr(t)) {
    e.push(e.helper(t));
    return;
  }
  switch (t.type) {
    case 1:
    case 9:
    case 11:
      au(
        t.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), ke(t.codegenNode, e);
      break;
    case 2:
      Yb(t, e);
      break;
    case 4:
      E0(t, e);
      break;
    case 5:
      Qb(t, e);
      break;
    case 12:
      ke(t.codegenNode, e);
      break;
    case 8:
      T0(t, e);
      break;
    case 3:
      e2(t, e);
      break;
    case 13:
      t2(t, e);
      break;
    case 14:
      s2(t, e);
      break;
    case 15:
      i2(t, e);
      break;
    case 17:
      n2(t, e);
      break;
    case 18:
      a2(t, e);
      break;
    case 19:
      o2(t, e);
      break;
    case 20:
      u2(t, e);
      break;
    case 21:
      ds(t.body, e, !0, !1);
      break;
    case 22:
      l2(t, e);
      break;
    case 23:
      w0(t, e);
      break;
    case 24:
      c2(t, e);
      break;
    case 25:
      h2(t, e);
      break;
    case 26:
      f2(t, e);
      break;
    case 10:
      break;
    default:
      return au(!1, `unhandled codegen node type: ${t.type}`), t;
  }
}
function Yb(t, e) {
  e.push(JSON.stringify(t.content), -3, t);
}
function E0(t, e) {
  const { content: r, isStatic: i } = t;
  e.push(
    i ? JSON.stringify(r) : r,
    -3,
    t
  );
}
function Qb(t, e) {
  const { push: r, helper: i, pure: n } = e;
  n && r(ua), r(`${i(ii)}(`), ke(t.content, e), r(")");
}
function T0(t, e) {
  for (let r = 0; r < t.children.length; r++) {
    const i = t.children[r];
    Se(i) ? e.push(
      i,
      -3
      /* Unknown */
    ) : ke(i, e);
  }
}
function Zb(t, e) {
  const { push: r } = e;
  if (t.type === 8)
    r("["), T0(t, e), r("]");
  else if (t.isStatic) {
    const i = Kt(t.content) ? t.content : JSON.stringify(t.content);
    r(i, -2, t);
  } else
    r(`[${t.content}]`, -3, t);
}
function e2(t, e) {
  const { push: r, helper: i, pure: n } = e;
  n && r(ua), r(
    `${i(hs)}(${JSON.stringify(t.content)})`,
    -3,
    t
  );
}
function t2(t, e) {
  const { push: r, helper: i, pure: n } = e, {
    tag: u,
    props: l,
    children: h,
    patchFlag: c,
    dynamicProps: p,
    directives: d,
    isBlock: m,
    disableTracking: y,
    isComponent: g
  } = t;
  let E;
  if (c)
    if (c < 0)
      E = c + ` /* ${Ls[c]} */`;
    else {
      const x = Object.keys(Ls).map(Number).filter((v) => v > 0 && c & v).map((v) => Ls[v]).join(", ");
      E = c + ` /* ${x} */`;
    }
  d && r(i(Wn) + "("), m && r(`(${i(cr)}(${y ? "true" : ""}), `), n && r(ua);
  const S = m ? Lr(e.inSSR, g) : kr(e.inSSR, g);
  r(i(S) + "(", -2, t), ds(
    r2([u, l, h, E, p]),
    e
  ), r(")"), m && r(")"), d && (r(", "), ke(d, e), r(")"));
}
function r2(t) {
  let e = t.length;
  for (; e-- && t[e] == null; )
    ;
  return t.slice(0, e + 1).map((r) => r || "null");
}
function s2(t, e) {
  const { push: r, helper: i, pure: n } = e, u = Se(t.callee) ? t.callee : i(t.callee);
  n && r(ua), r(u + "(", -2, t), ds(t.arguments, e), r(")");
}
function i2(t, e) {
  const { push: r, indent: i, deindent: n, newline: u } = e, { properties: l } = t;
  if (!l.length) {
    r("{}", -2, t);
    return;
  }
  const h = l.length > 1 || l.some((c) => c.value.type !== 4);
  r(h ? "{" : "{ "), h && i();
  for (let c = 0; c < l.length; c++) {
    const { key: p, value: d } = l[c];
    Zb(p, e), r(": "), ke(d, e), c < l.length - 1 && (r(","), u());
  }
  h && n(), r(h ? "}" : " }");
}
function n2(t, e) {
  la(t.elements, e);
}
function a2(t, e) {
  const { push: r, indent: i, deindent: n } = e, { params: u, returns: l, body: h, newline: c, isSlot: p } = t;
  p && r(`_${ot[Kn]}(`), r("(", -2, t), $e(u) ? ds(u, e) : u && ke(u, e), r(") => "), (c || h) && (r("{"), i()), l ? (c && r("return "), $e(l) ? la(l, e) : ke(l, e)) : h && ke(h, e), (c || h) && (n(), r("}")), p && r(")");
}
function o2(t, e) {
  const { test: r, consequent: i, alternate: n, newline: u } = t, { push: l, indent: h, deindent: c, newline: p } = e;
  if (r.type === 4) {
    const m = !Kt(r.content);
    m && l("("), E0(r, e), m && l(")");
  } else
    l("("), ke(r, e), l(")");
  u && h(), e.indentLevel++, u || l(" "), l("? "), ke(i, e), e.indentLevel--, u && p(), u || l(" "), l(": ");
  const d = n.type === 19;
  d || e.indentLevel++, ke(n, e), d || e.indentLevel--, u && c(
    !0
    /* without newline */
  );
}
function u2(t, e) {
  const { push: r, helper: i, indent: n, deindent: u, newline: l } = e, { needPauseTracking: h, needArraySpread: c } = t;
  c && r("[...("), r(`_cache[${t.index}] || (`), h && (n(), r(`${i(Ws)}(-1`), t.inVOnce && r(", true"), r("),"), l(), r("(")), r(`_cache[${t.index}] = `), ke(t.value, e), h && (r(`).cacheIndex = ${t.index},`), l(), r(`${i(Ws)}(1),`), l(), r(`_cache[${t.index}]`), u()), r(")"), c && r(")]");
}
function l2(t, e) {
  const { push: r, indent: i, deindent: n } = e;
  r("`");
  const u = t.elements.length, l = u > 3;
  for (let h = 0; h < u; h++) {
    const c = t.elements[h];
    Se(c) ? r(
      c.replace(/(`|\$|\\)/g, "\\$1"),
      -3
      /* Unknown */
    ) : (r("${"), l && i(), ke(c, e), l && n(), r("}"));
  }
  r("`");
}
function w0(t, e) {
  const { push: r, indent: i, deindent: n } = e, { test: u, consequent: l, alternate: h } = t;
  r("if ("), ke(u, e), r(") {"), i(), ke(l, e), n(), r("}"), h && (r(" else "), h.type === 23 ? w0(h, e) : (r("{"), i(), ke(h, e), n(), r("}")));
}
function c2(t, e) {
  ke(t.left, e), e.push(" = "), ke(t.right, e);
}
function h2(t, e) {
  e.push("("), ds(t.expressions, e), e.push(")");
}
function f2({ returns: t }, e) {
  e.push("return "), $e(t) ? la(t, e) : ke(t, e);
}
const p2 = /* @__PURE__ */ Xe("true,false,null,this"), rl = (t, e) => {
  if (t.type === 5)
    t.content = Ue(
      t.content,
      e
    );
  else if (t.type === 1) {
    const r = Fe(t, "memo");
    for (let i = 0; i < t.props.length; i++) {
      const n = t.props[i];
      if (n.type === 7 && n.name !== "for") {
        const u = n.exp, l = n.arg;
        u && u.type === 4 && !(n.name === "on" && l) && // key has been processed in transformFor(vMemo + vFor)
        !(r && l && l.type === 4 && l.content === "key") && (n.exp = Ue(
          u,
          e,
          // slot args must be processed as function params
          n.name === "slot"
        )), l && l.type === 4 && !l.isStatic && (n.arg = Ue(l, e));
      }
    }
  }
};
function Ue(t, e, r = !1, i = !1, n = Object.create(e.identifiers)) {
  if (!e.prefixIdentifiers || !t.content.trim())
    return t;
  const { inline: u, bindingMetadata: l } = e, h = (S, x, v) => {
    const P = Lu(l, S) && l[S];
    if (u) {
      const A = x && x.type === "AssignmentExpression" && x.left === v, N = x && x.type === "UpdateExpression" && x.argument === v, _ = x && Gs(x, m), R = x && Zd(m), M = (O) => {
        const I = `${e.helperString(ns)}(${O})`;
        return R ? `(${I})` : I;
      };
      if (Lh(P) || P === "setup-reactive-const" || n[S])
        return S;
      if (P === "setup-ref")
        return `${S}.value`;
      if (P === "setup-maybe-ref")
        return A || N || _ ? `${S}.value` : M(S);
      if (P === "setup-let")
        if (A) {
          const { right: O, operator: I } = x, k = c.slice(O.start - 1, O.end - 1), L = ca(
            Ue(
              te(k, !1),
              e,
              !1,
              !1,
              y
            )
          );
          return `${e.helperString(Hs)}(${S})${e.isTS ? ` //@ts-ignore
` : ""} ? ${S}.value ${I} ${L} : ${S}`;
        } else if (N) {
          v.start = x.start, v.end = x.end;
          const { prefix: O, operator: I } = x, k = O ? I : "", L = O ? "" : I;
          return `${e.helperString(Hs)}(${S})${e.isTS ? ` //@ts-ignore
` : ""} ? ${k}${S}.value${L} : ${k}${S}${L}`;
        } else return _ ? S : M(S);
      else {
        if (P === "props")
          return pn(S);
        if (P === "props-aliased")
          return pn(l.__propsAliases[S]);
      }
    } else {
      if (P && P.startsWith("setup") || P === "literal-const")
        return `$setup.${S}`;
      if (P === "props-aliased")
        return `$props['${l.__propsAliases[S]}']`;
      if (P)
        return `$${P}.${S}`;
    }
    return `_ctx.${S}`;
  }, c = t.content;
  let p = t.ast;
  if (p === !1)
    return t;
  if (p === null || !p && Kt(c)) {
    const S = e.identifiers[c], x = Ld(c), v = p2(c);
    return !r && !S && !v && (!x || l[c]) ? (Lh(l[c]) && (t.constType = 1), t.content = h(c)) : S || (v ? t.constType = 3 : t.constType = 2), t;
  }
  if (!p) {
    const S = i ? ` ${c} ` : `(${c})${r ? "=>{}" : ""}`;
    try {
      p = It.parseExpression(S, {
        sourceType: "module",
        plugins: e.expressionPlugins
      });
    } catch (x) {
      return e.onError(
        Te(
          45,
          t.loc,
          void 0,
          x.message
        )
      ), t;
    }
  }
  const d = [], m = [], y = Object.create(e.identifiers);
  ta(
    p,
    (S, x, v, P, A) => {
      if (s0(S, x))
        return;
      const N = P && d2(S);
      N && !A ? (ra(x) && x.shorthand && (S.prefix = `${S.name}: `), S.name = h(S.name, x, S), d.push(S)) : (!(N && A) && (!x || x.type !== "CallExpression" && x.type !== "NewExpression" && x.type !== "MemberExpression") && (S.isConstant = !0), d.push(S));
    },
    !0,
    // invoke on ALL identifiers
    m,
    y
  );
  const g = [];
  d.sort((S, x) => S.start - x.start), d.forEach((S, x) => {
    const v = S.start - 1, P = S.end - 1, A = d[x - 1], N = c.slice(A ? A.end - 1 : 0, v);
    (N.length || S.prefix) && g.push(N + (S.prefix || ""));
    const _ = c.slice(v, P);
    g.push(
      te(
        S.name,
        !1,
        {
          start: nu(t.loc.start, _, v),
          end: nu(t.loc.start, _, P),
          source: _
        },
        S.isConstant ? 3 : 0
      )
    ), x === d.length - 1 && P < c.length && g.push(c.slice(P));
  });
  let E;
  return g.length ? (E = je(g, t.loc), E.ast = p) : (E = t, E.constType = 3), E.identifiers = Object.keys(y), E;
}
function d2(t) {
  return !(Ld(t.name) || t.name === "require");
}
function ca(t) {
  return Se(t) ? t : t.type === 4 ? t.content : t.children.map(ca).join("");
}
function Lh(t) {
  return t === "setup-const" || t === "literal-const";
}
const m2 = oi(
  /^(if|else|else-if)$/,
  (t, e, r) => sl(t, e, r, (i, n, u) => {
    const l = r.parent.children;
    let h = l.indexOf(i), c = 0;
    for (; h-- >= 0; ) {
      const p = l[h];
      p && p.type === 9 && (c += p.branches.length);
    }
    return () => {
      if (u)
        i.codegenNode = Dh(
          n,
          c,
          r
        );
      else {
        const p = g2(i.codegenNode);
        p.alternate = Dh(
          n,
          c + i.branches.length - 1,
          r
        );
      }
    };
  })
);
function sl(t, e, r, i) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const n = e.exp ? e.exp.loc : t.loc;
    r.onError(
      Te(28, e.loc)
    ), e.exp = te("true", !1, n);
  }
  if (r.prefixIdentifiers && e.exp && (e.exp = Ue(e.exp, r)), e.name === "if") {
    const n = Rh(t, e), u = {
      type: 9,
      loc: Rb(t.loc),
      branches: [n]
    };
    if (r.replaceNode(u), i)
      return i(u, n, !0);
  } else {
    const n = r.parent.children, u = [];
    let l = n.indexOf(t);
    for (; l-- >= -1; ) {
      const h = n[l];
      if (h && h.type === 3) {
        r.removeNode(h), u.unshift(h);
        continue;
      }
      if (h && h.type === 2 && !h.content.trim().length) {
        r.removeNode(h);
        continue;
      }
      if (h && h.type === 9) {
        e.name === "else-if" && h.branches[h.branches.length - 1].condition === void 0 && r.onError(
          Te(30, t.loc)
        ), r.removeNode();
        const c = Rh(t, e);
        u.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(r.parent && r.parent.type === 1 && (r.parent.tag === "transition" || r.parent.tag === "Transition")) && (c.children = [...u, ...c.children]);
        {
          const d = c.userKey;
          d && h.branches.forEach(({ userKey: m }) => {
            y2(m, d) && r.onError(
              Te(
                29,
                c.userKey.loc
              )
            );
          });
        }
        h.branches.push(c);
        const p = i && i(h, c, !1);
        ps(c, r), p && p(), r.currentNode = null;
      } else
        r.onError(
          Te(30, t.loc)
        );
      break;
    }
  }
}
function Rh(t, e) {
  const r = t.tagType === 3;
  return {
    type: 10,
    loc: t.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: r && !Fe(t, "for") ? t.children : [t],
    userKey: ht(t, "key"),
    isTemplateIf: r
  };
}
function Dh(t, e, r) {
  return t.condition ? Ct(
    t.condition,
    Mh(t, e, r),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    pe(r.helper(hs), [
      '"v-if"',
      "true"
    ])
  ) : Mh(t, e, r);
}
function Mh(t, e, r) {
  const { helper: i } = r, n = Pe(
    "key",
    te(
      `${e}`,
      !1,
      Le,
      2
    )
  ), { children: u } = t, l = u[0];
  if (u.length !== 1 || l.type !== 1)
    if (u.length === 1 && l.type === 11) {
      const c = l.codegenNode;
      return Xs(c, n, r), c;
    } else {
      let c = 64;
      return !t.isTemplateIf && u.filter((p) => p.type !== 3).length === 1 && (c |= 2048), as(
        r,
        i(ss),
        lt([n]),
        u,
        c,
        void 0,
        void 0,
        !0,
        !1,
        !1,
        t.loc
      );
    }
  else {
    const c = l.codegenNode, p = u0(c);
    return p.type === 13 && Qn(p, r), Xs(p, n, r), c;
  }
}
function y2(t, e) {
  if (!t || t.type !== e.type)
    return !1;
  if (t.type === 6) {
    if (t.value.content !== e.value.content)
      return !1;
  } else {
    const r = t.exp, i = e.exp;
    if (r.type !== i.type || r.type !== 4 || r.isStatic !== i.isStatic || r.content !== i.content)
      return !1;
  }
  return !0;
}
function g2(t) {
  for (; ; )
    if (t.type === 19)
      if (t.alternate.type === 19)
        t = t.alternate;
      else
        return t;
    else t.type === 20 && (t = t.value);
}
const il = (t, e, r) => {
  const { modifiers: i, loc: n } = t, u = t.arg;
  let { exp: l } = t;
  if (l && l.type === 4 && !l.content.trim())
    return r.onError(
      Te(34, n)
    ), {
      props: [
        Pe(u, te("", !0, n))
      ]
    };
  if (!l) {
    if (u.type !== 4 || !u.isStatic)
      return r.onError(
        Te(
          52,
          u.loc
        )
      ), {
        props: [
          Pe(u, te("", !0, n))
        ]
      };
    P0(t, r), l = t.exp;
  }
  return u.type !== 4 ? (u.children.unshift("("), u.children.push(') || ""')) : u.isStatic || (u.content = u.content ? `${u.content} || ""` : '""'), i.some((h) => h.content === "camel") && (u.type === 4 ? u.isStatic ? u.content = ut(u.content) : u.content = `${r.helperString(dn)}(${u.content})` : (u.children.unshift(`${r.helperString(dn)}(`), u.children.push(")"))), r.inSSR || (i.some((h) => h.content === "prop") && Fh(u, "."), i.some((h) => h.content === "attr") && Fh(u, "^")), {
    props: [Pe(u, l)]
  };
}, P0 = (t, e) => {
  const r = t.arg, i = ut(r.content);
  t.exp = te(i, !1, r.loc), t.exp = Ue(t.exp, e);
}, Fh = (t, e) => {
  t.type === 4 ? t.isStatic ? t.content = e + t.content : t.content = `\`${e}\${${t.content}}\`` : (t.children.unshift(`'${e}' + (`), t.children.push(")"));
}, b2 = oi(
  "for",
  (t, e, r) => {
    const { helper: i, removeHelper: n } = r;
    return nl(t, e, r, (u) => {
      const l = pe(i(Hn), [
        u.source
      ]), h = os(t), c = Fe(t, "memo"), p = ht(t, "key", !1, !0), d = p && p.type === 7;
      d && !p.exp && P0(p, r);
      let m = p && (p.type === 6 ? p.value ? te(p.value.content, !0) : void 0 : p.exp);
      c && m && d && (p.exp = m = Ue(
        m,
        r
      ));
      const y = p && m ? Pe("key", m) : null;
      h && (c && (c.exp = Ue(
        c.exp,
        r
      )), y && p.type !== 6 && (y.value = Ue(
        y.value,
        r
      )));
      const g = u.source.type === 4 && u.source.constType > 0, E = g ? 64 : p ? 128 : 256;
      return u.codegenNode = as(
        r,
        i(ss),
        void 0,
        l,
        E,
        void 0,
        void 0,
        !0,
        !g,
        !1,
        t.loc
      ), () => {
        let S;
        const { children: x } = u;
        h && t.children.some((A) => {
          if (A.type === 1) {
            const N = ht(A, "key");
            if (N)
              return r.onError(
                Te(
                  33,
                  N.loc
                )
              ), !0;
          }
        });
        const v = x.length !== 1 || x[0].type !== 1, P = us(t) ? t : h && t.children.length === 1 && us(t.children[0]) ? t.children[0] : null;
        if (P ? (S = P.codegenNode, h && y && Xs(S, y, r)) : v ? S = as(
          r,
          i(ss),
          y ? lt([y]) : void 0,
          t.children,
          64,
          void 0,
          void 0,
          !0,
          void 0,
          !1
        ) : (S = x[0].codegenNode, h && y && Xs(S, y, r), S.isBlock !== !g && (S.isBlock ? (n(cr), n(
          Lr(r.inSSR, S.isComponent)
        )) : n(
          kr(r.inSSR, S.isComponent)
        )), S.isBlock = !g, S.isBlock ? (i(cr), i(Lr(r.inSSR, S.isComponent))) : i(kr(r.inSSR, S.isComponent))), c) {
          const A = St(
            Ks(u.parseResult, [
              te("_cached")
            ])
          );
          A.body = ni([
            je(["const _memo = (", c.exp, ")"]),
            je([
              "if (_cached",
              ...m ? [" && _cached.key === ", m] : [],
              ` && ${r.helperString(
                qu
              )}(_cached, _memo)) return _cached`
            ]),
            je(["const _item = ", S]),
            te("_item.memo = _memo"),
            te("return _item")
          ]), l.arguments.push(
            A,
            te("_cache"),
            te(String(r.cached.length))
          ), r.cached.push(null);
        } else
          l.arguments.push(
            St(
              Ks(u.parseResult),
              S,
              !0
            )
          );
      };
    });
  }
);
function nl(t, e, r, i) {
  if (!e.exp) {
    r.onError(
      Te(31, e.loc)
    );
    return;
  }
  const n = e.forParseResult;
  if (!n) {
    r.onError(
      Te(32, e.loc)
    );
    return;
  }
  al(n, r);
  const { addIdentifiers: u, removeIdentifiers: l, scopes: h } = r, { source: c, value: p, key: d, index: m } = n, y = {
    type: 11,
    loc: e.loc,
    source: c,
    valueAlias: p,
    keyAlias: d,
    objectIndexAlias: m,
    parseResult: n,
    children: os(t) ? t.children : [t]
  };
  r.replaceNode(y), h.vFor++, r.prefixIdentifiers && (p && u(p), d && u(d), m && u(m));
  const g = i && i(y);
  return () => {
    h.vFor--, r.prefixIdentifiers && (p && l(p), d && l(d), m && l(m)), g && g();
  };
}
function al(t, e) {
  t.finalized || (e.prefixIdentifiers && (t.source = Ue(
    t.source,
    e
  ), t.key && (t.key = Ue(
    t.key,
    e,
    !0
  )), t.index && (t.index = Ue(
    t.index,
    e,
    !0
  )), t.value && (t.value = Ue(
    t.value,
    e,
    !0
  ))), t.finalized = !0);
}
function Ks({ value: t, key: e, index: r }, i = []) {
  return S2([t, e, r, ...i]);
}
function S2(t) {
  let e = t.length;
  for (; e-- && !t[e]; )
    ;
  return t.slice(0, e + 1).map((r, i) => r || te("_".repeat(i + 1), !1));
}
const Bh = te("undefined", !1), ol = (t, e) => {
  if (t.type === 1 && (t.tagType === 1 || t.tagType === 3)) {
    const r = Fe(t, "slot");
    if (r) {
      const i = r.exp;
      return e.prefixIdentifiers && i && e.addIdentifiers(i), e.scopes.vSlot++, () => {
        e.prefixIdentifiers && i && e.removeIdentifiers(i), e.scopes.vSlot--;
      };
    }
  }
}, ul = (t, e) => {
  let r;
  if (os(t) && t.props.some(Qu) && (r = Fe(t, "for"))) {
    const i = r.forParseResult;
    if (i) {
      al(i, e);
      const { value: n, key: u, index: l } = i, { addIdentifiers: h, removeIdentifiers: c } = e;
      return n && h(n), u && h(u), l && h(l), () => {
        n && c(n), u && c(u), l && c(l);
      };
    }
  }
}, v2 = (t, e, r, i) => St(
  t,
  r,
  !1,
  !0,
  r.length ? r[0].loc : i
);
function Ys(t, e, r = v2) {
  e.helper(Kn);
  const { children: i, loc: n } = t, u = [], l = [];
  let h = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  !e.ssr && e.prefixIdentifiers && (h = at(t, e.identifiers));
  const c = Fe(t, "slot", !0);
  if (c) {
    const { arg: x, exp: v } = c;
    x && !He(x) && (h = !0), u.push(
      Pe(
        x || te("default", !0),
        r(v, void 0, i, n)
      )
    );
  }
  let p = !1, d = !1;
  const m = [], y = /* @__PURE__ */ new Set();
  let g = 0;
  for (let x = 0; x < i.length; x++) {
    const v = i[x];
    let P;
    if (!os(v) || !(P = Fe(v, "slot", !0))) {
      v.type !== 3 && m.push(v);
      continue;
    }
    if (c) {
      e.onError(
        Te(37, P.loc)
      );
      break;
    }
    p = !0;
    const { children: A, loc: N } = v, {
      arg: _ = te("default", !0),
      exp: R,
      loc: M
    } = P;
    let O;
    He(_) ? O = _ ? _.content : "default" : h = !0;
    const I = Fe(v, "for"), k = r(R, I, A, N);
    let L, V;
    if (L = Fe(v, "if"))
      h = !0, l.push(
        Ct(
          L.exp,
          Ti(_, k, g++),
          Bh
        )
      );
    else if (V = Fe(
      v,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let K = x, re;
      for (; K-- && (re = i[K], !(re.type !== 3 && cu(re))); )
        ;
      if (re && os(re) && Fe(re, /^(else-)?if$/)) {
        let z = l[l.length - 1];
        for (; z.alternate.type === 19; )
          z = z.alternate;
        z.alternate = V.exp ? Ct(
          V.exp,
          Ti(
            _,
            k,
            g++
          ),
          Bh
        ) : Ti(_, k, g++);
      } else
        e.onError(
          Te(30, V.loc)
        );
    } else if (I) {
      h = !0;
      const K = I.forParseResult;
      K ? (al(K, e), l.push(
        pe(e.helper(Hn), [
          K.source,
          St(
            Ks(K),
            Ti(_, k),
            !0
          )
        ])
      )) : e.onError(
        Te(
          32,
          I.loc
        )
      );
    } else {
      if (O) {
        if (y.has(O)) {
          e.onError(
            Te(
              38,
              M
            )
          );
          continue;
        }
        y.add(O), O === "default" && (d = !0);
      }
      u.push(Pe(_, k));
    }
  }
  if (!c) {
    const x = (v, P) => {
      const A = r(v, void 0, P, n);
      return Pe("default", A);
    };
    p ? m.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    m.some((v) => cu(v)) && (d ? e.onError(
      Te(
        39,
        m[0].loc
      )
    ) : u.push(
      x(void 0, m)
    )) : u.push(x(void 0, i));
  }
  const E = h ? 2 : an(t.children) ? 3 : 1;
  let S = lt(
    u.concat(
      Pe(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        te(
          E + ` /* ${Tg[E]} */`,
          !1
        )
      )
    ),
    n
  );
  return l.length && (S = pe(e.helper(Uu), [
    S,
    Gt(l)
  ])), {
    slots: S,
    hasDynamicSlots: h
  };
}
function Ti(t, e, r) {
  const i = [
    Pe("name", t),
    Pe("fn", e)
  ];
  return r != null && i.push(
    Pe("key", te(String(r), !0))
  ), lt(i);
}
function an(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    switch (r.type) {
      case 1:
        if (r.tagType === 2 || an(r.children))
          return !0;
        break;
      case 9:
        if (an(r.branches)) return !0;
        break;
      case 10:
      case 11:
        if (an(r.children)) return !0;
        break;
    }
  }
  return !1;
}
function cu(t) {
  return t.type !== 2 && t.type !== 12 ? !0 : t.type === 2 ? !!t.content.trim() : cu(t.content);
}
const _0 = /* @__PURE__ */ new WeakMap(), A0 = (t, e) => function() {
  if (t = e.currentNode, !(t.type === 1 && (t.tagType === 0 || t.tagType === 1)))
    return;
  const { tag: i, props: n } = t, u = t.tagType === 1;
  let l = u ? ha(t, e) : `"${i}"`;
  const h = pr(l) && l.callee === si;
  let c, p, d = 0, m, y, g, E = (
    // dynamic component may resolve to plain elements
    h || l === _r || l === cs || !u && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (i === "svg" || i === "foreignObject" || i === "math")
  );
  if (n.length > 0) {
    const S = ms(
      t,
      e,
      void 0,
      u,
      h
    );
    c = S.props, d = S.patchFlag, y = S.dynamicPropNames;
    const x = S.directives;
    g = x && x.length ? Gt(
      x.map((v) => ll(v, e))
    ) : void 0, S.shouldUseBlock && (E = !0);
  }
  if (t.children.length > 0)
    if (l === Vs && (E = !0, d |= 1024, t.children.length > 1 && e.onError(
      Te(46, {
        start: t.children[0].loc.start,
        end: t.children[t.children.length - 1].loc.end,
        source: ""
      })
    )), u && // Teleport is not a real component and has dedicated runtime handling
    l !== _r && // explained above.
    l !== Vs) {
      const { slots: x, hasDynamicSlots: v } = Ys(t, e);
      p = x, v && (d |= 1024);
    } else if (t.children.length === 1 && l !== _r) {
      const x = t.children[0], v = x.type, P = v === 5 || v === 8;
      P && ct(x, e) === 0 && (d |= 1), P || v === 2 ? p = x : p = t.children;
    } else
      p = t.children;
  y && y.length && (m = E2(y)), t.codegenNode = as(
    e,
    l,
    c,
    p,
    d === 0 ? void 0 : d,
    m,
    g,
    !!E,
    !1,
    u,
    t.loc
  );
};
function ha(t, e, r = !1) {
  let { tag: i } = t;
  const n = fu(i), u = ht(
    t,
    "is",
    !1,
    !0
    /* allow empty */
  );
  if (u)
    if (n) {
      let h;
      if (u.type === 6 ? h = u.value && te(u.value.content, !0) : (h = u.exp, h || (h = te("is", !1, u.arg.loc), h = u.exp = Ue(h, e))), h)
        return pe(e.helper(si), [
          h
        ]);
    } else u.type === 6 && u.value.content.startsWith("vue:") && (i = u.value.content.slice(4));
  const l = Ju(i) || e.isBuiltInComponent(i);
  if (l)
    return r || e.helper(l), l;
  {
    const h = hu(i, e);
    if (h)
      return h;
    const c = i.indexOf(".");
    if (c > 0) {
      const p = hu(i.slice(0, c), e);
      if (p)
        return p + i.slice(c);
    }
  }
  return e.selfName && lr(ut(i)) === e.selfName ? (e.helper(zs), e.components.add(i + "__self"), Js(i, "component")) : (e.helper(zs), e.components.add(i), Js(i, "component"));
}
function hu(t, e) {
  const r = e.bindingMetadata;
  if (!r || r.__isScriptSetup === !1)
    return;
  const i = ut(t), n = lr(i), u = (p) => {
    if (r[t] === p)
      return t;
    if (r[i] === p)
      return i;
    if (r[n] === p)
      return n;
  }, l = u("setup-const") || u("setup-reactive-const") || u("literal-const");
  if (l)
    return e.inline ? (
      // in inline mode, const setup bindings (e.g. imports) can be used as-is
      l
    ) : `$setup[${JSON.stringify(l)}]`;
  const h = u("setup-let") || u("setup-ref") || u("setup-maybe-ref");
  if (h)
    return e.inline ? (
      // setup scope bindings that may be refs need to be unrefed
      `${e.helperString(ns)}(${h})`
    ) : `$setup[${JSON.stringify(h)}]`;
  const c = u("props");
  if (c)
    return `${e.helperString(ns)}(${e.inline ? "__props" : "$props"}[${JSON.stringify(c)}])`;
}
function ms(t, e, r = t.props, i, n, u = !1) {
  const { tag: l, loc: h, children: c } = t;
  let p = [];
  const d = [], m = [], y = c.length > 0;
  let g = !1, E = 0, S = !1, x = !1, v = !1, P = !1, A = !1, N = !1;
  const _ = [], R = (k) => {
    p.length && (d.push(
      lt($h(p), h)
    ), p = []), k && d.push(k);
  }, M = () => {
    e.scopes.vFor > 0 && p.push(
      Pe(
        te("ref_for", !0),
        te("true")
      )
    );
  }, O = ({ key: k, value: L }) => {
    if (He(k)) {
      const V = k.content, K = Id(V);
      if (K && (!i || n) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      V.toLowerCase() !== "onclick" && // omit v-model handlers
      V !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !hh(V) && (P = !0), K && hh(V) && (N = !0), K && L.type === 14 && (L = L.arguments[0]), L.type === 20 || (L.type === 4 || L.type === 8) && ct(L, e) > 0)
        return;
      V === "ref" ? S = !0 : V === "class" ? x = !0 : V === "style" ? v = !0 : V !== "key" && !_.includes(V) && _.push(V), i && (V === "class" || V === "style") && !_.includes(V) && _.push(V);
    } else
      A = !0;
  };
  for (let k = 0; k < r.length; k++) {
    const L = r[k];
    if (L.type === 6) {
      const { loc: V, name: K, nameLoc: re, value: z } = L;
      let se = !0;
      if (K === "ref" && (S = !0, M(), z && e.inline)) {
        const he = e.bindingMetadata[z.content];
        (he === "setup-let" || he === "setup-ref" || he === "setup-maybe-ref") && (se = !1, p.push(
          Pe(
            te("ref_key", !0),
            te(z.content, !0, z.loc)
          )
        ));
      }
      if (K === "is" && (fu(l) || z && z.content.startsWith("vue:")))
        continue;
      p.push(
        Pe(
          te(K, !0, re),
          te(
            z ? z.content : "",
            se,
            z ? z.loc : V
          )
        )
      );
    } else {
      const { name: V, arg: K, exp: re, loc: z, modifiers: se } = L, he = V === "bind", ne = V === "on";
      if (V === "slot") {
        i || e.onError(
          Te(40, z)
        );
        continue;
      }
      if (V === "once" || V === "memo" || V === "is" || he && Mt(K, "is") && fu(l) || ne && u)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (he && Mt(K, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        ne && y && Mt(K, "vue:before-update")) && (g = !0), he && Mt(K, "ref") && M(), !K && (he || ne)
      ) {
        A = !0, re ? he ? (M(), R(), d.push(re)) : R({
          type: 14,
          loc: z,
          callee: e.helper(Jn),
          arguments: i ? [re] : [re, "true"]
        }) : e.onError(
          Te(
            he ? 34 : 35,
            z
          )
        );
        continue;
      }
      he && se.some((be) => be.content === "prop") && (E |= 32);
      const ge = e.directiveTransforms[V];
      if (ge) {
        const { props: be, needRuntime: Y } = ge(L, t, e);
        !u && be.forEach(O), ne && K && !He(K) ? R(lt(be, h)) : p.push(...be), Y && (m.push(L), fr(Y) && _0.set(L, Y));
      } else Du(V) || (m.push(L), y && (g = !0));
    }
  }
  let I;
  if (d.length ? (R(), d.length > 1 ? I = pe(
    e.helper(Or),
    d,
    h
  ) : I = d[0]) : p.length && (I = lt(
    $h(p),
    h
  )), A ? E |= 16 : (x && !i && (E |= 2), v && !i && (E |= 4), _.length && (E |= 8), P && (E |= 32)), !g && (E === 0 || E === 32) && (S || N || m.length > 0) && (E |= 512), !e.inSSR && I)
    switch (I.type) {
      case 15:
        let k = -1, L = -1, V = !1;
        for (let z = 0; z < I.properties.length; z++) {
          const se = I.properties[z].key;
          He(se) ? se.content === "class" ? k = z : se.content === "style" && (L = z) : se.isHandlerKey || (V = !0);
        }
        const K = I.properties[k], re = I.properties[L];
        V ? I = pe(
          e.helper(is),
          [I]
        ) : (K && !He(K.value) && (K.value = pe(
          e.helper(Gn),
          [K.value]
        )), re && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (v || re.value.type === 4 && re.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        re.value.type === 17) && (re.value = pe(
          e.helper(Xn),
          [re.value]
        )));
        break;
      case 14:
        break;
      default:
        I = pe(
          e.helper(is),
          [
            pe(e.helper(fs), [
              I
            ])
          ]
        );
        break;
    }
  return {
    props: I,
    directives: m,
    patchFlag: E,
    dynamicPropNames: _,
    shouldUseBlock: g
  };
}
function $h(t) {
  const e = /* @__PURE__ */ new Map(), r = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    if (n.key.type === 8 || !n.key.isStatic) {
      r.push(n);
      continue;
    }
    const u = n.key.content, l = e.get(u);
    l ? (u === "style" || u === "class" || Id(u)) && x2(l, n) : (e.set(u, n), r.push(n));
  }
  return r;
}
function x2(t, e) {
  t.value.type === 17 ? t.value.elements.push(e.value) : t.value = Gt(
    [t.value, e.value],
    t.loc
  );
}
function ll(t, e) {
  const r = [], i = _0.get(t);
  if (i)
    r.push(e.helperString(i));
  else {
    const u = hu("v-" + t.name, e);
    u ? r.push(u) : (e.helper(zn), e.directives.add(t.name), r.push(Js(t.name, "directive")));
  }
  const { loc: n } = t;
  if (t.exp && r.push(t.exp), t.arg && (t.exp || r.push("void 0"), r.push(t.arg)), Object.keys(t.modifiers).length) {
    t.arg || (t.exp || r.push("void 0"), r.push("void 0"));
    const u = te("true", !1, n);
    r.push(
      lt(
        t.modifiers.map(
          (l) => Pe(l, u)
        ),
        n
      )
    );
  }
  return Gt(r, t.loc);
}
function E2(t) {
  let e = "[";
  for (let r = 0, i = t.length; r < i; r++)
    e += JSON.stringify(t[r]), r < i - 1 && (e += ", ");
  return e + "]";
}
function fu(t) {
  return t === "component" || t === "Component";
}
const T2 = (t, e) => {
  if (us(t)) {
    const { children: r, loc: i } = t, { slotName: n, slotProps: u } = cl(t, e), l = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      n,
      "{}",
      "undefined",
      "true"
    ];
    let h = 2;
    u && (l[2] = u, h = 3), r.length && (l[3] = St([], r, !1, !1, i), h = 4), e.scopeId && !e.slotted && (h = 5), l.splice(h), t.codegenNode = pe(
      e.helper($u),
      l,
      i
    );
  }
};
function cl(t, e) {
  let r = '"default"', i;
  const n = [];
  for (let u = 0; u < t.props.length; u++) {
    const l = t.props[u];
    if (l.type === 6)
      l.value && (l.name === "name" ? r = JSON.stringify(l.value.content) : (l.name = ut(l.name), n.push(l)));
    else if (l.name === "bind" && Mt(l.arg, "name")) {
      if (l.exp)
        r = l.exp;
      else if (l.arg && l.arg.type === 4) {
        const h = ut(l.arg.content);
        r = l.exp = te(h, !1, l.arg.loc), r = l.exp = Ue(l.exp, e);
      }
    } else
      l.name === "bind" && l.arg && He(l.arg) && (l.arg.content = ut(l.arg.content)), n.push(l);
  }
  if (n.length > 0) {
    const { props: u, directives: l } = ms(
      t,
      e,
      n,
      !1,
      !1
    );
    i = u, l.length && e.onError(
      Te(
        36,
        l[0].loc
      )
    );
  }
  return {
    slotName: r,
    slotProps: i
  };
}
const fa = (t, e, r, i) => {
  const { loc: n, modifiers: u, arg: l } = t;
  !t.exp && !u.length && r.onError(Te(35, n));
  let h;
  if (l.type === 4)
    if (l.isStatic) {
      let m = l.content;
      m.startsWith("vnode") && r.onError(Te(51, l.loc)), m.startsWith("vue:") && (m = `vnode-${m.slice(4)}`);
      const y = e.tagType !== 0 || m.startsWith("vnode") || !/[A-Z]/.test(m) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        vg(ut(m))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${m}`
      );
      h = te(y, !0, l.loc);
    } else
      h = je([
        `${r.helperString(mn)}(`,
        l,
        ")"
      ]);
  else
    h = l, h.children.unshift(`${r.helperString(mn)}(`), h.children.push(")");
  let c = t.exp;
  c && !c.content.trim() && (c = void 0);
  let p = r.cacheHandlers && !c && !r.inVOnce;
  if (c) {
    const m = Ku(c, r), y = !(m || a0(c, r)), g = c.content.includes(";");
    r.prefixIdentifiers && (y && r.addIdentifiers("$event"), c = t.exp = Ue(
      c,
      r,
      !1,
      g
    ), y && r.removeIdentifiers("$event"), p = r.cacheHandlers && // unnecessary to cache inside v-once
    !r.inVOnce && // runtime constants don't need to be cached
    // (this is analyzed by compileScript in SFC <script setup>)
    !(c.type === 4 && c.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
    // we need to use the original function to preserve arity,
    // e.g. <transition> relies on checking cb.length to determine
    // transition end handling. Inline function is ok since its arity
    // is preserved even when cached.
    !(m && e.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
    // it must be passed fresh to avoid stale values.
    !at(c, r.identifiers), p && m && (c.type === 4 ? c.content = `${c.content} && ${c.content}(...args)` : c.children = [...c.children, " && ", ...c.children, "(...args)"])), (y || p && m) && (c = je([
      `${y ? r.isTS ? "($event: any)" : "$event" : `${r.isTS ? `
//@ts-ignore
` : ""}(...args)`} => ${g ? "{" : "("}`,
      c,
      g ? "}" : ")"
    ]));
  }
  let d = {
    props: [
      Pe(
        h,
        c || te("() => {}", !1, n)
      )
    ]
  };
  return i && (d = i(d)), p && (d.props[0].value = r.cache(d.props[0].value)), d.props.forEach((m) => m.key.isHandlerKey = !0), d;
}, w2 = (t, e) => {
  if (t.type === 0 || t.type === 1 || t.type === 11 || t.type === 10)
    return () => {
      const r = t.children;
      let i, n = !1;
      for (let u = 0; u < r.length; u++) {
        const l = r[u];
        if (Rs(l)) {
          n = !0;
          for (let h = u + 1; h < r.length; h++) {
            const c = r[h];
            if (Rs(c))
              i || (i = r[u] = je(
                [l],
                l.loc
              )), i.children.push(" + ", c), r.splice(h, 1), h--;
            else {
              i = void 0;
              break;
            }
          }
        }
      }
      if (!(!n || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      r.length === 1 && (t.type === 0 || t.type === 1 && t.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !t.props.find(
        (u) => u.type === 7 && !e.directiveTransforms[u.name]
      ))))
        for (let u = 0; u < r.length; u++) {
          const l = r[u];
          if (Rs(l) || l.type === 8) {
            const h = [];
            (l.type !== 2 || l.content !== " ") && h.push(l), !e.ssr && ct(l, e) === 0 && h.push(
              `1 /* ${Ls[1]} */`
            ), r[u] = {
              type: 12,
              content: l,
              loc: l.loc,
              codegenNode: pe(
                e.helper(jn),
                h
              )
            };
          }
        }
    };
}, Uh = /* @__PURE__ */ new WeakSet(), P2 = (t, e) => {
  if (t.type === 1 && Fe(t, "once", !0))
    return Uh.has(t) || e.inVOnce || e.inSSR ? void 0 : (Uh.add(t), e.inVOnce = !0, e.helper(Ws), () => {
      e.inVOnce = !1;
      const r = e.currentNode;
      r.codegenNode && (r.codegenNode = e.cache(
        r.codegenNode,
        !0,
        !0
      ));
    });
}, pa = (t, e, r) => {
  const { exp: i, arg: n } = t;
  if (!i)
    return r.onError(
      Te(41, t.loc)
    ), Ps();
  const u = i.loc.source.trim(), l = i.type === 4 ? i.content : u, h = r.bindingMetadata[u];
  if (h === "props" || h === "props-aliased")
    return r.onError(Te(44, i.loc)), Ps();
  const c = r.inline && (h === "setup-let" || h === "setup-ref" || h === "setup-maybe-ref");
  if (!l.trim() || !Ku(i, r) && !c)
    return r.onError(
      Te(42, i.loc)
    ), Ps();
  if (r.prefixIdentifiers && Kt(l) && r.identifiers[l])
    return r.onError(
      Te(43, i.loc)
    ), Ps();
  const p = n || te("modelValue", !0), d = n ? He(n) ? `onUpdate:${ut(n.content)}` : je(['"onUpdate:" + ', n]) : "onUpdate:modelValue";
  let m;
  const y = r.isTS ? "($event: any)" : "$event";
  if (c)
    if (h === "setup-ref")
      m = je([
        `${y} => ((`,
        te(u, !1, i.loc),
        ").value = $event)"
      ]);
    else {
      const E = h === "setup-let" ? `${u} = $event` : "null";
      m = je([
        `${y} => (${r.helperString(Hs)}(${u}) ? (`,
        te(u, !1, i.loc),
        `).value = $event : ${E})`
      ]);
    }
  else
    m = je([
      `${y} => ((`,
      i,
      ") = $event)"
    ]);
  const g = [
    // modelValue: foo
    Pe(p, t.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Pe(d, m)
  ];
  if (r.prefixIdentifiers && !r.inVOnce && r.cacheHandlers && !at(i, r.identifiers) && (g[1].value = r.cache(g[1].value)), t.modifiers.length && e.tagType === 1) {
    const E = t.modifiers.map((x) => x.content).map((x) => (Kt(x) ? x : JSON.stringify(x)) + ": true").join(", "), S = n ? He(n) ? `${n.content}Modifiers` : je([n, ' + "Modifiers"']) : "modelModifiers";
    g.push(
      Pe(
        S,
        te(
          `{ ${E} }`,
          !1,
          t.loc,
          2
        )
      )
    );
  }
  return Ps(g);
};
function Ps(t = []) {
  return { props: t };
}
const qh = /* @__PURE__ */ new WeakSet(), _2 = (t, e) => {
  if (t.type === 1) {
    const r = Fe(t, "memo");
    return !r || qh.has(t) ? void 0 : (qh.add(t), () => {
      const i = t.codegenNode || e.currentNode.codegenNode;
      i && i.type === 13 && (t.tagType !== 1 && Qn(i, e), t.codegenNode = pe(e.helper(Yn), [
        r.exp,
        St(void 0, i),
        "_cache",
        String(e.cached.length)
      ]), e.cached.push(null));
    });
  }
};
function hl(t) {
  return [
    [
      P2,
      m2,
      _2,
      b2,
      ...t ? [
        // order is important
        ul,
        rl
      ] : [],
      T2,
      A0,
      ol,
      w2
    ],
    {
      on: fa,
      bind: il,
      model: pa
    }
  ];
}
function C0(t, e = {}) {
  const r = e.onError || zu, i = e.mode === "module", n = e.prefixIdentifiers === !0 || i;
  !n && e.cacheHandlers && r(Te(49)), e.scopeId && !i && r(Te(50));
  const u = Bt({}, e, {
    prefixIdentifiers: n
  }), l = Se(t) ? aa(t, u) : t, [h, c] = hl(n);
  if (e.isTS) {
    const { expressionPlugins: p } = e;
    (!p || !p.includes("typescript")) && (e.expressionPlugins = [...p || [], "typescript"]);
  }
  return el(
    l,
    Bt({}, u, {
      nodeTransforms: [
        ...h,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: Bt(
        {},
        c,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), tl(l, u);
}
const A2 = {
  DATA: "data",
  PROPS: "props",
  PROPS_ALIASED: "props-aliased",
  SETUP_LET: "setup-let",
  SETUP_CONST: "setup-const",
  SETUP_REACTIVE_CONST: "setup-reactive-const",
  SETUP_MAYBE_REF: "setup-maybe-ref",
  SETUP_REF: "setup-ref",
  OPTIONS: "options",
  LITERAL_CONST: "literal-const"
}, Ds = () => ({ props: [] }), fl = Symbol("vModelRadio"), pl = Symbol(
  "vModelCheckbox"
), dl = Symbol("vModelText"), ml = Symbol(
  "vModelSelect"
), vn = Symbol(
  "vModelDynamic"
), yl = Symbol(
  "vOnModifiersGuard"
), gl = Symbol(
  "vOnKeysGuard"
), bl = Symbol("vShow"), Mr = Symbol("Transition"), ys = Symbol(
  "TransitionGroup"
);
ju({
  [fl]: "vModelRadio",
  [pl]: "vModelCheckbox",
  [dl]: "vModelText",
  [ml]: "vModelSelect",
  [vn]: "vModelDynamic",
  [yl]: "withModifiers",
  [gl]: "withKeys",
  [bl]: "vShow",
  [Mr]: "Transition",
  [ys]: "TransitionGroup"
});
const ls = {
  parseMode: "html",
  isVoidTag: Fd,
  isNativeTag: (t) => Lg(t) || Rg(t) || Dg(t),
  isPreTag: (t) => t === "pre",
  isIgnoreNewlineTag: (t) => t === "pre" || t === "textarea",
  decodeEntities: void 0,
  isBuiltInComponent: (t) => {
    if (t === "Transition" || t === "transition")
      return Mr;
    if (t === "TransitionGroup" || t === "transition-group")
      return ys;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(t, e, r) {
    let i = e ? e.ns : r;
    if (e && i === 2)
      if (e.tag === "annotation-xml") {
        if (t === "svg")
          return 1;
        e.props.some(
          (n) => n.type === 6 && n.name === "encoding" && n.value != null && (n.value.content === "text/html" || n.value.content === "application/xhtml+xml")
        ) && (i = 0);
      } else /^m(?:[ions]|text)$/.test(e.tag) && t !== "mglyph" && t !== "malignmark" && (i = 0);
    else e && i === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (i = 0);
    if (i === 0) {
      if (t === "svg")
        return 1;
      if (t === "math")
        return 2;
    }
    return i;
  }
}, Sl = (t) => {
  t.type === 1 && t.props.forEach((e, r) => {
    e.type === 6 && e.name === "style" && e.value && (t.props[r] = {
      type: 7,
      name: "bind",
      arg: te("style", !0, e.loc),
      exp: C2(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, C2 = (t, e) => {
  const r = Dd(t);
  return te(
    JSON.stringify(r),
    !1,
    e,
    3
  );
};
function Ze(t, e) {
  return Te(
    t,
    e,
    vl
  );
}
const I2 = {
  X_V_HTML_NO_EXPRESSION: 53,
  53: "X_V_HTML_NO_EXPRESSION",
  X_V_HTML_WITH_CHILDREN: 54,
  54: "X_V_HTML_WITH_CHILDREN",
  X_V_TEXT_NO_EXPRESSION: 55,
  55: "X_V_TEXT_NO_EXPRESSION",
  X_V_TEXT_WITH_CHILDREN: 56,
  56: "X_V_TEXT_WITH_CHILDREN",
  X_V_MODEL_ON_INVALID_ELEMENT: 57,
  57: "X_V_MODEL_ON_INVALID_ELEMENT",
  X_V_MODEL_ARG_ON_ELEMENT: 58,
  58: "X_V_MODEL_ARG_ON_ELEMENT",
  X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
  59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  X_V_MODEL_UNNECESSARY_VALUE: 60,
  60: "X_V_MODEL_UNNECESSARY_VALUE",
  X_V_SHOW_NO_EXPRESSION: 61,
  61: "X_V_SHOW_NO_EXPRESSION",
  X_TRANSITION_INVALID_CHILDREN: 62,
  62: "X_TRANSITION_INVALID_CHILDREN",
  X_IGNORED_SIDE_EFFECT_TAG: 63,
  63: "X_IGNORED_SIDE_EFFECT_TAG",
  __EXTEND_POINT__: 64,
  64: "__EXTEND_POINT__"
}, vl = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, N2 = (t, e, r) => {
  const { exp: i, loc: n } = t;
  return i || r.onError(
    Ze(53, n)
  ), e.children.length && (r.onError(
    Ze(54, n)
  ), e.children.length = 0), {
    props: [
      Pe(
        te("innerHTML", !0, n),
        i || te("", !0)
      )
    ]
  };
}, O2 = (t, e, r) => {
  const { exp: i, loc: n } = t;
  return i || r.onError(
    Ze(55, n)
  ), e.children.length && (r.onError(
    Ze(56, n)
  ), e.children.length = 0), {
    props: [
      Pe(
        te("textContent", !0),
        i ? ct(i, r) > 0 ? i : pe(
          r.helperString(ii),
          [i],
          n
        ) : te("", !0)
      )
    ]
  };
}, k2 = (t, e, r) => {
  const i = pa(t, e, r);
  if (!i.props.length || e.tagType === 1)
    return i;
  t.arg && r.onError(
    Ze(
      58,
      t.arg.loc
    )
  );
  function n() {
    const h = Fe(e, "bind");
    h && Mt(h.arg, "value") && r.onError(
      Ze(
        60,
        h.loc
      )
    );
  }
  const { tag: u } = e, l = r.isCustomElement(u);
  if (u === "input" || u === "textarea" || u === "select" || l) {
    let h = dl, c = !1;
    if (u === "input" || l) {
      const p = ht(e, "type");
      if (p) {
        if (p.type === 7)
          h = vn;
        else if (p.value)
          switch (p.value.content) {
            case "radio":
              h = fl;
              break;
            case "checkbox":
              h = pl;
              break;
            case "file":
              c = !0, r.onError(
                Ze(
                  59,
                  t.loc
                )
              );
              break;
            default:
              n();
              break;
          }
      } else na(e) ? h = vn : n();
    } else u === "select" ? h = ml : n();
    c || (i.needRuntime = r.helper(h));
  } else
    r.onError(
      Ze(
        57,
        t.loc
      )
    );
  return i.props = i.props.filter(
    (h) => !(h.key.type === 4 && h.key.content === "modelValue")
  ), i;
}, L2 = /* @__PURE__ */ Xe("passive,once,capture"), R2 = /* @__PURE__ */ Xe(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), D2 = /* @__PURE__ */ Xe("left,right"), I0 = /* @__PURE__ */ Xe("onkeyup,onkeydown,onkeypress"), M2 = (t, e, r, i) => {
  const n = [], u = [], l = [];
  for (let h = 0; h < e.length; h++) {
    const c = e[h].content;
    L2(c) ? l.push(c) : D2(c) ? He(t) ? I0(t.content.toLowerCase()) ? n.push(c) : u.push(c) : (n.push(c), u.push(c)) : R2(c) ? u.push(c) : n.push(c);
  }
  return {
    keyModifiers: n,
    nonKeyModifiers: u,
    eventOptionModifiers: l
  };
}, jh = (t, e) => He(t) && t.content.toLowerCase() === "onclick" ? te(e, !0) : t.type !== 4 ? je([
  "(",
  t,
  `) === "onClick" ? "${e}" : (`,
  t,
  ")"
]) : t, F2 = (t, e, r) => fa(t, e, r, (i) => {
  const { modifiers: n } = t;
  if (!n.length) return i;
  let { key: u, value: l } = i.props[0];
  const { keyModifiers: h, nonKeyModifiers: c, eventOptionModifiers: p } = M2(u, n, r, t.loc);
  if (c.includes("right") && (u = jh(u, "onContextmenu")), c.includes("middle") && (u = jh(u, "onMouseup")), c.length && (l = pe(r.helper(yl), [
    l,
    JSON.stringify(c)
  ])), h.length && // if event name is dynamic, always wrap with keys guard
  (!He(u) || I0(u.content.toLowerCase())) && (l = pe(r.helper(gl), [
    l,
    JSON.stringify(h)
  ])), p.length) {
    const d = p.map(lr).join("");
    u = He(u) ? te(`${u.content}${d}`, !0) : je(["(", u, `) + "${d}"`]);
  }
  return {
    props: [Pe(u, l)]
  };
}), B2 = (t, e, r) => {
  const { exp: i, loc: n } = t;
  return i || r.onError(
    Ze(61, n)
  ), {
    props: [],
    needRuntime: r.helper(bl)
  };
}, $2 = (t, e) => {
  if (t.type === 1 && t.tagType === 1 && e.isBuiltInComponent(t.tag) === Mr)
    return () => {
      if (!t.children.length)
        return;
      N0(t) && e.onError(
        Ze(
          62,
          {
            start: t.children[0].loc.start,
            end: t.children[t.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const i = t.children[0];
      if (i.type === 1)
        for (const n of i.props)
          n.type === 7 && n.name === "show" && t.props.push({
            type: 6,
            name: "persisted",
            nameLoc: t.loc,
            value: void 0,
            loc: t.loc
          });
    };
};
function N0(t) {
  const e = t.children = t.children.filter(
    (i) => i.type !== 3 && !(i.type === 2 && !i.content.trim())
  ), r = e[0];
  return e.length !== 1 || r.type === 11 || r.type === 9 && r.branches.some(N0);
}
const U2 = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, q2 = (t, e, r) => {
  if (e.scopes.vSlot > 0)
    return;
  const i = r.type === 1 && r.codegenNode && r.codegenNode.type === 13 && r.codegenNode.children && !$e(r.codegenNode.children) && r.codegenNode.children.type === 20;
  let n = 0, u = 0;
  const l = [], h = (p) => {
    if (n >= 20 || u >= 5) {
      const d = pe(e.helper(Vn), [
        JSON.stringify(
          l.map((y) => xl(y, e)).join("")
        ).replace(U2, '" + $1 + "'),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(l.length)
      ]), m = l.length - 1;
      if (i)
        t.splice(
          p - l.length,
          l.length,
          // @ts-expect-error
          d
        );
      else if (l[0].codegenNode.value = d, l.length > 1) {
        t.splice(p - l.length + 1, m);
        const y = e.cached.indexOf(
          l[l.length - 1].codegenNode
        );
        if (y > -1) {
          for (let g = y; g < e.cached.length; g++) {
            const E = e.cached[g];
            E && (E.index -= m);
          }
          e.cached.splice(y - m + 1, m);
        }
      }
      return m;
    }
    return 0;
  };
  let c = 0;
  for (; c < t.length; c++) {
    const p = t[c];
    if (i || j2(p)) {
      const m = W2(p);
      if (m) {
        n += m[0], u += m[1], l.push(p);
        continue;
      }
    }
    c -= h(c), n = 0, u = 0, l.length = 0;
  }
  h(c);
}, j2 = (t) => {
  if ((t.type === 1 && t.tagType === 0 || t.type === 12) && t.codegenNode && t.codegenNode.type === 20)
    return t.codegenNode;
}, V2 = /^(data|aria)-/, Vh = (t, e) => (e === 0 ? Ug(t) : e === 1 ? qg(t) : e === 2 ? jg(t) : !1) || V2.test(t), z2 = /* @__PURE__ */ Xe(
  "caption,thead,tr,th,tbody,td,tfoot,colgroup,col"
);
function W2(t) {
  if (t.type === 1 && z2(t.tag))
    return !1;
  if (t.type === 12)
    return [1, 0];
  let e = 1, r = t.props.length > 0 ? 1 : 0, i = !1;
  const n = () => (i = !0, !1);
  function u(l) {
    const h = l.tag === "option" && l.ns === 0;
    for (let c = 0; c < l.props.length; c++) {
      const p = l.props[c];
      if (p.type === 6 && !Vh(p.name, l.ns) || p.type === 7 && p.name === "bind" && (p.arg && (p.arg.type === 8 || p.arg.isStatic && !Vh(p.arg.content, l.ns)) || p.exp && (p.exp.type === 8 || p.exp.constType < 3) || h && Mt(p.arg, "value") && p.exp && !p.exp.isStatic))
        return n();
    }
    for (let c = 0; c < l.children.length; c++) {
      e++;
      const p = l.children[c];
      if (p.type === 1 && (p.props.length > 0 && r++, u(p), i))
        return !1;
    }
    return !0;
  }
  return u(t) ? [e, r] : !1;
}
function xl(t, e) {
  if (Se(t))
    return t;
  if (fr(t))
    return "";
  switch (t.type) {
    case 1:
      return H2(t, e);
    case 2:
      return Dt(t.content);
    case 3:
      return `<!--${Dt(t.content)}-->`;
    case 5:
      return Dt(Un(Cr(t.content)));
    case 8:
      return Dt(Cr(t));
    case 12:
      return xl(t.content, e);
    default:
      return "";
  }
}
function H2(t, e) {
  let r = `<${t.tag}`, i = "";
  for (let n = 0; n < t.props.length; n++) {
    const u = t.props[n];
    if (u.type === 6)
      r += ` ${u.name}`, u.value && (r += `="${Dt(u.value.content)}"`);
    else if (u.type === 7)
      if (u.name === "bind") {
        const l = u.exp;
        if (l.content[0] === "_") {
          r += ` ${u.arg.content}="__VUE_EXP_START__${l.content}__VUE_EXP_END__"`;
          continue;
        }
        if (Bd(u.arg.content) && l.content === "false")
          continue;
        let h = Cr(l);
        if (h != null) {
          const c = u.arg && u.arg.content;
          c === "class" ? h = Md(h) : c === "style" && (h = Cg(Rd(h))), r += ` ${u.arg.content}="${Dt(
            h
          )}"`;
        }
      } else u.name === "html" ? i = Cr(u.exp) : u.name === "text" && (i = Dt(
        Un(Cr(u.exp))
      ));
  }
  if (e.scopeId && (r += ` ${e.scopeId}`), r += ">", i)
    r += i;
  else
    for (let n = 0; n < t.children.length; n++)
      r += xl(t.children[n], e);
  return Fd(t.tag) || (r += `</${t.tag}>`), r;
}
function Cr(t) {
  if (t.type === 4)
    return new Function(`return (${t.content})`)();
  {
    let e = "";
    return t.children.forEach((r) => {
      Se(r) || fr(r) || (r.type === 2 ? e += r.content : r.type === 5 ? e += Un(Cr(r.content)) : e += Cr(r));
    }), e;
  }
}
const G2 = (t, e) => {
  t.type === 1 && t.tagType === 0 && (t.tag === "script" || t.tag === "style") && (e.onError(
    Ze(
      63,
      t.loc
    )
  ), e.removeNode());
};
function X2(t, e) {
  return t === "template" ? !0 : t in zh ? zh[t].has(e) : e in Wh ? Wh[e].has(t) : !(t in Hh && Hh[t].has(e) || e in Gh && Gh[e].has(t));
}
const Gr = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]), vr = /* @__PURE__ */ new Set([]), zh = {
  head: /* @__PURE__ */ new Set([
    "base",
    "basefront",
    "bgsound",
    "link",
    "meta",
    "title",
    "noscript",
    "noframes",
    "style",
    "script",
    "template"
  ]),
  optgroup: /* @__PURE__ */ new Set(["option"]),
  select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
  // table
  table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
  tr: /* @__PURE__ */ new Set(["td", "th"]),
  colgroup: /* @__PURE__ */ new Set(["col"]),
  tbody: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["tr"]),
  tfoot: /* @__PURE__ */ new Set(["tr"]),
  // these elements can not have any children elements
  script: vr,
  iframe: vr,
  option: vr,
  textarea: vr,
  style: vr,
  title: vr
}, Wh = {
  // sections
  html: vr,
  body: /* @__PURE__ */ new Set(["html"]),
  head: /* @__PURE__ */ new Set(["html"]),
  // table
  td: /* @__PURE__ */ new Set(["tr"]),
  colgroup: /* @__PURE__ */ new Set(["table"]),
  caption: /* @__PURE__ */ new Set(["table"]),
  tbody: /* @__PURE__ */ new Set(["table"]),
  tfoot: /* @__PURE__ */ new Set(["table"]),
  col: /* @__PURE__ */ new Set(["colgroup"]),
  th: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["table"]),
  tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
  // data list
  dd: /* @__PURE__ */ new Set(["dl", "div"]),
  dt: /* @__PURE__ */ new Set(["dl", "div"]),
  // other
  figcaption: /* @__PURE__ */ new Set(["figure"]),
  // li: new Set(["ul", "ol"]),
  summary: /* @__PURE__ */ new Set(["details"]),
  area: /* @__PURE__ */ new Set(["map"])
}, Hh = {
  p: /* @__PURE__ */ new Set([
    "address",
    "article",
    "aside",
    "blockquote",
    "center",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "fieldset",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "menu",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
  ]),
  svg: /* @__PURE__ */ new Set([
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "menu",
    "meta",
    "ol",
    "p",
    "pre",
    "ruby",
    "s",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "table",
    "u",
    "ul",
    "var"
  ])
}, Gh = {
  a: /* @__PURE__ */ new Set(["a"]),
  button: /* @__PURE__ */ new Set(["button"]),
  dd: /* @__PURE__ */ new Set(["dd", "dt"]),
  dt: /* @__PURE__ */ new Set(["dd", "dt"]),
  form: /* @__PURE__ */ new Set(["form"]),
  li: /* @__PURE__ */ new Set(["li"]),
  h1: Gr,
  h2: Gr,
  h3: Gr,
  h4: Gr,
  h5: Gr,
  h6: Gr
}, J2 = (t, e) => {
  if (t.type === 1 && t.tagType === 0 && e.parent && e.parent.type === 1 && e.parent.tagType === 0 && !X2(e.parent.tag, t.tag)) {
    const r = new SyntaxError(
      `<${t.tag}> cannot be child of <${e.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
    );
    r.loc = t.loc, e.onWarn(r);
  }
}, El = [
  Sl,
  $2,
  J2
], Tl = {
  cloak: Ds,
  html: N2,
  text: O2,
  model: k2,
  // override compiler-core
  on: F2,
  // override compiler-core
  show: B2
};
function K2(t, e = {}) {
  return C0(
    t,
    Bt({}, ls, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        G2,
        ...El,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: Bt(
        {},
        Tl,
        e.directiveTransforms || {}
      ),
      transformHoist: q2
    })
  );
}
function Y2(t, e = {}) {
  return aa(t, Bt({}, ls, e));
}
var pu = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BASE_TRANSITION: Mu,
  BindingTypes: A2,
  CAMELIZE: dn,
  CAPITALIZE: jd,
  CREATE_BLOCK: Fu,
  CREATE_COMMENT: hs,
  CREATE_ELEMENT_BLOCK: Bu,
  CREATE_ELEMENT_VNODE: qn,
  CREATE_SLOTS: Uu,
  CREATE_STATIC: Vn,
  CREATE_TEXT: jn,
  CREATE_VNODE: ri,
  CompilerDeprecationTypes: ob,
  ConstantTypes: Jg,
  DOMDirectiveTransforms: Tl,
  DOMErrorCodes: I2,
  DOMErrorMessages: vl,
  DOMNodeTransforms: El,
  ElementTypes: Xg,
  ErrorCodes: hb,
  FRAGMENT: ss,
  GUARD_REACTIVE_PROPS: fs,
  IS_MEMO_SAME: qu,
  IS_REF: Hs,
  KEEP_ALIVE: Vs,
  MERGE_PROPS: Or,
  NORMALIZE_CLASS: Gn,
  NORMALIZE_PROPS: is,
  NORMALIZE_STYLE: Xn,
  Namespaces: Hg,
  NodeTypes: Gg,
  OPEN_BLOCK: cr,
  POP_SCOPE_ID: zd,
  PUSH_SCOPE_ID: Vd,
  RENDER_LIST: Hn,
  RENDER_SLOT: $u,
  RESOLVE_COMPONENT: zs,
  RESOLVE_DIRECTIVE: zn,
  RESOLVE_DYNAMIC_COMPONENT: si,
  RESOLVE_FILTER: qd,
  SET_BLOCK_TRACKING: Ws,
  SUSPENSE: cs,
  TELEPORT: _r,
  TO_DISPLAY_STRING: ii,
  TO_HANDLERS: Jn,
  TO_HANDLER_KEY: mn,
  TRANSITION: Mr,
  TRANSITION_GROUP: ys,
  TS_NODE_TYPES: sa,
  UNREF: ns,
  V_MODEL_CHECKBOX: pl,
  V_MODEL_DYNAMIC: vn,
  V_MODEL_RADIO: fl,
  V_MODEL_SELECT: ml,
  V_MODEL_TEXT: dl,
  V_ON_WITH_KEYS: gl,
  V_ON_WITH_MODIFIERS: yl,
  V_SHOW: bl,
  WITH_CTX: Kn,
  WITH_DIRECTIVES: Wn,
  WITH_MEMO: Yn,
  advancePositionWithClone: nu,
  advancePositionWithMutation: Yu,
  assert: au,
  baseCompile: C0,
  baseParse: aa,
  buildDirectiveArgs: ll,
  buildProps: ms,
  buildSlots: Ys,
  checkCompatEnabled: cb,
  compile: K2,
  convertToBlock: Qn,
  createArrayExpression: Gt,
  createAssignmentExpression: en,
  createBlockStatement: ni,
  createCacheExpression: Wd,
  createCallExpression: pe,
  createCompilerError: Te,
  createCompoundExpression: je,
  createConditionalExpression: Ct,
  createDOMCompilerError: Ze,
  createForLoopParams: Ks,
  createFunctionExpression: St,
  createIfStatement: gn,
  createInterpolation: yn,
  createObjectExpression: lt,
  createObjectProperty: Pe,
  createReturnStatement: Gd,
  createRoot: Dr,
  createSequenceExpression: Hd,
  createSimpleExpression: te,
  createStructuralDirectiveTransform: oi,
  createTemplateLiteral: Vu,
  createTransformContext: ai,
  createVNodeCall: as,
  errorMessages: Wu,
  extractIdentifiers: _t,
  findDir: Fe,
  findProp: ht,
  forAliasRE: l0,
  generate: tl,
  generateCodeFrame: ti,
  getBaseTransformPreset: hl,
  getConstantType: ct,
  getMemoedVNodeCall: u0,
  getVNodeBlockHelper: Lr,
  getVNodeHelper: kr,
  hasDynamicKeyVBind: na,
  hasScopeRef: at,
  helperNameMap: ot,
  injectProp: Xs,
  isCoreComponent: Ju,
  isFnExpression: a0,
  isFnExpressionBrowser: Eb,
  isFnExpressionNode: n0,
  isFunctionType: ur,
  isInDestructureAssignment: Gs,
  isInNewExpression: Zd,
  isMemberExpression: Ku,
  isMemberExpressionBrowser: vb,
  isMemberExpressionNode: i0,
  isReferencedIdentifier: Gu,
  isSimpleIdentifier: Kt,
  isSlotOutlet: us,
  isStaticArgOf: Mt,
  isStaticExp: He,
  isStaticProperty: ra,
  isStaticPropertyKey: s0,
  isTemplateNode: os,
  isText: Rs,
  isVPre: ou,
  isVSlot: Qu,
  locStub: Le,
  noopDirectiveTransform: Ds,
  parse: Y2,
  parserOptions: ls,
  processExpression: Ue,
  processFor: nl,
  processIf: sl,
  processSlotOutlet: cl,
  registerRuntimeHelpers: ju,
  resolveComponentType: ha,
  stringifyExpression: ca,
  toValidAssetId: Js,
  trackSlotScopes: ol,
  trackVForSlotScopes: ul,
  transform: el,
  transformBind: il,
  transformElement: A0,
  transformExpression: rl,
  transformModel: pa,
  transformOn: fa,
  transformStyle: Sl,
  traverseNode: ps,
  unwrapTSNode: vt,
  walkBlockDeclarations: e0,
  walkFunctionParams: Xu,
  walkIdentifiers: ta,
  warnDeprecation: Yd
}), Qa, Xh;
function Q2() {
  if (Xh) return Qa;
  Xh = 1;
  function t(l, h) {
    for (; l.length < h; )
      l = "0" + l;
    return l;
  }
  function e(l, h) {
    var c, p, d;
    if (h.length === 0)
      return l;
    for (c = 0, d = h.length; c < d; c++)
      p = h.charCodeAt(c), l = (l << 5) - l + p, l |= 0;
    return l < 0 ? l * -2 : l;
  }
  function r(l, h, c) {
    return Object.keys(h).sort().reduce(p, l);
    function p(d, m) {
      return i(d, h[m], m, c);
    }
  }
  function i(l, h, c, p) {
    var d = e(e(e(l, c), n(h)), typeof h);
    if (h === null)
      return e(d, "null");
    if (h === void 0)
      return e(d, "undefined");
    if (typeof h == "object" || typeof h == "function") {
      if (p.indexOf(h) !== -1)
        return e(d, "[Circular]" + c);
      p.push(h);
      var m = r(d, h, p);
      if (!("valueOf" in h) || typeof h.valueOf != "function")
        return m;
      try {
        return e(m, String(h.valueOf()));
      } catch (y) {
        return e(m, "[valueOf exception]" + (y.stack || y.message));
      }
    }
    return e(d, h.toString());
  }
  function n(l) {
    return Object.prototype.toString.call(l);
  }
  function u(l) {
    return t(i(0, l, "", []).toString(16), 8);
  }
  return Qa = u, Qa;
}
var Z2 = /* @__PURE__ */ Q2(), eS = /* @__PURE__ */ Zn(Z2);
const xn = "useCssVars";
function O0(t, e, r, i = !1) {
  return `{
  ${t.map(
    (n) => (
      // The `:` prefix here is used in `ssrRenderStyle` to distinguish whether
      // a custom property comes from `ssrCssVars`. If it does, we need to reset
      // its value to `initial` on the component instance to avoid unintentionally
      // inheriting the same property value from a different instance of the same
      // component in the outer scope.
      `"${i ? ":--" : ""}${k0(e, n, r, i)}": (${n})`
    )
  ).join(`,
  `)}
}`;
}
function k0(t, e, r, i = !1) {
  return r ? eS(t + e) : `${t}-${Wg(e, i)}`;
}
function L0(t) {
  return t = t.trim(), t[0] === "'" && t[t.length - 1] === "'" || t[0] === '"' && t[t.length - 1] === '"' ? t.slice(1, -1) : t;
}
const on = /v-bind\s*\(/g;
function tS(t) {
  const e = [];
  return t.styles.forEach((r) => {
    let i;
    const n = r.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    for (; i = on.exec(n); ) {
      const u = i.index + i[0].length, l = R0(n, u);
      if (l !== null) {
        const h = L0(n.slice(u, l));
        e.includes(h) || e.push(h);
      }
    }
  }), e;
}
function R0(t, e) {
  let r = 0, i = 0;
  for (let n = e; n < t.length; n++) {
    const u = t.charAt(n);
    switch (r) {
      case 0:
        if (u === "'")
          r = 1;
        else if (u === '"')
          r = 2;
        else if (u === "(")
          i++;
        else if (u === ")")
          if (i > 0)
            i--;
          else
            return n;
        break;
      case 1:
        u === "'" && (r = 0);
        break;
      case 2:
        u === '"' && (r = 0);
        break;
    }
  }
  return null;
}
const D0 = (t) => {
  const { id: e, isProd: r } = t;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(i) {
      const n = i.value;
      if (on.test(n)) {
        on.lastIndex = 0;
        let u = "", l = 0, h;
        for (; h = on.exec(n); ) {
          const c = h.index + h[0].length, p = R0(n, c);
          if (p !== null) {
            const d = L0(n.slice(c, p));
            u += n.slice(l, h.index) + `var(--${k0(e, d, r)})`, l = p + 1;
          }
        }
        i.value = u + n.slice(l);
      }
    }
  };
};
D0.postcss = !0;
function M0(t, e, r, i) {
  const n = O0(t, r, i), u = te(n, !1), l = ai(Dr([]), {
    prefixIdentifiers: !0,
    inline: !0,
    bindingMetadata: e.__isScriptSetup === !1 ? void 0 : e
  }), h = Ue(u, l), c = h.type === 4 ? h.content : h.children.map((p) => typeof p == "string" ? p : p.content).join("");
  return `_${xn}(_ctx => (${c}))`;
}
function rS(t, e, r, i, n) {
  return `
import { ${xn} as _${xn} } from 'vue'
const __injectCSSVars__ = () => {
${M0(
    t,
    e,
    r,
    i
  )}}
const __setup__ = ${n}.setup
${n}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}
var hr = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function F0() {
  throw new Error("setTimeout has not been defined");
}
function B0() {
  throw new Error("clearTimeout has not been defined");
}
var ir = F0, nr = B0;
typeof hr.setTimeout == "function" && (ir = setTimeout);
typeof hr.clearTimeout == "function" && (nr = clearTimeout);
function $0(t) {
  if (ir === setTimeout)
    return setTimeout(t, 0);
  if ((ir === F0 || !ir) && setTimeout)
    return ir = setTimeout, setTimeout(t, 0);
  try {
    return ir(t, 0);
  } catch {
    try {
      return ir.call(null, t, 0);
    } catch {
      return ir.call(this, t, 0);
    }
  }
}
function sS(t) {
  if (nr === clearTimeout)
    return clearTimeout(t);
  if ((nr === B0 || !nr) && clearTimeout)
    return nr = clearTimeout, clearTimeout(t);
  try {
    return nr(t);
  } catch {
    try {
      return nr.call(null, t);
    } catch {
      return nr.call(this, t);
    }
  }
}
var zt = [], Zr = !1, wr, un = -1;
function iS() {
  !Zr || !wr || (Zr = !1, wr.length ? zt = wr.concat(zt) : un = -1, zt.length && U0());
}
function U0() {
  if (!Zr) {
    var t = $0(iS);
    Zr = !0;
    for (var e = zt.length; e; ) {
      for (wr = zt, zt = []; ++un < e; )
        wr && wr[un].run();
      un = -1, e = zt.length;
    }
    wr = null, Zr = !1, sS(t);
  }
}
function nS(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  zt.push(new q0(t, e)), zt.length === 1 && !Zr && $0(U0);
}
function q0(t, e) {
  this.fun = t, this.array = e;
}
q0.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var aS = "browser", oS = "browser", uS = !0, lS = {}, cS = [], hS = "", fS = {}, pS = {}, dS = {};
function Fr() {
}
var mS = Fr, yS = Fr, gS = Fr, bS = Fr, SS = Fr, vS = Fr, xS = Fr;
function ES(t) {
  throw new Error("process.binding is not supported");
}
function TS() {
  return "/";
}
function wS(t) {
  throw new Error("process.chdir is not supported");
}
function PS() {
  return 0;
}
var Jr = hr.performance || {}, _S = Jr.now || Jr.mozNow || Jr.msNow || Jr.oNow || Jr.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function AS(t) {
  var e = _S.call(Jr) * 1e-3, r = Math.floor(e), i = Math.floor(e % 1 * 1e9);
  return t && (r = r - t[0], i = i - t[1], i < 0 && (r--, i += 1e9)), [r, i];
}
var CS = /* @__PURE__ */ new Date();
function IS() {
  var t = /* @__PURE__ */ new Date(), e = t - CS;
  return e / 1e3;
}
var ft = {
  nextTick: nS,
  title: aS,
  browser: uS,
  env: lS,
  argv: cS,
  version: hS,
  versions: fS,
  on: mS,
  addListener: yS,
  once: gS,
  off: bS,
  removeListener: SS,
  removeAllListeners: vS,
  emit: xS,
  binding: ES,
  cwd: TS,
  chdir: wS,
  umask: PS,
  hrtime: AS,
  platform: oS,
  release: pS,
  config: dS,
  uptime: IS
};
function wl(t = 500) {
  return /* @__PURE__ */ new Map();
}
function j0(t, e) {
  return NS(e).has(t);
}
const Jh = wl();
function NS(t) {
  const { content: e, ast: r } = t.template, i = Jh.get(e);
  if (i)
    return i;
  const n = /* @__PURE__ */ new Set();
  r.children.forEach(u);
  function u(l) {
    var h;
    switch (l.type) {
      case 1:
        let c = l.tag;
        c.includes(".") && (c = c.split(".")[0].trim()), !ls.isNativeTag(c) && !ls.isBuiltInComponent(c) && (n.add(ut(c)), n.add(lr(ut(c))));
        for (let p = 0; p < l.props.length; p++) {
          const d = l.props[p];
          d.type === 7 && (Du(d.name) || n.add(`v${lr(ut(d.name))}`), d.arg && !d.arg.isStatic && wi(n, d.arg), d.name === "for" ? wi(n, d.forParseResult.source) : d.exp ? wi(n, d.exp) : d.name === "bind" && !d.exp && n.add(ut(d.arg.content))), d.type === 6 && d.name === "ref" && ((h = d.value) != null && h.content) && n.add(d.value.content);
        }
        l.children.forEach(u);
        break;
      case 5:
        wi(n, l.content);
        break;
    }
  }
  return Jh.set(e, n), n;
}
function wi(t, e) {
  e.ast ? ta(e.ast, (r) => t.add(r.name)) : e.ast === null && t.add(e.content);
}
var OS = Object.defineProperty, kS = Object.defineProperties, LS = Object.getOwnPropertyDescriptors, Kh = Object.getOwnPropertySymbols, RS = Object.prototype.hasOwnProperty, DS = Object.prototype.propertyIsEnumerable, Yh = (t, e, r) => e in t ? OS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Qh = (t, e) => {
  for (var r in e || (e = {}))
    RS.call(e, r) && Yh(t, r, e[r]);
  if (Kh)
    for (var r of Kh(e))
      DS.call(e, r) && Yh(t, r, e[r]);
  return t;
}, Zh = (t, e) => kS(t, LS(e));
const V0 = "anonymous.vue", ef = wl();
function z0(t, e = {}) {
  var r;
  const i = Eg(t, Zh(Qh({}, e), {
    compiler: { parse: (r = e.compiler) == null ? void 0 : r.parse }
  })), n = ef.get(i);
  if (n)
    return n;
  const {
    sourceMap: u = !0,
    filename: l = V0,
    sourceRoot: h = "",
    pad: c = !1,
    ignoreEmpty: p = !0,
    compiler: d = pu,
    templateParseOptions: m = {}
  } = e, y = {
    filename: l,
    source: t,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: !1,
    shouldForceReload: (P) => jS(P, y)
  }, g = [];
  d.parse(t, Zh(Qh({
    parseMode: "sfc",
    prefixIdentifiers: !0
  }, m), {
    onError: (P) => {
      g.push(P);
    }
  })).children.forEach((P) => {
    if (P.type === 1 && !(p && P.tag !== "template" && qS(P) && !US(P)))
      switch (P.tag) {
        case "template":
          if (y.template)
            g.push(tf(P));
          else {
            const R = y.template = Pi(
              P,
              t,
              !1
            );
            if (R.attrs.src || (R.ast = Dr(P.children, t)), R.attrs.functional) {
              const M = new SyntaxError(
                "<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead."
              );
              M.loc = P.props.find(
                (O) => O.type === 6 && O.name === "functional"
              ).loc, g.push(M);
            }
          }
          break;
        case "script":
          const A = Pi(P, t, c), N = !!A.attrs.setup;
          if (N && !y.scriptSetup) {
            y.scriptSetup = A;
            break;
          }
          if (!N && !y.script) {
            y.script = A;
            break;
          }
          g.push(tf(P, N));
          break;
        case "style":
          const _ = Pi(P, t, c);
          _.attrs.vars && g.push(
            new SyntaxError(
              "<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231"
            )
          ), y.styles.push(_);
          break;
        default:
          y.customBlocks.push(Pi(P, t, c));
          break;
      }
  }), !y.template && !y.script && !y.scriptSetup && g.push(
    new SyntaxError(
      `At least one <template> or <script> is required in a single file component. ${y.filename}`
    )
  ), y.scriptSetup && (y.scriptSetup.src && (g.push(
    new SyntaxError(
      '<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.'
    )
  ), y.scriptSetup = null), y.script && y.script.src && (g.push(
    new SyntaxError(
      '<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.'
    )
  ), y.script = null));
  let S = 0;
  if (y.template && (y.template.lang === "pug" || y.template.lang === "jade") && ([y.template.content, S] = VS(
    y.template.content
  )), u) {
    const P = (A, N = 0) => {
      A && !A.src && (A.map = BS(
        l,
        t,
        A.content,
        h,
        !c || A.type === "template" ? A.loc.start.line - 1 : 0,
        N
      ));
    };
    P(y.template, S), P(y.script), y.styles.forEach((A) => P(A)), y.customBlocks.forEach((A) => P(A));
  }
  y.cssVars = tS(y);
  const x = /(?:::v-|:)slotted\(/;
  y.slotted = y.styles.some(
    (P) => P.scoped && x.test(P.content)
  );
  const v = {
    descriptor: y,
    errors: g
  };
  return ef.set(i, v), v;
}
function tf(t, e = !1) {
  const r = new SyntaxError(
    `Single file component can contain only one <${t.tag}${e ? " setup" : ""}> element`
  );
  return r.loc = t.loc, r;
}
function Pi(t, e, r) {
  const i = t.tag, n = t.innerLoc, u = {}, l = {
    type: i,
    content: e.slice(n.start.offset, n.end.offset),
    loc: n,
    attrs: u
  };
  return r && (l.content = $S(e, l, r) + l.content), t.props.forEach((h) => {
    if (h.type === 6) {
      const c = h.name;
      u[c] = h.value && h.value.content || !0, c === "lang" ? l.lang = h.value && h.value.content : c === "src" ? l.src = h.value && h.value.content : i === "style" ? c === "scoped" ? l.scoped = !0 : c === "module" && (l.module = u[c]) : i === "script" && c === "setup" && (l.setup = u.setup);
    }
  }), l;
}
const W0 = /\r?\n/g, MS = /^(?:\/\/)?\s*$/, FS = /./g;
function BS(t, e, r, i, n, u) {
  const l = new Ar.SourceMapGenerator({
    file: t.replace(/\\/g, "/"),
    sourceRoot: i.replace(/\\/g, "/")
  });
  return l.setSourceContent(t, e), l._sources.add(t), r.split(W0).forEach((h, c) => {
    if (!MS.test(h)) {
      const p = c + 1 + n, d = c + 1;
      for (let m = 0; m < h.length; m++)
        /\s/.test(h[m]) || l._mappings.add({
          originalLine: p,
          originalColumn: m + u,
          generatedLine: d,
          generatedColumn: m,
          source: t,
          name: null
        });
    }
  }), l.toJSON();
}
function $S(t, e, r) {
  if (t = t.slice(0, e.loc.start.offset), r === "space")
    return t.replace(FS, " ");
  {
    const i = t.split(W0).length, n = e.type === "script" && !e.lang ? `//
` : `
`;
    return Array(i).join(n);
  }
}
function US(t) {
  return t.props.some((e) => e.type !== 6 ? !1 : e.name === "src");
}
function qS(t) {
  for (let e = 0; e < t.children.length; e++) {
    const r = t.children[e];
    if (r.type !== 2 || r.content.trim() !== "")
      return !1;
  }
  return !0;
}
function jS(t, e) {
  if (!e.scriptSetup || e.scriptSetup.lang !== "ts" && e.scriptSetup.lang !== "tsx")
    return !1;
  for (const r in t)
    if (!t[r].isUsedInTemplate && j0(r, e))
      return !0;
  return !1;
}
function VS(t) {
  const e = t.split(`
`), r = e.reduce(function(i, n) {
    var u, l;
    if (n.trim() === "")
      return i;
    const h = ((l = (u = n.match(/^\s*/)) == null ? void 0 : u[0]) == null ? void 0 : l.length) || 0;
    return Math.min(h, i);
  }, 1 / 0);
  return r === 0 ? [t, r] : [
    e.map(function(i) {
      return i.slice(r);
    }).join(`
`),
    r
  ];
}
function H0(t, e) {
  for (var r = 0, i = t.length - 1; i >= 0; i--) {
    var n = t[i];
    n === "." ? t.splice(i, 1) : n === ".." ? (t.splice(i, 1), r++) : r && (t.splice(i, 1), r--);
  }
  if (e)
    for (; r--; r)
      t.unshift("..");
  return t;
}
var zS = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Pl = function(t) {
  return zS.exec(t).slice(1);
};
function En() {
  for (var t = "", e = !1, r = arguments.length - 1; r >= -1 && !e; r--) {
    var i = r >= 0 ? arguments[r] : "/";
    if (typeof i != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!i)
      continue;
    t = i + "/" + t, e = i.charAt(0) === "/";
  }
  return t = H0(Il(t.split("/"), function(n) {
    return !!n;
  }), !e).join("/"), (e ? "/" : "") + t || ".";
}
function _l(t) {
  var e = Al(t), r = WS(t, -1) === "/";
  return t = H0(Il(t.split("/"), function(i) {
    return !!i;
  }), !e).join("/"), !t && !e && (t = "."), t && r && (t += "/"), (e ? "/" : "") + t;
}
function Al(t) {
  return t.charAt(0) === "/";
}
function G0() {
  var t = Array.prototype.slice.call(arguments, 0);
  return _l(Il(t, function(e, r) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function X0(t, e) {
  t = En(t).substr(1), e = En(e).substr(1);
  function r(p) {
    for (var d = 0; d < p.length && p[d] === ""; d++)
      ;
    for (var m = p.length - 1; m >= 0 && p[m] === ""; m--)
      ;
    return d > m ? [] : p.slice(d, m - d + 1);
  }
  for (var i = r(t.split("/")), n = r(e.split("/")), u = Math.min(i.length, n.length), l = u, h = 0; h < u; h++)
    if (i[h] !== n[h]) {
      l = h;
      break;
    }
  for (var c = [], h = l; h < i.length; h++)
    c.push("..");
  return c = c.concat(n.slice(l)), c.join("/");
}
var J0 = "/", K0 = ":";
function Tn(t) {
  var e = Pl(t), r = e[0], i = e[1];
  return !r && !i ? "." : (i && (i = i.substr(0, i.length - 1)), r + i);
}
function Y0(t, e) {
  var r = Pl(t)[2];
  return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r;
}
function Cl(t) {
  return Pl(t)[3];
}
var Yt = {
  extname: Cl,
  basename: Y0,
  dirname: Tn,
  sep: J0,
  delimiter: K0,
  relative: X0,
  join: G0,
  isAbsolute: Al,
  normalize: _l,
  resolve: En
};
function Il(t, e) {
  if (t.filter) return t.filter(e);
  for (var r = [], i = 0; i < t.length; i++)
    e(t[i], i, t) && r.push(t[i]);
  return r;
}
var WS = "ab".substr(-1) === "b" ? function(t, e, r) {
  return t.substr(e, r);
} : function(t, e, r) {
  return e < 0 && (e = t.length + e), t.substr(e, r);
}, HS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename: Y0,
  default: Yt,
  delimiter: K0,
  dirname: Tn,
  extname: Cl,
  isAbsolute: Al,
  join: G0,
  normalize: _l,
  relative: X0,
  resolve: En,
  sep: J0
});
/*! https://mths.be/punycode v1.4.1 by @mathias */
var Za = 2147483647, Ms = 36, Q0 = 1, du = 26, GS = 38, XS = 700, JS = 72, KS = 128, YS = "-", QS = /[^\x20-\x7E]/, ZS = /[\x2E\u3002\uFF0E\uFF61]/g, ev = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, eo = Ms - Q0, Yr = Math.floor, to = String.fromCharCode;
function rf(t) {
  throw new RangeError(ev[t]);
}
function tv(t, e) {
  for (var r = t.length, i = []; r--; )
    i[r] = e(t[r]);
  return i;
}
function rv(t, e) {
  var r = t.split("@"), i = "";
  r.length > 1 && (i = r[0] + "@", t = r[1]), t = t.replace(ZS, ".");
  var n = t.split("."), u = tv(n, e).join(".");
  return i + u;
}
function sv(t) {
  for (var e = [], r = 0, i = t.length, n, u; r < i; )
    n = t.charCodeAt(r++), n >= 55296 && n <= 56319 && r < i ? (u = t.charCodeAt(r++), (u & 64512) == 56320 ? e.push(((n & 1023) << 10) + (u & 1023) + 65536) : (e.push(n), r--)) : e.push(n);
  return e;
}
function sf(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}
function iv(t, e, r) {
  var i = 0;
  for (t = r ? Yr(t / XS) : t >> 1, t += Yr(t / e); t > eo * du >> 1; i += Ms)
    t = Yr(t / eo);
  return Yr(i + (eo + 1) * t / (t + GS));
}
function nv(t) {
  var e, r, i, n, u, l, h, c, p, d, m, y = [], g, E, S, x;
  for (t = sv(t), g = t.length, e = KS, r = 0, u = JS, l = 0; l < g; ++l)
    m = t[l], m < 128 && y.push(to(m));
  for (i = n = y.length, n && y.push(YS); i < g; ) {
    for (h = Za, l = 0; l < g; ++l)
      m = t[l], m >= e && m < h && (h = m);
    for (E = i + 1, h - e > Yr((Za - r) / E) && rf("overflow"), r += (h - e) * E, e = h, l = 0; l < g; ++l)
      if (m = t[l], m < e && ++r > Za && rf("overflow"), m == e) {
        for (c = r, p = Ms; d = p <= u ? Q0 : p >= u + du ? du : p - u, !(c < d); p += Ms)
          x = c - d, S = Ms - d, y.push(
            to(sf(d + x % S, 0))
          ), c = Yr(x / S);
        y.push(to(sf(c, 0))), u = iv(r, E, i == n), r = 0, ++i;
      }
    ++r, ++e;
  }
  return y.join("");
}
function av(t) {
  return rv(t, function(e) {
    return QS.test(e) ? "xn--" + nv(e) : e;
  });
}
var Rt = [], Et = [], ov = typeof Uint8Array < "u" ? Uint8Array : Array, Nl = !1;
function Z0() {
  Nl = !0;
  for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, r = t.length; e < r; ++e)
    Rt[e] = t[e], Et[t.charCodeAt(e)] = e;
  Et[45] = 62, Et[95] = 63;
}
function uv(t) {
  Nl || Z0();
  var e, r, i, n, u, l, h = t.length;
  if (h % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  u = t[h - 2] === "=" ? 2 : t[h - 1] === "=" ? 1 : 0, l = new ov(h * 3 / 4 - u), i = u > 0 ? h - 4 : h;
  var c = 0;
  for (e = 0, r = 0; e < i; e += 4, r += 3)
    n = Et[t.charCodeAt(e)] << 18 | Et[t.charCodeAt(e + 1)] << 12 | Et[t.charCodeAt(e + 2)] << 6 | Et[t.charCodeAt(e + 3)], l[c++] = n >> 16 & 255, l[c++] = n >> 8 & 255, l[c++] = n & 255;
  return u === 2 ? (n = Et[t.charCodeAt(e)] << 2 | Et[t.charCodeAt(e + 1)] >> 4, l[c++] = n & 255) : u === 1 && (n = Et[t.charCodeAt(e)] << 10 | Et[t.charCodeAt(e + 1)] << 4 | Et[t.charCodeAt(e + 2)] >> 2, l[c++] = n >> 8 & 255, l[c++] = n & 255), l;
}
function lv(t) {
  return Rt[t >> 18 & 63] + Rt[t >> 12 & 63] + Rt[t >> 6 & 63] + Rt[t & 63];
}
function cv(t, e, r) {
  for (var i, n = [], u = e; u < r; u += 3)
    i = (t[u] << 16) + (t[u + 1] << 8) + t[u + 2], n.push(lv(i));
  return n.join("");
}
function nf(t) {
  Nl || Z0();
  for (var e, r = t.length, i = r % 3, n = "", u = [], l = 16383, h = 0, c = r - i; h < c; h += l)
    u.push(cv(t, h, h + l > c ? c : h + l));
  return i === 1 ? (e = t[r - 1], n += Rt[e >> 2], n += Rt[e << 4 & 63], n += "==") : i === 2 && (e = (t[r - 2] << 8) + t[r - 1], n += Rt[e >> 10], n += Rt[e >> 4 & 63], n += Rt[e << 2 & 63], n += "="), u.push(n), u.join("");
}
function da(t, e, r, i, n) {
  var u, l, h = n * 8 - i - 1, c = (1 << h) - 1, p = c >> 1, d = -7, m = r ? n - 1 : 0, y = r ? -1 : 1, g = t[e + m];
  for (m += y, u = g & (1 << -d) - 1, g >>= -d, d += h; d > 0; u = u * 256 + t[e + m], m += y, d -= 8)
    ;
  for (l = u & (1 << -d) - 1, u >>= -d, d += i; d > 0; l = l * 256 + t[e + m], m += y, d -= 8)
    ;
  if (u === 0)
    u = 1 - p;
  else {
    if (u === c)
      return l ? NaN : (g ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, i), u = u - p;
  }
  return (g ? -1 : 1) * l * Math.pow(2, u - i);
}
function em(t, e, r, i, n, u) {
  var l, h, c, p = u * 8 - n - 1, d = (1 << p) - 1, m = d >> 1, y = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = i ? 0 : u - 1, E = i ? 1 : -1, S = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (h = isNaN(e) ? 1 : 0, l = d) : (l = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -l)) < 1 && (l--, c *= 2), l + m >= 1 ? e += y / c : e += y * Math.pow(2, 1 - m), e * c >= 2 && (l++, c /= 2), l + m >= d ? (h = 0, l = d) : l + m >= 1 ? (h = (e * c - 1) * Math.pow(2, n), l = l + m) : (h = e * Math.pow(2, m - 1) * Math.pow(2, n), l = 0)); n >= 8; t[r + g] = h & 255, g += E, h /= 256, n -= 8)
    ;
  for (l = l << n | h, p += n; p > 0; t[r + g] = l & 255, g += E, l /= 256, p -= 8)
    ;
  t[r + g - E] |= S * 128;
}
var hv = {}.toString, tm = Array.isArray || function(t) {
  return hv.call(t) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var fv = 50;
X.TYPED_ARRAY_SUPPORT = hr.TYPED_ARRAY_SUPPORT !== void 0 ? hr.TYPED_ARRAY_SUPPORT : !0;
wn();
function wn() {
  return X.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Wt(t, e) {
  if (wn() < e)
    throw new RangeError("Invalid typed array length");
  return X.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e), t.__proto__ = X.prototype) : (t === null && (t = new X(e)), t.length = e), t;
}
function X(t, e, r) {
  if (!X.TYPED_ARRAY_SUPPORT && !(this instanceof X))
    return new X(t, e, r);
  if (typeof t == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return Ol(this, t);
  }
  return rm(this, t, e, r);
}
X.poolSize = 8192;
X._augment = function(t) {
  return t.__proto__ = X.prototype, t;
};
function rm(t, e, r, i) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? mv(t, e, r, i) : typeof e == "string" ? dv(t, e, r) : yv(t, e);
}
X.from = function(t, e, r) {
  return rm(null, t, e, r);
};
X.TYPED_ARRAY_SUPPORT && (X.prototype.__proto__ = Uint8Array.prototype, X.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && X[Symbol.species]);
function sm(t) {
  if (typeof t != "number")
    throw new TypeError('"size" argument must be a number');
  if (t < 0)
    throw new RangeError('"size" argument must not be negative');
}
function pv(t, e, r, i) {
  return sm(e), e <= 0 ? Wt(t, e) : r !== void 0 ? typeof i == "string" ? Wt(t, e).fill(r, i) : Wt(t, e).fill(r) : Wt(t, e);
}
X.alloc = function(t, e, r) {
  return pv(null, t, e, r);
};
function Ol(t, e) {
  if (sm(e), t = Wt(t, e < 0 ? 0 : kl(e) | 0), !X.TYPED_ARRAY_SUPPORT)
    for (var r = 0; r < e; ++r)
      t[r] = 0;
  return t;
}
X.allocUnsafe = function(t) {
  return Ol(null, t);
};
X.allocUnsafeSlow = function(t) {
  return Ol(null, t);
};
function dv(t, e, r) {
  if ((typeof r != "string" || r === "") && (r = "utf8"), !X.isEncoding(r))
    throw new TypeError('"encoding" must be a valid string encoding');
  var i = im(e, r) | 0;
  t = Wt(t, i);
  var n = t.write(e, r);
  return n !== i && (t = t.slice(0, n)), t;
}
function mu(t, e) {
  var r = e.length < 0 ? 0 : kl(e.length) | 0;
  t = Wt(t, r);
  for (var i = 0; i < r; i += 1)
    t[i] = e[i] & 255;
  return t;
}
function mv(t, e, r, i) {
  if (e.byteLength, r < 0 || e.byteLength < r)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < r + (i || 0))
    throw new RangeError("'length' is out of bounds");
  return r === void 0 && i === void 0 ? e = new Uint8Array(e) : i === void 0 ? e = new Uint8Array(e, r) : e = new Uint8Array(e, r, i), X.TYPED_ARRAY_SUPPORT ? (t = e, t.__proto__ = X.prototype) : t = mu(t, e), t;
}
function yv(t, e) {
  if (qt(e)) {
    var r = kl(e.length) | 0;
    return t = Wt(t, r), t.length === 0 || e.copy(t, 0, 0, r), t;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || Dv(e.length) ? Wt(t, 0) : mu(t, e);
    if (e.type === "Buffer" && tm(e.data))
      return mu(t, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function kl(t) {
  if (t >= wn())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + wn().toString(16) + " bytes");
  return t | 0;
}
X.isBuffer = Mv;
function qt(t) {
  return !!(t != null && t._isBuffer);
}
X.compare = function(e, r) {
  if (!qt(e) || !qt(r))
    throw new TypeError("Arguments must be Buffers");
  if (e === r) return 0;
  for (var i = e.length, n = r.length, u = 0, l = Math.min(i, n); u < l; ++u)
    if (e[u] !== r[u]) {
      i = e[u], n = r[u];
      break;
    }
  return i < n ? -1 : n < i ? 1 : 0;
};
X.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
X.concat = function(e, r) {
  if (!tm(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return X.alloc(0);
  var i;
  if (r === void 0)
    for (r = 0, i = 0; i < e.length; ++i)
      r += e[i].length;
  var n = X.allocUnsafe(r), u = 0;
  for (i = 0; i < e.length; ++i) {
    var l = e[i];
    if (!qt(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    l.copy(n, u), u += l.length;
  }
  return n;
};
function im(t, e) {
  if (qt(t))
    return t.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
    return t.byteLength;
  typeof t != "string" && (t = "" + t);
  var r = t.length;
  if (r === 0) return 0;
  for (var i = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return r;
      case "utf8":
      case "utf-8":
      case void 0:
        return Pn(t).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return r * 2;
      case "hex":
        return r >>> 1;
      case "base64":
        return hm(t).length;
      default:
        if (i) return Pn(t).length;
        e = ("" + e).toLowerCase(), i = !0;
    }
}
X.byteLength = im;
function gv(t, e, r) {
  var i = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
    return "";
  for (t || (t = "utf8"); ; )
    switch (t) {
      case "hex":
        return Av(this, e, r);
      case "utf8":
      case "utf-8":
        return om(this, e, r);
      case "ascii":
        return Pv(this, e, r);
      case "latin1":
      case "binary":
        return _v(this, e, r);
      case "base64":
        return Tv(this, e, r);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Cv(this, e, r);
      default:
        if (i) throw new TypeError("Unknown encoding: " + t);
        t = (t + "").toLowerCase(), i = !0;
    }
}
X.prototype._isBuffer = !0;
function Pr(t, e, r) {
  var i = t[e];
  t[e] = t[r], t[r] = i;
}
X.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r = 0; r < e; r += 2)
    Pr(this, r, r + 1);
  return this;
};
X.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r = 0; r < e; r += 4)
    Pr(this, r, r + 3), Pr(this, r + 1, r + 2);
  return this;
};
X.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r = 0; r < e; r += 8)
    Pr(this, r, r + 7), Pr(this, r + 1, r + 6), Pr(this, r + 2, r + 5), Pr(this, r + 3, r + 4);
  return this;
};
X.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? om(this, 0, e) : gv.apply(this, arguments);
};
X.prototype.equals = function(e) {
  if (!qt(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : X.compare(this, e) === 0;
};
X.prototype.inspect = function() {
  var e = "", r = fv;
  return this.length > 0 && (e = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (e += " ... ")), "<Buffer " + e + ">";
};
X.prototype.compare = function(e, r, i, n, u) {
  if (!qt(e))
    throw new TypeError("Argument must be a Buffer");
  if (r === void 0 && (r = 0), i === void 0 && (i = e ? e.length : 0), n === void 0 && (n = 0), u === void 0 && (u = this.length), r < 0 || i > e.length || n < 0 || u > this.length)
    throw new RangeError("out of range index");
  if (n >= u && r >= i)
    return 0;
  if (n >= u)
    return -1;
  if (r >= i)
    return 1;
  if (r >>>= 0, i >>>= 0, n >>>= 0, u >>>= 0, this === e) return 0;
  for (var l = u - n, h = i - r, c = Math.min(l, h), p = this.slice(n, u), d = e.slice(r, i), m = 0; m < c; ++m)
    if (p[m] !== d[m]) {
      l = p[m], h = d[m];
      break;
    }
  return l < h ? -1 : h < l ? 1 : 0;
};
function nm(t, e, r, i, n) {
  if (t.length === 0) return -1;
  if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
    if (n) return -1;
    r = t.length - 1;
  } else if (r < 0)
    if (n) r = 0;
    else return -1;
  if (typeof e == "string" && (e = X.from(e, i)), qt(e))
    return e.length === 0 ? -1 : af(t, e, r, i, n);
  if (typeof e == "number")
    return e = e & 255, X.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : af(t, [e], r, i, n);
  throw new TypeError("val must be string, number or Buffer");
}
function af(t, e, r, i, n) {
  var u = 1, l = t.length, h = e.length;
  if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
    if (t.length < 2 || e.length < 2)
      return -1;
    u = 2, l /= 2, h /= 2, r /= 2;
  }
  function c(g, E) {
    return u === 1 ? g[E] : g.readUInt16BE(E * u);
  }
  var p;
  if (n) {
    var d = -1;
    for (p = r; p < l; p++)
      if (c(t, p) === c(e, d === -1 ? 0 : p - d)) {
        if (d === -1 && (d = p), p - d + 1 === h) return d * u;
      } else
        d !== -1 && (p -= p - d), d = -1;
  } else
    for (r + h > l && (r = l - h), p = r; p >= 0; p--) {
      for (var m = !0, y = 0; y < h; y++)
        if (c(t, p + y) !== c(e, y)) {
          m = !1;
          break;
        }
      if (m) return p;
    }
  return -1;
}
X.prototype.includes = function(e, r, i) {
  return this.indexOf(e, r, i) !== -1;
};
X.prototype.indexOf = function(e, r, i) {
  return nm(this, e, r, i, !0);
};
X.prototype.lastIndexOf = function(e, r, i) {
  return nm(this, e, r, i, !1);
};
function bv(t, e, r, i) {
  r = Number(r) || 0;
  var n = t.length - r;
  i ? (i = Number(i), i > n && (i = n)) : i = n;
  var u = e.length;
  if (u % 2 !== 0) throw new TypeError("Invalid hex string");
  i > u / 2 && (i = u / 2);
  for (var l = 0; l < i; ++l) {
    var h = parseInt(e.substr(l * 2, 2), 16);
    if (isNaN(h)) return l;
    t[r + l] = h;
  }
  return l;
}
function Sv(t, e, r, i) {
  return ga(Pn(e, t.length - r), t, r, i);
}
function am(t, e, r, i) {
  return ga(Lv(e), t, r, i);
}
function vv(t, e, r, i) {
  return am(t, e, r, i);
}
function xv(t, e, r, i) {
  return ga(hm(e), t, r, i);
}
function Ev(t, e, r, i) {
  return ga(Rv(e, t.length - r), t, r, i);
}
X.prototype.write = function(e, r, i, n) {
  if (r === void 0)
    n = "utf8", i = this.length, r = 0;
  else if (i === void 0 && typeof r == "string")
    n = r, i = this.length, r = 0;
  else if (isFinite(r))
    r = r | 0, isFinite(i) ? (i = i | 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var u = this.length - r;
  if ((i === void 0 || i > u) && (i = u), e.length > 0 && (i < 0 || r < 0) || r > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var l = !1; ; )
    switch (n) {
      case "hex":
        return bv(this, e, r, i);
      case "utf8":
      case "utf-8":
        return Sv(this, e, r, i);
      case "ascii":
        return am(this, e, r, i);
      case "latin1":
      case "binary":
        return vv(this, e, r, i);
      case "base64":
        return xv(this, e, r, i);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Ev(this, e, r, i);
      default:
        if (l) throw new TypeError("Unknown encoding: " + n);
        n = ("" + n).toLowerCase(), l = !0;
    }
};
X.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function Tv(t, e, r) {
  return e === 0 && r === t.length ? nf(t) : nf(t.slice(e, r));
}
function om(t, e, r) {
  r = Math.min(t.length, r);
  for (var i = [], n = e; n < r; ) {
    var u = t[n], l = null, h = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
    if (n + h <= r) {
      var c, p, d, m;
      switch (h) {
        case 1:
          u < 128 && (l = u);
          break;
        case 2:
          c = t[n + 1], (c & 192) === 128 && (m = (u & 31) << 6 | c & 63, m > 127 && (l = m));
          break;
        case 3:
          c = t[n + 1], p = t[n + 2], (c & 192) === 128 && (p & 192) === 128 && (m = (u & 15) << 12 | (c & 63) << 6 | p & 63, m > 2047 && (m < 55296 || m > 57343) && (l = m));
          break;
        case 4:
          c = t[n + 1], p = t[n + 2], d = t[n + 3], (c & 192) === 128 && (p & 192) === 128 && (d & 192) === 128 && (m = (u & 15) << 18 | (c & 63) << 12 | (p & 63) << 6 | d & 63, m > 65535 && m < 1114112 && (l = m));
      }
    }
    l === null ? (l = 65533, h = 1) : l > 65535 && (l -= 65536, i.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), i.push(l), n += h;
  }
  return wv(i);
}
var of = 4096;
function wv(t) {
  var e = t.length;
  if (e <= of)
    return String.fromCharCode.apply(String, t);
  for (var r = "", i = 0; i < e; )
    r += String.fromCharCode.apply(
      String,
      t.slice(i, i += of)
    );
  return r;
}
function Pv(t, e, r) {
  var i = "";
  r = Math.min(t.length, r);
  for (var n = e; n < r; ++n)
    i += String.fromCharCode(t[n] & 127);
  return i;
}
function _v(t, e, r) {
  var i = "";
  r = Math.min(t.length, r);
  for (var n = e; n < r; ++n)
    i += String.fromCharCode(t[n]);
  return i;
}
function Av(t, e, r) {
  var i = t.length;
  (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i);
  for (var n = "", u = e; u < r; ++u)
    n += kv(t[u]);
  return n;
}
function Cv(t, e, r) {
  for (var i = t.slice(e, r), n = "", u = 0; u < i.length; u += 2)
    n += String.fromCharCode(i[u] + i[u + 1] * 256);
  return n;
}
X.prototype.slice = function(e, r) {
  var i = this.length;
  e = ~~e, r = r === void 0 ? i : ~~r, e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < e && (r = e);
  var n;
  if (X.TYPED_ARRAY_SUPPORT)
    n = this.subarray(e, r), n.__proto__ = X.prototype;
  else {
    var u = r - e;
    n = new X(u, void 0);
    for (var l = 0; l < u; ++l)
      n[l] = this[l + e];
  }
  return n;
};
function ze(t, e, r) {
  if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint");
  if (t + e > r) throw new RangeError("Trying to access beyond buffer length");
}
X.prototype.readUIntLE = function(e, r, i) {
  e = e | 0, r = r | 0, i || ze(e, r, this.length);
  for (var n = this[e], u = 1, l = 0; ++l < r && (u *= 256); )
    n += this[e + l] * u;
  return n;
};
X.prototype.readUIntBE = function(e, r, i) {
  e = e | 0, r = r | 0, i || ze(e, r, this.length);
  for (var n = this[e + --r], u = 1; r > 0 && (u *= 256); )
    n += this[e + --r] * u;
  return n;
};
X.prototype.readUInt8 = function(e, r) {
  return r || ze(e, 1, this.length), this[e];
};
X.prototype.readUInt16LE = function(e, r) {
  return r || ze(e, 2, this.length), this[e] | this[e + 1] << 8;
};
X.prototype.readUInt16BE = function(e, r) {
  return r || ze(e, 2, this.length), this[e] << 8 | this[e + 1];
};
X.prototype.readUInt32LE = function(e, r) {
  return r || ze(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
X.prototype.readUInt32BE = function(e, r) {
  return r || ze(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
X.prototype.readIntLE = function(e, r, i) {
  e = e | 0, r = r | 0, i || ze(e, r, this.length);
  for (var n = this[e], u = 1, l = 0; ++l < r && (u *= 256); )
    n += this[e + l] * u;
  return u *= 128, n >= u && (n -= Math.pow(2, 8 * r)), n;
};
X.prototype.readIntBE = function(e, r, i) {
  e = e | 0, r = r | 0, i || ze(e, r, this.length);
  for (var n = r, u = 1, l = this[e + --n]; n > 0 && (u *= 256); )
    l += this[e + --n] * u;
  return u *= 128, l >= u && (l -= Math.pow(2, 8 * r)), l;
};
X.prototype.readInt8 = function(e, r) {
  return r || ze(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
X.prototype.readInt16LE = function(e, r) {
  r || ze(e, 2, this.length);
  var i = this[e] | this[e + 1] << 8;
  return i & 32768 ? i | 4294901760 : i;
};
X.prototype.readInt16BE = function(e, r) {
  r || ze(e, 2, this.length);
  var i = this[e + 1] | this[e] << 8;
  return i & 32768 ? i | 4294901760 : i;
};
X.prototype.readInt32LE = function(e, r) {
  return r || ze(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
X.prototype.readInt32BE = function(e, r) {
  return r || ze(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
X.prototype.readFloatLE = function(e, r) {
  return r || ze(e, 4, this.length), da(this, e, !0, 23, 4);
};
X.prototype.readFloatBE = function(e, r) {
  return r || ze(e, 4, this.length), da(this, e, !1, 23, 4);
};
X.prototype.readDoubleLE = function(e, r) {
  return r || ze(e, 8, this.length), da(this, e, !0, 52, 8);
};
X.prototype.readDoubleBE = function(e, r) {
  return r || ze(e, 8, this.length), da(this, e, !1, 52, 8);
};
function pt(t, e, r, i, n, u) {
  if (!qt(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > n || e < u) throw new RangeError('"value" argument is out of bounds');
  if (r + i > t.length) throw new RangeError("Index out of range");
}
X.prototype.writeUIntLE = function(e, r, i, n) {
  if (e = +e, r = r | 0, i = i | 0, !n) {
    var u = Math.pow(2, 8 * i) - 1;
    pt(this, e, r, i, u, 0);
  }
  var l = 1, h = 0;
  for (this[r] = e & 255; ++h < i && (l *= 256); )
    this[r + h] = e / l & 255;
  return r + i;
};
X.prototype.writeUIntBE = function(e, r, i, n) {
  if (e = +e, r = r | 0, i = i | 0, !n) {
    var u = Math.pow(2, 8 * i) - 1;
    pt(this, e, r, i, u, 0);
  }
  var l = i - 1, h = 1;
  for (this[r + l] = e & 255; --l >= 0 && (h *= 256); )
    this[r + l] = e / h & 255;
  return r + i;
};
X.prototype.writeUInt8 = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 1, 255, 0), X.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[r] = e & 255, r + 1;
};
function ma(t, e, r, i) {
  e < 0 && (e = 65535 + e + 1);
  for (var n = 0, u = Math.min(t.length - r, 2); n < u; ++n)
    t[r + n] = (e & 255 << 8 * (i ? n : 1 - n)) >>> (i ? n : 1 - n) * 8;
}
X.prototype.writeUInt16LE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 2, 65535, 0), X.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8) : ma(this, e, r, !0), r + 2;
};
X.prototype.writeUInt16BE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 2, 65535, 0), X.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 8, this[r + 1] = e & 255) : ma(this, e, r, !1), r + 2;
};
function ya(t, e, r, i) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var n = 0, u = Math.min(t.length - r, 4); n < u; ++n)
    t[r + n] = e >>> (i ? n : 3 - n) * 8 & 255;
}
X.prototype.writeUInt32LE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 4, 4294967295, 0), X.TYPED_ARRAY_SUPPORT ? (this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255) : ya(this, e, r, !0), r + 4;
};
X.prototype.writeUInt32BE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 4, 4294967295, 0), X.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255) : ya(this, e, r, !1), r + 4;
};
X.prototype.writeIntLE = function(e, r, i, n) {
  if (e = +e, r = r | 0, !n) {
    var u = Math.pow(2, 8 * i - 1);
    pt(this, e, r, i, u - 1, -u);
  }
  var l = 0, h = 1, c = 0;
  for (this[r] = e & 255; ++l < i && (h *= 256); )
    e < 0 && c === 0 && this[r + l - 1] !== 0 && (c = 1), this[r + l] = (e / h >> 0) - c & 255;
  return r + i;
};
X.prototype.writeIntBE = function(e, r, i, n) {
  if (e = +e, r = r | 0, !n) {
    var u = Math.pow(2, 8 * i - 1);
    pt(this, e, r, i, u - 1, -u);
  }
  var l = i - 1, h = 1, c = 0;
  for (this[r + l] = e & 255; --l >= 0 && (h *= 256); )
    e < 0 && c === 0 && this[r + l + 1] !== 0 && (c = 1), this[r + l] = (e / h >> 0) - c & 255;
  return r + i;
};
X.prototype.writeInt8 = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 1, 127, -128), X.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
};
X.prototype.writeInt16LE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 2, 32767, -32768), X.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8) : ma(this, e, r, !0), r + 2;
};
X.prototype.writeInt16BE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 2, 32767, -32768), X.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 8, this[r + 1] = e & 255) : ma(this, e, r, !1), r + 2;
};
X.prototype.writeInt32LE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 4, 2147483647, -2147483648), X.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24) : ya(this, e, r, !0), r + 4;
};
X.prototype.writeInt32BE = function(e, r, i) {
  return e = +e, r = r | 0, i || pt(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), X.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255) : ya(this, e, r, !1), r + 4;
};
function um(t, e, r, i, n, u) {
  if (r + i > t.length) throw new RangeError("Index out of range");
  if (r < 0) throw new RangeError("Index out of range");
}
function lm(t, e, r, i, n) {
  return n || um(t, e, r, 4), em(t, e, r, i, 23, 4), r + 4;
}
X.prototype.writeFloatLE = function(e, r, i) {
  return lm(this, e, r, !0, i);
};
X.prototype.writeFloatBE = function(e, r, i) {
  return lm(this, e, r, !1, i);
};
function cm(t, e, r, i, n) {
  return n || um(t, e, r, 8), em(t, e, r, i, 52, 8), r + 8;
}
X.prototype.writeDoubleLE = function(e, r, i) {
  return cm(this, e, r, !0, i);
};
X.prototype.writeDoubleBE = function(e, r, i) {
  return cm(this, e, r, !1, i);
};
X.prototype.copy = function(e, r, i, n) {
  if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= e.length && (r = e.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || e.length === 0 || this.length === 0) return 0;
  if (r < 0)
    throw new RangeError("targetStart out of bounds");
  if (i < 0 || i >= this.length) throw new RangeError("sourceStart out of bounds");
  if (n < 0) throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length), e.length - r < n - i && (n = e.length - r + i);
  var u = n - i, l;
  if (this === e && i < r && r < n)
    for (l = u - 1; l >= 0; --l)
      e[l + r] = this[l + i];
  else if (u < 1e3 || !X.TYPED_ARRAY_SUPPORT)
    for (l = 0; l < u; ++l)
      e[l + r] = this[l + i];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(i, i + u),
      r
    );
  return u;
};
X.prototype.fill = function(e, r, i, n) {
  if (typeof e == "string") {
    if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), e.length === 1) {
      var u = e.charCodeAt(0);
      u < 256 && (e = u);
    }
    if (n !== void 0 && typeof n != "string")
      throw new TypeError("encoding must be a string");
    if (typeof n == "string" && !X.isEncoding(n))
      throw new TypeError("Unknown encoding: " + n);
  } else typeof e == "number" && (e = e & 255);
  if (r < 0 || this.length < r || this.length < i)
    throw new RangeError("Out of range index");
  if (i <= r)
    return this;
  r = r >>> 0, i = i === void 0 ? this.length : i >>> 0, e || (e = 0);
  var l;
  if (typeof e == "number")
    for (l = r; l < i; ++l)
      this[l] = e;
  else {
    var h = qt(e) ? e : Pn(new X(e, n).toString()), c = h.length;
    for (l = 0; l < i - r; ++l)
      this[l + r] = h[l % c];
  }
  return this;
};
var Iv = /[^+\/0-9A-Za-z-_]/g;
function Nv(t) {
  if (t = Ov(t).replace(Iv, ""), t.length < 2) return "";
  for (; t.length % 4 !== 0; )
    t = t + "=";
  return t;
}
function Ov(t) {
  return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
}
function kv(t) {
  return t < 16 ? "0" + t.toString(16) : t.toString(16);
}
function Pn(t, e) {
  e = e || 1 / 0;
  for (var r, i = t.length, n = null, u = [], l = 0; l < i; ++l) {
    if (r = t.charCodeAt(l), r > 55295 && r < 57344) {
      if (!n) {
        if (r > 56319) {
          (e -= 3) > -1 && u.push(239, 191, 189);
          continue;
        } else if (l + 1 === i) {
          (e -= 3) > -1 && u.push(239, 191, 189);
          continue;
        }
        n = r;
        continue;
      }
      if (r < 56320) {
        (e -= 3) > -1 && u.push(239, 191, 189), n = r;
        continue;
      }
      r = (n - 55296 << 10 | r - 56320) + 65536;
    } else n && (e -= 3) > -1 && u.push(239, 191, 189);
    if (n = null, r < 128) {
      if ((e -= 1) < 0) break;
      u.push(r);
    } else if (r < 2048) {
      if ((e -= 2) < 0) break;
      u.push(
        r >> 6 | 192,
        r & 63 | 128
      );
    } else if (r < 65536) {
      if ((e -= 3) < 0) break;
      u.push(
        r >> 12 | 224,
        r >> 6 & 63 | 128,
        r & 63 | 128
      );
    } else if (r < 1114112) {
      if ((e -= 4) < 0) break;
      u.push(
        r >> 18 | 240,
        r >> 12 & 63 | 128,
        r >> 6 & 63 | 128,
        r & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return u;
}
function Lv(t) {
  for (var e = [], r = 0; r < t.length; ++r)
    e.push(t.charCodeAt(r) & 255);
  return e;
}
function Rv(t, e) {
  for (var r, i, n, u = [], l = 0; l < t.length && !((e -= 2) < 0); ++l)
    r = t.charCodeAt(l), i = r >> 8, n = r % 256, u.push(n), u.push(i);
  return u;
}
function hm(t) {
  return uv(Nv(t));
}
function ga(t, e, r, i) {
  for (var n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n)
    e[n + r] = t[n];
  return n;
}
function Dv(t) {
  return t !== t;
}
function Mv(t) {
  return t != null && (!!t._isBuffer || fm(t) || Fv(t));
}
function fm(t) {
  return !!t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
}
function Fv(t) {
  return typeof t.readFloatLE == "function" && typeof t.slice == "function" && fm(t.slice(0, 0));
}
var _n;
typeof Object.create == "function" ? _n = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : _n = function(e, r) {
  e.super_ = r;
  var i = function() {
  };
  i.prototype = r.prototype, e.prototype = new i(), e.prototype.constructor = e;
};
var pm = Object.getOwnPropertyDescriptors || function(e) {
  for (var r = Object.keys(e), i = {}, n = 0; n < r.length; n++)
    i[r[n]] = Object.getOwnPropertyDescriptor(e, r[n]);
  return i;
}, Bv = /%[sdj%]/g;
function ba(t) {
  if (!dr(t)) {
    for (var e = [], r = 0; r < arguments.length; r++)
      e.push($t(arguments[r]));
    return e.join(" ");
  }
  for (var r = 1, i = arguments, n = i.length, u = String(t).replace(Bv, function(h) {
    if (h === "%%") return "%";
    if (r >= n) return h;
    switch (h) {
      case "%s":
        return String(i[r++]);
      case "%d":
        return Number(i[r++]);
      case "%j":
        try {
          return JSON.stringify(i[r++]);
        } catch {
          return "[Circular]";
        }
      default:
        return h;
    }
  }), l = i[r]; r < n; l = i[++r])
    Ht(l) || !Qt(l) ? u += " " + l : u += " " + $t(l);
  return u;
}
function Ll(t, e) {
  if (Ft(hr.process))
    return function() {
      return Ll(t, e).apply(this, arguments);
    };
  if (ft.noDeprecation === !0)
    return t;
  var r = !1;
  function i() {
    if (!r) {
      if (ft.throwDeprecation)
        throw new Error(e);
      ft.traceDeprecation ? console.trace(e) : console.error(e), r = !0;
    }
    return t.apply(this, arguments);
  }
  return i;
}
var _i = {}, ro;
function dm(t) {
  if (Ft(ro) && (ro = ft.env.NODE_DEBUG || ""), t = t.toUpperCase(), !_i[t])
    if (new RegExp("\\b" + t + "\\b", "i").test(ro)) {
      var e = 0;
      _i[t] = function() {
        var r = ba.apply(null, arguments);
        console.error("%s %d: %s", t, e, r);
      };
    } else
      _i[t] = function() {
      };
  return _i[t];
}
function $t(t, e) {
  var r = {
    seen: [],
    stylize: Uv
  };
  return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), Sa(e) ? r.showHidden = e : e && Bl(r, e), Ft(r.showHidden) && (r.showHidden = !1), Ft(r.depth) && (r.depth = 2), Ft(r.colors) && (r.colors = !1), Ft(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = $v), An(r, t, r.depth);
}
$t.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
$t.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function $v(t, e) {
  var r = $t.styles[e];
  return r ? "\x1B[" + $t.colors[r][0] + "m" + t + "\x1B[" + $t.colors[r][1] + "m" : t;
}
function Uv(t, e) {
  return t;
}
function qv(t) {
  var e = {};
  return t.forEach(function(r, i) {
    e[r] = !0;
  }), e;
}
function An(t, e, r) {
  if (t.customInspect && e && $s(e.inspect) && // Filter out the util module, it's inspect function is special
  e.inspect !== $t && // Also filter out any prototype objects using the circular check.
  !(e.constructor && e.constructor.prototype === e)) {
    var i = e.inspect(r, t);
    return dr(i) || (i = An(t, i, r)), i;
  }
  var n = jv(t, e);
  if (n)
    return n;
  var u = Object.keys(e), l = qv(u);
  if (t.showHidden && (u = Object.getOwnPropertyNames(e)), Bs(e) && (u.indexOf("message") >= 0 || u.indexOf("description") >= 0))
    return so(e);
  if (u.length === 0) {
    if ($s(e)) {
      var h = e.name ? ": " + e.name : "";
      return t.stylize("[Function" + h + "]", "special");
    }
    if (Fs(e))
      return t.stylize(RegExp.prototype.toString.call(e), "regexp");
    if (Cn(e))
      return t.stylize(Date.prototype.toString.call(e), "date");
    if (Bs(e))
      return so(e);
  }
  var c = "", p = !1, d = ["{", "}"];
  if (Rl(e) && (p = !0, d = ["[", "]"]), $s(e)) {
    var m = e.name ? ": " + e.name : "";
    c = " [Function" + m + "]";
  }
  if (Fs(e) && (c = " " + RegExp.prototype.toString.call(e)), Cn(e) && (c = " " + Date.prototype.toUTCString.call(e)), Bs(e) && (c = " " + so(e)), u.length === 0 && (!p || e.length == 0))
    return d[0] + c + d[1];
  if (r < 0)
    return Fs(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
  t.seen.push(e);
  var y;
  return p ? y = Vv(t, e, r, l, u) : y = u.map(function(g) {
    return yu(t, e, r, l, g, p);
  }), t.seen.pop(), zv(y, c, d);
}
function jv(t, e) {
  if (Ft(e))
    return t.stylize("undefined", "undefined");
  if (dr(e)) {
    var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return t.stylize(r, "string");
  }
  if (Ml(e))
    return t.stylize("" + e, "number");
  if (Sa(e))
    return t.stylize("" + e, "boolean");
  if (Ht(e))
    return t.stylize("null", "null");
}
function so(t) {
  return "[" + Error.prototype.toString.call(t) + "]";
}
function Vv(t, e, r, i, n) {
  for (var u = [], l = 0, h = e.length; l < h; ++l)
    Sm(e, String(l)) ? u.push(yu(
      t,
      e,
      r,
      i,
      String(l),
      !0
    )) : u.push("");
  return n.forEach(function(c) {
    c.match(/^\d+$/) || u.push(yu(
      t,
      e,
      r,
      i,
      c,
      !0
    ));
  }), u;
}
function yu(t, e, r, i, n, u) {
  var l, h, c;
  if (c = Object.getOwnPropertyDescriptor(e, n) || { value: e[n] }, c.get ? c.set ? h = t.stylize("[Getter/Setter]", "special") : h = t.stylize("[Getter]", "special") : c.set && (h = t.stylize("[Setter]", "special")), Sm(i, n) || (l = "[" + n + "]"), h || (t.seen.indexOf(c.value) < 0 ? (Ht(r) ? h = An(t, c.value, null) : h = An(t, c.value, r - 1), h.indexOf(`
`) > -1 && (u ? h = h.split(`
`).map(function(p) {
    return "  " + p;
  }).join(`
`).substr(2) : h = `
` + h.split(`
`).map(function(p) {
    return "   " + p;
  }).join(`
`))) : h = t.stylize("[Circular]", "special")), Ft(l)) {
    if (u && n.match(/^\d+$/))
      return h;
    l = JSON.stringify("" + n), l.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (l = l.substr(1, l.length - 2), l = t.stylize(l, "name")) : (l = l.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), l = t.stylize(l, "string"));
  }
  return l + ": " + h;
}
function zv(t, e, r) {
  var i = t.reduce(function(n, u) {
    return u.indexOf(`
`) >= 0, n + u.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return i > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1];
}
function Rl(t) {
  return Array.isArray(t);
}
function Sa(t) {
  return typeof t == "boolean";
}
function Ht(t) {
  return t === null;
}
function Dl(t) {
  return t == null;
}
function Ml(t) {
  return typeof t == "number";
}
function dr(t) {
  return typeof t == "string";
}
function mm(t) {
  return typeof t == "symbol";
}
function Ft(t) {
  return t === void 0;
}
function Fs(t) {
  return Qt(t) && Fl(t) === "[object RegExp]";
}
function Qt(t) {
  return typeof t == "object" && t !== null;
}
function Cn(t) {
  return Qt(t) && Fl(t) === "[object Date]";
}
function Bs(t) {
  return Qt(t) && (Fl(t) === "[object Error]" || t instanceof Error);
}
function $s(t) {
  return typeof t == "function";
}
function ym(t) {
  return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || // ES6 symbol
  typeof t > "u";
}
function gm(t) {
  return X.isBuffer(t);
}
function Fl(t) {
  return Object.prototype.toString.call(t);
}
function io(t) {
  return t < 10 ? "0" + t.toString(10) : t.toString(10);
}
var Wv = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function Hv() {
  var t = /* @__PURE__ */ new Date(), e = [
    io(t.getHours()),
    io(t.getMinutes()),
    io(t.getSeconds())
  ].join(":");
  return [t.getDate(), Wv[t.getMonth()], e].join(" ");
}
function bm() {
  console.log("%s - %s", Hv(), ba.apply(null, arguments));
}
function Bl(t, e) {
  if (!e || !Qt(e)) return t;
  for (var r = Object.keys(e), i = r.length; i--; )
    t[r[i]] = e[r[i]];
  return t;
}
function Sm(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
var xr = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function $l(t) {
  if (typeof t != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (xr && t[xr]) {
    var e = t[xr];
    if (typeof e != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(e, xr, {
      value: e,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), e;
  }
  function e() {
    for (var r, i, n = new Promise(function(h, c) {
      r = h, i = c;
    }), u = [], l = 0; l < arguments.length; l++)
      u.push(arguments[l]);
    u.push(function(h, c) {
      h ? i(h) : r(c);
    });
    try {
      t.apply(this, u);
    } catch (h) {
      i(h);
    }
    return n;
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), xr && Object.defineProperty(e, xr, {
    value: e,
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), Object.defineProperties(
    e,
    pm(t)
  );
}
$l.custom = xr;
function Gv(t, e) {
  if (!t) {
    var r = new Error("Promise was rejected with a falsy value");
    r.reason = t, t = r;
  }
  return e(t);
}
function vm(t) {
  if (typeof t != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function e() {
    for (var r = [], i = 0; i < arguments.length; i++)
      r.push(arguments[i]);
    var n = r.pop();
    if (typeof n != "function")
      throw new TypeError("The last argument must be of type Function");
    var u = this, l = function() {
      return n.apply(u, arguments);
    };
    t.apply(this, r).then(
      function(h) {
        ft.nextTick(l.bind(null, null, h));
      },
      function(h) {
        ft.nextTick(Gv.bind(null, h, l));
      }
    );
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, pm(t)), e;
}
var Xv = {
  inherits: _n,
  _extend: Bl,
  log: bm,
  isBuffer: gm,
  isPrimitive: ym,
  isFunction: $s,
  isError: Bs,
  isDate: Cn,
  isObject: Qt,
  isRegExp: Fs,
  isUndefined: Ft,
  isSymbol: mm,
  isString: dr,
  isNumber: Ml,
  isNullOrUndefined: Dl,
  isNull: Ht,
  isBoolean: Sa,
  isArray: Rl,
  inspect: $t,
  deprecate: Ll,
  format: ba,
  debuglog: dm,
  promisify: $l,
  callbackify: vm
}, Jv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: Bl,
  callbackify: vm,
  debuglog: dm,
  default: Xv,
  deprecate: Ll,
  format: ba,
  inherits: _n,
  inspect: $t,
  isArray: Rl,
  isBoolean: Sa,
  isBuffer: gm,
  isDate: Cn,
  isError: Bs,
  isFunction: $s,
  isNull: Ht,
  isNullOrUndefined: Dl,
  isNumber: Ml,
  isObject: Qt,
  isPrimitive: ym,
  isRegExp: Fs,
  isString: dr,
  isSymbol: mm,
  isUndefined: Ft,
  log: bm,
  promisify: $l
});
function Kv(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
var xm = Array.isArray || function(t) {
  return Object.prototype.toString.call(t) === "[object Array]";
};
function no(t) {
  switch (typeof t) {
    case "string":
      return t;
    case "boolean":
      return t ? "true" : "false";
    case "number":
      return isFinite(t) ? t : "";
    default:
      return "";
  }
}
function Yv(t, e, r, i) {
  return e = e || "&", r = r || "=", t === null && (t = void 0), typeof t == "object" ? uf(Qv(t), function(n) {
    var u = encodeURIComponent(no(n)) + r;
    return xm(t[n]) ? uf(t[n], function(l) {
      return u + encodeURIComponent(no(l));
    }).join(e) : u + encodeURIComponent(no(t[n]));
  }).join(e) : "";
}
function uf(t, e) {
  if (t.map) return t.map(e);
  for (var r = [], i = 0; i < t.length; i++)
    r.push(e(t[i], i));
  return r;
}
var Qv = Object.keys || function(t) {
  var e = [];
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.push(r);
  return e;
};
function lf(t, e, r, i) {
  e = e || "&", r = r || "=";
  var n = {};
  if (typeof t != "string" || t.length === 0)
    return n;
  var u = /\+/g;
  t = t.split(e);
  var l = 1e3, h = t.length;
  h > l && (h = l);
  for (var c = 0; c < h; ++c) {
    var p = t[c].replace(u, "%20"), d = p.indexOf(r), m, y, g, E;
    d >= 0 ? (m = p.substr(0, d), y = p.substr(d + 1)) : (m = p, y = ""), g = decodeURIComponent(m), E = decodeURIComponent(y), Kv(n, g) ? xm(n[g]) ? n[g].push(E) : n[g] = [n[g], E] : n[g] = E;
  }
  return n;
}
const Em = hr.URL, Tm = hr.URLSearchParams;
var Zv = {
  parse: gs,
  resolve: Am,
  resolveObject: Cm,
  fileURLToPath: Pm,
  format: _m,
  Url: bt,
  // WHATWG API
  URL: Em,
  URLSearchParams: Tm
};
function bt() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var ex = /^([a-z0-9.+-]+:)/i, tx = /:[0-9]*$/, rx = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, sx = ["<", ">", '"', "`", " ", "\r", `
`, "	"], ix = ["{", "}", "|", "\\", "^", "`"].concat(sx), gu = ["'"].concat(ix), cf = ["%", "/", "?", ";", "#"].concat(gu), hf = ["/", "?", "#"], nx = 255, ff = /^[+a-z0-9A-Z_-]{0,63}$/, ax = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, ox = {
  javascript: !0,
  "javascript:": !0
}, bu = {
  javascript: !0,
  "javascript:": !0
}, es = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function gs(t, e, r) {
  if (t && Qt(t) && t instanceof bt) return t;
  var i = new bt();
  return i.parse(t, e, r), i;
}
bt.prototype.parse = function(t, e, r) {
  return wm(this, t, e, r);
};
function wm(t, e, r, i) {
  if (!dr(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var n = e.indexOf("?"), u = n !== -1 && n < e.indexOf("#") ? "?" : "#", l = e.split(u), h = /\\/g;
  l[0] = l[0].replace(h, "/"), e = l.join(u);
  var c = e;
  if (c = c.trim(), !i && e.split("#").length === 1) {
    var p = rx.exec(c);
    if (p)
      return t.path = c, t.href = c, t.pathname = p[1], p[2] ? (t.search = p[2], r ? t.query = lf(t.search.substr(1)) : t.query = t.search.substr(1)) : r && (t.search = "", t.query = {}), t;
  }
  var d = ex.exec(c);
  if (d) {
    d = d[0];
    var m = d.toLowerCase();
    t.protocol = m, c = c.substr(d.length);
  }
  if (i || d || c.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var y = c.substr(0, 2) === "//";
    y && !(d && bu[d]) && (c = c.substr(2), t.slashes = !0);
  }
  var g, E, S, x;
  if (!bu[d] && (y || d && !es[d])) {
    var v = -1;
    for (g = 0; g < hf.length; g++)
      E = c.indexOf(hf[g]), E !== -1 && (v === -1 || E < v) && (v = E);
    var P, A;
    for (v === -1 ? A = c.lastIndexOf("@") : A = c.lastIndexOf("@", v), A !== -1 && (P = c.slice(0, A), c = c.slice(A + 1), t.auth = decodeURIComponent(P)), v = -1, g = 0; g < cf.length; g++)
      E = c.indexOf(cf[g]), E !== -1 && (v === -1 || E < v) && (v = E);
    v === -1 && (v = c.length), t.host = c.slice(0, v), c = c.slice(v), Im(t), t.hostname = t.hostname || "";
    var N = t.hostname[0] === "[" && t.hostname[t.hostname.length - 1] === "]";
    if (!N) {
      var _ = t.hostname.split(/\./);
      for (g = 0, S = _.length; g < S; g++) {
        var R = _[g];
        if (R && !R.match(ff)) {
          for (var M = "", O = 0, I = R.length; O < I; O++)
            R.charCodeAt(O) > 127 ? M += "x" : M += R[O];
          if (!M.match(ff)) {
            var k = _.slice(0, g), L = _.slice(g + 1), V = R.match(ax);
            V && (k.push(V[1]), L.unshift(V[2])), L.length && (c = "/" + L.join(".") + c), t.hostname = k.join(".");
            break;
          }
        }
      }
    }
    t.hostname.length > nx ? t.hostname = "" : t.hostname = t.hostname.toLowerCase(), N || (t.hostname = av(t.hostname)), x = t.port ? ":" + t.port : "";
    var K = t.hostname || "";
    t.host = K + x, t.href += t.host, N && (t.hostname = t.hostname.substr(1, t.hostname.length - 2), c[0] !== "/" && (c = "/" + c));
  }
  if (!ox[m])
    for (g = 0, S = gu.length; g < S; g++) {
      var re = gu[g];
      if (c.indexOf(re) !== -1) {
        var z = encodeURIComponent(re);
        z === re && (z = escape(re)), c = c.split(re).join(z);
      }
    }
  var se = c.indexOf("#");
  se !== -1 && (t.hash = c.substr(se), c = c.slice(0, se));
  var he = c.indexOf("?");
  if (he !== -1 ? (t.search = c.substr(he), t.query = c.substr(he + 1), r && (t.query = lf(t.query)), c = c.slice(0, he)) : r && (t.search = "", t.query = {}), c && (t.pathname = c), es[m] && t.hostname && !t.pathname && (t.pathname = "/"), t.pathname || t.search) {
    x = t.pathname || "";
    var ne = t.search || "";
    t.path = x + ne;
  }
  return t.href = Ul(t), t;
}
function Pm(t) {
  if (typeof t == "string")
    t = new bt().parse(t);
  else if (!(t instanceof bt))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof t + String(t));
  if (t.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return ux(t);
}
function ux(t) {
  const e = t.pathname;
  for (let r = 0; r < e.length; r++)
    if (e[r] === "%") {
      const i = e.codePointAt(r + 2) | 32;
      if (e[r + 1] === "2" && i === 102)
        throw new TypeError(
          "must not include encoded / characters"
        );
    }
  return decodeURIComponent(e);
}
function _m(t) {
  return dr(t) && (t = wm({}, t)), Ul(t);
}
function Ul(t) {
  var e = t.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var r = t.protocol || "", i = t.pathname || "", n = t.hash || "", u = !1, l = "";
  t.host ? u = e + t.host : t.hostname && (u = e + (t.hostname.indexOf(":") === -1 ? t.hostname : "[" + this.hostname + "]"), t.port && (u += ":" + t.port)), t.query && Qt(t.query) && Object.keys(t.query).length && (l = Yv(t.query));
  var h = t.search || l && "?" + l || "";
  return r && r.substr(-1) !== ":" && (r += ":"), t.slashes || (!r || es[r]) && u !== !1 ? (u = "//" + (u || ""), i && i.charAt(0) !== "/" && (i = "/" + i)) : u || (u = ""), n && n.charAt(0) !== "#" && (n = "#" + n), h && h.charAt(0) !== "?" && (h = "?" + h), i = i.replace(/[?#]/g, function(c) {
    return encodeURIComponent(c);
  }), h = h.replace("#", "%23"), r + u + i + h + n;
}
bt.prototype.format = function() {
  return Ul(this);
};
function Am(t, e) {
  return gs(t, !1, !0).resolve(e);
}
bt.prototype.resolve = function(t) {
  return this.resolveObject(gs(t, !1, !0)).format();
};
function Cm(t, e) {
  return t ? gs(t, !1, !0).resolveObject(e) : e;
}
bt.prototype.resolveObject = function(t) {
  if (dr(t)) {
    var e = new bt();
    e.parse(t, !1, !0), t = e;
  }
  for (var r = new bt(), i = Object.keys(this), n = 0; n < i.length; n++) {
    var u = i[n];
    r[u] = this[u];
  }
  if (r.hash = t.hash, t.href === "")
    return r.href = r.format(), r;
  if (t.slashes && !t.protocol) {
    for (var l = Object.keys(t), h = 0; h < l.length; h++) {
      var c = l[h];
      c !== "protocol" && (r[c] = t[c]);
    }
    return es[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
  }
  var p;
  if (t.protocol && t.protocol !== r.protocol) {
    if (!es[t.protocol]) {
      for (var d = Object.keys(t), m = 0; m < d.length; m++) {
        var y = d[m];
        r[y] = t[y];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = t.protocol, !t.host && !bu[t.protocol]) {
      for (p = (t.pathname || "").split("/"); p.length && !(t.host = p.shift()); ) ;
      t.host || (t.host = ""), t.hostname || (t.hostname = ""), p[0] !== "" && p.unshift(""), p.length < 2 && p.unshift(""), r.pathname = p.join("/");
    } else
      r.pathname = t.pathname;
    if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
      var g = r.pathname || "", E = r.search || "";
      r.path = g + E;
    }
    return r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
  }
  var S = r.pathname && r.pathname.charAt(0) === "/", x = t.host || t.pathname && t.pathname.charAt(0) === "/", v = x || S || r.host && t.pathname, P = v, A = r.pathname && r.pathname.split("/") || [], N = r.protocol && !es[r.protocol];
  p = t.pathname && t.pathname.split("/") || [], N && (r.hostname = "", r.port = null, r.host && (A[0] === "" ? A[0] = r.host : A.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (p[0] === "" ? p[0] = t.host : p.unshift(t.host)), t.host = null), v = v && (p[0] === "" || A[0] === ""));
  var _;
  if (x)
    r.host = t.host || t.host === "" ? t.host : r.host, r.hostname = t.hostname || t.hostname === "" ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, A = p;
  else if (p.length)
    A || (A = []), A.pop(), A = A.concat(p), r.search = t.search, r.query = t.query;
  else if (!Dl(t.search))
    return N && (r.hostname = r.host = A.shift(), _ = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1, _ && (r.auth = _.shift(), r.host = r.hostname = _.shift())), r.search = t.search, r.query = t.query, (!Ht(r.pathname) || !Ht(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  if (!A.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var R = A.slice(-1)[0], M = (r.host || t.host || A.length > 1) && (R === "." || R === "..") || R === "", O = 0, I = A.length; I >= 0; I--)
    R = A[I], R === "." ? A.splice(I, 1) : R === ".." ? (A.splice(I, 1), O++) : O && (A.splice(I, 1), O--);
  if (!v && !P)
    for (; O--; O)
      A.unshift("..");
  v && A[0] !== "" && (!A[0] || A[0].charAt(0) !== "/") && A.unshift(""), M && A.join("/").substr(-1) !== "/" && A.push("");
  var k = A[0] === "" || A[0] && A[0].charAt(0) === "/";
  return N && (r.hostname = r.host = k ? "" : A.length ? A.shift() : "", _ = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1, _ && (r.auth = _.shift(), r.host = r.hostname = _.shift())), v = v || r.host && A.length, v && !k && A.unshift(""), A.length ? r.pathname = A.join("/") : (r.pathname = null, r.path = null), (!Ht(r.pathname) || !Ht(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
};
bt.prototype.parseHost = function() {
  return Im(this);
};
function Im(t) {
  var e = t.host, r = tx.exec(e);
  r && (r = r[0], r !== ":" && (t.port = r.substr(1)), e = e.substr(0, e.length - r.length)), e && (t.hostname = e);
}
var lx = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  URL: Em,
  URLSearchParams: Tm,
  Url: bt,
  default: Zv,
  fileURLToPath: Pm,
  format: _m,
  parse: gs,
  resolve: Am,
  resolveObject: Cm
});
function Nm(t) {
  const e = t.charAt(0);
  return e === "." || e === "~" || e === "@";
}
const cx = /^(https?:)?\/\//;
function Om(t) {
  return cx.test(t);
}
const hx = /^\s*data:/i;
function Su(t) {
  return hx.test(t);
}
function vu(t) {
  if (t.charAt(0) === "~") {
    const r = t.charAt(1);
    t = t.slice(r === "/" ? 2 : 1);
  }
  return fx(t);
}
function fx(t) {
  return gs(Se(t) ? t : "", !1, !0);
}
var px = Object.defineProperty, dx = Object.defineProperties, mx = Object.getOwnPropertyDescriptors, pf = Object.getOwnPropertySymbols, yx = Object.prototype.hasOwnProperty, gx = Object.prototype.propertyIsEnumerable, df = (t, e, r) => e in t ? px(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ao = (t, e) => {
  for (var r in e || (e = {}))
    yx.call(e, r) && df(t, r, e[r]);
  if (pf)
    for (var r of pf(e))
      gx.call(e, r) && df(t, r, e[r]);
  return t;
}, bx = (t, e) => dx(t, mx(e));
const Qs = {
  base: null,
  includeAbsolute: !1,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
}, Sx = (t) => Object.keys(t).some((e) => $e(t[e])) ? bx(ao({}, Qs), {
  tags: t
}) : ao(ao({}, Qs), t), vx = (t) => (e, r) => km(e, r, t), km = (t, e, r = Qs) => {
  if (t.type === 1) {
    if (!t.props.length)
      return;
    const i = r.tags || Qs.tags, n = i[t.tag], u = i["*"];
    if (!n && !u)
      return;
    const l = (n || []).concat(u || []);
    t.props.forEach((h, c) => {
      if (h.type !== 6 || !l.includes(h.name) || !h.value || Om(h.value.content) || Su(h.value.content) || h.value.content[0] === "#" || !r.includeAbsolute && !Nm(h.value.content))
        return;
      const p = vu(h.value.content);
      if (r.base && h.value.content[0] === ".") {
        const m = vu(r.base), y = m.protocol || "", g = m.host ? y + "//" + m.host : "", E = m.path || "/";
        h.value.content = g + (Yt.posix || Yt).join(E, p.path + (p.hash || ""));
        return;
      }
      const d = xx(p.path, p.hash, h.loc, e);
      t.props[c] = {
        type: 7,
        name: "bind",
        arg: te(h.name, !0, h.loc),
        exp: d,
        modifiers: [],
        loc: h.loc
      };
    });
  }
};
function xx(t, e, r, i) {
  if (t) {
    let n, u;
    const l = i.imports.findIndex((d) => d.path === t);
    if (l > -1 ? (n = `_imports_${l}`, u = i.imports[l].exp) : (n = `_imports_${i.imports.length}`, u = te(
      n,
      !1,
      r,
      3
    ), i.imports.push({
      exp: u,
      path: decodeURIComponent(t)
    })), !e)
      return u;
    const h = `${n} + '${e}'`, c = te(
      h,
      !1,
      r,
      3
    );
    if (!i.hoistStatic)
      return c;
    const p = i.hoists.findIndex((d) => d && d.type === 4 && !d.isStatic && d.content === h);
    return p > -1 ? te(
      `_hoisted_${p + 1}`,
      !1,
      r,
      3
    ) : i.hoist(c);
  } else
    return te("''", !1, r, 3);
}
const Ex = ["img", "source"], Tx = /( |\\t|\\n|\\f|\\r)+/g, wx = (t) => (e, r) => Lm(e, r, t), Lm = (t, e, r = Qs) => {
  t.type === 1 && Ex.includes(t.tag) && t.props.length && t.props.forEach((i, n) => {
    if (i.name === "srcset" && i.type === 6) {
      if (!i.value) return;
      const u = i.value.content;
      if (!u) return;
      const l = u.split(",").map((d) => {
        const [m, y] = d.replace(Tx, " ").trim().split(" ", 2);
        return { url: m, descriptor: y };
      });
      for (let d = 0; d < l.length; d++) {
        const { url: m } = l[d];
        Su(m) && (l[d + 1].url = m + "," + l[d + 1].url, l.splice(d, 1));
      }
      const h = (d) => d && !Om(d) && !Su(d) && (r.includeAbsolute || Nm(d));
      if (!l.some(({ url: d }) => h(d)))
        return;
      if (r.base) {
        const d = r.base, m = [];
        let y = !1;
        if (l.forEach((g) => {
          let { url: E, descriptor: S } = g;
          S = S ? ` ${S}` : "", E[0] === "." ? (g.url = (Yt.posix || Yt).join(d, E), m.push(g.url + S)) : h(E) ? y = !0 : m.push(E + S);
        }), !y) {
          i.value.content = m.join(", ");
          return;
        }
      }
      const c = je([], i.loc);
      l.forEach(({ url: d, descriptor: m }, y) => {
        if (h(d)) {
          const { path: E } = vu(d);
          let S;
          if (E) {
            const x = e.imports.findIndex(
              (v) => v.path === E
            );
            x > -1 ? S = te(
              `_imports_${x}`,
              !1,
              i.loc,
              3
            ) : (S = te(
              `_imports_${e.imports.length}`,
              !1,
              i.loc,
              3
            ), e.imports.push({ exp: S, path: E })), c.children.push(S);
          }
        } else {
          const E = te(
            `"${d}"`,
            !1,
            i.loc,
            3
          );
          c.children.push(E);
        }
        const g = l.length - 1 > y;
        m && g ? c.children.push(` + ' ${m}, ' + `) : m ? c.children.push(` + ' ${m}'`) : g && c.children.push(" + ', ' + ");
      });
      let p = c;
      e.hoistStatic && (p = e.hoist(c), p.constType = 3), t.props[n] = {
        type: 7,
        name: "bind",
        arg: te("srcset", !0, i.loc),
        exp: p,
        modifiers: [],
        loc: i.loc
      };
    }
  });
}, In = Symbol("ssrInterpolate"), Rm = Symbol("ssrRenderVNode"), Dm = Symbol("ssrRenderComponent"), Mm = Symbol("ssrRenderSlot"), Fm = Symbol("ssrRenderSlotInner"), Bm = Symbol("ssrRenderClass"), $m = Symbol("ssrRenderStyle"), ql = Symbol("ssrRenderAttrs"), Um = Symbol("ssrRenderAttr"), qm = Symbol("ssrRenderDynamicAttr"), jm = Symbol("ssrRenderList"), jl = Symbol(
  "ssrIncludeBooleanAttr"
), ln = Symbol("ssrLooseEqual"), xu = Symbol("ssrLooseContain"), Vm = Symbol(
  "ssrRenderDynamicModel"
), zm = Symbol(
  "ssrGetDynamicModelProps"
), Wm = Symbol("ssrRenderTeleport"), Hm = Symbol("ssrRenderSuspense"), Gm = Symbol("ssrGetDirectiveProps"), Eu = {
  [In]: "ssrInterpolate",
  [Rm]: "ssrRenderVNode",
  [Dm]: "ssrRenderComponent",
  [Mm]: "ssrRenderSlot",
  [Fm]: "ssrRenderSlotInner",
  [Bm]: "ssrRenderClass",
  [$m]: "ssrRenderStyle",
  [ql]: "ssrRenderAttrs",
  [Um]: "ssrRenderAttr",
  [qm]: "ssrRenderDynamicAttr",
  [jm]: "ssrRenderList",
  [jl]: "ssrIncludeBooleanAttr",
  [ln]: "ssrLooseEqual",
  [xu]: "ssrLooseContain",
  [Vm]: "ssrRenderDynamicModel",
  [zm]: "ssrGetDynamicModelProps",
  [Wm]: "ssrRenderTeleport",
  [Hm]: "ssrRenderSuspense",
  [Gm]: "ssrGetDirectiveProps"
};
ju(Eu);
const Px = oi(
  /^(if|else|else-if)$/,
  sl
);
function _x(t, e, r = !1, i = !1) {
  const [n] = t.branches, u = gn(
    n.condition,
    mf(n, e, r)
  );
  e.pushStatement(u);
  let l = u;
  for (let h = 1; h < t.branches.length; h++) {
    const c = t.branches[h], p = mf(
      c,
      e,
      r
    );
    c.condition ? l = l.alternate = gn(
      c.condition,
      p
    ) : l.alternate = p;
  }
  !l.alternate && !i && (l.alternate = ni([
    pe("_push", ["`<!---->`"])
  ]));
}
function mf(t, e, r = !1) {
  const { children: i } = t, n = !r && (i.length !== 1 || i[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode
  !(i.length === 1 && i[0].type === 11);
  return bs(t, e, n);
}
const Ax = oi("for", nl);
function Cx(t, e, r = !1) {
  const i = !r && (t.children.length !== 1 || t.children[0].type !== 1), n = St(
    Ks(t.parseResult)
  );
  n.body = bs(
    t,
    e,
    i
  ), r || e.pushStringPart("<!--[-->"), e.pushStatement(
    pe(e.helper(jm), [
      t.source,
      n
    ])
  ), r || e.pushStringPart("<!--]-->");
}
const Ix = (t, e) => {
  if (us(t)) {
    const { slotName: r, slotProps: i } = cl(t, e), n = [
      "_ctx.$slots",
      r,
      i || "{}",
      // fallback content placeholder. will be replaced in the process phase
      "null",
      "_push",
      "_parent"
    ];
    e.scopeId && e.slotted !== !1 && n.push(`"${e.scopeId}-s"`);
    let u = Mm, l = e.parent;
    if (l) {
      const h = l.children;
      l.type === 10 && (l = e.grandParent);
      let c;
      l.type === 1 && l.tagType === 1 && ((c = ha(l, e, !0)) === Mr || c === ys) && h.filter((p) => p.type === 1).length === 1 && (u = Fm, e.scopeId && e.slotted !== !1 || n.push("null"), n.push("true"));
    }
    t.ssrCodegenNode = pe(e.helper(u), n);
  }
};
function Nx(t, e) {
  const r = t.ssrCodegenNode;
  if (t.children.length) {
    const i = St([]);
    i.body = bs(t, e), r.arguments[3] = i;
  }
  if (e.withSlotScopeId) {
    const i = r.arguments[6];
    r.arguments[6] = i ? `${i} + _scopeId` : "_scopeId";
  }
  e.pushStatement(t.ssrCodegenNode);
}
function Zs(t, e) {
  return Te(t, e, Ox);
}
const Ox = {
  65: "Unsafe attribute name for SSR.",
  66: "Missing the 'to' prop on teleport element.",
  67: "Invalid AST node during SSR transform."
};
function kx(t, e) {
  const r = ht(t, "to");
  if (!r) {
    e.onError(
      Zs(66, t.loc)
    );
    return;
  }
  let i;
  if (r.type === 6 ? i = r.value && te(r.value.content, !0) : i = r.exp, !i) {
    e.onError(
      Zs(
        66,
        r.loc
      )
    );
    return;
  }
  const n = ht(
    t,
    "disabled",
    !1,
    !0
    /* allow empty */
  ), u = n ? n.type === 6 ? "true" : n.exp || "false" : "false", l = St(
    ["_push"],
    void 0,
    // Body is added later
    !0,
    // newline
    !1,
    // isSlot
    t.loc
  );
  l.body = bs(t, e), e.pushStatement(
    pe(e.helper(Wm), [
      "_push",
      l,
      i,
      u,
      "_parent"
    ])
  );
}
const Xm = /* @__PURE__ */ new WeakMap();
function Lx(t, e) {
  return () => {
    if (t.children.length) {
      const r = {
        slotsExp: null,
        // to be immediately set
        wipSlots: []
      };
      Xm.set(t, r), r.slotsExp = Ys(
        t,
        e,
        (i, n, u, l) => {
          const h = St(
            [],
            void 0,
            // no return, assign body later
            !0,
            // newline
            !1,
            // suspense slots are not treated as normal slots
            l
          );
          return r.wipSlots.push({
            fn: h,
            children: u
          }), h;
        }
      ).slots;
    }
  };
}
function Rx(t, e) {
  const r = Xm.get(t);
  if (!r)
    return;
  const { slotsExp: i, wipSlots: n } = r;
  for (let u = 0; u < n.length; u++) {
    const l = n[u];
    l.fn.body = bs(l, e);
  }
  e.pushStatement(
    pe(e.helper(Hm), [
      "_push",
      i
    ])
  );
}
const ks = /* @__PURE__ */ new WeakMap(), Dx = (t, e) => {
  if (!(t.type !== 1 || t.tagType !== 0))
    return function() {
      const i = [`<${t.tag}`], n = t.tag === "textarea" || t.tag.indexOf("-") > 0, u = na(t), l = t.props.some(
        (m) => m.type === 7 && !Du(m.name)
      ), h = u || l;
      if (h) {
        const { props: m, directives: y } = ms(
          t,
          e,
          t.props,
          !1,
          !1,
          !0
        );
        if (m || y.length) {
          const g = Vl(m, y, e), E = pe(
            e.helper(ql),
            [g]
          );
          if (t.tag === "textarea") {
            const S = t.children[0];
            if (!S || S.type !== 5) {
              const x = `_temp${e.temps++}`;
              E.arguments = [
                en(
                  te(x, !1),
                  g
                )
              ], ks.set(
                t,
                pe(e.helper(In), [
                  Ct(
                    te(`"value" in ${x}`, !1),
                    te(`${x}.value`, !1),
                    te(
                      S ? S.content : "",
                      !0
                    ),
                    !1
                  )
                ])
              );
            }
          } else if (t.tag === "input") {
            const S = $x(t);
            if (S) {
              const x = `_temp${e.temps++}`, v = te(x, !1);
              E.arguments = [
                Hd([
                  en(v, g),
                  pe(e.helper(Or), [
                    v,
                    pe(
                      e.helper(zm),
                      [
                        v,
                        // existing props
                        S.exp
                        // model
                      ]
                    )
                  ])
                ])
              ];
            }
          } else if (y.length && !t.children.length && !Fe(t, "text")) {
            const x = `_temp${e.temps++}`;
            E.arguments = [
              en(
                te(x, !1),
                g
              )
            ], ks.set(
              t,
              Ct(
                te(`"textContent" in ${x}`, !1),
                pe(e.helper(In), [
                  te(`${x}.textContent`, !1)
                ]),
                te(`${x}.innerHTML ?? ''`, !1),
                !1
              )
            );
          }
          n && E.arguments.push(`"${t.tag}"`), i.push(E);
        }
      }
      let c, p, d;
      for (let m = 0; m < t.props.length; m++) {
        const y = t.props[m];
        if (!(t.tag === "input" && Mx(y)))
          if (y.type === 7) {
            if (y.name === "html" && y.exp)
              ks.set(
                t,
                je(["(", y.exp, ") ?? ''"])
              );
            else if (y.name === "text" && y.exp)
              t.children = [yn(y.exp, y.loc)];
            else if (y.name === "slot")
              e.onError(
                Te(40, y.loc)
              );
            else if (Fx(t, y) && y.exp)
              h || (t.children = [yn(y.exp, y.loc)]);
            else if (!h && y.name !== "on") {
              const g = e.directiveTransforms[y.name];
              if (g) {
                const { props: E, ssrTagParts: S } = g(
                  y,
                  t,
                  e
                );
                S && i.push(...S);
                for (let x = 0; x < E.length; x++) {
                  const { key: v, value: P } = E[x];
                  if (He(v)) {
                    let A = v.content;
                    if (A === "key" || A === "ref")
                      continue;
                    A === "class" ? i.push(
                      ' class="',
                      c = pe(
                        e.helper(Bm),
                        [P]
                      ),
                      '"'
                    ) : A === "style" ? d ? yf(d, P) : i.push(
                      ' style="',
                      d = pe(
                        e.helper($m),
                        [P]
                      ),
                      '"'
                    ) : (A = t.tag.indexOf("-") > 0 ? A : $g[A] || A.toLowerCase(), Bd(A) ? i.push(
                      Ct(
                        pe(
                          e.helper(jl),
                          [P]
                        ),
                        te(" " + A, !0),
                        te("", !0),
                        !1
                      )
                    ) : Bg(A) ? i.push(
                      pe(e.helper(Um), [
                        v,
                        P
                      ])
                    ) : e.onError(
                      Zs(
                        65,
                        v.loc
                      )
                    ));
                  } else {
                    const A = [v, P];
                    n && A.push(`"${t.tag}"`), i.push(
                      pe(
                        e.helper(qm),
                        A
                      )
                    );
                  }
                }
              }
            }
          } else {
            const g = y.name;
            if (t.tag === "textarea" && g === "value" && y.value)
              ks.set(t, Dt(y.value.content));
            else if (!h) {
              if (g === "key" || g === "ref")
                continue;
              g === "class" && y.value && (p = JSON.stringify(y.value.content)), i.push(
                ` ${y.name}` + (y.value ? `="${Dt(y.value.content)}"` : "")
              );
            }
          }
      }
      c && p && (yf(c, p), Bx(i, "class")), e.scopeId && i.push(` ${e.scopeId}`), t.ssrCodegenNode = Vu(i);
    };
};
function Vl(t, e, r) {
  let i = [];
  if (t && (t.type === 14 ? i = t.arguments : i.push(t)), e.length)
    for (const n of e)
      i.push(
        pe(r.helper(Gm), [
          "_ctx",
          ...ll(n, r).elements
        ])
      );
  return i.length > 1 ? pe(r.helper(Or), i) : i[0];
}
function Mx(t) {
  return t.type === 7 ? t.name === "bind" && t.arg && He(t.arg) && (t.arg.content === "true-value" || t.arg.content === "false-value") : t.name === "true-value" || t.name === "false-value";
}
function Fx(t, e) {
  return !!(t.tag === "textarea" && e.name === "bind" && Mt(e.arg, "value"));
}
function yf(t, e) {
  const r = t.arguments[0];
  r.type === 17 ? r.elements.push(e) : t.arguments[0] = Gt([r, e]);
}
function Bx(t, e) {
  const r = new RegExp(`^ ${e}=".+"$`), i = t.findIndex((n) => typeof n == "string" && r.test(n));
  i > -1 && t.splice(i, 1);
}
function $x(t) {
  return t.props.find(
    (e) => e.type === 7 && e.name === "model" && e.exp
  );
}
function Ux(t, e) {
  const r = e.options.isVoidTag || Os, i = t.ssrCodegenNode.elements;
  for (let u = 0; u < i.length; u++)
    e.pushStringPart(i[u]);
  e.withSlotScopeId && e.pushStringPart(te("_scopeId", !1)), e.pushStringPart(">");
  const n = ks.get(t);
  n ? e.pushStringPart(n) : t.children.length && Jt(t, e), r(t.tag) || e.pushStringPart(`</${t.tag}>`);
}
const Jm = /* @__PURE__ */ new WeakMap();
function qx(t, e) {
  return () => {
    const r = ht(t, "tag");
    if (r) {
      const i = t.props.filter((h) => h !== r), { props: n, directives: u } = ms(
        t,
        e,
        i,
        !0,
        !1,
        !0
      );
      let l = null;
      (n || u.length) && (l = pe(e.helper(ql), [
        Vl(n, u, e)
      ])), Jm.set(t, {
        tag: r,
        propsExp: l,
        scopeId: e.scopeId || null
      });
    }
  };
}
function jx(t, e) {
  const r = Jm.get(t);
  if (r) {
    const { tag: i, propsExp: n, scopeId: u } = r;
    i.type === 7 ? (e.pushStringPart("<"), e.pushStringPart(i.exp), n && e.pushStringPart(n), u && e.pushStringPart(` ${u}`), e.pushStringPart(">"), Jt(
      t,
      e,
      !1,
      /**
       * TransitionGroup has the special runtime behavior of flattening and
       * concatenating all children into a single fragment (in order for them to
       * be patched using the same key map) so we need to account for that here
       * by disabling nested fragment wrappers from being generated.
       */
      !0,
      /**
       * TransitionGroup filters out comment children at runtime and thus
       * doesn't expect comments to be present during hydration. We need to
       * account for that by disabling the empty comment that is otherwise
       * rendered for a falsy v-if that has no v-else specified. (#6715)
       */
      !0
    ), e.pushStringPart("</"), e.pushStringPart(i.exp), e.pushStringPart(">")) : (e.pushStringPart(`<${i.value.content}`), n && e.pushStringPart(n), u && e.pushStringPart(` ${u}`), e.pushStringPart(">"), Jt(t, e, !1, !0, !0), e.pushStringPart(`</${i.value.content}>`));
  } else
    Jt(t, e, !0, !0, !0);
}
const Km = /* @__PURE__ */ new WeakMap();
function Vx(t, e) {
  return () => {
    const r = ht(t, "appear", !1, !0);
    Km.set(t, !!r);
  };
}
function zx(t, e) {
  t.children = t.children.filter((i) => i.type !== 3), Km.get(t) ? (e.pushStringPart("<template>"), Jt(t, e, !1, !0), e.pushStringPart("</template>")) : Jt(t, e, !1, !0);
}
var Wx = Object.defineProperty, Hx = Object.defineProperties, Gx = Object.getOwnPropertyDescriptors, gf = Object.getOwnPropertySymbols, Xx = Object.prototype.hasOwnProperty, Jx = Object.prototype.propertyIsEnumerable, bf = (t, e, r) => e in t ? Wx(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ir = (t, e) => {
  for (var r in e || (e = {}))
    Xx.call(e, r) && bf(t, r, e[r]);
  if (gf)
    for (var r of gf(e))
      Jx.call(e, r) && bf(t, r, e[r]);
  return t;
}, Kx = (t, e) => Hx(t, Gx(e));
const Ym = /* @__PURE__ */ new WeakMap(), Qm = Symbol(), Zm = /* @__PURE__ */ new WeakMap(), Yx = (t, e) => {
  if (t.type !== 1 || t.tagType !== 1)
    return;
  const r = ha(
    t,
    e,
    !0
    /* ssr */
  ), i = pr(r) && r.callee === si;
  if (Zm.set(t, r), fr(r))
    return r === cs ? Lx(t, e) : r === ys ? qx(t, e) : r === Mr ? Vx(t) : void 0;
  const n = [], u = Tu(t);
  return function() {
    u.children.length && Ys(u, e, (m, y, g) => (n.push(
      sE(m, y, g, e)
    ), St(void 0)));
    let h = "null";
    if (t.props.length) {
      const { props: m, directives: y } = ms(
        t,
        e,
        void 0,
        !0,
        i
      );
      (m || y.length) && (h = Vl(m, y, e));
    }
    const c = [];
    Ym.set(t, c);
    const p = (m, y, g, E) => {
      const S = m && ca(m) || "_", x = St(
        [S, "_push", "_parent", "_scopeId"],
        void 0,
        // no return, assign body later
        !0,
        // newline
        !0,
        // isSlot
        E
      );
      return c.push({
        type: Qm,
        fn: x,
        children: g,
        // also collect the corresponding vnode branch built earlier
        vnodeBranch: n[c.length]
      }), x;
    }, d = t.children.length ? Ys(t, e, p).slots : "null";
    typeof r != "string" ? t.ssrCodegenNode = pe(
      e.helper(Rm),
      [
        "_push",
        pe(e.helper(ri), [
          r,
          h,
          d
        ]),
        "_parent"
      ]
    ) : t.ssrCodegenNode = pe(
      e.helper(Dm),
      [r, h, d, "_parent"]
    );
  };
};
function Qx(t, e, r) {
  const i = Zm.get(t);
  if (t.ssrCodegenNode) {
    const n = Ym.get(t) || [];
    for (let u = 0; u < n.length; u++) {
      const { fn: l, vnodeBranch: h } = n[u];
      l.body = gn(
        te("_push", !1),
        bs(
          n[u],
          e,
          !1,
          !0
        ),
        h
      );
    }
    e.withSlotScopeId && t.ssrCodegenNode.arguments.push("_scopeId"), typeof i == "string" ? e.pushStatement(
      pe("_push", [t.ssrCodegenNode])
    ) : e.pushStatement(t.ssrCodegenNode);
  } else {
    if (i === _r)
      return kx(t, e);
    if (i === cs)
      return Rx(t, e);
    if (i === ys)
      return jx(t, e);
    if (r.type === Qm && e.pushStringPart(""), i === Mr)
      return zx(t, e);
    Jt(t, e);
  }
}
const e1 = /* @__PURE__ */ new WeakMap(), [Zx, eE] = hl(!0), tE = [...Zx, ...El], rE = Ir(Ir({}, eE), Tl);
function sE(t, e, r, i) {
  const n = e1.get(i.root), u = Kx(Ir({}, n), {
    // overwrite with vnode-based transforms
    nodeTransforms: [
      ...tE,
      ...n.nodeTransforms || []
    ],
    directiveTransforms: Ir(Ir({}, rE), n.directiveTransforms || {})
  }), l = [];
  return t && l.push({
    type: 7,
    name: "slot",
    exp: t,
    arg: void 0,
    modifiers: [],
    loc: Le
  }), e && l.push(Bt({}, e)), iE({
    type: 1,
    ns: 0,
    tag: "template",
    tagType: 3,
    props: l,
    children: r,
    loc: Le,
    codegenNode: void 0
  }, u, i), Gd(r);
}
function iE(t, e, r) {
  const i = Dr([t]), n = ai(i, e);
  n.ssr = !1, n.scopes = Ir({}, r.scopes), n.identifiers = Ir({}, r.identifiers), n.imports = r.imports, ps(i, n), ["helpers", "components", "directives"].forEach((u) => {
    n[u].forEach((l, h) => {
      if (u === "helpers") {
        const c = r.helpers.get(h);
        c === void 0 ? r.helpers.set(h, l) : r.helpers.set(h, l + c);
      } else
        r[u].add(l);
    });
  });
}
function Tu(t) {
  if ($e(t))
    return t.map(Tu);
  if (kd(t)) {
    const e = {};
    for (const r in t)
      e[r] = Tu(t[r]);
    return e;
  } else
    return t;
}
function nE(t, e) {
  const r = t1(t, e);
  if (e.ssrCssVars) {
    const n = ai(Dr([]), e), u = Ue(
      te(e.ssrCssVars, !1),
      n
    );
    r.body.push(
      je(["const _cssVars = { style: ", u, "}"])
    ), Array.from(n.helpers.keys()).forEach((l) => {
      t.helpers.add(l);
    });
  }
  const i = t.children.length > 1 && t.children.some((n) => !Rs(n));
  Jt(t, r, i), t.codegenNode = ni(r.body), t.ssrHelpers = Array.from(
    /* @__PURE__ */ new Set([
      ...Array.from(t.helpers).filter((n) => n in Eu),
      ...r.helpers
    ])
  ), t.helpers = new Set(Array.from(t.helpers).filter((n) => !(n in Eu)));
}
function t1(t, e, r = /* @__PURE__ */ new Set(), i = !1) {
  const n = [];
  let u = null;
  return {
    root: t,
    options: e,
    body: n,
    helpers: r,
    withSlotScopeId: i,
    onError: e.onError || ((l) => {
      throw l;
    }),
    helper(l) {
      return r.add(l), l;
    },
    pushStringPart(l) {
      if (!u) {
        const p = pe("_push");
        n.push(p), u = Vu([]), p.arguments.push(u);
      }
      const h = u.elements, c = h[h.length - 1];
      Se(l) && Se(c) ? h[h.length - 1] += l : h.push(l);
    },
    pushStatement(l) {
      u = null, n.push(l);
    }
  };
}
function aE(t, e = t.withSlotScopeId) {
  return t1(
    t.root,
    t.options,
    t.helpers,
    e
  );
}
function Jt(t, e, r = !1, i = !1, n = !1) {
  r && e.pushStringPart("<!--[-->");
  const { children: u } = t;
  for (let l = 0; l < u.length; l++) {
    const h = u[l];
    switch (h.type) {
      case 1:
        switch (h.tagType) {
          case 0:
            Ux(h, e);
            break;
          case 1:
            Qx(h, e, t);
            break;
          case 2:
            Nx(h, e);
            break;
          case 3:
            break;
          default:
            return e.onError(
              Zs(
                67,
                h.loc
              )
            ), h;
        }
        break;
      case 2:
        e.pushStringPart(Dt(h.content));
        break;
      case 3:
        n || e.pushStringPart(`<!--${h.content}-->`);
        break;
      case 5:
        e.pushStringPart(
          pe(e.helper(In), [
            h.content
          ])
        );
        break;
      case 9:
        _x(h, e, i, n);
        break;
      case 11:
        Cx(h, e, i);
        break;
      case 10:
        break;
      case 12:
      case 8:
        break;
      default:
        return e.onError(
          Zs(
            67,
            h.loc
          )
        ), h;
    }
  }
  r && e.pushStringPart("<!--]-->");
}
function bs(t, e, r = !1, i = e.withSlotScopeId) {
  const n = aE(e, i);
  return Jt(t, n, r), ni(n.body);
}
const oE = (t, e, r) => {
  const i = t.exp;
  function n() {
    const h = ht(e, "value");
    h && r.onError(
      Ze(
        60,
        h.loc
      )
    );
  }
  const u = (h) => {
    h.forEach((c) => {
      c.type === 1 ? l(c) : c.type === 11 ? u(c.children) : c.type === 9 && c.branches.forEach((p) => u(p.children));
    });
  };
  function l(h) {
    if (h.tag === "option") {
      if (h.props.findIndex((c) => c.name === "selected") === -1) {
        const c = Sf(h);
        h.ssrCodegenNode.elements.push(
          Ct(
            pe(r.helper(jl), [
              Ct(
                pe("Array.isArray", [i]),
                pe(r.helper(xu), [
                  i,
                  c
                ]),
                pe(r.helper(ln), [
                  i,
                  c
                ])
              )
            ]),
            te(" selected", !0),
            te("", !0),
            !1
          )
        );
      }
    } else h.tag === "optgroup" && u(h.children);
  }
  if (e.tagType === 0) {
    const h = { props: [] }, c = [
      // default value binding for text type inputs
      Pe("value", i)
    ];
    if (e.tag === "input") {
      const p = ht(e, "type");
      if (p) {
        const d = Sf(e);
        if (p.type === 7)
          h.ssrTagParts = [
            pe(r.helper(Vm), [
              p.exp,
              i,
              d
            ])
          ];
        else if (p.value)
          switch (p.value.content) {
            case "radio":
              h.props = [
                Pe(
                  "checked",
                  pe(r.helper(ln), [
                    i,
                    d
                  ])
                )
              ];
              break;
            case "checkbox":
              const m = ht(e, "true-value");
              if (m) {
                const y = m.type === 6 ? JSON.stringify(m.value.content) : m.exp;
                h.props = [
                  Pe(
                    "checked",
                    pe(r.helper(ln), [
                      i,
                      y
                    ])
                  )
                ];
              } else
                h.props = [
                  Pe(
                    "checked",
                    Ct(
                      pe("Array.isArray", [i]),
                      pe(r.helper(xu), [
                        i,
                        d
                      ]),
                      i
                    )
                  )
                ];
              break;
            case "file":
              r.onError(
                Ze(
                  59,
                  t.loc
                )
              );
              break;
            default:
              n(), h.props = c;
              break;
          }
      } else na(e) || (n(), h.props = c);
    } else e.tag === "textarea" ? (n(), e.children = [yn(i, i.loc)]) : e.tag === "select" ? u(e.children) : r.onError(
      Ze(
        57,
        t.loc
      )
    );
    return h;
  } else
    return pa(t, e, r);
};
function Sf(t) {
  const e = ht(t, "value");
  return e ? e.type === 7 ? e.exp : te(e.value.content, !0) : te("null", !1);
}
const uE = (t, e, r) => (t.exp || r.onError(
  Ze(61)
), {
  props: [
    Pe(
      "style",
      Ct(
        t.exp,
        te("null", !1),
        lt([
          Pe(
            "display",
            te("none", !0)
          )
        ]),
        !1
      )
    )
  ]
}), wu = (t) => t.children.filter((e) => e.type !== 3), oo = (t) => wu(t).length === 1, lE = (t, e) => {
  if (t.type === 0 && (e.identifiers._attrs = 1), t.type === 1 && t.tagType === 1 && (t.tag === "transition" || t.tag === "Transition" || t.tag === "KeepAlive" || t.tag === "keep-alive")) {
    const i = wu(e.root);
    if (i.length === 1 && i[0] === t) {
      oo(t) && uo(t.children[0]);
      return;
    }
  }
  const r = e.parent;
  if (!(!r || r.type !== 0))
    if (t.type === 10 && oo(t)) {
      let i = !1;
      for (const n of wu(r))
        if (n.type === 9 || n.type === 1 && Fe(n, "if")) {
          if (i) return;
          i = !0;
        } else if (
          // node before v-if
          !i || // non else nodes
          !(n.type === 1 && Fe(n, /else/, !0))
        )
          return;
      uo(t.children[0]);
    } else oo(r) && uo(t);
};
function uo(t) {
  t.type === 1 && (t.tagType === 0 || t.tagType === 1) && !Fe(t, "for") && t.props.push({
    type: 7,
    name: "bind",
    arg: void 0,
    exp: te("_attrs", !1),
    modifiers: [],
    loc: Le
  });
}
const cE = (t, e) => {
  if (!e.ssrCssVars)
    return;
  t.type === 0 && (e.identifiers._cssVars = 1);
  const r = e.parent;
  if (!(!r || r.type !== 0))
    if (t.type === 10)
      for (const i of t.children)
        Nn(i);
    else
      Nn(t);
};
function Nn(t) {
  if (t.type === 1 && (t.tagType === 0 || t.tagType === 1) && !Fe(t, "for"))
    if (t.tag === "suspense" || t.tag === "Suspense")
      for (const e of t.children)
        e.type === 1 && e.tagType === 3 ? e.children.forEach(Nn) : Nn(e);
    else
      t.props.push({
        type: 7,
        name: "bind",
        arg: void 0,
        exp: te("_cssVars", !1),
        modifiers: [],
        loc: Le
      });
}
var hE = Object.defineProperty, fE = Object.defineProperties, pE = Object.getOwnPropertyDescriptors, vf = Object.getOwnPropertySymbols, dE = Object.prototype.hasOwnProperty, mE = Object.prototype.propertyIsEnumerable, xf = (t, e, r) => e in t ? hE(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ai = (t, e) => {
  for (var r in e || (e = {}))
    dE.call(e, r) && xf(t, r, e[r]);
  if (vf)
    for (var r of vf(e))
      mE.call(e, r) && xf(t, r, e[r]);
  return t;
}, Ef = (t, e) => fE(t, pE(e));
function yE(t, e = {}) {
  e = Ef(Ai(Ai({}, e), ls), {
    ssr: !0,
    inSSR: !0,
    scopeId: e.mode === "function" ? null : e.scopeId,
    // always prefix since compiler-ssr doesn't have size concern
    prefixIdentifiers: !0,
    // disable optimizations that are unnecessary for ssr
    cacheHandlers: !1,
    hoistStatic: !1
  });
  const r = typeof t == "string" ? aa(t, e) : t;
  return e1.set(r, e), el(r, Ef(Ai({}, e), {
    hoistStatic: !1,
    nodeTransforms: [
      Px,
      Ax,
      ul,
      rl,
      Ix,
      lE,
      cE,
      Dx,
      Yx,
      ol,
      Sl,
      ...e.nodeTransforms || []
      // user transforms
    ],
    directiveTransforms: Ai({
      // reusing core v-bind
      bind: il,
      on: fa,
      // model and show have dedicated SSR handling
      model: oE,
      show: uE,
      // the following are ignored during SSR
      // on: noopDirectiveTransform,
      cloak: Ds,
      once: Ds,
      memo: Ds
    }, e.directiveTransforms || {})
  })), nE(r, e), tl(r, e);
}
var gE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compile: yE
}), bE = {}, SE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: bE
}), vE = /* @__PURE__ */ ea(SE), zl = /* @__PURE__ */ ea(HS), xE = /* @__PURE__ */ ea(Jv);
const Tf = {};
function Us(t) {
  !(typeof process < "u" && process.env.NODE_ENV === "production") && !Tf[t] && (Tf[t] = !0, On(t));
}
function On(t) {
  console.warn(
    `\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${t}\x1B[0m
`
  );
}
var EE = Object.defineProperty, TE = Object.defineProperties, wE = Object.getOwnPropertyDescriptors, wf = Object.getOwnPropertySymbols, PE = Object.prototype.hasOwnProperty, _E = Object.prototype.propertyIsEnumerable, Pf = (t, e, r) => e in t ? EE(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, kn = (t, e) => {
  for (var r in e || (e = {}))
    PE.call(e, r) && Pf(t, r, e[r]);
  if (wf)
    for (var r of wf(e))
      _E.call(e, r) && Pf(t, r, e[r]);
  return t;
}, Pu = (t, e) => TE(t, wE(e));
function AE({ source: t, filename: e, preprocessOptions: r }, i) {
  let n = "", u = null;
  if (i.render(
    t,
    kn({ filename: e }, r),
    (l, h) => {
      l && (u = l), n = h;
    }
  ), u) throw u;
  return n;
}
function r1(t) {
  const { preprocessLang: e, preprocessCustomRequire: r } = t;
  if (e && !r)
    throw new Error(
      "[@vue/compiler-sfc] Template preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor in the shape of { render(): string }."
    );
  const i = e ? r ? r(e) : void 0 : !1;
  if (i)
    try {
      return _f(Pu(kn({}, t), {
        source: AE(t, i),
        ast: void 0
        // invalidate AST if template goes through preprocessor
      }));
    } catch (n) {
      return {
        code: "export default function render() {}",
        source: t.source,
        tips: [],
        errors: [n]
      };
    }
  else return e ? {
    code: "export default function render() {}",
    source: t.source,
    tips: [
      `Component ${t.filename} uses lang ${e} for template. Please install the language preprocessor.`
    ],
    errors: [
      `Component ${t.filename} uses lang ${e} for template, however it is not installed.`
    ]
  } : _f(t);
}
function _f({
  filename: t,
  id: e,
  scoped: r,
  slotted: i,
  inMap: n,
  source: u,
  ast: l,
  ssr: h = !1,
  ssrCssVars: c,
  isProd: p = !1,
  compiler: d,
  compilerOptions: m = {},
  transformAssetUrls: y
}) {
  const g = [], E = [];
  let S = [];
  if (pr(y)) {
    const O = Sx(y);
    S = [
      vx(O),
      wx(O)
    ];
  } else y !== !1 && (S = [km, Lm]);
  h && !c && Us(
    "compileTemplate is called with `ssr: true` but no corresponding `cssVars` option."
  ), e || (Us("compileTemplate now requires the `id` option."), e = "");
  const x = e.replace(/^data-v-/, ""), v = `data-v-${x}`, P = h ? gE : pu;
  if (d = d || P, d !== P && (l = void 0), l != null && l.transformed) {
    const I = (h ? pu : d).parse(l.source, Pu(kn({
      prefixIdentifiers: !0
    }, m), {
      parseMode: "sfc",
      onError: (k) => g.push(k)
    })).children.find(
      (k) => k.type === 1 && k.tag === "template"
    );
    l = Dr(I.children, l.source);
  }
  let { code: A, ast: N, preamble: _, map: R } = d.compile(l || u, Pu(kn({
    mode: "module",
    prefixIdentifiers: !0,
    hoistStatic: !0,
    cacheHandlers: !0,
    ssrCssVars: h && c && c.length ? O0(c, x, p, !0) : "",
    scopeId: r ? v : void 0,
    slotted: i,
    sourceMap: !0
  }, m), {
    hmr: !p,
    nodeTransforms: S.concat(m.nodeTransforms || []),
    filename: t,
    onError: (O) => g.push(O),
    onWarn: (O) => E.push(O)
  }));
  n && !l && (R && (R = CE(n, R)), g.length && IE(g, u, n));
  const M = E.map((O) => {
    let I = O.message;
    return O.loc && (I += `
${ti(
      (l == null ? void 0 : l.source) || u,
      O.loc.start.offset,
      O.loc.end.offset
    )}`), I;
  });
  return { code: A, ast: N, preamble: _, source: u, errors: g, tips: M, map: R };
}
function CE(t, e) {
  if (!t) return e;
  if (!e) return t;
  const r = new Ar.SourceMapConsumer(t), i = new Ar.SourceMapConsumer(e), n = new Ar.SourceMapGenerator();
  i.eachMapping((l) => {
    if (l.originalLine == null)
      return;
    const h = r.originalPositionFor({
      line: l.originalLine,
      column: l.originalColumn
    });
    h.source != null && n.addMapping({
      generated: {
        line: l.generatedLine,
        column: l.generatedColumn
      },
      original: {
        line: h.line,
        // map line
        // use current column, since the oldMap produced by @vue/compiler-sfc
        // does not
        column: l.originalColumn
      },
      source: h.source,
      name: h.name
    });
  });
  const u = n;
  return r.sources.forEach((l) => {
    u._sources.add(l);
    const h = r.sourceContentFor(l);
    h != null && n.setSourceContent(l, h);
  }), u._sourceRoot = t.sourceRoot, u._file = t.file, u.toJSON();
}
function IE(t, e, r) {
  const i = r.sourcesContent[0], n = i.indexOf(e), u = i.slice(0, n).split(/\r?\n/).length - 1;
  t.forEach((l) => {
    l.loc && (l.loc.start.line += u, l.loc.start.offset += n, l.loc.end !== l.loc.start && (l.loc.end.line += u, l.loc.end.offset += n));
  });
}
var Ci = { exports: {} }, Af;
function s1() {
  if (Af) return Ci.exports;
  Af = 1;
  let t = ft || {}, e = t.argv || [], r = t.env || {}, i = !(r.NO_COLOR || e.includes("--no-color")) && (!!r.FORCE_COLOR || e.includes("--color") || t.platform === "win32" || (t.stdout || {}).isTTY && r.TERM !== "dumb" || !!r.CI), n = (h, c, p = h) => (d) => {
    let m = "" + d, y = m.indexOf(c, h.length);
    return ~y ? h + u(m, c, p, y) + c : h + m + c;
  }, u = (h, c, p, d) => {
    let m = "", y = 0;
    do
      m += h.substring(y, d) + p, y = d + c.length, d = h.indexOf(c, y);
    while (~d);
    return m + h.substring(y);
  }, l = (h = i) => {
    let c = h ? n : () => String;
    return {
      isColorSupported: h,
      reset: c("\x1B[0m", "\x1B[0m"),
      bold: c("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: c("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: c("\x1B[3m", "\x1B[23m"),
      underline: c("\x1B[4m", "\x1B[24m"),
      inverse: c("\x1B[7m", "\x1B[27m"),
      hidden: c("\x1B[8m", "\x1B[28m"),
      strikethrough: c("\x1B[9m", "\x1B[29m"),
      black: c("\x1B[30m", "\x1B[39m"),
      red: c("\x1B[31m", "\x1B[39m"),
      green: c("\x1B[32m", "\x1B[39m"),
      yellow: c("\x1B[33m", "\x1B[39m"),
      blue: c("\x1B[34m", "\x1B[39m"),
      magenta: c("\x1B[35m", "\x1B[39m"),
      cyan: c("\x1B[36m", "\x1B[39m"),
      white: c("\x1B[37m", "\x1B[39m"),
      gray: c("\x1B[90m", "\x1B[39m"),
      bgBlack: c("\x1B[40m", "\x1B[49m"),
      bgRed: c("\x1B[41m", "\x1B[49m"),
      bgGreen: c("\x1B[42m", "\x1B[49m"),
      bgYellow: c("\x1B[43m", "\x1B[49m"),
      bgBlue: c("\x1B[44m", "\x1B[49m"),
      bgMagenta: c("\x1B[45m", "\x1B[49m"),
      bgCyan: c("\x1B[46m", "\x1B[49m"),
      bgWhite: c("\x1B[47m", "\x1B[49m"),
      blackBright: c("\x1B[90m", "\x1B[39m"),
      redBright: c("\x1B[91m", "\x1B[39m"),
      greenBright: c("\x1B[92m", "\x1B[39m"),
      yellowBright: c("\x1B[93m", "\x1B[39m"),
      blueBright: c("\x1B[94m", "\x1B[39m"),
      magentaBright: c("\x1B[95m", "\x1B[39m"),
      cyanBright: c("\x1B[96m", "\x1B[39m"),
      whiteBright: c("\x1B[97m", "\x1B[39m"),
      bgBlackBright: c("\x1B[100m", "\x1B[49m"),
      bgRedBright: c("\x1B[101m", "\x1B[49m"),
      bgGreenBright: c("\x1B[102m", "\x1B[49m"),
      bgYellowBright: c("\x1B[103m", "\x1B[49m"),
      bgBlueBright: c("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: c("\x1B[105m", "\x1B[49m"),
      bgCyanBright: c("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: c("\x1B[107m", "\x1B[49m")
    };
  };
  return Ci.exports = l(), Ci.exports.createColors = l, Ci.exports;
}
var lo, Cf;
function i1() {
  if (Cf) return lo;
  Cf = 1;
  const t = 39, e = 34, r = 92, i = 47, n = 10, u = 32, l = 12, h = 9, c = 13, p = 91, d = 93, m = 40, y = 41, g = 123, E = 125, S = 59, x = 42, v = 58, P = 64, A = /[\t\n\f\r "#'()/;[\\\]{}]/g, N = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, _ = /.[\r\n"'(/\\]/, R = /[\da-f]/i;
  return lo = function(O, I = {}) {
    let k = O.css.valueOf(), L = I.ignoreErrors, V, K, re, z, se, he, ne, ge, be, Y, ie = k.length, H = 0, j = [], U = [];
    function G() {
      return H;
    }
    function B(Z) {
      throw O.error("Unclosed " + Z, H);
    }
    function W() {
      return U.length === 0 && H >= ie;
    }
    function ce(Z) {
      if (U.length) return U.pop();
      if (H >= ie) return;
      let le = Z ? Z.ignoreUnclosed : !1;
      switch (V = k.charCodeAt(H), V) {
        case n:
        case u:
        case h:
        case c:
        case l: {
          z = H;
          do
            z += 1, V = k.charCodeAt(z);
          while (V === u || V === n || V === h || V === c || V === l);
          he = ["space", k.slice(H, z)], H = z - 1;
          break;
        }
        case p:
        case d:
        case g:
        case E:
        case v:
        case S:
        case y: {
          let ve = String.fromCharCode(V);
          he = [ve, ve, H];
          break;
        }
        case m: {
          if (Y = j.length ? j.pop()[1] : "", be = k.charCodeAt(H + 1), Y === "url" && be !== t && be !== e && be !== u && be !== n && be !== h && be !== l && be !== c) {
            z = H;
            do {
              if (ne = !1, z = k.indexOf(")", z + 1), z === -1)
                if (L || le) {
                  z = H;
                  break;
                } else
                  B("bracket");
              for (ge = z; k.charCodeAt(ge - 1) === r; )
                ge -= 1, ne = !ne;
            } while (ne);
            he = ["brackets", k.slice(H, z + 1), H, z], H = z;
          } else
            z = k.indexOf(")", H + 1), K = k.slice(H, z + 1), z === -1 || _.test(K) ? he = ["(", "(", H] : (he = ["brackets", K, H, z], H = z);
          break;
        }
        case t:
        case e: {
          se = V === t ? "'" : '"', z = H;
          do {
            if (ne = !1, z = k.indexOf(se, z + 1), z === -1)
              if (L || le) {
                z = H + 1;
                break;
              } else
                B("string");
            for (ge = z; k.charCodeAt(ge - 1) === r; )
              ge -= 1, ne = !ne;
          } while (ne);
          he = ["string", k.slice(H, z + 1), H, z], H = z;
          break;
        }
        case P: {
          A.lastIndex = H + 1, A.test(k), A.lastIndex === 0 ? z = k.length - 1 : z = A.lastIndex - 2, he = ["at-word", k.slice(H, z + 1), H, z], H = z;
          break;
        }
        case r: {
          for (z = H, re = !0; k.charCodeAt(z + 1) === r; )
            z += 1, re = !re;
          if (V = k.charCodeAt(z + 1), re && V !== i && V !== u && V !== n && V !== h && V !== c && V !== l && (z += 1, R.test(k.charAt(z)))) {
            for (; R.test(k.charAt(z + 1)); )
              z += 1;
            k.charCodeAt(z + 1) === u && (z += 1);
          }
          he = ["word", k.slice(H, z + 1), H, z], H = z;
          break;
        }
        default: {
          V === i && k.charCodeAt(H + 1) === x ? (z = k.indexOf("*/", H + 2) + 1, z === 0 && (L || le ? z = k.length : B("comment")), he = ["comment", k.slice(H, z + 1), H, z], H = z) : (N.lastIndex = H + 1, N.test(k), N.lastIndex === 0 ? z = k.length - 1 : z = N.lastIndex - 2, he = ["word", k.slice(H, z + 1), H, z], j.push(he), H = z);
          break;
        }
      }
      return H++, he;
    }
    function Q(Z) {
      U.push(Z);
    }
    return {
      back: Q,
      endOfFile: W,
      nextToken: ce,
      position: G
    };
  }, lo;
}
var co, If;
function n1() {
  if (If) return co;
  If = 1;
  let t = /* @__PURE__ */ s1(), e = /* @__PURE__ */ i1(), r;
  function i(h) {
    r = h;
  }
  const n = {
    ";": t.yellow,
    ":": t.yellow,
    "(": t.cyan,
    ")": t.cyan,
    "[": t.yellow,
    "]": t.yellow,
    "{": t.yellow,
    "}": t.yellow,
    "at-word": t.cyan,
    brackets: t.cyan,
    call: t.cyan,
    class: t.yellow,
    comment: t.gray,
    hash: t.magenta,
    string: t.green
  };
  function u([h, c], p) {
    if (h === "word") {
      if (c[0] === ".")
        return "class";
      if (c[0] === "#")
        return "hash";
    }
    if (!p.endOfFile()) {
      let d = p.nextToken();
      if (p.back(d), d[0] === "brackets" || d[0] === "(") return "call";
    }
    return h;
  }
  function l(h) {
    let c = e(new r(h), { ignoreErrors: !0 }), p = "";
    for (; !c.endOfFile(); ) {
      let d = c.nextToken(), m = n[u(d, c)];
      m ? p += d[1].split(/\r?\n/).map((y) => m(y)).join(`
`) : p += d[1];
    }
    return p;
  }
  return l.registerInput = i, co = l, co;
}
var ho, Nf;
function Wl() {
  if (Nf) return ho;
  Nf = 1;
  let t = /* @__PURE__ */ s1(), e = /* @__PURE__ */ n1();
  class r extends Error {
    constructor(n, u, l, h, c, p) {
      super(n), this.name = "CssSyntaxError", this.reason = n, c && (this.file = c), h && (this.source = h), p && (this.plugin = p), typeof u < "u" && typeof l < "u" && (typeof u == "number" ? (this.line = u, this.column = l) : (this.line = u.line, this.column = u.column, this.endLine = l.line, this.endColumn = l.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, r);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(n) {
      if (!this.source) return "";
      let u = this.source;
      n == null && (n = t.isColorSupported);
      let l = (g) => g, h = (g) => g, c = (g) => g;
      if (n) {
        let { bold: g, gray: E, red: S } = t.createColors(!0);
        h = (x) => g(S(x)), l = (x) => E(x), e && (c = (x) => e(x));
      }
      let p = u.split(/\r?\n/), d = Math.max(this.line - 3, 0), m = Math.min(this.line + 2, p.length), y = String(m).length;
      return p.slice(d, m).map((g, E) => {
        let S = d + 1 + E, x = " " + (" " + S).slice(-y) + " | ";
        if (S === this.line) {
          if (g.length > 160) {
            let P = 20, A = Math.max(0, this.column - P), N = Math.max(
              this.column + P,
              this.endColumn + P
            ), _ = g.slice(A, N), R = l(x.replace(/\d/g, " ")) + g.slice(0, Math.min(this.column - 1, P - 1)).replace(/[^\t]/g, " ");
            return h(">") + l(x) + c(_) + `
 ` + R + h("^");
          }
          let v = l(x.replace(/\d/g, " ")) + g.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return h(">") + l(x) + c(g) + `
 ` + v + h("^");
        }
        return " " + l(x) + c(g);
      }).join(`
`);
    }
    toString() {
      let n = this.showSourceCode();
      return n && (n = `

` + n + `
`), this.name + ": " + this.message + n;
    }
  }
  return ho = r, r.default = r, ho;
}
var fo, Of;
function a1() {
  if (Of) return fo;
  Of = 1;
  const t = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: !1
  };
  function e(i) {
    return i[0].toUpperCase() + i.slice(1);
  }
  class r {
    constructor(n) {
      this.builder = n;
    }
    atrule(n, u) {
      let l = "@" + n.name, h = n.params ? this.rawValue(n, "params") : "";
      if (typeof n.raws.afterName < "u" ? l += n.raws.afterName : h && (l += " "), n.nodes)
        this.block(n, l + h);
      else {
        let c = (n.raws.between || "") + (u ? ";" : "");
        this.builder(l + h + c, n);
      }
    }
    beforeAfter(n, u) {
      let l;
      n.type === "decl" ? l = this.raw(n, null, "beforeDecl") : n.type === "comment" ? l = this.raw(n, null, "beforeComment") : u === "before" ? l = this.raw(n, null, "beforeRule") : l = this.raw(n, null, "beforeClose");
      let h = n.parent, c = 0;
      for (; h && h.type !== "root"; )
        c += 1, h = h.parent;
      if (l.includes(`
`)) {
        let p = this.raw(n, null, "indent");
        if (p.length)
          for (let d = 0; d < c; d++) l += p;
      }
      return l;
    }
    block(n, u) {
      let l = this.raw(n, "between", "beforeOpen");
      this.builder(u + l + "{", n, "start");
      let h;
      n.nodes && n.nodes.length ? (this.body(n), h = this.raw(n, "after")) : h = this.raw(n, "after", "emptyBody"), h && this.builder(h), this.builder("}", n, "end");
    }
    body(n) {
      let u = n.nodes.length - 1;
      for (; u > 0 && n.nodes[u].type === "comment"; )
        u -= 1;
      let l = this.raw(n, "semicolon");
      for (let h = 0; h < n.nodes.length; h++) {
        let c = n.nodes[h], p = this.raw(c, "before");
        p && this.builder(p), this.stringify(c, u !== h || l);
      }
    }
    comment(n) {
      let u = this.raw(n, "left", "commentLeft"), l = this.raw(n, "right", "commentRight");
      this.builder("/*" + u + n.text + l + "*/", n);
    }
    decl(n, u) {
      let l = this.raw(n, "between", "colon"), h = n.prop + l + this.rawValue(n, "value");
      n.important && (h += n.raws.important || " !important"), u && (h += ";"), this.builder(h, n);
    }
    document(n) {
      this.body(n);
    }
    raw(n, u, l) {
      let h;
      if (l || (l = u), u && (h = n.raws[u], typeof h < "u"))
        return h;
      let c = n.parent;
      if (l === "before" && (!c || c.type === "root" && c.first === n || c && c.type === "document"))
        return "";
      if (!c) return t[l];
      let p = n.root();
      if (p.rawCache || (p.rawCache = {}), typeof p.rawCache[l] < "u")
        return p.rawCache[l];
      if (l === "before" || l === "after")
        return this.beforeAfter(n, l);
      {
        let d = "raw" + e(l);
        this[d] ? h = this[d](p, n) : p.walk((m) => {
          if (h = m.raws[u], typeof h < "u") return !1;
        });
      }
      return typeof h > "u" && (h = t[l]), p.rawCache[l] = h, h;
    }
    rawBeforeClose(n) {
      let u;
      return n.walk((l) => {
        if (l.nodes && l.nodes.length > 0 && typeof l.raws.after < "u")
          return u = l.raws.after, u.includes(`
`) && (u = u.replace(/[^\n]+$/, "")), !1;
      }), u && (u = u.replace(/\S/g, "")), u;
    }
    rawBeforeComment(n, u) {
      let l;
      return n.walkComments((h) => {
        if (typeof h.raws.before < "u")
          return l = h.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(u, null, "beforeDecl") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeDecl(n, u) {
      let l;
      return n.walkDecls((h) => {
        if (typeof h.raws.before < "u")
          return l = h.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(u, null, "beforeRule") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeOpen(n) {
      let u;
      return n.walk((l) => {
        if (l.type !== "decl" && (u = l.raws.between, typeof u < "u"))
          return !1;
      }), u;
    }
    rawBeforeRule(n) {
      let u;
      return n.walk((l) => {
        if (l.nodes && (l.parent !== n || n.first !== l) && typeof l.raws.before < "u")
          return u = l.raws.before, u.includes(`
`) && (u = u.replace(/[^\n]+$/, "")), !1;
      }), u && (u = u.replace(/\S/g, "")), u;
    }
    rawColon(n) {
      let u;
      return n.walkDecls((l) => {
        if (typeof l.raws.between < "u")
          return u = l.raws.between.replace(/[^\s:]/g, ""), !1;
      }), u;
    }
    rawEmptyBody(n) {
      let u;
      return n.walk((l) => {
        if (l.nodes && l.nodes.length === 0 && (u = l.raws.after, typeof u < "u"))
          return !1;
      }), u;
    }
    rawIndent(n) {
      if (n.raws.indent) return n.raws.indent;
      let u;
      return n.walk((l) => {
        let h = l.parent;
        if (h && h !== n && h.parent && h.parent === n && typeof l.raws.before < "u") {
          let c = l.raws.before.split(`
`);
          return u = c[c.length - 1], u = u.replace(/\S/g, ""), !1;
        }
      }), u;
    }
    rawSemicolon(n) {
      let u;
      return n.walk((l) => {
        if (l.nodes && l.nodes.length && l.last.type === "decl" && (u = l.raws.semicolon, typeof u < "u"))
          return !1;
      }), u;
    }
    rawValue(n, u) {
      let l = n[u], h = n.raws[u];
      return h && h.value === l ? h.raw : l;
    }
    root(n) {
      this.body(n), n.raws.after && this.builder(n.raws.after);
    }
    rule(n) {
      this.block(n, this.rawValue(n, "selector")), n.raws.ownSemicolon && this.builder(n.raws.ownSemicolon, n, "end");
    }
    stringify(n, u) {
      if (!this[n.type])
        throw new Error(
          "Unknown AST node type " + n.type + ". Maybe you need to change PostCSS stringifier."
        );
      this[n.type](n, u);
    }
  }
  return fo = r, r.default = r, fo;
}
var po, kf;
function va() {
  if (kf) return po;
  kf = 1;
  let t = /* @__PURE__ */ a1();
  function e(r, i) {
    new t(i).stringify(r);
  }
  return po = e, e.default = e, po;
}
var Ii = {}, Lf;
function Hl() {
  return Lf || (Lf = 1, Ii.isClean = Symbol("isClean"), Ii.my = Symbol("my")), Ii;
}
var mo, Rf;
function xa() {
  if (Rf) return mo;
  Rf = 1;
  let t = /* @__PURE__ */ Wl(), e = /* @__PURE__ */ a1(), r = /* @__PURE__ */ va(), { isClean: i, my: n } = /* @__PURE__ */ Hl();
  function u(c, p) {
    let d = new c.constructor();
    for (let m in c) {
      if (!Object.prototype.hasOwnProperty.call(c, m) || m === "proxyCache") continue;
      let y = c[m], g = typeof y;
      m === "parent" && g === "object" ? p && (d[m] = p) : m === "source" ? d[m] = y : Array.isArray(y) ? d[m] = y.map((E) => u(E, d)) : (g === "object" && y !== null && (y = u(y)), d[m] = y);
    }
    return d;
  }
  function l(c, p) {
    if (p && typeof p.offset < "u")
      return p.offset;
    let d = 1, m = 1, y = 0;
    for (let g = 0; g < c.length; g++) {
      if (m === p.line && d === p.column) {
        y = g;
        break;
      }
      c[g] === `
` ? (d = 1, m += 1) : d += 1;
    }
    return y;
  }
  class h {
    get proxyOf() {
      return this;
    }
    constructor(p = {}) {
      this.raws = {}, this[i] = !1, this[n] = !0;
      for (let d in p)
        if (d === "nodes") {
          this.nodes = [];
          for (let m of p[d])
            typeof m.clone == "function" ? this.append(m.clone()) : this.append(m);
        } else
          this[d] = p[d];
    }
    addToError(p) {
      if (p.postcssNode = this, p.stack && this.source && /\n\s{4}at /.test(p.stack)) {
        let d = this.source;
        p.stack = p.stack.replace(
          /\n\s{4}at /,
          `$&${d.input.from}:${d.start.line}:${d.start.column}$&`
        );
      }
      return p;
    }
    after(p) {
      return this.parent.insertAfter(this, p), this;
    }
    assign(p = {}) {
      for (let d in p)
        this[d] = p[d];
      return this;
    }
    before(p) {
      return this.parent.insertBefore(this, p), this;
    }
    cleanRaws(p) {
      delete this.raws.before, delete this.raws.after, p || delete this.raws.between;
    }
    clone(p = {}) {
      let d = u(this);
      for (let m in p)
        d[m] = p[m];
      return d;
    }
    cloneAfter(p = {}) {
      let d = this.clone(p);
      return this.parent.insertAfter(this, d), d;
    }
    cloneBefore(p = {}) {
      let d = this.clone(p);
      return this.parent.insertBefore(this, d), d;
    }
    error(p, d = {}) {
      if (this.source) {
        let { end: m, start: y } = this.rangeBy(d);
        return this.source.input.error(
          p,
          { column: y.column, line: y.line },
          { column: m.column, line: m.line },
          d
        );
      }
      return new t(p);
    }
    getProxyProcessor() {
      return {
        get(p, d) {
          return d === "proxyOf" ? p : d === "root" ? () => p.root().toProxy() : p[d];
        },
        set(p, d, m) {
          return p[d] === m || (p[d] = m, (d === "prop" || d === "value" || d === "name" || d === "params" || d === "important" || /* c8 ignore next */
          d === "text") && p.markDirty()), !0;
        }
      };
    }
    /* c8 ignore next 3 */
    markClean() {
      this[i] = !0;
    }
    markDirty() {
      if (this[i]) {
        this[i] = !1;
        let p = this;
        for (; p = p.parent; )
          p[i] = !1;
      }
    }
    next() {
      if (!this.parent) return;
      let p = this.parent.index(this);
      return this.parent.nodes[p + 1];
    }
    positionBy(p = {}) {
      let d = this.source.start;
      if (p.index)
        d = this.positionInside(p.index);
      else if (p.word) {
        let m = "document" in this.source.input ? this.source.input.document : this.source.input.css, g = m.slice(
          l(m, this.source.start),
          l(m, this.source.end)
        ).indexOf(p.word);
        g !== -1 && (d = this.positionInside(g));
      }
      return d;
    }
    positionInside(p) {
      let d = this.source.start.column, m = this.source.start.line, y = "document" in this.source.input ? this.source.input.document : this.source.input.css, g = l(y, this.source.start), E = g + p;
      for (let S = g; S < E; S++)
        y[S] === `
` ? (d = 1, m += 1) : d += 1;
      return { column: d, line: m, offset: E };
    }
    prev() {
      if (!this.parent) return;
      let p = this.parent.index(this);
      return this.parent.nodes[p - 1];
    }
    rangeBy(p = {}) {
      let d = "document" in this.source.input ? this.source.input.document : this.source.input.css, m = {
        column: this.source.start.column,
        line: this.source.start.line,
        offset: l(d, this.source.start)
      }, y = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line,
        offset: typeof this.source.end.offset == "number" ? (
          // `source.end.offset` is exclusive, so we don't need to add 1
          this.source.end.offset
        ) : (
          // Since line/column in this.source.end is inclusive,
          // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
          // So, we add 1 to convert it to exclusive.
          l(d, this.source.end) + 1
        )
      } : {
        column: m.column + 1,
        line: m.line,
        offset: m.offset + 1
      };
      if (p.word) {
        let E = d.slice(
          l(d, this.source.start),
          l(d, this.source.end)
        ).indexOf(p.word);
        E !== -1 && (m = this.positionInside(E), y = this.positionInside(E + p.word.length));
      } else
        p.start ? m = {
          column: p.start.column,
          line: p.start.line,
          offset: l(d, p.start)
        } : p.index && (m = this.positionInside(p.index)), p.end ? y = {
          column: p.end.column,
          line: p.end.line,
          offset: l(d, p.end)
        } : typeof p.endIndex == "number" ? y = this.positionInside(p.endIndex) : p.index && (y = this.positionInside(p.index + 1));
      return (y.line < m.line || y.line === m.line && y.column <= m.column) && (y = {
        column: m.column + 1,
        line: m.line,
        offset: m.offset + 1
      }), { end: y, start: m };
    }
    raw(p, d) {
      return new e().raw(this, p, d);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...p) {
      if (this.parent) {
        let d = this, m = !1;
        for (let y of p)
          y === this ? m = !0 : m ? (this.parent.insertAfter(d, y), d = y) : this.parent.insertBefore(d, y);
        m || this.remove();
      }
      return this;
    }
    root() {
      let p = this;
      for (; p.parent && p.parent.type !== "document"; )
        p = p.parent;
      return p;
    }
    toJSON(p, d) {
      let m = {}, y = d == null;
      d = d || /* @__PURE__ */ new Map();
      let g = 0;
      for (let E in this) {
        if (!Object.prototype.hasOwnProperty.call(this, E) || E === "parent" || E === "proxyCache") continue;
        let S = this[E];
        if (Array.isArray(S))
          m[E] = S.map((x) => typeof x == "object" && x.toJSON ? x.toJSON(null, d) : x);
        else if (typeof S == "object" && S.toJSON)
          m[E] = S.toJSON(null, d);
        else if (E === "source") {
          if (S == null) continue;
          let x = d.get(S.input);
          x == null && (x = g, d.set(S.input, g), g++), m[E] = {
            end: S.end,
            inputId: x,
            start: S.start
          };
        } else
          m[E] = S;
      }
      return y && (m.inputs = [...d.keys()].map((E) => E.toJSON())), m;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(p = r) {
      p.stringify && (p = p.stringify);
      let d = "";
      return p(this, (m) => {
        d += m;
      }), d;
    }
    warn(p, d, m = {}) {
      let y = { node: this };
      for (let g in m) y[g] = m[g];
      return p.warn(d, y);
    }
  }
  return mo = h, h.default = h, mo;
}
var yo, Df;
function Ea() {
  if (Df) return yo;
  Df = 1;
  let t = /* @__PURE__ */ xa();
  class e extends t {
    constructor(i) {
      super(i), this.type = "comment";
    }
  }
  return yo = e, e.default = e, yo;
}
var go, Mf;
function Ta() {
  if (Mf) return go;
  Mf = 1;
  let t = /* @__PURE__ */ xa();
  class e extends t {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(i) {
      i && typeof i.value < "u" && typeof i.value != "string" && (i = { ...i, value: String(i.value) }), super(i), this.type = "decl";
    }
  }
  return go = e, e.default = e, go;
}
var bo, Ff;
function Br() {
  if (Ff) return bo;
  Ff = 1;
  let t = /* @__PURE__ */ Ea(), e = /* @__PURE__ */ Ta(), r = /* @__PURE__ */ xa(), { isClean: i, my: n } = /* @__PURE__ */ Hl(), u, l, h, c;
  function p(y) {
    return y.map((g) => (g.nodes && (g.nodes = p(g.nodes)), delete g.source, g));
  }
  function d(y) {
    if (y[i] = !1, y.proxyOf.nodes)
      for (let g of y.proxyOf.nodes)
        d(g);
  }
  class m extends r {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...g) {
      for (let E of g) {
        let S = this.normalize(E, this.last);
        for (let x of S) this.proxyOf.nodes.push(x);
      }
      return this.markDirty(), this;
    }
    cleanRaws(g) {
      if (super.cleanRaws(g), this.nodes)
        for (let E of this.nodes) E.cleanRaws(g);
    }
    each(g) {
      if (!this.proxyOf.nodes) return;
      let E = this.getIterator(), S, x;
      for (; this.indexes[E] < this.proxyOf.nodes.length && (S = this.indexes[E], x = g(this.proxyOf.nodes[S], S), x !== !1); )
        this.indexes[E] += 1;
      return delete this.indexes[E], x;
    }
    every(g) {
      return this.nodes.every(g);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let g = this.lastEach;
      return this.indexes[g] = 0, g;
    }
    getProxyProcessor() {
      return {
        get(g, E) {
          return E === "proxyOf" ? g : g[E] ? E === "each" || typeof E == "string" && E.startsWith("walk") ? (...S) => g[E](
            ...S.map((x) => typeof x == "function" ? (v, P) => x(v.toProxy(), P) : x)
          ) : E === "every" || E === "some" ? (S) => g[E](
            (x, ...v) => S(x.toProxy(), ...v)
          ) : E === "root" ? () => g.root().toProxy() : E === "nodes" ? g.nodes.map((S) => S.toProxy()) : E === "first" || E === "last" ? g[E].toProxy() : g[E] : g[E];
        },
        set(g, E, S) {
          return g[E] === S || (g[E] = S, (E === "name" || E === "params" || E === "selector") && g.markDirty()), !0;
        }
      };
    }
    index(g) {
      return typeof g == "number" ? g : (g.proxyOf && (g = g.proxyOf), this.proxyOf.nodes.indexOf(g));
    }
    insertAfter(g, E) {
      let S = this.index(g), x = this.normalize(E, this.proxyOf.nodes[S]).reverse();
      S = this.index(g);
      for (let P of x) this.proxyOf.nodes.splice(S + 1, 0, P);
      let v;
      for (let P in this.indexes)
        v = this.indexes[P], S < v && (this.indexes[P] = v + x.length);
      return this.markDirty(), this;
    }
    insertBefore(g, E) {
      let S = this.index(g), x = S === 0 ? "prepend" : !1, v = this.normalize(
        E,
        this.proxyOf.nodes[S],
        x
      ).reverse();
      S = this.index(g);
      for (let A of v) this.proxyOf.nodes.splice(S, 0, A);
      let P;
      for (let A in this.indexes)
        P = this.indexes[A], S <= P && (this.indexes[A] = P + v.length);
      return this.markDirty(), this;
    }
    normalize(g, E) {
      if (typeof g == "string")
        g = p(l(g).nodes);
      else if (typeof g > "u")
        g = [];
      else if (Array.isArray(g)) {
        g = g.slice(0);
        for (let x of g)
          x.parent && x.parent.removeChild(x, "ignore");
      } else if (g.type === "root" && this.type !== "document") {
        g = g.nodes.slice(0);
        for (let x of g)
          x.parent && x.parent.removeChild(x, "ignore");
      } else if (g.type)
        g = [g];
      else if (g.prop) {
        if (typeof g.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof g.value != "string" && (g.value = String(g.value)), g = [new e(g)];
      } else if (g.selector || g.selectors)
        g = [new c(g)];
      else if (g.name)
        g = [new u(g)];
      else if (g.text)
        g = [new t(g)];
      else
        throw new Error("Unknown node type in node creation");
      return g.map((x) => (x[n] || m.rebuild(x), x = x.proxyOf, x.parent && x.parent.removeChild(x), x[i] && d(x), x.raws || (x.raws = {}), typeof x.raws.before > "u" && E && typeof E.raws.before < "u" && (x.raws.before = E.raws.before.replace(/\S/g, "")), x.parent = this.proxyOf, x));
    }
    prepend(...g) {
      g = g.reverse();
      for (let E of g) {
        let S = this.normalize(E, this.first, "prepend").reverse();
        for (let x of S) this.proxyOf.nodes.unshift(x);
        for (let x in this.indexes)
          this.indexes[x] = this.indexes[x] + S.length;
      }
      return this.markDirty(), this;
    }
    push(g) {
      return g.parent = this, this.proxyOf.nodes.push(g), this;
    }
    removeAll() {
      for (let g of this.proxyOf.nodes) g.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(g) {
      g = this.index(g), this.proxyOf.nodes[g].parent = void 0, this.proxyOf.nodes.splice(g, 1);
      let E;
      for (let S in this.indexes)
        E = this.indexes[S], E >= g && (this.indexes[S] = E - 1);
      return this.markDirty(), this;
    }
    replaceValues(g, E, S) {
      return S || (S = E, E = {}), this.walkDecls((x) => {
        E.props && !E.props.includes(x.prop) || E.fast && !x.value.includes(E.fast) || (x.value = x.value.replace(g, S));
      }), this.markDirty(), this;
    }
    some(g) {
      return this.nodes.some(g);
    }
    walk(g) {
      return this.each((E, S) => {
        let x;
        try {
          x = g(E, S);
        } catch (v) {
          throw E.addToError(v);
        }
        return x !== !1 && E.walk && (x = E.walk(g)), x;
      });
    }
    walkAtRules(g, E) {
      return E ? g instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "atrule" && g.test(S.name))
          return E(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "atrule" && S.name === g)
          return E(S, x);
      }) : (E = g, this.walk((S, x) => {
        if (S.type === "atrule")
          return E(S, x);
      }));
    }
    walkComments(g) {
      return this.walk((E, S) => {
        if (E.type === "comment")
          return g(E, S);
      });
    }
    walkDecls(g, E) {
      return E ? g instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "decl" && g.test(S.prop))
          return E(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "decl" && S.prop === g)
          return E(S, x);
      }) : (E = g, this.walk((S, x) => {
        if (S.type === "decl")
          return E(S, x);
      }));
    }
    walkRules(g, E) {
      return E ? g instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "rule" && g.test(S.selector))
          return E(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "rule" && S.selector === g)
          return E(S, x);
      }) : (E = g, this.walk((S, x) => {
        if (S.type === "rule")
          return E(S, x);
      }));
    }
  }
  return m.registerParse = (y) => {
    l = y;
  }, m.registerRule = (y) => {
    c = y;
  }, m.registerAtRule = (y) => {
    u = y;
  }, m.registerRoot = (y) => {
    h = y;
  }, bo = m, m.default = m, m.rebuild = (y) => {
    y.type === "atrule" ? Object.setPrototypeOf(y, u.prototype) : y.type === "rule" ? Object.setPrototypeOf(y, c.prototype) : y.type === "decl" ? Object.setPrototypeOf(y, e.prototype) : y.type === "comment" ? Object.setPrototypeOf(y, t.prototype) : y.type === "root" && Object.setPrototypeOf(y, h.prototype), y[n] = !0, y.nodes && y.nodes.forEach((g) => {
      m.rebuild(g);
    });
  }, bo;
}
var So, Bf;
function Gl() {
  if (Bf) return So;
  Bf = 1;
  let t = /* @__PURE__ */ Br();
  class e extends t {
    constructor(i) {
      super(i), this.type = "atrule";
    }
    append(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...i);
    }
    prepend(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...i);
    }
  }
  return So = e, e.default = e, t.registerAtRule(e), So;
}
var vo, $f;
function Xl() {
  if ($f) return vo;
  $f = 1;
  let t = /* @__PURE__ */ Br(), e, r;
  class i extends t {
    constructor(u) {
      super({ type: "document", ...u }), this.nodes || (this.nodes = []);
    }
    toResult(u = {}) {
      return new e(new r(), this, u).stringify();
    }
  }
  return i.registerLazyResult = (n) => {
    e = n;
  }, i.registerProcessor = (n) => {
    r = n;
  }, vo = i, i.default = i, vo;
}
var xo, Uf;
function NE() {
  if (Uf) return xo;
  Uf = 1;
  let t = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return xo = { nanoid: (i = 21) => {
    let n = "", u = i | 0;
    for (; u--; )
      n += t[Math.random() * 64 | 0];
    return n;
  }, customAlphabet: (i, n = 21) => (u = n) => {
    let l = "", h = u | 0;
    for (; h--; )
      l += i[Math.random() * i.length | 0];
    return l;
  } }, xo;
}
var o1 = /* @__PURE__ */ ea(lx), Eo, qf;
function u1() {
  if (qf) return Eo;
  qf = 1;
  let { existsSync: t, readFileSync: e } = vE, { dirname: r, join: i } = zl, { SourceMapConsumer: n, SourceMapGenerator: u } = /* @__PURE__ */ oa();
  function l(c) {
    return X ? X.from(c, "base64").toString() : window.atob(c);
  }
  class h {
    constructor(p, d) {
      if (d.map === !1) return;
      this.loadAnnotation(p), this.inline = this.startWith(this.annotation, "data:");
      let m = d.map ? d.map.prev : void 0, y = this.loadMap(d.from, m);
      !this.mapFile && d.from && (this.mapFile = d.from), this.mapFile && (this.root = r(this.mapFile)), y && (this.text = y);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new n(this.text)), this.consumerCache;
    }
    decodeInline(p) {
      let d = /^data:application\/json;charset=utf-?8;base64,/, m = /^data:application\/json;base64,/, y = /^data:application\/json;charset=utf-?8,/, g = /^data:application\/json,/, E = p.match(y) || p.match(g);
      if (E)
        return decodeURIComponent(p.substr(E[0].length));
      let S = p.match(d) || p.match(m);
      if (S)
        return l(p.substr(S[0].length));
      let x = p.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + x);
    }
    getAnnotationURL(p) {
      return p.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(p) {
      return typeof p != "object" ? !1 : typeof p.mappings == "string" || typeof p._mappings == "string" || Array.isArray(p.sections);
    }
    loadAnnotation(p) {
      let d = p.match(/\/\*\s*# sourceMappingURL=/g);
      if (!d) return;
      let m = p.lastIndexOf(d.pop()), y = p.indexOf("*/", m);
      m > -1 && y > -1 && (this.annotation = this.getAnnotationURL(p.substring(m, y)));
    }
    loadFile(p) {
      if (this.root = r(p), t(p))
        return this.mapFile = p, e(p, "utf-8").toString().trim();
    }
    loadMap(p, d) {
      if (d === !1) return !1;
      if (d) {
        if (typeof d == "string")
          return d;
        if (typeof d == "function") {
          let m = d(p);
          if (m) {
            let y = this.loadFile(m);
            if (!y)
              throw new Error(
                "Unable to load previous source map: " + m.toString()
              );
            return y;
          }
        } else {
          if (d instanceof n)
            return u.fromSourceMap(d).toString();
          if (d instanceof u)
            return d.toString();
          if (this.isMap(d))
            return JSON.stringify(d);
          throw new Error(
            "Unsupported previous source map format: " + d.toString()
          );
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let m = this.annotation;
          return p && (m = i(r(p), m)), this.loadFile(m);
        }
      }
    }
    startWith(p, d) {
      return p ? p.substr(0, d.length) === d : !1;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return Eo = h, h.default = h, Eo;
}
var To, jf;
function wa() {
  if (jf) return To;
  jf = 1;
  let { nanoid: t } = /* @__PURE__ */ NE(), { isAbsolute: e, resolve: r } = zl, { SourceMapConsumer: i, SourceMapGenerator: n } = /* @__PURE__ */ oa(), { fileURLToPath: u, pathToFileURL: l } = o1, h = /* @__PURE__ */ Wl(), c = /* @__PURE__ */ u1(), p = /* @__PURE__ */ n1(), d = Symbol("lineToIndexCache"), m = !!(i && n), y = !!(r && e);
  function g(S) {
    if (S[d]) return S[d];
    let x = S.css.split(`
`), v = new Array(x.length), P = 0;
    for (let A = 0, N = x.length; A < N; A++)
      v[A] = P, P += x[A].length + 1;
    return S[d] = v, v;
  }
  class E {
    get from() {
      return this.file || this.id;
    }
    constructor(x, v = {}) {
      if (x === null || typeof x > "u" || typeof x == "object" && !x.toString)
        throw new Error(`PostCSS received ${x} instead of CSS string`);
      if (this.css = x.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, v.document && (this.document = v.document.toString()), v.from && (!y || /^\w+:\/\//.test(v.from) || e(v.from) ? this.file = v.from : this.file = r(v.from)), y && m) {
        let P = new c(this.css, v);
        if (P.text) {
          this.map = P;
          let A = P.consumer().file;
          !this.file && A && (this.file = this.mapResolve(A));
        }
      }
      this.file || (this.id = "<input css " + t(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(x, v, P, A = {}) {
      let N, _, R, M, O;
      if (v && typeof v == "object") {
        let k = v, L = P;
        if (typeof k.offset == "number") {
          M = k.offset;
          let V = this.fromOffset(M);
          v = V.line, P = V.col;
        } else
          v = k.line, P = k.column, M = this.fromLineAndColumn(v, P);
        if (typeof L.offset == "number") {
          R = L.offset;
          let V = this.fromOffset(R);
          _ = V.line, N = V.col;
        } else
          _ = L.line, N = L.column, R = this.fromLineAndColumn(L.line, L.column);
      } else if (P)
        M = this.fromLineAndColumn(v, P);
      else {
        M = v;
        let k = this.fromOffset(M);
        v = k.line, P = k.col;
      }
      let I = this.origin(v, P, _, N);
      return I ? O = new h(
        x,
        I.endLine === void 0 ? I.line : { column: I.column, line: I.line },
        I.endLine === void 0 ? I.column : { column: I.endColumn, line: I.endLine },
        I.source,
        I.file,
        A.plugin
      ) : O = new h(
        x,
        _ === void 0 ? v : { column: P, line: v },
        _ === void 0 ? P : { column: N, line: _ },
        this.css,
        this.file,
        A.plugin
      ), O.input = { column: P, endColumn: N, endLine: _, endOffset: R, line: v, offset: M, source: this.css }, this.file && (l && (O.input.url = l(this.file).toString()), O.input.file = this.file), O;
    }
    fromLineAndColumn(x, v) {
      return g(this)[x - 1] + v - 1;
    }
    fromOffset(x) {
      let v = g(this), P = v[v.length - 1], A = 0;
      if (x >= P)
        A = v.length - 1;
      else {
        let N = v.length - 2, _;
        for (; A < N; )
          if (_ = A + (N - A >> 1), x < v[_])
            N = _ - 1;
          else if (x >= v[_ + 1])
            A = _ + 1;
          else {
            A = _;
            break;
          }
      }
      return {
        col: x - v[A] + 1,
        line: A + 1
      };
    }
    mapResolve(x) {
      return /^\w+:\/\//.test(x) ? x : r(this.map.consumer().sourceRoot || this.map.root || ".", x);
    }
    origin(x, v, P, A) {
      if (!this.map) return !1;
      let N = this.map.consumer(), _ = N.originalPositionFor({ column: v, line: x });
      if (!_.source) return !1;
      let R;
      typeof P == "number" && (R = N.originalPositionFor({ column: A, line: P }));
      let M;
      e(_.source) ? M = l(_.source) : M = new URL(
        _.source,
        this.map.consumer().sourceRoot || l(this.map.mapFile)
      );
      let O = {
        column: _.column,
        endColumn: R && R.column,
        endLine: R && R.line,
        line: _.line,
        url: M.toString()
      };
      if (M.protocol === "file:")
        if (u)
          O.file = u(M);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let I = N.sourceContentFor(_.source);
      return I && (O.source = I), O;
    }
    toJSON() {
      let x = {};
      for (let v of ["hasBOM", "css", "file", "id"])
        this[v] != null && (x[v] = this[v]);
      return this.map && (x.map = { ...this.map }, x.map.consumerCache && (x.map.consumerCache = void 0)), x;
    }
  }
  return To = E, E.default = E, p && p.registerInput && p.registerInput(E), To;
}
var wo, Vf;
function li() {
  if (Vf) return wo;
  Vf = 1;
  let t = /* @__PURE__ */ Br(), e, r;
  class i extends t {
    constructor(u) {
      super(u), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(u, l, h) {
      let c = super.normalize(u);
      if (l) {
        if (h === "prepend")
          this.nodes.length > 1 ? l.raws.before = this.nodes[1].raws.before : delete l.raws.before;
        else if (this.first !== l)
          for (let p of c)
            p.raws.before = l.raws.before;
      }
      return c;
    }
    removeChild(u, l) {
      let h = this.index(u);
      return !l && h === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[h].raws.before), super.removeChild(u);
    }
    toResult(u = {}) {
      return new e(new r(), this, u).stringify();
    }
  }
  return i.registerLazyResult = (n) => {
    e = n;
  }, i.registerProcessor = (n) => {
    r = n;
  }, wo = i, i.default = i, t.registerRoot(i), wo;
}
var Po, zf;
function l1() {
  if (zf) return Po;
  zf = 1;
  let t = {
    comma(e) {
      return t.split(e, [","], !0);
    },
    space(e) {
      let r = [" ", `
`, "	"];
      return t.split(e, r);
    },
    split(e, r, i) {
      let n = [], u = "", l = !1, h = 0, c = !1, p = "", d = !1;
      for (let m of e)
        d ? d = !1 : m === "\\" ? d = !0 : c ? m === p && (c = !1) : m === '"' || m === "'" ? (c = !0, p = m) : m === "(" ? h += 1 : m === ")" ? h > 0 && (h -= 1) : h === 0 && r.includes(m) && (l = !0), l ? (u !== "" && n.push(u.trim()), u = "", l = !1) : u += m;
      return (i || u !== "") && n.push(u.trim()), n;
    }
  };
  return Po = t, t.default = t, Po;
}
var _o, Wf;
function Jl() {
  if (Wf) return _o;
  Wf = 1;
  let t = /* @__PURE__ */ Br(), e = /* @__PURE__ */ l1();
  class r extends t {
    get selectors() {
      return e.comma(this.selector);
    }
    set selectors(n) {
      let u = this.selector ? this.selector.match(/,\s*/) : null, l = u ? u[0] : "," + this.raw("between", "beforeOpen");
      this.selector = n.join(l);
    }
    constructor(n) {
      super(n), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return _o = r, r.default = r, t.registerRule(r), _o;
}
var Ao, Hf;
function OE() {
  if (Hf) return Ao;
  Hf = 1;
  let t = /* @__PURE__ */ Gl(), e = /* @__PURE__ */ Ea(), r = /* @__PURE__ */ Ta(), i = /* @__PURE__ */ wa(), n = /* @__PURE__ */ u1(), u = /* @__PURE__ */ li(), l = /* @__PURE__ */ Jl();
  function h(c, p) {
    if (Array.isArray(c)) return c.map((y) => h(y));
    let { inputs: d, ...m } = c;
    if (d) {
      p = [];
      for (let y of d) {
        let g = { ...y, __proto__: i.prototype };
        g.map && (g.map = {
          ...g.map,
          __proto__: n.prototype
        }), p.push(g);
      }
    }
    if (m.nodes && (m.nodes = c.nodes.map((y) => h(y, p))), m.source) {
      let { inputId: y, ...g } = m.source;
      m.source = g, y != null && (m.source.input = p[y]);
    }
    if (m.type === "root")
      return new u(m);
    if (m.type === "decl")
      return new r(m);
    if (m.type === "rule")
      return new l(m);
    if (m.type === "comment")
      return new e(m);
    if (m.type === "atrule")
      return new t(m);
    throw new Error("Unknown node type: " + c.type);
  }
  return Ao = h, h.default = h, Ao;
}
var Co, Gf;
function c1() {
  if (Gf) return Co;
  Gf = 1;
  let { dirname: t, relative: e, resolve: r, sep: i } = zl, { SourceMapConsumer: n, SourceMapGenerator: u } = /* @__PURE__ */ oa(), { pathToFileURL: l } = o1, h = /* @__PURE__ */ wa(), c = !!(n && u), p = !!(t && r && e && i);
  class d {
    constructor(y, g, E, S) {
      this.stringify = y, this.mapOpts = E.map || {}, this.root = g, this.opts = E, this.css = S, this.originalCSS = S, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let y;
      this.isInline() ? y = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? y = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? y = this.mapOpts.annotation(this.opts.to, this.root) : y = this.outputFile() + ".map";
      let g = `
`;
      this.css.includes(`\r
`) && (g = `\r
`), this.css += g + "/*# sourceMappingURL=" + y + " */";
    }
    applyPrevMaps() {
      for (let y of this.previous()) {
        let g = this.toUrl(this.path(y.file)), E = y.root || t(y.file), S;
        this.mapOpts.sourcesContent === !1 ? (S = new n(y.text), S.sourcesContent && (S.sourcesContent = null)) : S = y.consumer(), this.map.applySourceMap(S, g, this.toUrl(this.path(E)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== !1)
        if (this.root) {
          let y;
          for (let g = this.root.nodes.length - 1; g >= 0; g--)
            y = this.root.nodes[g], y.type === "comment" && y.text.startsWith("# sourceMappingURL=") && this.root.removeChild(g);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), p && c && this.isMap())
        return this.generateMap();
      {
        let y = "";
        return this.stringify(this.root, (g) => {
          y += g;
        }), [y];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let y = this.previous()[0].consumer();
        y.file = this.outputFile(), this.map = u.fromSourceMap(y, {
          ignoreInvalidMapping: !0
        });
      } else
        this.map = new u({
          file: this.outputFile(),
          ignoreInvalidMapping: !0
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new u({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      });
      let y = 1, g = 1, E = "<no source>", S = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, x, v;
      this.stringify(this.root, (P, A, N) => {
        if (this.css += P, A && N !== "end" && (S.generated.line = y, S.generated.column = g - 1, A.source && A.source.start ? (S.source = this.sourcePath(A), S.original.line = A.source.start.line, S.original.column = A.source.start.column - 1, this.map.addMapping(S)) : (S.source = E, S.original.line = 1, S.original.column = 0, this.map.addMapping(S))), v = P.match(/\n/g), v ? (y += v.length, x = P.lastIndexOf(`
`), g = P.length - x) : g += P.length, A && N !== "start") {
          let _ = A.parent || { raws: {} };
          (!(A.type === "decl" || A.type === "atrule" && !A.nodes) || A !== _.last || _.raws.semicolon) && (A.source && A.source.end ? (S.source = this.sourcePath(A), S.original.line = A.source.end.line, S.original.column = A.source.end.column - 1, S.generated.line = y, S.generated.column = g - 2, this.map.addMapping(S)) : (S.source = E, S.original.line = 1, S.original.column = 0, S.generated.line = y, S.generated.column = g - 1, this.map.addMapping(S)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((y) => y.annotation) : !0;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let y = this.mapOpts.annotation;
      return typeof y < "u" && y !== !0 ? !1 : this.previous().length ? this.previous().some((g) => g.inline) : !0;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((y) => y.withContent()) : !0;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(y) {
      if (this.mapOpts.absolute || y.charCodeAt(0) === 60 || /^\w+:\/\//.test(y)) return y;
      let g = this.memoizedPaths.get(y);
      if (g) return g;
      let E = this.opts.to ? t(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (E = t(r(E, this.mapOpts.annotation)));
      let S = e(E, y);
      return this.memoizedPaths.set(y, S), S;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((y) => {
            if (y.source && y.source.input.map) {
              let g = y.source.input.map;
              this.previousMaps.includes(g) || this.previousMaps.push(g);
            }
          });
        else {
          let y = new h(this.originalCSS, this.opts);
          y.map && this.previousMaps.push(y.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let y = {};
      if (this.root)
        this.root.walk((g) => {
          if (g.source) {
            let E = g.source.input.from;
            if (E && !y[E]) {
              y[E] = !0;
              let S = this.usesFileUrls ? this.toFileUrl(E) : this.toUrl(this.path(E));
              this.map.setSourceContent(S, g.source.input.css);
            }
          }
        });
      else if (this.css) {
        let g = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(g, this.css);
      }
    }
    sourcePath(y) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(y.source.input.from) : this.toUrl(this.path(y.source.input.from));
    }
    toBase64(y) {
      return X ? X.from(y).toString("base64") : window.btoa(unescape(encodeURIComponent(y)));
    }
    toFileUrl(y) {
      let g = this.memoizedFileURLs.get(y);
      if (g) return g;
      if (l) {
        let E = l(y).toString();
        return this.memoizedFileURLs.set(y, E), E;
      } else
        throw new Error(
          "`map.absolute` option is not available in this PostCSS build"
        );
    }
    toUrl(y) {
      let g = this.memoizedURLs.get(y);
      if (g) return g;
      i === "\\" && (y = y.replace(/\\/g, "/"));
      let E = encodeURI(y).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(y, E), E;
    }
  }
  return Co = d, Co;
}
var Io, Xf;
function kE() {
  if (Xf) return Io;
  Xf = 1;
  let t = /* @__PURE__ */ Gl(), e = /* @__PURE__ */ Ea(), r = /* @__PURE__ */ Ta(), i = /* @__PURE__ */ li(), n = /* @__PURE__ */ Jl(), u = /* @__PURE__ */ i1();
  const l = {
    empty: !0,
    space: !0
  };
  function h(p) {
    for (let d = p.length - 1; d >= 0; d--) {
      let m = p[d], y = m[3] || m[2];
      if (y) return y;
    }
  }
  class c {
    constructor(d) {
      this.input = d, this.root = new i(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: d, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(d) {
      let m = new t();
      m.name = d[1].slice(1), m.name === "" && this.unnamedAtrule(m, d), this.init(m, d[2]);
      let y, g, E, S = !1, x = !1, v = [], P = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (d = this.tokenizer.nextToken(), y = d[0], y === "(" || y === "[" ? P.push(y === "(" ? ")" : "]") : y === "{" && P.length > 0 ? P.push("}") : y === P[P.length - 1] && P.pop(), P.length === 0)
          if (y === ";") {
            m.source.end = this.getPosition(d[2]), m.source.end.offset++, this.semicolon = !0;
            break;
          } else if (y === "{") {
            x = !0;
            break;
          } else if (y === "}") {
            if (v.length > 0) {
              for (E = v.length - 1, g = v[E]; g && g[0] === "space"; )
                g = v[--E];
              g && (m.source.end = this.getPosition(g[3] || g[2]), m.source.end.offset++);
            }
            this.end(d);
            break;
          } else
            v.push(d);
        else
          v.push(d);
        if (this.tokenizer.endOfFile()) {
          S = !0;
          break;
        }
      }
      m.raws.between = this.spacesAndCommentsFromEnd(v), v.length ? (m.raws.afterName = this.spacesAndCommentsFromStart(v), this.raw(m, "params", v), S && (d = v[v.length - 1], m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++, this.spaces = m.raws.between, m.raws.between = "")) : (m.raws.afterName = "", m.params = ""), x && (m.nodes = [], this.current = m);
    }
    checkMissedSemicolon(d) {
      let m = this.colon(d);
      if (m === !1) return;
      let y = 0, g;
      for (let E = m - 1; E >= 0 && (g = d[E], !(g[0] !== "space" && (y += 1, y === 2))); E--)
        ;
      throw this.input.error(
        "Missed semicolon",
        g[0] === "word" ? g[3] + 1 : g[2]
      );
    }
    colon(d) {
      let m = 0, y, g, E;
      for (let [S, x] of d.entries()) {
        if (g = x, E = g[0], E === "(" && (m += 1), E === ")" && (m -= 1), m === 0 && E === ":")
          if (!y)
            this.doubleColon(g);
          else {
            if (y[0] === "word" && y[1] === "progid")
              continue;
            return S;
          }
        y = g;
      }
      return !1;
    }
    comment(d) {
      let m = new e();
      this.init(m, d[2]), m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++;
      let y = d[1].slice(2, -2);
      if (/^\s*$/.test(y))
        m.text = "", m.raws.left = y, m.raws.right = "";
      else {
        let g = y.match(/^(\s*)([^]*\S)(\s*)$/);
        m.text = g[2], m.raws.left = g[1], m.raws.right = g[3];
      }
    }
    createTokenizer() {
      this.tokenizer = u(this.input);
    }
    decl(d, m) {
      let y = new r();
      this.init(y, d[0][2]);
      let g = d[d.length - 1];
      for (g[0] === ";" && (this.semicolon = !0, d.pop()), y.source.end = this.getPosition(
        g[3] || g[2] || h(d)
      ), y.source.end.offset++; d[0][0] !== "word"; )
        d.length === 1 && this.unknownWord(d), y.raws.before += d.shift()[1];
      for (y.source.start = this.getPosition(d[0][2]), y.prop = ""; d.length; ) {
        let P = d[0][0];
        if (P === ":" || P === "space" || P === "comment")
          break;
        y.prop += d.shift()[1];
      }
      y.raws.between = "";
      let E;
      for (; d.length; )
        if (E = d.shift(), E[0] === ":") {
          y.raws.between += E[1];
          break;
        } else
          E[0] === "word" && /\w/.test(E[1]) && this.unknownWord([E]), y.raws.between += E[1];
      (y.prop[0] === "_" || y.prop[0] === "*") && (y.raws.before += y.prop[0], y.prop = y.prop.slice(1));
      let S = [], x;
      for (; d.length && (x = d[0][0], !(x !== "space" && x !== "comment")); )
        S.push(d.shift());
      this.precheckMissedSemicolon(d);
      for (let P = d.length - 1; P >= 0; P--) {
        if (E = d[P], E[1].toLowerCase() === "!important") {
          y.important = !0;
          let A = this.stringFrom(d, P);
          A = this.spacesFromEnd(d) + A, A !== " !important" && (y.raws.important = A);
          break;
        } else if (E[1].toLowerCase() === "important") {
          let A = d.slice(0), N = "";
          for (let _ = P; _ > 0; _--) {
            let R = A[_][0];
            if (N.trim().startsWith("!") && R !== "space")
              break;
            N = A.pop()[1] + N;
          }
          N.trim().startsWith("!") && (y.important = !0, y.raws.important = N, d = A);
        }
        if (E[0] !== "space" && E[0] !== "comment")
          break;
      }
      d.some((P) => P[0] !== "space" && P[0] !== "comment") && (y.raws.between += S.map((P) => P[1]).join(""), S = []), this.raw(y, "value", S.concat(d), m), y.value.includes(":") && !m && this.checkMissedSemicolon(d);
    }
    doubleColon(d) {
      throw this.input.error(
        "Double colon",
        { offset: d[2] },
        { offset: d[2] + d[1].length }
      );
    }
    emptyRule(d) {
      let m = new n();
      this.init(m, d[2]), m.selector = "", m.raws.between = "", this.current = m;
    }
    end(d) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(d[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(d);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(d) {
      if (this.spaces += d[1], this.current.nodes) {
        let m = this.current.nodes[this.current.nodes.length - 1];
        m && m.type === "rule" && !m.raws.ownSemicolon && (m.raws.ownSemicolon = this.spaces, this.spaces = "", m.source.end = this.getPosition(d[2]), m.source.end.offset += m.raws.ownSemicolon.length);
      }
    }
    // Helpers
    getPosition(d) {
      let m = this.input.fromOffset(d);
      return {
        column: m.col,
        line: m.line,
        offset: d
      };
    }
    init(d, m) {
      this.current.push(d), d.source = {
        input: this.input,
        start: this.getPosition(m)
      }, d.raws.before = this.spaces, this.spaces = "", d.type !== "comment" && (this.semicolon = !1);
    }
    other(d) {
      let m = !1, y = null, g = !1, E = null, S = [], x = d[1].startsWith("--"), v = [], P = d;
      for (; P; ) {
        if (y = P[0], v.push(P), y === "(" || y === "[")
          E || (E = P), S.push(y === "(" ? ")" : "]");
        else if (x && g && y === "{")
          E || (E = P), S.push("}");
        else if (S.length === 0)
          if (y === ";")
            if (g) {
              this.decl(v, x);
              return;
            } else
              break;
          else if (y === "{") {
            this.rule(v);
            return;
          } else if (y === "}") {
            this.tokenizer.back(v.pop()), m = !0;
            break;
          } else y === ":" && (g = !0);
        else y === S[S.length - 1] && (S.pop(), S.length === 0 && (E = null));
        P = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (m = !0), S.length > 0 && this.unclosedBracket(E), m && g) {
        if (!x)
          for (; v.length && (P = v[v.length - 1][0], !(P !== "space" && P !== "comment")); )
            this.tokenizer.back(v.pop());
        this.decl(v, x);
      } else
        this.unknownWord(v);
    }
    parse() {
      let d;
      for (; !this.tokenizer.endOfFile(); )
        switch (d = this.tokenizer.nextToken(), d[0]) {
          case "space":
            this.spaces += d[1];
            break;
          case ";":
            this.freeSemicolon(d);
            break;
          case "}":
            this.end(d);
            break;
          case "comment":
            this.comment(d);
            break;
          case "at-word":
            this.atrule(d);
            break;
          case "{":
            this.emptyRule(d);
            break;
          default:
            this.other(d);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(d, m, y, g) {
      let E, S, x = y.length, v = "", P = !0, A, N;
      for (let _ = 0; _ < x; _ += 1)
        E = y[_], S = E[0], S === "space" && _ === x - 1 && !g ? P = !1 : S === "comment" ? (N = y[_ - 1] ? y[_ - 1][0] : "empty", A = y[_ + 1] ? y[_ + 1][0] : "empty", !l[N] && !l[A] ? v.slice(-1) === "," ? P = !1 : v += E[1] : P = !1) : v += E[1];
      if (!P) {
        let _ = y.reduce((R, M) => R + M[1], "");
        d.raws[m] = { raw: _, value: v };
      }
      d[m] = v;
    }
    rule(d) {
      d.pop();
      let m = new n();
      this.init(m, d[0][2]), m.raws.between = this.spacesAndCommentsFromEnd(d), this.raw(m, "selector", d), this.current = m;
    }
    spacesAndCommentsFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], !(m !== "space" && m !== "comment")); )
        y = d.pop()[1] + y;
      return y;
    }
    // Errors
    spacesAndCommentsFromStart(d) {
      let m, y = "";
      for (; d.length && (m = d[0][0], !(m !== "space" && m !== "comment")); )
        y += d.shift()[1];
      return y;
    }
    spacesFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], m === "space"); )
        y = d.pop()[1] + y;
      return y;
    }
    stringFrom(d, m) {
      let y = "";
      for (let g = m; g < d.length; g++)
        y += d[g][1];
      return d.splice(m, d.length - m), y;
    }
    unclosedBlock() {
      let d = this.current.source.start;
      throw this.input.error("Unclosed block", d.line, d.column);
    }
    unclosedBracket(d) {
      throw this.input.error(
        "Unclosed bracket",
        { offset: d[2] },
        { offset: d[2] + 1 }
      );
    }
    unexpectedClose(d) {
      throw this.input.error(
        "Unexpected }",
        { offset: d[2] },
        { offset: d[2] + 1 }
      );
    }
    unknownWord(d) {
      throw this.input.error(
        "Unknown word " + d[0][1],
        { offset: d[0][2] },
        { offset: d[0][2] + d[0][1].length }
      );
    }
    unnamedAtrule(d, m) {
      throw this.input.error(
        "At-rule without name",
        { offset: m[2] },
        { offset: m[2] + m[1].length }
      );
    }
  }
  return Io = c, Io;
}
var No, Jf;
function Kl() {
  if (Jf) return No;
  Jf = 1;
  let t = /* @__PURE__ */ Br(), e = /* @__PURE__ */ wa(), r = /* @__PURE__ */ kE();
  function i(n, u) {
    let l = new e(n, u), h = new r(l);
    try {
      h.parse();
    } catch (c) {
      throw ft.env.NODE_ENV !== "production" && c.name === "CssSyntaxError" && u && u.from && (/\.scss$/i.test(u.from) ? c.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(u.from) ? c.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(u.from) && (c.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), c;
    }
    return h.root;
  }
  return No = i, i.default = i, t.registerParse(i), No;
}
var Oo, Kf;
function h1() {
  if (Kf) return Oo;
  Kf = 1;
  class t {
    constructor(r, i = {}) {
      if (this.type = "warning", this.text = r, i.node && i.node.source) {
        let n = i.node.rangeBy(i);
        this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
      }
      for (let n in i) this[n] = i[n];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return Oo = t, t.default = t, Oo;
}
var ko, Yf;
function Yl() {
  if (Yf) return ko;
  Yf = 1;
  let t = /* @__PURE__ */ h1();
  class e {
    get content() {
      return this.css;
    }
    constructor(i, n, u) {
      this.processor = i, this.messages = [], this.root = n, this.opts = u, this.css = "", this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(i, n = {}) {
      n.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (n.plugin = this.lastPlugin.postcssPlugin);
      let u = new t(i, n);
      return this.messages.push(u), u;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
  }
  return ko = e, e.default = e, ko;
}
var Lo, Qf;
function f1() {
  if (Qf) return Lo;
  Qf = 1;
  let t = {};
  return Lo = function(r) {
    t[r] || (t[r] = !0, typeof console < "u" && console.warn && console.warn(r));
  }, Lo;
}
var Ro, Zf;
function p1() {
  if (Zf) return Ro;
  Zf = 1;
  let t = /* @__PURE__ */ Br(), e = /* @__PURE__ */ Xl(), r = /* @__PURE__ */ c1(), i = /* @__PURE__ */ Kl(), n = /* @__PURE__ */ Yl(), u = /* @__PURE__ */ li(), l = /* @__PURE__ */ va(), { isClean: h, my: c } = /* @__PURE__ */ Hl(), p = /* @__PURE__ */ f1();
  const d = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, m = {
    AtRule: !0,
    AtRuleExit: !0,
    Comment: !0,
    CommentExit: !0,
    Declaration: !0,
    DeclarationExit: !0,
    Document: !0,
    DocumentExit: !0,
    Once: !0,
    OnceExit: !0,
    postcssPlugin: !0,
    prepare: !0,
    Root: !0,
    RootExit: !0,
    Rule: !0,
    RuleExit: !0
  }, y = {
    Once: !0,
    postcssPlugin: !0,
    prepare: !0
  }, g = 0;
  function E(N) {
    return typeof N == "object" && typeof N.then == "function";
  }
  function S(N) {
    let _ = !1, R = d[N.type];
    return N.type === "decl" ? _ = N.prop.toLowerCase() : N.type === "atrule" && (_ = N.name.toLowerCase()), _ && N.append ? [
      R,
      R + "-" + _,
      g,
      R + "Exit",
      R + "Exit-" + _
    ] : _ ? [R, R + "-" + _, R + "Exit", R + "Exit-" + _] : N.append ? [R, g, R + "Exit"] : [R, R + "Exit"];
  }
  function x(N) {
    let _;
    return N.type === "document" ? _ = ["Document", g, "DocumentExit"] : N.type === "root" ? _ = ["Root", g, "RootExit"] : _ = S(N), {
      eventIndex: 0,
      events: _,
      iterator: 0,
      node: N,
      visitorIndex: 0,
      visitors: []
    };
  }
  function v(N) {
    return N[h] = !1, N.nodes && N.nodes.forEach((_) => v(_)), N;
  }
  let P = {};
  class A {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(_, R, M) {
      this.stringified = !1, this.processed = !1;
      let O;
      if (typeof R == "object" && R !== null && (R.type === "root" || R.type === "document"))
        O = v(R);
      else if (R instanceof A || R instanceof n)
        O = v(R.root), R.map && (typeof M.map > "u" && (M.map = {}), M.map.inline || (M.map.inline = !1), M.map.prev = R.map);
      else {
        let I = i;
        M.syntax && (I = M.syntax.parse), M.parser && (I = M.parser), I.parse && (I = I.parse);
        try {
          O = I(R, M);
        } catch (k) {
          this.processed = !0, this.error = k;
        }
        O && !O[c] && t.rebuild(O);
      }
      this.result = new n(_, O, M), this.helpers = { ...P, postcss: P, result: this.result }, this.plugins = this.processor.plugins.map((I) => typeof I == "object" && I.prepare ? { ...I, ...I.prepare(this.result) } : I);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(_) {
      return this.async().catch(_);
    }
    finally(_) {
      return this.async().then(_, _);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(_, R) {
      let M = this.result.lastPlugin;
      try {
        if (R && R.addToError(_), this.error = _, _.name === "CssSyntaxError" && !_.plugin)
          _.plugin = M.postcssPlugin, _.setMessage();
        else if (M.postcssVersion && ft.env.NODE_ENV !== "production") {
          let O = M.postcssPlugin, I = M.postcssVersion, k = this.result.processor.version, L = I.split("."), V = k.split(".");
          (L[0] !== V[0] || parseInt(L[1]) > parseInt(V[1])) && console.error(
            "Unknown error from PostCSS plugin. Your current PostCSS version is " + k + ", but " + O + " uses " + I + ". Perhaps this is the source of the error below."
          );
        }
      } catch (O) {
        console && console.error && console.error(O);
      }
      return _;
    }
    prepareVisitors() {
      this.listeners = {};
      let _ = (R, M, O) => {
        this.listeners[M] || (this.listeners[M] = []), this.listeners[M].push([R, O]);
      };
      for (let R of this.plugins)
        if (typeof R == "object")
          for (let M in R) {
            if (!m[M] && /^[A-Z]/.test(M))
              throw new Error(
                `Unknown event ${M} in ${R.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
              );
            if (!y[M])
              if (typeof R[M] == "object")
                for (let O in R[M])
                  O === "*" ? _(R, M, R[M][O]) : _(
                    R,
                    M + "-" + O.toLowerCase(),
                    R[M][O]
                  );
              else typeof R[M] == "function" && _(R, M, R[M]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let _ = 0; _ < this.plugins.length; _++) {
        let R = this.plugins[_], M = this.runOnRoot(R);
        if (E(M))
          try {
            await M;
          } catch (O) {
            throw this.handleError(O);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let _ = this.result.root;
        for (; !_[h]; ) {
          _[h] = !0;
          let R = [x(_)];
          for (; R.length > 0; ) {
            let M = this.visitTick(R);
            if (E(M))
              try {
                await M;
              } catch (O) {
                let I = R[R.length - 1].node;
                throw this.handleError(O, I);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [R, M] of this.listeners.OnceExit) {
            this.result.lastPlugin = R;
            try {
              if (_.type === "document") {
                let O = _.nodes.map(
                  (I) => M(I, this.helpers)
                );
                await Promise.all(O);
              } else
                await M(_, this.helpers);
            } catch (O) {
              throw this.handleError(O);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(_) {
      this.result.lastPlugin = _;
      try {
        if (typeof _ == "object" && _.Once) {
          if (this.result.root.type === "document") {
            let R = this.result.root.nodes.map(
              (M) => _.Once(M, this.helpers)
            );
            return E(R[0]) ? Promise.all(R) : R;
          }
          return _.Once(this.result.root, this.helpers);
        } else if (typeof _ == "function")
          return _(this.result.root, this.result);
      } catch (R) {
        throw this.handleError(R);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = !0, this.sync();
      let _ = this.result.opts, R = l;
      _.syntax && (R = _.syntax.stringify), _.stringifier && (R = _.stringifier), R.stringify && (R = R.stringify);
      let O = new r(R, this.result.root, this.result.opts).generate();
      return this.result.css = O[0], this.result.map = O[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let _ of this.plugins) {
        let R = this.runOnRoot(_);
        if (E(R))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let _ = this.result.root;
        for (; !_[h]; )
          _[h] = !0, this.walkSync(_);
        if (this.listeners.OnceExit)
          if (_.type === "document")
            for (let R of _.nodes)
              this.visitSync(this.listeners.OnceExit, R);
          else
            this.visitSync(this.listeners.OnceExit, _);
      }
      return this.result;
    }
    then(_, R) {
      return ft.env.NODE_ENV !== "production" && ("from" in this.opts || p(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(_, R);
    }
    toString() {
      return this.css;
    }
    visitSync(_, R) {
      for (let [M, O] of _) {
        this.result.lastPlugin = M;
        let I;
        try {
          I = O(R, this.helpers);
        } catch (k) {
          throw this.handleError(k, R.proxyOf);
        }
        if (R.type !== "root" && R.type !== "document" && !R.parent)
          return !0;
        if (E(I))
          throw this.getAsyncError();
      }
    }
    visitTick(_) {
      let R = _[_.length - 1], { node: M, visitors: O } = R;
      if (M.type !== "root" && M.type !== "document" && !M.parent) {
        _.pop();
        return;
      }
      if (O.length > 0 && R.visitorIndex < O.length) {
        let [k, L] = O[R.visitorIndex];
        R.visitorIndex += 1, R.visitorIndex === O.length && (R.visitors = [], R.visitorIndex = 0), this.result.lastPlugin = k;
        try {
          return L(M.toProxy(), this.helpers);
        } catch (V) {
          throw this.handleError(V, M);
        }
      }
      if (R.iterator !== 0) {
        let k = R.iterator, L;
        for (; L = M.nodes[M.indexes[k]]; )
          if (M.indexes[k] += 1, !L[h]) {
            L[h] = !0, _.push(x(L));
            return;
          }
        R.iterator = 0, delete M.indexes[k];
      }
      let I = R.events;
      for (; R.eventIndex < I.length; ) {
        let k = I[R.eventIndex];
        if (R.eventIndex += 1, k === g) {
          M.nodes && M.nodes.length && (M[h] = !0, R.iterator = M.getIterator());
          return;
        } else if (this.listeners[k]) {
          R.visitors = this.listeners[k];
          return;
        }
      }
      _.pop();
    }
    walkSync(_) {
      _[h] = !0;
      let R = S(_);
      for (let M of R)
        if (M === g)
          _.nodes && _.each((O) => {
            O[h] || this.walkSync(O);
          });
        else {
          let O = this.listeners[M];
          if (O && this.visitSync(O, _.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return A.registerPostcss = (N) => {
    P = N;
  }, Ro = A, A.default = A, u.registerLazyResult(A), e.registerLazyResult(A), Ro;
}
var Do, ep;
function LE() {
  if (ep) return Do;
  ep = 1;
  let t = /* @__PURE__ */ c1(), e = /* @__PURE__ */ Kl();
  const r = /* @__PURE__ */ Yl();
  let i = /* @__PURE__ */ va(), n = /* @__PURE__ */ f1();
  class u {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let h, c = e;
      try {
        h = c(this._css, this._opts);
      } catch (p) {
        this.error = p;
      }
      if (this.error)
        throw this.error;
      return this._root = h, h;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(h, c, p) {
      c = c.toString(), this.stringified = !1, this._processor = h, this._css = c, this._opts = p, this._map = void 0;
      let d, m = i;
      this.result = new r(this._processor, d, this._opts), this.result.css = c;
      let y = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return y.root;
        }
      });
      let g = new t(m, d, this._opts, c);
      if (g.isMap()) {
        let [E, S] = g.generate();
        E && (this.result.css = E), S && (this.result.map = S);
      } else
        g.clearAnnotation(), this.result.css = g.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(h) {
      return this.async().catch(h);
    }
    finally(h) {
      return this.async().then(h, h);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(h, c) {
      return ft.env.NODE_ENV !== "production" && ("from" in this._opts || n(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(h, c);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Do = u, u.default = u, Do;
}
var Mo, tp;
function RE() {
  if (tp) return Mo;
  tp = 1;
  let t = /* @__PURE__ */ Xl(), e = /* @__PURE__ */ p1(), r = /* @__PURE__ */ LE(), i = /* @__PURE__ */ li();
  class n {
    constructor(l = []) {
      this.version = "8.5.6", this.plugins = this.normalize(l);
    }
    normalize(l) {
      let h = [];
      for (let c of l)
        if (c.postcss === !0 ? c = c() : c.postcss && (c = c.postcss), typeof c == "object" && Array.isArray(c.plugins))
          h = h.concat(c.plugins);
        else if (typeof c == "object" && c.postcssPlugin)
          h.push(c);
        else if (typeof c == "function")
          h.push(c);
        else if (typeof c == "object" && (c.parse || c.stringify)) {
          if (ft.env.NODE_ENV !== "production")
            throw new Error(
              "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
            );
        } else
          throw new Error(c + " is not a PostCSS plugin");
      return h;
    }
    process(l, h = {}) {
      return !this.plugins.length && !h.parser && !h.stringifier && !h.syntax ? new r(this, l, h) : new e(this, l, h);
    }
    use(l) {
      return this.plugins = this.plugins.concat(this.normalize([l])), this;
    }
  }
  return Mo = n, n.default = n, i.registerProcessor(n), t.registerProcessor(n), Mo;
}
var Fo, rp;
function DE() {
  if (rp) return Fo;
  rp = 1;
  let t = /* @__PURE__ */ Gl(), e = /* @__PURE__ */ Ea(), r = /* @__PURE__ */ Br(), i = /* @__PURE__ */ Wl(), n = /* @__PURE__ */ Ta(), u = /* @__PURE__ */ Xl(), l = /* @__PURE__ */ OE(), h = /* @__PURE__ */ wa(), c = /* @__PURE__ */ p1(), p = /* @__PURE__ */ l1(), d = /* @__PURE__ */ xa(), m = /* @__PURE__ */ Kl(), y = /* @__PURE__ */ RE(), g = /* @__PURE__ */ Yl(), E = /* @__PURE__ */ li(), S = /* @__PURE__ */ Jl(), x = /* @__PURE__ */ va(), v = /* @__PURE__ */ h1();
  function P(...A) {
    return A.length === 1 && Array.isArray(A[0]) && (A = A[0]), new y(A);
  }
  return P.plugin = function(N, _) {
    let R = !1;
    function M(...I) {
      console && console.warn && !R && (R = !0, console.warn(
        N + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
      ), ft.env.LANG && ft.env.LANG.startsWith("cn") && console.warn(
        N + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
      ));
      let k = _(...I);
      return k.postcssPlugin = N, k.postcssVersion = new y().version, k;
    }
    let O;
    return Object.defineProperty(M, "postcss", {
      get() {
        return O || (O = M()), O;
      }
    }), M.process = function(I, k, L) {
      return P([M(L)]).process(I, k);
    }, M;
  }, P.stringify = x, P.parse = m, P.fromJSON = l, P.list = p, P.comment = (A) => new e(A), P.atRule = (A) => new t(A), P.decl = (A) => new n(A), P.rule = (A) => new S(A), P.root = (A) => new E(A), P.document = (A) => new u(A), P.CssSyntaxError = i, P.Declaration = n, P.Container = r, P.Processor = y, P.Document = u, P.Comment = e, P.Warning = v, P.AtRule = t, P.Result = g, P.Input = h, P.Rule = S, P.Root = E, P.Node = d, c.registerPostcss(P), Fo = P, P.default = P, Fo;
}
var ME = /* @__PURE__ */ DE(), Oe = /* @__PURE__ */ Zn(ME);
Oe.stringify;
Oe.fromJSON;
Oe.plugin;
Oe.parse;
Oe.list;
Oe.document;
Oe.comment;
Oe.atRule;
Oe.rule;
Oe.decl;
Oe.root;
Oe.CssSyntaxError;
Oe.Declaration;
Oe.Container;
Oe.Processor;
Oe.Document;
Oe.Comment;
Oe.Warning;
Oe.AtRule;
Oe.Result;
Oe.Input;
const FE = Oe.Rule;
Oe.Root;
Oe.Node;
const d1 = () => ({
  postcssPlugin: "vue-sfc-trim",
  Once(t) {
    t.walk(({ type: e, raws: r }) => {
      (e === "rule" || e === "atrule") && (r.before && (r.before = `
`), "after" in r && r.after && (r.after = `
`));
    });
  }
});
d1.postcss = !0;
var Ni = { exports: {} }, Oi = { exports: {} }, ki = { exports: {} }, Li = { exports: {} }, Ri = { exports: {} }, Di = { exports: {} }, wt = {}, Mi = { exports: {} }, sp;
function m1() {
  return sp || (sp = 1, function(t, e) {
    e.__esModule = !0, e.default = n;
    function r(u) {
      for (var l = u.toLowerCase(), h = "", c = !1, p = 0; p < 6 && l[p] !== void 0; p++) {
        var d = l.charCodeAt(p), m = d >= 97 && d <= 102 || d >= 48 && d <= 57;
        if (c = d === 32, !m)
          break;
        h += l[p];
      }
      if (h.length !== 0) {
        var y = parseInt(h, 16), g = y >= 55296 && y <= 57343;
        return g || y === 0 || y > 1114111 ? ["�", h.length + (c ? 1 : 0)] : [String.fromCodePoint(y), h.length + (c ? 1 : 0)];
      }
    }
    var i = /\\/;
    function n(u) {
      var l = i.test(u);
      if (!l)
        return u;
      for (var h = "", c = 0; c < u.length; c++) {
        if (u[c] === "\\") {
          var p = r(u.slice(c + 1, c + 7));
          if (p !== void 0) {
            h += p[0], c += p[1];
            continue;
          }
          if (u[c + 1] === "\\") {
            h += "\\", c++;
            continue;
          }
          u.length === c + 1 && (h += u[c]);
          continue;
        }
        h += u[c];
      }
      return h;
    }
    t.exports = e.default;
  }(Mi, Mi.exports)), Mi.exports;
}
var Fi = { exports: {} }, ip;
function BE() {
  return ip || (ip = 1, function(t, e) {
    e.__esModule = !0, e.default = r;
    function r(i) {
      for (var n = arguments.length, u = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
        u[l - 1] = arguments[l];
      for (; u.length > 0; ) {
        var h = u.shift();
        if (!i[h])
          return;
        i = i[h];
      }
      return i;
    }
    t.exports = e.default;
  }(Fi, Fi.exports)), Fi.exports;
}
var Bi = { exports: {} }, np;
function $E() {
  return np || (np = 1, function(t, e) {
    e.__esModule = !0, e.default = r;
    function r(i) {
      for (var n = arguments.length, u = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
        u[l - 1] = arguments[l];
      for (; u.length > 0; ) {
        var h = u.shift();
        i[h] || (i[h] = {}), i = i[h];
      }
    }
    t.exports = e.default;
  }(Bi, Bi.exports)), Bi.exports;
}
var $i = { exports: {} }, ap;
function UE() {
  return ap || (ap = 1, function(t, e) {
    e.__esModule = !0, e.default = r;
    function r(i) {
      for (var n = "", u = i.indexOf("/*"), l = 0; u >= 0; ) {
        n = n + i.slice(l, u);
        var h = i.indexOf("*/", u + 2);
        if (h < 0)
          return n;
        l = h + 2, u = i.indexOf("/*", l);
      }
      return n = n + i.slice(l), n;
    }
    t.exports = e.default;
  }($i, $i.exports)), $i.exports;
}
var op;
function Pa() {
  if (op) return wt;
  op = 1, wt.__esModule = !0, wt.unesc = wt.stripComments = wt.getProp = wt.ensureObject = void 0;
  var t = n(/* @__PURE__ */ m1());
  wt.unesc = t.default;
  var e = n(/* @__PURE__ */ BE());
  wt.getProp = e.default;
  var r = n(/* @__PURE__ */ $E());
  wt.ensureObject = r.default;
  var i = n(/* @__PURE__ */ UE());
  wt.stripComments = i.default;
  function n(u) {
    return u && u.__esModule ? u : { default: u };
  }
  return wt;
}
var up;
function mr() {
  return up || (up = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = /* @__PURE__ */ Pa();
    function i(h, c) {
      for (var p = 0; p < c.length; p++) {
        var d = c[p];
        d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(h, d.key, d);
      }
    }
    function n(h, c, p) {
      return c && i(h.prototype, c), Object.defineProperty(h, "prototype", { writable: !1 }), h;
    }
    var u = function h(c, p) {
      if (typeof c != "object" || c === null)
        return c;
      var d = new c.constructor();
      for (var m in c)
        if (c.hasOwnProperty(m)) {
          var y = c[m], g = typeof y;
          m === "parent" && g === "object" ? p && (d[m] = p) : y instanceof Array ? d[m] = y.map(function(E) {
            return h(E, d);
          }) : d[m] = h(y, d);
        }
      return d;
    }, l = /* @__PURE__ */ function() {
      function h(p) {
        p === void 0 && (p = {}), Object.assign(this, p), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var c = h.prototype;
      return c.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, c.replaceWith = function() {
        if (this.parent) {
          for (var d in arguments)
            this.parent.insertBefore(this, arguments[d]);
          this.remove();
        }
        return this;
      }, c.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, c.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, c.clone = function(d) {
        d === void 0 && (d = {});
        var m = u(this);
        for (var y in d)
          m[y] = d[y];
        return m;
      }, c.appendToPropertyAndEscape = function(d, m, y) {
        this.raws || (this.raws = {});
        var g = this[d], E = this.raws[d];
        this[d] = g + m, E || y !== m ? this.raws[d] = (E || g) + y : delete this.raws[d];
      }, c.setPropertyAndEscape = function(d, m, y) {
        this.raws || (this.raws = {}), this[d] = m, this.raws[d] = y;
      }, c.setPropertyWithoutEscape = function(d, m) {
        this[d] = m, this.raws && delete this.raws[d];
      }, c.isAtPosition = function(d, m) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > d || this.source.end.line < d || this.source.start.line === d && this.source.start.column > m || this.source.end.line === d && this.source.end.column < m);
      }, c.stringifyProperty = function(d) {
        return this.raws && this.raws[d] || this[d];
      }, c.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, c.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, n(h, [{
        key: "rawSpaceBefore",
        get: function() {
          var d = this.raws && this.raws.spaces && this.raws.spaces.before;
          return d === void 0 && (d = this.spaces && this.spaces.before), d || "";
        },
        set: function(d) {
          (0, r.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = d;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var d = this.raws && this.raws.spaces && this.raws.spaces.after;
          return d === void 0 && (d = this.spaces.after), d || "";
        },
        set: function(d) {
          (0, r.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = d;
        }
      }]), h;
    }();
    e.default = l, t.exports = e.default;
  }(Di, Di.exports)), Di.exports;
}
var Ae = {}, lp;
function et() {
  if (lp) return Ae;
  lp = 1, Ae.__esModule = !0, Ae.UNIVERSAL = Ae.TAG = Ae.STRING = Ae.SELECTOR = Ae.ROOT = Ae.PSEUDO = Ae.NESTING = Ae.ID = Ae.COMMENT = Ae.COMBINATOR = Ae.CLASS = Ae.ATTRIBUTE = void 0;
  var t = "tag";
  Ae.TAG = t;
  var e = "string";
  Ae.STRING = e;
  var r = "selector";
  Ae.SELECTOR = r;
  var i = "root";
  Ae.ROOT = i;
  var n = "pseudo";
  Ae.PSEUDO = n;
  var u = "nesting";
  Ae.NESTING = u;
  var l = "id";
  Ae.ID = l;
  var h = "comment";
  Ae.COMMENT = h;
  var c = "combinator";
  Ae.COMBINATOR = c;
  var p = "class";
  Ae.CLASS = p;
  var d = "attribute";
  Ae.ATTRIBUTE = d;
  var m = "universal";
  return Ae.UNIVERSAL = m, Ae;
}
var cp;
function Ql() {
  return cp || (cp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = l(/* @__PURE__ */ mr()), i = u(/* @__PURE__ */ et());
    function n(S) {
      if (typeof WeakMap != "function") return null;
      var x = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
      return (n = function(A) {
        return A ? v : x;
      })(S);
    }
    function u(S, x) {
      if (S && S.__esModule)
        return S;
      if (S === null || typeof S != "object" && typeof S != "function")
        return { default: S };
      var v = n(x);
      if (v && v.has(S))
        return v.get(S);
      var P = {}, A = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var N in S)
        if (N !== "default" && Object.prototype.hasOwnProperty.call(S, N)) {
          var _ = A ? Object.getOwnPropertyDescriptor(S, N) : null;
          _ && (_.get || _.set) ? Object.defineProperty(P, N, _) : P[N] = S[N];
        }
      return P.default = S, v && v.set(S, P), P;
    }
    function l(S) {
      return S && S.__esModule ? S : { default: S };
    }
    function h(S, x) {
      var v = typeof Symbol < "u" && S[Symbol.iterator] || S["@@iterator"];
      if (v) return (v = v.call(S)).next.bind(v);
      if (Array.isArray(S) || (v = c(S)) || x) {
        v && (S = v);
        var P = 0;
        return function() {
          return P >= S.length ? { done: !0 } : { done: !1, value: S[P++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function c(S, x) {
      if (S) {
        if (typeof S == "string") return p(S, x);
        var v = Object.prototype.toString.call(S).slice(8, -1);
        if (v === "Object" && S.constructor && (v = S.constructor.name), v === "Map" || v === "Set") return Array.from(S);
        if (v === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(v)) return p(S, x);
      }
    }
    function p(S, x) {
      (x == null || x > S.length) && (x = S.length);
      for (var v = 0, P = new Array(x); v < x; v++)
        P[v] = S[v];
      return P;
    }
    function d(S, x) {
      for (var v = 0; v < x.length; v++) {
        var P = x[v];
        P.enumerable = P.enumerable || !1, P.configurable = !0, "value" in P && (P.writable = !0), Object.defineProperty(S, P.key, P);
      }
    }
    function m(S, x, v) {
      return x && d(S.prototype, x), Object.defineProperty(S, "prototype", { writable: !1 }), S;
    }
    function y(S, x) {
      S.prototype = Object.create(x.prototype), S.prototype.constructor = S, g(S, x);
    }
    function g(S, x) {
      return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(P, A) {
        return P.__proto__ = A, P;
      }, g(S, x);
    }
    var E = /* @__PURE__ */ function(S) {
      y(x, S);
      function x(P) {
        var A;
        return A = S.call(this, P) || this, A.nodes || (A.nodes = []), A;
      }
      var v = x.prototype;
      return v.append = function(A) {
        return A.parent = this, this.nodes.push(A), this;
      }, v.prepend = function(A) {
        A.parent = this, this.nodes.unshift(A);
        for (var N in this.indexes)
          this.indexes[N]++;
        return this;
      }, v.at = function(A) {
        return this.nodes[A];
      }, v.index = function(A) {
        return typeof A == "number" ? A : this.nodes.indexOf(A);
      }, v.removeChild = function(A) {
        A = this.index(A), this.at(A).parent = void 0, this.nodes.splice(A, 1);
        var N;
        for (var _ in this.indexes)
          N = this.indexes[_], N >= A && (this.indexes[_] = N - 1);
        return this;
      }, v.removeAll = function() {
        for (var A = h(this.nodes), N; !(N = A()).done; ) {
          var _ = N.value;
          _.parent = void 0;
        }
        return this.nodes = [], this;
      }, v.empty = function() {
        return this.removeAll();
      }, v.insertAfter = function(A, N) {
        var _;
        N.parent = this;
        for (var R = this.index(A), M = [], O = 2; O < arguments.length; O++)
          M.push(arguments[O]);
        (_ = this.nodes).splice.apply(_, [R + 1, 0, N].concat(M)), N.parent = this;
        var I;
        for (var k in this.indexes)
          I = this.indexes[k], R < I && (this.indexes[k] = I + arguments.length - 1);
        return this;
      }, v.insertBefore = function(A, N) {
        var _;
        N.parent = this;
        for (var R = this.index(A), M = [], O = 2; O < arguments.length; O++)
          M.push(arguments[O]);
        (_ = this.nodes).splice.apply(_, [R, 0, N].concat(M)), N.parent = this;
        var I;
        for (var k in this.indexes)
          I = this.indexes[k], I >= R && (this.indexes[k] = I + arguments.length - 1);
        return this;
      }, v._findChildAtPosition = function(A, N) {
        var _ = void 0;
        return this.each(function(R) {
          if (R.atPosition) {
            var M = R.atPosition(A, N);
            if (M)
              return _ = M, !1;
          } else if (R.isAtPosition(A, N))
            return _ = R, !1;
        }), _;
      }, v.atPosition = function(A, N) {
        if (this.isAtPosition(A, N))
          return this._findChildAtPosition(A, N) || this;
      }, v._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, v.each = function(A) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var N = this.lastEach;
        if (this.indexes[N] = 0, !!this.length) {
          for (var _, R; this.indexes[N] < this.length && (_ = this.indexes[N], R = A(this.at(_), _), R !== !1); )
            this.indexes[N] += 1;
          if (delete this.indexes[N], R === !1)
            return !1;
        }
      }, v.walk = function(A) {
        return this.each(function(N, _) {
          var R = A(N, _);
          if (R !== !1 && N.length && (R = N.walk(A)), R === !1)
            return !1;
        });
      }, v.walkAttributes = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.ATTRIBUTE)
            return A.call(N, _);
        });
      }, v.walkClasses = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.CLASS)
            return A.call(N, _);
        });
      }, v.walkCombinators = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.COMBINATOR)
            return A.call(N, _);
        });
      }, v.walkComments = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.COMMENT)
            return A.call(N, _);
        });
      }, v.walkIds = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.ID)
            return A.call(N, _);
        });
      }, v.walkNesting = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.NESTING)
            return A.call(N, _);
        });
      }, v.walkPseudos = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.PSEUDO)
            return A.call(N, _);
        });
      }, v.walkTags = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.TAG)
            return A.call(N, _);
        });
      }, v.walkUniversals = function(A) {
        var N = this;
        return this.walk(function(_) {
          if (_.type === i.UNIVERSAL)
            return A.call(N, _);
        });
      }, v.split = function(A) {
        var N = this, _ = [];
        return this.reduce(function(R, M, O) {
          var I = A.call(N, M);
          return _.push(M), I ? (R.push(_), _ = []) : O === N.length - 1 && R.push(_), R;
        }, []);
      }, v.map = function(A) {
        return this.nodes.map(A);
      }, v.reduce = function(A, N) {
        return this.nodes.reduce(A, N);
      }, v.every = function(A) {
        return this.nodes.every(A);
      }, v.some = function(A) {
        return this.nodes.some(A);
      }, v.filter = function(A) {
        return this.nodes.filter(A);
      }, v.sort = function(A) {
        return this.nodes.sort(A);
      }, v.toString = function() {
        return this.map(String).join("");
      }, m(x, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), x;
    }(r.default);
    e.default = E, t.exports = e.default;
  }(Ri, Ri.exports)), Ri.exports;
}
var hp;
function y1() {
  return hp || (hp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ Ql()), i = /* @__PURE__ */ et();
    function n(d) {
      return d && d.__esModule ? d : { default: d };
    }
    function u(d, m) {
      for (var y = 0; y < m.length; y++) {
        var g = m[y];
        g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(d, g.key, g);
      }
    }
    function l(d, m, y) {
      return m && u(d.prototype, m), Object.defineProperty(d, "prototype", { writable: !1 }), d;
    }
    function h(d, m) {
      d.prototype = Object.create(m.prototype), d.prototype.constructor = d, c(d, m);
    }
    function c(d, m) {
      return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(g, E) {
        return g.__proto__ = E, g;
      }, c(d, m);
    }
    var p = /* @__PURE__ */ function(d) {
      h(m, d);
      function m(g) {
        var E;
        return E = d.call(this, g) || this, E.type = i.ROOT, E;
      }
      var y = m.prototype;
      return y.toString = function() {
        var E = this.reduce(function(S, x) {
          return S.push(String(x)), S;
        }, []).join(",");
        return this.trailingComma ? E + "," : E;
      }, y.error = function(E, S) {
        return this._error ? this._error(E, S) : new Error(E);
      }, l(m, [{
        key: "errorGenerator",
        set: function(E) {
          this._error = E;
        }
      }]), m;
    }(r.default);
    e.default = p, t.exports = e.default;
  }(Li, Li.exports)), Li.exports;
}
var Ui = { exports: {} }, fp;
function g1() {
  return fp || (fp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ Ql()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.SELECTOR, m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Ui, Ui.exports)), Ui.exports;
}
var qi = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var Bo, pp;
function Zl() {
  if (pp) return Bo;
  pp = 1;
  var t = {}, e = t.hasOwnProperty, r = function(c, p) {
    if (!c)
      return p;
    var d = {};
    for (var m in p)
      d[m] = e.call(c, m) ? c[m] : p[m];
    return d;
  }, i = /[ -,\.\/:-@\[-\^`\{-~]/, n = /[ -,\.\/:-@\[\]\^`\{-~]/, u = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, l = function h(c, p) {
    p = r(p, h.options), p.quotes != "single" && p.quotes != "double" && (p.quotes = "single");
    for (var d = p.quotes == "double" ? '"' : "'", m = p.isIdentifier, y = c.charAt(0), g = "", E = 0, S = c.length; E < S; ) {
      var x = c.charAt(E++), v = x.charCodeAt(), P = void 0;
      if (v < 32 || v > 126) {
        if (v >= 55296 && v <= 56319 && E < S) {
          var A = c.charCodeAt(E++);
          (A & 64512) == 56320 ? v = ((v & 1023) << 10) + (A & 1023) + 65536 : E--;
        }
        P = "\\" + v.toString(16).toUpperCase() + " ";
      } else
        p.escapeEverything ? i.test(x) ? P = "\\" + x : P = "\\" + v.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(x) ? P = "\\" + v.toString(16).toUpperCase() + " " : x == "\\" || !m && (x == '"' && d == x || x == "'" && d == x) || m && n.test(x) ? P = "\\" + x : P = x;
      g += P;
    }
    return m && (/^-[-\d]/.test(g) ? g = "\\-" + g.slice(1) : /\d/.test(y) && (g = "\\3" + y + " " + g.slice(1))), g = g.replace(u, function(N, _, R) {
      return _ && _.length % 2 ? N : (_ || "") + R;
    }), !m && p.wrap ? d + g + d : g;
  };
  return l.options = {
    escapeEverything: !1,
    isIdentifier: !1,
    quotes: "single",
    wrap: !1
  }, l.version = "3.0.0", Bo = l, Bo;
}
var dp;
function b1() {
  return dp || (dp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = l(/* @__PURE__ */ Zl()), i = /* @__PURE__ */ Pa(), n = l(/* @__PURE__ */ mr()), u = /* @__PURE__ */ et();
    function l(y) {
      return y && y.__esModule ? y : { default: y };
    }
    function h(y, g) {
      for (var E = 0; E < g.length; E++) {
        var S = g[E];
        S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(y, S.key, S);
      }
    }
    function c(y, g, E) {
      return g && h(y.prototype, g), Object.defineProperty(y, "prototype", { writable: !1 }), y;
    }
    function p(y, g) {
      y.prototype = Object.create(g.prototype), y.prototype.constructor = y, d(y, g);
    }
    function d(y, g) {
      return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, x) {
        return S.__proto__ = x, S;
      }, d(y, g);
    }
    var m = /* @__PURE__ */ function(y) {
      p(g, y);
      function g(S) {
        var x;
        return x = y.call(this, S) || this, x.type = u.CLASS, x._constructed = !0, x;
      }
      var E = g.prototype;
      return E.valueToString = function() {
        return "." + y.prototype.valueToString.call(this);
      }, c(g, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(x) {
          if (this._constructed) {
            var v = (0, r.default)(x, {
              isIdentifier: !0
            });
            v !== x ? ((0, i.ensureObject)(this, "raws"), this.raws.value = v) : this.raws && delete this.raws.value;
          }
          this._value = x;
        }
      }]), g;
    }(n.default);
    e.default = m, t.exports = e.default;
  }(qi, qi.exports)), qi.exports;
}
var ji = { exports: {} }, mp;
function S1() {
  return mp || (mp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ mr()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.COMMENT, m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(ji, ji.exports)), ji.exports;
}
var Vi = { exports: {} }, yp;
function v1() {
  return yp || (yp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ mr()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(m) {
        var y;
        return y = c.call(this, m) || this, y.type = i.ID, y;
      }
      var d = p.prototype;
      return d.valueToString = function() {
        return "#" + c.prototype.valueToString.call(this);
      }, p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Vi, Vi.exports)), Vi.exports;
}
var zi = { exports: {} }, Wi = { exports: {} }, gp;
function ec() {
  return gp || (gp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = u(/* @__PURE__ */ Zl()), i = /* @__PURE__ */ Pa(), n = u(/* @__PURE__ */ mr());
    function u(m) {
      return m && m.__esModule ? m : { default: m };
    }
    function l(m, y) {
      for (var g = 0; g < y.length; g++) {
        var E = y[g];
        E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(m, E.key, E);
      }
    }
    function h(m, y, g) {
      return y && l(m.prototype, y), Object.defineProperty(m, "prototype", { writable: !1 }), m;
    }
    function c(m, y) {
      m.prototype = Object.create(y.prototype), m.prototype.constructor = m, p(m, y);
    }
    function p(m, y) {
      return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E, S) {
        return E.__proto__ = S, E;
      }, p(m, y);
    }
    var d = /* @__PURE__ */ function(m) {
      c(y, m);
      function y() {
        return m.apply(this, arguments) || this;
      }
      var g = y.prototype;
      return g.qualifiedName = function(S) {
        return this.namespace ? this.namespaceString + "|" + S : S;
      }, g.valueToString = function() {
        return this.qualifiedName(m.prototype.valueToString.call(this));
      }, h(y, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(S) {
          if (S === !0 || S === "*" || S === "&") {
            this._namespace = S, this.raws && delete this.raws.namespace;
            return;
          }
          var x = (0, r.default)(S, {
            isIdentifier: !0
          });
          this._namespace = S, x !== S ? ((0, i.ensureObject)(this, "raws"), this.raws.namespace = x) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(S) {
          this.namespace = S;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var S = this.stringifyProperty("namespace");
            return S === !0 ? "" : S;
          } else
            return "";
        }
      }]), y;
    }(n.default);
    e.default = d, t.exports = e.default;
  }(Wi, Wi.exports)), Wi.exports;
}
var bp;
function x1() {
  return bp || (bp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ ec()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.TAG, m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(zi, zi.exports)), zi.exports;
}
var Hi = { exports: {} }, Sp;
function E1() {
  return Sp || (Sp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ mr()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.STRING, m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Hi, Hi.exports)), Hi.exports;
}
var Gi = { exports: {} }, vp;
function T1() {
  return vp || (vp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ Ql()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(m) {
        var y;
        return y = c.call(this, m) || this, y.type = i.PSEUDO, y;
      }
      var d = p.prototype;
      return d.toString = function() {
        var y = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), y, this.rawSpaceAfter].join("");
      }, p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Gi, Gi.exports)), Gi.exports;
}
var $o = {}, Uo, xp;
function qE() {
  return xp || (xp = 1, Uo = xE.deprecate), Uo;
}
var Ep;
function w1() {
  return Ep || (Ep = 1, function(t) {
    t.__esModule = !0, t.default = void 0, t.unescapeValue = x;
    var e = l(/* @__PURE__ */ Zl()), r = l(/* @__PURE__ */ m1()), i = l(/* @__PURE__ */ ec()), n = /* @__PURE__ */ et(), u;
    function l(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    function h(_, R) {
      for (var M = 0; M < R.length; M++) {
        var O = R[M];
        O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(_, O.key, O);
      }
    }
    function c(_, R, M) {
      return R && h(_.prototype, R), Object.defineProperty(_, "prototype", { writable: !1 }), _;
    }
    function p(_, R) {
      _.prototype = Object.create(R.prototype), _.prototype.constructor = _, d(_, R);
    }
    function d(_, R) {
      return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(O, I) {
        return O.__proto__ = I, O;
      }, d(_, R);
    }
    var m = /* @__PURE__ */ qE(), y = /^('|")([^]*)\1$/, g = m(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), E = m(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), S = m(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function x(_) {
      var R = !1, M = null, O = _, I = O.match(y);
      return I && (M = I[1], O = I[2]), O = (0, r.default)(O), O !== _ && (R = !0), {
        deprecatedUsage: R,
        unescaped: O,
        quoteMark: M
      };
    }
    function v(_) {
      if (_.quoteMark !== void 0 || _.value === void 0)
        return _;
      S();
      var R = x(_.value), M = R.quoteMark, O = R.unescaped;
      return _.raws || (_.raws = {}), _.raws.value === void 0 && (_.raws.value = _.value), _.value = O, _.quoteMark = M, _;
    }
    var P = /* @__PURE__ */ function(_) {
      p(R, _);
      function R(O) {
        var I;
        return O === void 0 && (O = {}), I = _.call(this, v(O)) || this, I.type = n.ATTRIBUTE, I.raws = I.raws || {}, Object.defineProperty(I.raws, "unquoted", {
          get: m(function() {
            return I.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: m(function() {
            return I.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), I._constructed = !0, I;
      }
      var M = R.prototype;
      return M.getQuotedValue = function(I) {
        I === void 0 && (I = {});
        var k = this._determineQuoteMark(I), L = A[k], V = (0, e.default)(this._value, L);
        return V;
      }, M._determineQuoteMark = function(I) {
        return I.smart ? this.smartQuoteMark(I) : this.preferredQuoteMark(I);
      }, M.setValue = function(I, k) {
        k === void 0 && (k = {}), this._value = I, this._quoteMark = this._determineQuoteMark(k), this._syncRawValue();
      }, M.smartQuoteMark = function(I) {
        var k = this.value, L = k.replace(/[^']/g, "").length, V = k.replace(/[^"]/g, "").length;
        if (L + V === 0) {
          var K = (0, e.default)(k, {
            isIdentifier: !0
          });
          if (K === k)
            return R.NO_QUOTE;
          var re = this.preferredQuoteMark(I);
          if (re === R.NO_QUOTE) {
            var z = this.quoteMark || I.quoteMark || R.DOUBLE_QUOTE, se = A[z], he = (0, e.default)(k, se);
            if (he.length < K.length)
              return z;
          }
          return re;
        } else return V === L ? this.preferredQuoteMark(I) : V < L ? R.DOUBLE_QUOTE : R.SINGLE_QUOTE;
      }, M.preferredQuoteMark = function(I) {
        var k = I.preferCurrentQuoteMark ? this.quoteMark : I.quoteMark;
        return k === void 0 && (k = I.preferCurrentQuoteMark ? I.quoteMark : this.quoteMark), k === void 0 && (k = R.DOUBLE_QUOTE), k;
      }, M._syncRawValue = function() {
        var I = (0, e.default)(this._value, A[this.quoteMark]);
        I === this._value ? this.raws && delete this.raws.value : this.raws.value = I;
      }, M._handleEscapes = function(I, k) {
        if (this._constructed) {
          var L = (0, e.default)(k, {
            isIdentifier: !0
          });
          L !== k ? this.raws[I] = L : delete this.raws[I];
        }
      }, M._spacesFor = function(I) {
        var k = {
          before: "",
          after: ""
        }, L = this.spaces[I] || {}, V = this.raws.spaces && this.raws.spaces[I] || {};
        return Object.assign(k, L, V);
      }, M._stringFor = function(I, k, L) {
        k === void 0 && (k = I), L === void 0 && (L = N);
        var V = this._spacesFor(k);
        return L(this.stringifyProperty(I), V);
      }, M.offsetOf = function(I) {
        var k = 1, L = this._spacesFor("attribute");
        if (k += L.before.length, I === "namespace" || I === "ns")
          return this.namespace ? k : -1;
        if (I === "attributeNS" || (k += this.namespaceString.length, this.namespace && (k += 1), I === "attribute"))
          return k;
        k += this.stringifyProperty("attribute").length, k += L.after.length;
        var V = this._spacesFor("operator");
        k += V.before.length;
        var K = this.stringifyProperty("operator");
        if (I === "operator")
          return K ? k : -1;
        k += K.length, k += V.after.length;
        var re = this._spacesFor("value");
        k += re.before.length;
        var z = this.stringifyProperty("value");
        if (I === "value")
          return z ? k : -1;
        k += z.length, k += re.after.length;
        var se = this._spacesFor("insensitive");
        return k += se.before.length, I === "insensitive" && this.insensitive ? k : -1;
      }, M.toString = function() {
        var I = this, k = [this.rawSpaceBefore, "["];
        return k.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k.push(this._stringFor("operator")), k.push(this._stringFor("value")), k.push(this._stringFor("insensitiveFlag", "insensitive", function(L, V) {
          return L.length > 0 && !I.quoted && V.before.length === 0 && !(I.spaces.value && I.spaces.value.after) && (V.before = " "), N(L, V);
        }))), k.push("]"), k.push(this.rawSpaceAfter), k.join("");
      }, c(R, [{
        key: "quoted",
        get: function() {
          var I = this.quoteMark;
          return I === "'" || I === '"';
        },
        set: function(I) {
          E();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(I) {
          if (!this._constructed) {
            this._quoteMark = I;
            return;
          }
          this._quoteMark !== I && (this._quoteMark = I, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function(I) {
            if (this._constructed) {
              var k = x(I), L = k.deprecatedUsage, V = k.unescaped, K = k.quoteMark;
              if (L && g(), V === this._value && K === this._quoteMark)
                return;
              this._value = V, this._quoteMark = K, this._syncRawValue();
            } else
              this._value = I;
          }
        )
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(I) {
          I || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = I;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(I) {
          this._handleEscapes("attribute", I), this._attribute = I;
        }
      }]), R;
    }(i.default);
    t.default = P, P.NO_QUOTE = null, P.SINGLE_QUOTE = "'", P.DOUBLE_QUOTE = '"';
    var A = (u = {
      "'": {
        quotes: "single",
        wrap: !0
      },
      '"': {
        quotes: "double",
        wrap: !0
      }
    }, u[null] = {
      isIdentifier: !0
    }, u);
    function N(_, R) {
      return "" + R.before + _ + R.after;
    }
  }($o)), $o;
}
var Xi = { exports: {} }, Tp;
function P1() {
  return Tp || (Tp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ ec()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.UNIVERSAL, m.value = "*", m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Xi, Xi.exports)), Xi.exports;
}
var Ji = { exports: {} }, wp;
function _1() {
  return wp || (wp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ mr()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.COMBINATOR, m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Ji, Ji.exports)), Ji.exports;
}
var Ki = { exports: {} }, Pp;
function A1() {
  return Pp || (Pp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = n(/* @__PURE__ */ mr()), i = /* @__PURE__ */ et();
    function n(c) {
      return c && c.__esModule ? c : { default: c };
    }
    function u(c, p) {
      c.prototype = Object.create(p.prototype), c.prototype.constructor = c, l(c, p);
    }
    function l(c, p) {
      return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, l(c, p);
    }
    var h = /* @__PURE__ */ function(c) {
      u(p, c);
      function p(d) {
        var m;
        return m = c.call(this, d) || this, m.type = i.NESTING, m.value = "&", m;
      }
      return p;
    }(r.default);
    e.default = h, t.exports = e.default;
  }(Ki, Ki.exports)), Ki.exports;
}
var Yi = { exports: {} }, _p;
function jE() {
  return _p || (_p = 1, function(t, e) {
    e.__esModule = !0, e.default = r;
    function r(i) {
      return i.sort(function(n, u) {
        return n - u;
      });
    }
    t.exports = e.default;
  }(Yi, Yi.exports)), Yi.exports;
}
var qo = {}, ue = {}, Ap;
function C1() {
  if (Ap) return ue;
  Ap = 1, ue.__esModule = !0, ue.word = ue.tilde = ue.tab = ue.str = ue.space = ue.slash = ue.singleQuote = ue.semicolon = ue.plus = ue.pipe = ue.openSquare = ue.openParenthesis = ue.newline = ue.greaterThan = ue.feed = ue.equals = ue.doubleQuote = ue.dollar = ue.cr = ue.comment = ue.comma = ue.combinator = ue.colon = ue.closeSquare = ue.closeParenthesis = ue.caret = ue.bang = ue.backslash = ue.at = ue.asterisk = ue.ampersand = void 0;
  var t = 38;
  ue.ampersand = t;
  var e = 42;
  ue.asterisk = e;
  var r = 64;
  ue.at = r;
  var i = 44;
  ue.comma = i;
  var n = 58;
  ue.colon = n;
  var u = 59;
  ue.semicolon = u;
  var l = 40;
  ue.openParenthesis = l;
  var h = 41;
  ue.closeParenthesis = h;
  var c = 91;
  ue.openSquare = c;
  var p = 93;
  ue.closeSquare = p;
  var d = 36;
  ue.dollar = d;
  var m = 126;
  ue.tilde = m;
  var y = 94;
  ue.caret = y;
  var g = 43;
  ue.plus = g;
  var E = 61;
  ue.equals = E;
  var S = 124;
  ue.pipe = S;
  var x = 62;
  ue.greaterThan = x;
  var v = 32;
  ue.space = v;
  var P = 39;
  ue.singleQuote = P;
  var A = 34;
  ue.doubleQuote = A;
  var N = 47;
  ue.slash = N;
  var _ = 33;
  ue.bang = _;
  var R = 92;
  ue.backslash = R;
  var M = 13;
  ue.cr = M;
  var O = 12;
  ue.feed = O;
  var I = 10;
  ue.newline = I;
  var k = 9;
  ue.tab = k;
  var L = P;
  ue.str = L;
  var V = -1;
  ue.comment = V;
  var K = -2;
  ue.word = K;
  var re = -3;
  return ue.combinator = re, ue;
}
var Cp;
function VE() {
  return Cp || (Cp = 1, function(t) {
    t.__esModule = !0, t.FIELDS = void 0, t.default = E;
    var e = u(/* @__PURE__ */ C1()), r, i;
    function n(S) {
      if (typeof WeakMap != "function") return null;
      var x = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
      return (n = function(A) {
        return A ? v : x;
      })(S);
    }
    function u(S, x) {
      if (S && S.__esModule)
        return S;
      if (S === null || typeof S != "object" && typeof S != "function")
        return { default: S };
      var v = n(x);
      if (v && v.has(S))
        return v.get(S);
      var P = {}, A = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var N in S)
        if (N !== "default" && Object.prototype.hasOwnProperty.call(S, N)) {
          var _ = A ? Object.getOwnPropertyDescriptor(S, N) : null;
          _ && (_.get || _.set) ? Object.defineProperty(P, N, _) : P[N] = S[N];
        }
      return P.default = S, v && v.set(S, P), P;
    }
    for (var l = (r = {}, r[e.tab] = !0, r[e.newline] = !0, r[e.cr] = !0, r[e.feed] = !0, r), h = (i = {}, i[e.space] = !0, i[e.tab] = !0, i[e.newline] = !0, i[e.cr] = !0, i[e.feed] = !0, i[e.ampersand] = !0, i[e.asterisk] = !0, i[e.bang] = !0, i[e.comma] = !0, i[e.colon] = !0, i[e.semicolon] = !0, i[e.openParenthesis] = !0, i[e.closeParenthesis] = !0, i[e.openSquare] = !0, i[e.closeSquare] = !0, i[e.singleQuote] = !0, i[e.doubleQuote] = !0, i[e.plus] = !0, i[e.pipe] = !0, i[e.tilde] = !0, i[e.greaterThan] = !0, i[e.equals] = !0, i[e.dollar] = !0, i[e.caret] = !0, i[e.slash] = !0, i), c = {}, p = "0123456789abcdefABCDEF", d = 0; d < p.length; d++)
      c[p.charCodeAt(d)] = !0;
    function m(S, x) {
      var v = x, P;
      do {
        if (P = S.charCodeAt(v), h[P])
          return v - 1;
        P === e.backslash ? v = y(S, v) + 1 : v++;
      } while (v < S.length);
      return v - 1;
    }
    function y(S, x) {
      var v = x, P = S.charCodeAt(v + 1);
      if (!l[P]) if (c[P]) {
        var A = 0;
        do
          v++, A++, P = S.charCodeAt(v + 1);
        while (c[P] && A < 6);
        A < 6 && P === e.space && v++;
      } else
        v++;
      return v;
    }
    var g = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    t.FIELDS = g;
    function E(S) {
      var x = [], v = S.css.valueOf(), P = v, A = P.length, N = -1, _ = 1, R = 0, M = 0, O, I, k, L, V, K, re, z, se, he, ne, ge, be;
      function Y(ie, H) {
        if (S.safe)
          v += H, se = v.length - 1;
        else
          throw S.error("Unclosed " + ie, _, R - N, R);
      }
      for (; R < A; ) {
        switch (O = v.charCodeAt(R), O === e.newline && (N = R, _ += 1), O) {
          case e.space:
          case e.tab:
          case e.newline:
          case e.cr:
          case e.feed:
            se = R;
            do
              se += 1, O = v.charCodeAt(se), O === e.newline && (N = se, _ += 1);
            while (O === e.space || O === e.newline || O === e.tab || O === e.cr || O === e.feed);
            be = e.space, L = _, k = se - N - 1, M = se;
            break;
          case e.plus:
          case e.greaterThan:
          case e.tilde:
          case e.pipe:
            se = R;
            do
              se += 1, O = v.charCodeAt(se);
            while (O === e.plus || O === e.greaterThan || O === e.tilde || O === e.pipe);
            be = e.combinator, L = _, k = R - N, M = se;
            break;
          case e.asterisk:
          case e.ampersand:
          case e.bang:
          case e.comma:
          case e.equals:
          case e.dollar:
          case e.caret:
          case e.openSquare:
          case e.closeSquare:
          case e.colon:
          case e.semicolon:
          case e.openParenthesis:
          case e.closeParenthesis:
            se = R, be = O, L = _, k = R - N, M = se + 1;
            break;
          case e.singleQuote:
          case e.doubleQuote:
            ge = O === e.singleQuote ? "'" : '"', se = R;
            do
              for (V = !1, se = v.indexOf(ge, se + 1), se === -1 && Y("quote", ge), K = se; v.charCodeAt(K - 1) === e.backslash; )
                K -= 1, V = !V;
            while (V);
            be = e.str, L = _, k = R - N, M = se + 1;
            break;
          default:
            O === e.slash && v.charCodeAt(R + 1) === e.asterisk ? (se = v.indexOf("*/", R + 2) + 1, se === 0 && Y("comment", "*/"), I = v.slice(R, se + 1), z = I.split(`
`), re = z.length - 1, re > 0 ? (he = _ + re, ne = se - z[re].length) : (he = _, ne = N), be = e.comment, _ = he, L = he, k = se - ne) : O === e.slash ? (se = R, be = O, L = _, k = R - N, M = se + 1) : (se = m(v, R), be = e.word, L = _, k = se - N), M = se + 1;
            break;
        }
        x.push([
          be,
          // [0] Token type
          _,
          // [1] Starting line
          R - N,
          // [2] Starting column
          L,
          // [3] Ending line
          k,
          // [4] Ending column
          R,
          // [5] Start position / Source index
          M
          // [6] End position
        ]), ne && (N = ne, ne = null), R = M;
      }
      return x;
    }
  }(qo)), qo;
}
var Ip;
function zE() {
  return Ip || (Ip = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = M(/* @__PURE__ */ y1()), i = M(/* @__PURE__ */ g1()), n = M(/* @__PURE__ */ b1()), u = M(/* @__PURE__ */ S1()), l = M(/* @__PURE__ */ v1()), h = M(/* @__PURE__ */ x1()), c = M(/* @__PURE__ */ E1()), p = M(/* @__PURE__ */ T1()), d = R(/* @__PURE__ */ w1()), m = M(/* @__PURE__ */ P1()), y = M(/* @__PURE__ */ _1()), g = M(/* @__PURE__ */ A1()), E = M(/* @__PURE__ */ jE()), S = R(/* @__PURE__ */ VE()), x = R(/* @__PURE__ */ C1()), v = R(/* @__PURE__ */ et()), P = /* @__PURE__ */ Pa(), A, N;
    function _(Y) {
      if (typeof WeakMap != "function") return null;
      var ie = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap();
      return (_ = function(U) {
        return U ? H : ie;
      })(Y);
    }
    function R(Y, ie) {
      if (Y && Y.__esModule)
        return Y;
      if (Y === null || typeof Y != "object" && typeof Y != "function")
        return { default: Y };
      var H = _(ie);
      if (H && H.has(Y))
        return H.get(Y);
      var j = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var G in Y)
        if (G !== "default" && Object.prototype.hasOwnProperty.call(Y, G)) {
          var B = U ? Object.getOwnPropertyDescriptor(Y, G) : null;
          B && (B.get || B.set) ? Object.defineProperty(j, G, B) : j[G] = Y[G];
        }
      return j.default = Y, H && H.set(Y, j), j;
    }
    function M(Y) {
      return Y && Y.__esModule ? Y : { default: Y };
    }
    function O(Y, ie) {
      for (var H = 0; H < ie.length; H++) {
        var j = ie[H];
        j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(Y, j.key, j);
      }
    }
    function I(Y, ie, H) {
      return ie && O(Y.prototype, ie), Object.defineProperty(Y, "prototype", { writable: !1 }), Y;
    }
    var k = (A = {}, A[x.space] = !0, A[x.cr] = !0, A[x.feed] = !0, A[x.newline] = !0, A[x.tab] = !0, A), L = Object.assign({}, k, (N = {}, N[x.comment] = !0, N));
    function V(Y) {
      return {
        line: Y[S.FIELDS.START_LINE],
        column: Y[S.FIELDS.START_COL]
      };
    }
    function K(Y) {
      return {
        line: Y[S.FIELDS.END_LINE],
        column: Y[S.FIELDS.END_COL]
      };
    }
    function re(Y, ie, H, j) {
      return {
        start: {
          line: Y,
          column: ie
        },
        end: {
          line: H,
          column: j
        }
      };
    }
    function z(Y) {
      return re(Y[S.FIELDS.START_LINE], Y[S.FIELDS.START_COL], Y[S.FIELDS.END_LINE], Y[S.FIELDS.END_COL]);
    }
    function se(Y, ie) {
      if (Y)
        return re(Y[S.FIELDS.START_LINE], Y[S.FIELDS.START_COL], ie[S.FIELDS.END_LINE], ie[S.FIELDS.END_COL]);
    }
    function he(Y, ie) {
      var H = Y[ie];
      if (typeof H == "string")
        return H.indexOf("\\") !== -1 && ((0, P.ensureObject)(Y, "raws"), Y[ie] = (0, P.unesc)(H), Y.raws[ie] === void 0 && (Y.raws[ie] = H)), Y;
    }
    function ne(Y, ie) {
      for (var H = -1, j = []; (H = Y.indexOf(ie, H + 1)) !== -1; )
        j.push(H);
      return j;
    }
    function ge() {
      var Y = Array.prototype.concat.apply([], arguments);
      return Y.filter(function(ie, H) {
        return H === Y.indexOf(ie);
      });
    }
    var be = /* @__PURE__ */ function() {
      function Y(H, j) {
        j === void 0 && (j = {}), this.rule = H, this.options = Object.assign({
          lossy: !1,
          safe: !1
        }, j), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, S.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var U = se(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new r.default({
          source: U
        }), this.root.errorGenerator = this._errorGenerator();
        var G = new i.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(G), this.current = G, this.loop();
      }
      var ie = Y.prototype;
      return ie._errorGenerator = function() {
        var j = this;
        return function(U, G) {
          return typeof j.rule == "string" ? new Error(U) : j.rule.error(U, G);
        };
      }, ie.attribute = function() {
        var j = [], U = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[S.FIELDS.TYPE] !== x.closeSquare; )
          j.push(this.currToken), this.position++;
        if (this.currToken[S.FIELDS.TYPE] !== x.closeSquare)
          return this.expected("closing square bracket", this.currToken[S.FIELDS.START_POS]);
        var G = j.length, B = {
          source: re(U[1], U[2], this.currToken[3], this.currToken[4]),
          sourceIndex: U[S.FIELDS.START_POS]
        };
        if (G === 1 && !~[x.word].indexOf(j[0][S.FIELDS.TYPE]))
          return this.expected("attribute", j[0][S.FIELDS.START_POS]);
        for (var W = 0, ce = "", Q = "", Z = null, le = !1; W < G; ) {
          var ve = j[W], de = this.content(ve), we = j[W + 1];
          switch (ve[S.FIELDS.TYPE]) {
            case x.space:
              if (le = !0, this.options.lossy)
                break;
              if (Z) {
                (0, P.ensureObject)(B, "spaces", Z);
                var it = B.spaces[Z].after || "";
                B.spaces[Z].after = it + de;
                var dt = (0, P.getProp)(B, "raws", "spaces", Z, "after") || null;
                dt && (B.raws.spaces[Z].after = dt + de);
              } else
                ce = ce + de, Q = Q + de;
              break;
            case x.asterisk:
              if (we[S.FIELDS.TYPE] === x.equals)
                B.operator = de, Z = "operator";
              else if ((!B.namespace || Z === "namespace" && !le) && we) {
                ce && ((0, P.ensureObject)(B, "spaces", "attribute"), B.spaces.attribute.before = ce, ce = ""), Q && ((0, P.ensureObject)(B, "raws", "spaces", "attribute"), B.raws.spaces.attribute.before = ce, Q = ""), B.namespace = (B.namespace || "") + de;
                var tt = (0, P.getProp)(B, "raws", "namespace") || null;
                tt && (B.raws.namespace += de), Z = "namespace";
              }
              le = !1;
              break;
            case x.dollar:
              if (Z === "value") {
                var Be = (0, P.getProp)(B, "raws", "value");
                B.value += "$", Be && (B.raws.value = Be + "$");
                break;
              }
            case x.caret:
              we[S.FIELDS.TYPE] === x.equals && (B.operator = de, Z = "operator"), le = !1;
              break;
            case x.combinator:
              if (de === "~" && we[S.FIELDS.TYPE] === x.equals && (B.operator = de, Z = "operator"), de !== "|") {
                le = !1;
                break;
              }
              we[S.FIELDS.TYPE] === x.equals ? (B.operator = de, Z = "operator") : !B.namespace && !B.attribute && (B.namespace = !0), le = !1;
              break;
            case x.word:
              if (we && this.content(we) === "|" && j[W + 2] && j[W + 2][S.FIELDS.TYPE] !== x.equals && // this look-ahead probably fails with comment nodes involved.
              !B.operator && !B.namespace)
                B.namespace = de, Z = "namespace";
              else if (!B.attribute || Z === "attribute" && !le) {
                ce && ((0, P.ensureObject)(B, "spaces", "attribute"), B.spaces.attribute.before = ce, ce = ""), Q && ((0, P.ensureObject)(B, "raws", "spaces", "attribute"), B.raws.spaces.attribute.before = Q, Q = ""), B.attribute = (B.attribute || "") + de;
                var mt = (0, P.getProp)(B, "raws", "attribute") || null;
                mt && (B.raws.attribute += de), Z = "attribute";
              } else if (!B.value && B.value !== "" || Z === "value" && !(le || B.quoteMark)) {
                var yt = (0, P.unesc)(de), Nt = (0, P.getProp)(B, "raws", "value") || "", $r = B.value || "";
                B.value = $r + yt, B.quoteMark = null, (yt !== de || Nt) && ((0, P.ensureObject)(B, "raws"), B.raws.value = (Nt || $r) + de), Z = "value";
              } else {
                var Ur = de === "i" || de === "I";
                (B.value || B.value === "") && (B.quoteMark || le) ? (B.insensitive = Ur, (!Ur || de === "I") && ((0, P.ensureObject)(B, "raws"), B.raws.insensitiveFlag = de), Z = "insensitive", ce && ((0, P.ensureObject)(B, "spaces", "insensitive"), B.spaces.insensitive.before = ce, ce = ""), Q && ((0, P.ensureObject)(B, "raws", "spaces", "insensitive"), B.raws.spaces.insensitive.before = Q, Q = "")) : (B.value || B.value === "") && (Z = "value", B.value += de, B.raws.value && (B.raws.value += de));
              }
              le = !1;
              break;
            case x.str:
              if (!B.attribute || !B.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: ve[S.FIELDS.START_POS]
                });
              var nt = (0, d.unescapeValue)(de), qr = nt.unescaped, Ia = nt.quoteMark;
              B.value = qr, B.quoteMark = Ia, Z = "value", (0, P.ensureObject)(B, "raws"), B.raws.value = de, le = !1;
              break;
            case x.equals:
              if (!B.attribute)
                return this.expected("attribute", ve[S.FIELDS.START_POS], de);
              if (B.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: ve[S.FIELDS.START_POS]
                });
              B.operator = B.operator ? B.operator + de : de, Z = "operator", le = !1;
              break;
            case x.comment:
              if (Z)
                if (le || we && we[S.FIELDS.TYPE] === x.space || Z === "insensitive") {
                  var jr = (0, P.getProp)(B, "spaces", Z, "after") || "", Tt = (0, P.getProp)(B, "raws", "spaces", Z, "after") || jr;
                  (0, P.ensureObject)(B, "raws", "spaces", Z), B.raws.spaces[Z].after = Tt + de;
                } else {
                  var Ss = B[Z] || "", fi = (0, P.getProp)(B, "raws", Z) || Ss;
                  (0, P.ensureObject)(B, "raws"), B.raws[Z] = fi + de;
                }
              else
                Q = Q + de;
              break;
            default:
              return this.error('Unexpected "' + de + '" found.', {
                index: ve[S.FIELDS.START_POS]
              });
          }
          W++;
        }
        he(B, "attribute"), he(B, "namespace"), this.newNode(new d.default(B)), this.position++;
      }, ie.parseWhitespaceEquivalentTokens = function(j) {
        j < 0 && (j = this.tokens.length);
        var U = this.position, G = [], B = "", W = void 0;
        do
          if (k[this.currToken[S.FIELDS.TYPE]])
            this.options.lossy || (B += this.content());
          else if (this.currToken[S.FIELDS.TYPE] === x.comment) {
            var ce = {};
            B && (ce.before = B, B = ""), W = new u.default({
              value: this.content(),
              source: z(this.currToken),
              sourceIndex: this.currToken[S.FIELDS.START_POS],
              spaces: ce
            }), G.push(W);
          }
        while (++this.position < j);
        if (B) {
          if (W)
            W.spaces.after = B;
          else if (!this.options.lossy) {
            var Q = this.tokens[U], Z = this.tokens[this.position - 1];
            G.push(new c.default({
              value: "",
              source: re(Q[S.FIELDS.START_LINE], Q[S.FIELDS.START_COL], Z[S.FIELDS.END_LINE], Z[S.FIELDS.END_COL]),
              sourceIndex: Q[S.FIELDS.START_POS],
              spaces: {
                before: B,
                after: ""
              }
            }));
          }
        }
        return G;
      }, ie.convertWhitespaceNodesToSpace = function(j, U) {
        var G = this;
        U === void 0 && (U = !1);
        var B = "", W = "";
        j.forEach(function(Q) {
          var Z = G.lossySpace(Q.spaces.before, U), le = G.lossySpace(Q.rawSpaceBefore, U);
          B += Z + G.lossySpace(Q.spaces.after, U && Z.length === 0), W += Z + Q.value + G.lossySpace(Q.rawSpaceAfter, U && le.length === 0);
        }), W === B && (W = void 0);
        var ce = {
          space: B,
          rawSpace: W
        };
        return ce;
      }, ie.isNamedCombinator = function(j) {
        return j === void 0 && (j = this.position), this.tokens[j + 0] && this.tokens[j + 0][S.FIELDS.TYPE] === x.slash && this.tokens[j + 1] && this.tokens[j + 1][S.FIELDS.TYPE] === x.word && this.tokens[j + 2] && this.tokens[j + 2][S.FIELDS.TYPE] === x.slash;
      }, ie.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var j = this.content(this.tokens[this.position + 1]), U = (0, P.unesc)(j).toLowerCase(), G = {};
          U !== j && (G.value = "/" + j + "/");
          var B = new y.default({
            value: "/" + U + "/",
            source: re(this.currToken[S.FIELDS.START_LINE], this.currToken[S.FIELDS.START_COL], this.tokens[this.position + 2][S.FIELDS.END_LINE], this.tokens[this.position + 2][S.FIELDS.END_COL]),
            sourceIndex: this.currToken[S.FIELDS.START_POS],
            raws: G
          });
          return this.position = this.position + 3, B;
        } else
          this.unexpected();
      }, ie.combinator = function() {
        var j = this;
        if (this.content() === "|")
          return this.namespace();
        var U = this.locateNextMeaningfulToken(this.position);
        if (U < 0 || this.tokens[U][S.FIELDS.TYPE] === x.comma || this.tokens[U][S.FIELDS.TYPE] === x.closeParenthesis) {
          var G = this.parseWhitespaceEquivalentTokens(U);
          if (G.length > 0) {
            var B = this.current.last;
            if (B) {
              var W = this.convertWhitespaceNodesToSpace(G), ce = W.space, Q = W.rawSpace;
              Q !== void 0 && (B.rawSpaceAfter += Q), B.spaces.after += ce;
            } else
              G.forEach(function(Nt) {
                return j.newNode(Nt);
              });
          }
          return;
        }
        var Z = this.currToken, le = void 0;
        U > this.position && (le = this.parseWhitespaceEquivalentTokens(U));
        var ve;
        if (this.isNamedCombinator() ? ve = this.namedCombinator() : this.currToken[S.FIELDS.TYPE] === x.combinator ? (ve = new y.default({
          value: this.content(),
          source: z(this.currToken),
          sourceIndex: this.currToken[S.FIELDS.START_POS]
        }), this.position++) : k[this.currToken[S.FIELDS.TYPE]] || le || this.unexpected(), ve) {
          if (le) {
            var de = this.convertWhitespaceNodesToSpace(le), we = de.space, it = de.rawSpace;
            ve.spaces.before = we, ve.rawSpaceBefore = it;
          }
        } else {
          var dt = this.convertWhitespaceNodesToSpace(le, !0), tt = dt.space, Be = dt.rawSpace;
          Be || (Be = tt);
          var mt = {}, yt = {
            spaces: {}
          };
          tt.endsWith(" ") && Be.endsWith(" ") ? (mt.before = tt.slice(0, tt.length - 1), yt.spaces.before = Be.slice(0, Be.length - 1)) : tt.startsWith(" ") && Be.startsWith(" ") ? (mt.after = tt.slice(1), yt.spaces.after = Be.slice(1)) : yt.value = Be, ve = new y.default({
            value: " ",
            source: se(Z, this.tokens[this.position - 1]),
            sourceIndex: Z[S.FIELDS.START_POS],
            spaces: mt,
            raws: yt
          });
        }
        return this.currToken && this.currToken[S.FIELDS.TYPE] === x.space && (ve.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(ve);
      }, ie.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = !0, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var j = new i.default({
          source: {
            start: V(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][S.FIELDS.START_POS]
        });
        this.current.parent.append(j), this.current = j, this.position++;
      }, ie.comment = function() {
        var j = this.currToken;
        this.newNode(new u.default({
          value: this.content(),
          source: z(j),
          sourceIndex: j[S.FIELDS.START_POS]
        })), this.position++;
      }, ie.error = function(j, U) {
        throw this.root.error(j, U);
      }, ie.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[S.FIELDS.START_POS]
        });
      }, ie.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[S.FIELDS.START_POS]);
      }, ie.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[S.FIELDS.START_POS]);
      }, ie.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[S.FIELDS.START_POS]);
      }, ie.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[S.FIELDS.START_POS]);
      }, ie.namespace = function() {
        var j = this.prevToken && this.content(this.prevToken) || !0;
        if (this.nextToken[S.FIELDS.TYPE] === x.word)
          return this.position++, this.word(j);
        if (this.nextToken[S.FIELDS.TYPE] === x.asterisk)
          return this.position++, this.universal(j);
        this.unexpectedPipe();
      }, ie.nesting = function() {
        if (this.nextToken) {
          var j = this.content(this.nextToken);
          if (j === "|") {
            this.position++;
            return;
          }
        }
        var U = this.currToken;
        this.newNode(new g.default({
          value: this.content(),
          source: z(U),
          sourceIndex: U[S.FIELDS.START_POS]
        })), this.position++;
      }, ie.parentheses = function() {
        var j = this.current.last, U = 1;
        if (this.position++, j && j.type === v.PSEUDO) {
          var G = new i.default({
            source: {
              start: V(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][S.FIELDS.START_POS]
          }), B = this.current;
          for (j.append(G), this.current = G; this.position < this.tokens.length && U; )
            this.currToken[S.FIELDS.TYPE] === x.openParenthesis && U++, this.currToken[S.FIELDS.TYPE] === x.closeParenthesis && U--, U ? this.parse() : (this.current.source.end = K(this.currToken), this.current.parent.source.end = K(this.currToken), this.position++);
          this.current = B;
        } else {
          for (var W = this.currToken, ce = "(", Q; this.position < this.tokens.length && U; )
            this.currToken[S.FIELDS.TYPE] === x.openParenthesis && U++, this.currToken[S.FIELDS.TYPE] === x.closeParenthesis && U--, Q = this.currToken, ce += this.parseParenthesisToken(this.currToken), this.position++;
          j ? j.appendToPropertyAndEscape("value", ce, ce) : this.newNode(new c.default({
            value: ce,
            source: re(W[S.FIELDS.START_LINE], W[S.FIELDS.START_COL], Q[S.FIELDS.END_LINE], Q[S.FIELDS.END_COL]),
            sourceIndex: W[S.FIELDS.START_POS]
          }));
        }
        if (U)
          return this.expected("closing parenthesis", this.currToken[S.FIELDS.START_POS]);
      }, ie.pseudo = function() {
        for (var j = this, U = "", G = this.currToken; this.currToken && this.currToken[S.FIELDS.TYPE] === x.colon; )
          U += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[S.FIELDS.TYPE] === x.word)
          this.splitWord(!1, function(B, W) {
            U += B, j.newNode(new p.default({
              value: U,
              source: se(G, j.currToken),
              sourceIndex: G[S.FIELDS.START_POS]
            })), W > 1 && j.nextToken && j.nextToken[S.FIELDS.TYPE] === x.openParenthesis && j.error("Misplaced parenthesis.", {
              index: j.nextToken[S.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[S.FIELDS.START_POS]);
      }, ie.space = function() {
        var j = this.content();
        this.position === 0 || this.prevToken[S.FIELDS.TYPE] === x.comma || this.prevToken[S.FIELDS.TYPE] === x.openParenthesis || this.current.nodes.every(function(U) {
          return U.type === "comment";
        }) ? (this.spaces = this.optionalSpace(j), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[S.FIELDS.TYPE] === x.comma || this.nextToken[S.FIELDS.TYPE] === x.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(j), this.position++) : this.combinator();
      }, ie.string = function() {
        var j = this.currToken;
        this.newNode(new c.default({
          value: this.content(),
          source: z(j),
          sourceIndex: j[S.FIELDS.START_POS]
        })), this.position++;
      }, ie.universal = function(j) {
        var U = this.nextToken;
        if (U && this.content(U) === "|")
          return this.position++, this.namespace();
        var G = this.currToken;
        this.newNode(new m.default({
          value: this.content(),
          source: z(G),
          sourceIndex: G[S.FIELDS.START_POS]
        }), j), this.position++;
      }, ie.splitWord = function(j, U) {
        for (var G = this, B = this.nextToken, W = this.content(); B && ~[x.dollar, x.caret, x.equals, x.word].indexOf(B[S.FIELDS.TYPE]); ) {
          this.position++;
          var ce = this.content();
          if (W += ce, ce.lastIndexOf("\\") === ce.length - 1) {
            var Q = this.nextToken;
            Q && Q[S.FIELDS.TYPE] === x.space && (W += this.requiredSpace(this.content(Q)), this.position++);
          }
          B = this.nextToken;
        }
        var Z = ne(W, ".").filter(function(we) {
          var it = W[we - 1] === "\\", dt = /^\d+\.\d+%$/.test(W);
          return !it && !dt;
        }), le = ne(W, "#").filter(function(we) {
          return W[we - 1] !== "\\";
        }), ve = ne(W, "#{");
        ve.length && (le = le.filter(function(we) {
          return !~ve.indexOf(we);
        }));
        var de = (0, E.default)(ge([0].concat(Z, le)));
        de.forEach(function(we, it) {
          var dt = de[it + 1] || W.length, tt = W.slice(we, dt);
          if (it === 0 && U)
            return U.call(G, tt, de.length);
          var Be, mt = G.currToken, yt = mt[S.FIELDS.START_POS] + de[it], Nt = re(mt[1], mt[2] + we, mt[3], mt[2] + (dt - 1));
          if (~Z.indexOf(we)) {
            var $r = {
              value: tt.slice(1),
              source: Nt,
              sourceIndex: yt
            };
            Be = new n.default(he($r, "value"));
          } else if (~le.indexOf(we)) {
            var Ur = {
              value: tt.slice(1),
              source: Nt,
              sourceIndex: yt
            };
            Be = new l.default(he(Ur, "value"));
          } else {
            var nt = {
              value: tt,
              source: Nt,
              sourceIndex: yt
            };
            he(nt, "value"), Be = new h.default(nt);
          }
          G.newNode(Be, j), j = null;
        }), this.position++;
      }, ie.word = function(j) {
        var U = this.nextToken;
        return U && this.content(U) === "|" ? (this.position++, this.namespace()) : this.splitWord(j);
      }, ie.loop = function() {
        for (; this.position < this.tokens.length; )
          this.parse(!0);
        return this.current._inferEndPosition(), this.root;
      }, ie.parse = function(j) {
        switch (this.currToken[S.FIELDS.TYPE]) {
          case x.space:
            this.space();
            break;
          case x.comment:
            this.comment();
            break;
          case x.openParenthesis:
            this.parentheses();
            break;
          case x.closeParenthesis:
            j && this.missingParenthesis();
            break;
          case x.openSquare:
            this.attribute();
            break;
          case x.dollar:
          case x.caret:
          case x.equals:
          case x.word:
            this.word();
            break;
          case x.colon:
            this.pseudo();
            break;
          case x.comma:
            this.comma();
            break;
          case x.asterisk:
            this.universal();
            break;
          case x.ampersand:
            this.nesting();
            break;
          case x.slash:
          case x.combinator:
            this.combinator();
            break;
          case x.str:
            this.string();
            break;
          case x.closeSquare:
            this.missingSquareBracket();
          case x.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, ie.expected = function(j, U, G) {
        if (Array.isArray(j)) {
          var B = j.pop();
          j = j.join(", ") + " or " + B;
        }
        var W = /^[aeiou]/.test(j[0]) ? "an" : "a";
        return G ? this.error("Expected " + W + " " + j + ', found "' + G + '" instead.', {
          index: U
        }) : this.error("Expected " + W + " " + j + ".", {
          index: U
        });
      }, ie.requiredSpace = function(j) {
        return this.options.lossy ? " " : j;
      }, ie.optionalSpace = function(j) {
        return this.options.lossy ? "" : j;
      }, ie.lossySpace = function(j, U) {
        return this.options.lossy ? U ? " " : "" : j;
      }, ie.parseParenthesisToken = function(j) {
        var U = this.content(j);
        return j[S.FIELDS.TYPE] === x.space ? this.requiredSpace(U) : U;
      }, ie.newNode = function(j, U) {
        return U && (/^ +$/.test(U) && (this.options.lossy || (this.spaces = (this.spaces || "") + U), U = !0), j.namespace = U, he(j, "namespace")), this.spaces && (j.spaces.before = this.spaces, this.spaces = ""), this.current.append(j);
      }, ie.content = function(j) {
        return j === void 0 && (j = this.currToken), this.css.slice(j[S.FIELDS.START_POS], j[S.FIELDS.END_POS]);
      }, ie.locateNextMeaningfulToken = function(j) {
        j === void 0 && (j = this.position + 1);
        for (var U = j; U < this.tokens.length; )
          if (L[this.tokens[U][S.FIELDS.TYPE]]) {
            U++;
            continue;
          } else
            return U;
        return -1;
      }, I(Y, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), Y;
    }();
    e.default = be, t.exports = e.default;
  }(ki, ki.exports)), ki.exports;
}
var Np;
function WE() {
  return Np || (Np = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = i(/* @__PURE__ */ zE());
    function i(u) {
      return u && u.__esModule ? u : { default: u };
    }
    var n = /* @__PURE__ */ function() {
      function u(h, c) {
        this.func = h || function() {
        }, this.funcRes = null, this.options = c;
      }
      var l = u.prototype;
      return l._shouldUpdateSelector = function(c, p) {
        p === void 0 && (p = {});
        var d = Object.assign({}, this.options, p);
        return d.updateSelector === !1 ? !1 : typeof c != "string";
      }, l._isLossy = function(c) {
        c === void 0 && (c = {});
        var p = Object.assign({}, this.options, c);
        return p.lossless === !1;
      }, l._root = function(c, p) {
        p === void 0 && (p = {});
        var d = new r.default(c, this._parseOptions(p));
        return d.root;
      }, l._parseOptions = function(c) {
        return {
          lossy: this._isLossy(c)
        };
      }, l._run = function(c, p) {
        var d = this;
        return p === void 0 && (p = {}), new Promise(function(m, y) {
          try {
            var g = d._root(c, p);
            Promise.resolve(d.func(g)).then(function(E) {
              var S = void 0;
              return d._shouldUpdateSelector(c, p) && (S = g.toString(), c.selector = S), {
                transform: E,
                root: g,
                string: S
              };
            }).then(m, y);
          } catch (E) {
            y(E);
            return;
          }
        });
      }, l._runSync = function(c, p) {
        p === void 0 && (p = {});
        var d = this._root(c, p), m = this.func(d);
        if (m && typeof m.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var y = void 0;
        return p.updateSelector && typeof c != "string" && (y = d.toString(), c.selector = y), {
          transform: m,
          root: d,
          string: y
        };
      }, l.ast = function(c, p) {
        return this._run(c, p).then(function(d) {
          return d.root;
        });
      }, l.astSync = function(c, p) {
        return this._runSync(c, p).root;
      }, l.transform = function(c, p) {
        return this._run(c, p).then(function(d) {
          return d.transform;
        });
      }, l.transformSync = function(c, p) {
        return this._runSync(c, p).transform;
      }, l.process = function(c, p) {
        return this._run(c, p).then(function(d) {
          return d.string || d.root.toString();
        });
      }, l.processSync = function(c, p) {
        var d = this._runSync(c, p);
        return d.string || d.root.toString();
      }, u;
    }();
    e.default = n, t.exports = e.default;
  }(Oi, Oi.exports)), Oi.exports;
}
var jo = {}, Ce = {}, Op;
function HE() {
  if (Op) return Ce;
  Op = 1, Ce.__esModule = !0, Ce.universal = Ce.tag = Ce.string = Ce.selector = Ce.root = Ce.pseudo = Ce.nesting = Ce.id = Ce.comment = Ce.combinator = Ce.className = Ce.attribute = void 0;
  var t = y(/* @__PURE__ */ w1()), e = y(/* @__PURE__ */ b1()), r = y(/* @__PURE__ */ _1()), i = y(/* @__PURE__ */ S1()), n = y(/* @__PURE__ */ v1()), u = y(/* @__PURE__ */ A1()), l = y(/* @__PURE__ */ T1()), h = y(/* @__PURE__ */ y1()), c = y(/* @__PURE__ */ g1()), p = y(/* @__PURE__ */ E1()), d = y(/* @__PURE__ */ x1()), m = y(/* @__PURE__ */ P1());
  function y(I) {
    return I && I.__esModule ? I : { default: I };
  }
  var g = function(k) {
    return new t.default(k);
  };
  Ce.attribute = g;
  var E = function(k) {
    return new e.default(k);
  };
  Ce.className = E;
  var S = function(k) {
    return new r.default(k);
  };
  Ce.combinator = S;
  var x = function(k) {
    return new i.default(k);
  };
  Ce.comment = x;
  var v = function(k) {
    return new n.default(k);
  };
  Ce.id = v;
  var P = function(k) {
    return new u.default(k);
  };
  Ce.nesting = P;
  var A = function(k) {
    return new l.default(k);
  };
  Ce.pseudo = A;
  var N = function(k) {
    return new h.default(k);
  };
  Ce.root = N;
  var _ = function(k) {
    return new c.default(k);
  };
  Ce.selector = _;
  var R = function(k) {
    return new p.default(k);
  };
  Ce.string = R;
  var M = function(k) {
    return new d.default(k);
  };
  Ce.tag = M;
  var O = function(k) {
    return new m.default(k);
  };
  return Ce.universal = O, Ce;
}
var Ee = {}, kp;
function GE() {
  if (kp) return Ee;
  kp = 1, Ee.__esModule = !0, Ee.isComment = Ee.isCombinator = Ee.isClassName = Ee.isAttribute = void 0, Ee.isContainer = A, Ee.isIdentifier = void 0, Ee.isNamespace = N, Ee.isNesting = void 0, Ee.isNode = i, Ee.isPseudo = void 0, Ee.isPseudoClass = P, Ee.isPseudoElement = v, Ee.isUniversal = Ee.isTag = Ee.isString = Ee.isSelector = Ee.isRoot = void 0;
  var t = /* @__PURE__ */ et(), e, r = (e = {}, e[t.ATTRIBUTE] = !0, e[t.CLASS] = !0, e[t.COMBINATOR] = !0, e[t.COMMENT] = !0, e[t.ID] = !0, e[t.NESTING] = !0, e[t.PSEUDO] = !0, e[t.ROOT] = !0, e[t.SELECTOR] = !0, e[t.STRING] = !0, e[t.TAG] = !0, e[t.UNIVERSAL] = !0, e);
  function i(_) {
    return typeof _ == "object" && r[_.type];
  }
  function n(_, R) {
    return i(R) && R.type === _;
  }
  var u = n.bind(null, t.ATTRIBUTE);
  Ee.isAttribute = u;
  var l = n.bind(null, t.CLASS);
  Ee.isClassName = l;
  var h = n.bind(null, t.COMBINATOR);
  Ee.isCombinator = h;
  var c = n.bind(null, t.COMMENT);
  Ee.isComment = c;
  var p = n.bind(null, t.ID);
  Ee.isIdentifier = p;
  var d = n.bind(null, t.NESTING);
  Ee.isNesting = d;
  var m = n.bind(null, t.PSEUDO);
  Ee.isPseudo = m;
  var y = n.bind(null, t.ROOT);
  Ee.isRoot = y;
  var g = n.bind(null, t.SELECTOR);
  Ee.isSelector = g;
  var E = n.bind(null, t.STRING);
  Ee.isString = E;
  var S = n.bind(null, t.TAG);
  Ee.isTag = S;
  var x = n.bind(null, t.UNIVERSAL);
  Ee.isUniversal = x;
  function v(_) {
    return m(_) && _.value && (_.value.startsWith("::") || _.value.toLowerCase() === ":before" || _.value.toLowerCase() === ":after" || _.value.toLowerCase() === ":first-letter" || _.value.toLowerCase() === ":first-line");
  }
  function P(_) {
    return m(_) && !v(_);
  }
  function A(_) {
    return !!(i(_) && _.walk);
  }
  function N(_) {
    return u(_) || S(_);
  }
  return Ee;
}
var Lp;
function XE() {
  return Lp || (Lp = 1, function(t) {
    t.__esModule = !0;
    var e = /* @__PURE__ */ et();
    Object.keys(e).forEach(function(n) {
      n === "default" || n === "__esModule" || n in t && t[n] === e[n] || (t[n] = e[n]);
    });
    var r = /* @__PURE__ */ HE();
    Object.keys(r).forEach(function(n) {
      n === "default" || n === "__esModule" || n in t && t[n] === r[n] || (t[n] = r[n]);
    });
    var i = /* @__PURE__ */ GE();
    Object.keys(i).forEach(function(n) {
      n === "default" || n === "__esModule" || n in t && t[n] === i[n] || (t[n] = i[n]);
    });
  }(jo)), jo;
}
var Rp;
function JE() {
  return Rp || (Rp = 1, function(t, e) {
    e.__esModule = !0, e.default = void 0;
    var r = l(/* @__PURE__ */ WE()), i = u(/* @__PURE__ */ XE());
    function n(p) {
      if (typeof WeakMap != "function") return null;
      var d = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
      return (n = function(g) {
        return g ? m : d;
      })(p);
    }
    function u(p, d) {
      if (p && p.__esModule)
        return p;
      if (p === null || typeof p != "object" && typeof p != "function")
        return { default: p };
      var m = n(d);
      if (m && m.has(p))
        return m.get(p);
      var y = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var E in p)
        if (E !== "default" && Object.prototype.hasOwnProperty.call(p, E)) {
          var S = g ? Object.getOwnPropertyDescriptor(p, E) : null;
          S && (S.get || S.set) ? Object.defineProperty(y, E, S) : y[E] = p[E];
        }
      return y.default = p, m && m.set(p, y), y;
    }
    function l(p) {
      return p && p.__esModule ? p : { default: p };
    }
    var h = function(d) {
      return new r.default(d);
    };
    Object.assign(h, i), delete h.__esModule;
    var c = h;
    e.default = c, t.exports = e.default;
  }(Ni, Ni.exports)), Ni.exports;
}
var KE = /* @__PURE__ */ JE(), cn = /* @__PURE__ */ Zn(KE);
const YE = /^(-\w+-)?animation-name$/, QE = /^(-\w+-)?animation$/, I1 = /^(?:-\w+-)?keyframes$/, N1 = (t = "") => {
  const e = /* @__PURE__ */ Object.create(null), r = t.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(i) {
      ZE(t, i);
    },
    AtRule(i) {
      I1.test(i.name) && !i.params.endsWith(`-${r}`) && (e[i.params] = i.params = i.params + "-" + r);
    },
    OnceExit(i) {
      Object.keys(e).length && i.walkDecls((n) => {
        YE.test(n.prop) && (n.value = n.value.split(",").map((u) => e[u.trim()] || u.trim()).join(",")), QE.test(n.prop) && (n.value = n.value.split(",").map((u) => {
          const l = u.trim().split(/\s+/), h = l.findIndex((c) => e[c]);
          return h !== -1 ? (l.splice(h, 1, e[l[h]]), l.join(" ")) : u;
        }).join(","));
      });
    }
  };
}, Dp = /* @__PURE__ */ new WeakSet();
function ZE(t, e) {
  if (Dp.has(e) || e.parent && e.parent.type === "atrule" && I1.test(e.parent.name))
    return;
  Dp.add(e);
  let r = !1, i = e.parent;
  for (; i && i.type !== "root"; ) {
    if (i.__deep) {
      r = !0;
      break;
    }
    i = i.parent;
  }
  e.selector = cn((n) => {
    n.each((u) => {
      _u(t, e, u, n, r);
    });
  }).processSync(e.selector);
}
function _u(t, e, r, i, n, u = !1) {
  let l = null, h = !n;
  if (r.each((c) => {
    if (c.type === "combinator" && (c.value === ">>>" || c.value === "/deep/"))
      return c.value = " ", c.spaces.before = c.spaces.after = "", On(
        "the >>> and /deep/ combinators have been deprecated. Use :deep() instead."
      ), !1;
    if (c.type === "pseudo") {
      const { value: p } = c;
      if (p === ":deep" || p === "::v-deep") {
        if (e.__deep = !0, c.nodes.length) {
          let d = c;
          c.nodes[0].each((y) => {
            r.insertAfter(d, y), d = y;
          });
          const m = r.at(r.index(c) - 1);
          (!m || !Mp(m)) && r.insertAfter(
            c,
            cn.combinator({
              value: " "
            })
          ), r.removeChild(c);
        } else {
          On(
            `${p} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${p} <inner-selector>.`
          );
          const d = r.at(r.index(c) - 1);
          d && Mp(d) && r.removeChild(d), r.removeChild(c);
        }
        return !1;
      }
      if (p === ":slotted" || p === "::v-slotted") {
        _u(
          t,
          e,
          c.nodes[0],
          i,
          n,
          !0
        );
        let d = c;
        return c.nodes[0].each((m) => {
          r.insertAfter(d, m), d = m;
        }), r.removeChild(c), h = !1, !1;
      }
      if (p === ":global" || p === "::v-global")
        return r.replaceWith(c.nodes[0]), !1;
    }
    if (c.type === "universal") {
      const p = r.at(r.index(c) - 1), d = r.at(r.index(c) + 1);
      if (!p)
        if (d) {
          d.type === "combinator" && d.value === " " && r.removeChild(d), r.removeChild(c);
          return;
        } else
          return l = cn.combinator({
            value: ""
          }), r.insertBefore(c, l), r.removeChild(c), !1;
      if (l) return;
    }
    (c.type !== "pseudo" && c.type !== "combinator" || c.type === "pseudo" && (c.value === ":is" || c.value === ":where") && !l) && (l = c);
  }), e.nodes.some((c) => c.type === "rule")) {
    const c = e.__deep;
    if (!c) {
      Fp(e);
      const p = e.nodes.filter((d) => d.type === "atrule");
      for (const d of p)
        Fp(d);
    }
    h = c;
  }
  if (l) {
    const { type: c, value: p } = l;
    c === "pseudo" && (p === ":is" || p === ":where") && (l.nodes.forEach(
      (d) => _u(t, e, d, i, n, u)
    ), h = !1);
  }
  if (l ? l.spaces.after = "" : r.first.spaces.before = "", h) {
    const c = u ? t + "-s" : t;
    r.insertAfter(
      // If node is null it means we need to inject [id] at the start
      // insertAfter can handle `null` here
      l,
      cn.attribute({
        attribute: c,
        value: c,
        raws: {},
        quoteMark: '"'
      })
    );
  }
}
function Mp(t) {
  return t.type === "combinator" && /^\s+$/.test(t.value);
}
function Fp(t) {
  if (!t.nodes) return;
  const e = t.nodes.filter(
    (r) => r.type === "decl" || r.type === "comment"
  );
  if (e.length) {
    for (const i of e)
      t.removeChild(i);
    const r = new FE({
      nodes: e,
      selector: "&"
    });
    t.prepend(r);
  }
}
N1.postcss = !0;
var _s = {}, Vo = {}, Qi = {}, Zi = {}, Bp;
function eT() {
  if (Bp) return Zi;
  Bp = 1;
  var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Zi.encode = function(e) {
    if (0 <= e && e < t.length)
      return t[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  }, Zi.decode = function(e) {
    var r = 65, i = 90, n = 97, u = 122, l = 48, h = 57, c = 43, p = 47, d = 26, m = 52;
    return r <= e && e <= i ? e - r : n <= e && e <= u ? e - n + d : l <= e && e <= h ? e - l + m : e == c ? 62 : e == p ? 63 : -1;
  }, Zi;
}
var $p;
function O1() {
  if ($p) return Qi;
  $p = 1;
  var t = /* @__PURE__ */ eT(), e = 5, r = 1 << e, i = r - 1, n = r;
  function u(h) {
    return h < 0 ? (-h << 1) + 1 : (h << 1) + 0;
  }
  function l(h) {
    var c = (h & 1) === 1, p = h >> 1;
    return c ? -p : p;
  }
  return Qi.encode = function(c) {
    var p = "", d, m = u(c);
    do
      d = m & i, m >>>= e, m > 0 && (d |= n), p += t.encode(d);
    while (m > 0);
    return p;
  }, Qi.decode = function(c, p, d) {
    var m = c.length, y = 0, g = 0, E, S;
    do {
      if (p >= m)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (S = t.decode(c.charCodeAt(p++)), S === -1)
        throw new Error("Invalid base64 digit: " + c.charAt(p - 1));
      E = !!(S & n), S &= i, y = y + (S << g), g += e;
    } while (E);
    d.value = l(y), d.rest = p;
  }, Qi;
}
var zo = {}, Up;
function ci() {
  return Up || (Up = 1, function(t) {
    function e(N, _, R) {
      if (_ in N)
        return N[_];
      if (arguments.length === 3)
        return R;
      throw new Error('"' + _ + '" is a required argument.');
    }
    t.getArg = e;
    var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, i = /^data:.+\,.+$/;
    function n(N) {
      var _ = N.match(r);
      return _ ? {
        scheme: _[1],
        auth: _[2],
        host: _[3],
        port: _[4],
        path: _[5]
      } : null;
    }
    t.urlParse = n;
    function u(N) {
      var _ = "";
      return N.scheme && (_ += N.scheme + ":"), _ += "//", N.auth && (_ += N.auth + "@"), N.host && (_ += N.host), N.port && (_ += ":" + N.port), N.path && (_ += N.path), _;
    }
    t.urlGenerate = u;
    function l(N) {
      var _ = N, R = n(N);
      if (R) {
        if (!R.path)
          return N;
        _ = R.path;
      }
      for (var M = t.isAbsolute(_), O = _.split(/\/+/), I, k = 0, L = O.length - 1; L >= 0; L--)
        I = O[L], I === "." ? O.splice(L, 1) : I === ".." ? k++ : k > 0 && (I === "" ? (O.splice(L + 1, k), k = 0) : (O.splice(L, 2), k--));
      return _ = O.join("/"), _ === "" && (_ = M ? "/" : "."), R ? (R.path = _, u(R)) : _;
    }
    t.normalize = l;
    function h(N, _) {
      N === "" && (N = "."), _ === "" && (_ = ".");
      var R = n(_), M = n(N);
      if (M && (N = M.path || "/"), R && !R.scheme)
        return M && (R.scheme = M.scheme), u(R);
      if (R || _.match(i))
        return _;
      if (M && !M.host && !M.path)
        return M.host = _, u(M);
      var O = _.charAt(0) === "/" ? _ : l(N.replace(/\/+$/, "") + "/" + _);
      return M ? (M.path = O, u(M)) : O;
    }
    t.join = h, t.isAbsolute = function(N) {
      return N.charAt(0) === "/" || r.test(N);
    };
    function c(N, _) {
      N === "" && (N = "."), N = N.replace(/\/$/, "");
      for (var R = 0; _.indexOf(N + "/") !== 0; ) {
        var M = N.lastIndexOf("/");
        if (M < 0 || (N = N.slice(0, M), N.match(/^([^\/]+:\/)?\/*$/)))
          return _;
        ++R;
      }
      return Array(R + 1).join("../") + _.substr(N.length + 1);
    }
    t.relative = c;
    var p = function() {
      var N = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in N);
    }();
    function d(N) {
      return N;
    }
    function m(N) {
      return g(N) ? "$" + N : N;
    }
    t.toSetString = p ? d : m;
    function y(N) {
      return g(N) ? N.slice(1) : N;
    }
    t.fromSetString = p ? d : y;
    function g(N) {
      if (!N)
        return !1;
      var _ = N.length;
      if (_ < 9 || N.charCodeAt(_ - 1) !== 95 || N.charCodeAt(_ - 2) !== 95 || N.charCodeAt(_ - 3) !== 111 || N.charCodeAt(_ - 4) !== 116 || N.charCodeAt(_ - 5) !== 111 || N.charCodeAt(_ - 6) !== 114 || N.charCodeAt(_ - 7) !== 112 || N.charCodeAt(_ - 8) !== 95 || N.charCodeAt(_ - 9) !== 95)
        return !1;
      for (var R = _ - 10; R >= 0; R--)
        if (N.charCodeAt(R) !== 36)
          return !1;
      return !0;
    }
    function E(N, _, R) {
      var M = x(N.source, _.source);
      return M !== 0 || (M = N.originalLine - _.originalLine, M !== 0) || (M = N.originalColumn - _.originalColumn, M !== 0 || R) || (M = N.generatedColumn - _.generatedColumn, M !== 0) || (M = N.generatedLine - _.generatedLine, M !== 0) ? M : x(N.name, _.name);
    }
    t.compareByOriginalPositions = E;
    function S(N, _, R) {
      var M = N.generatedLine - _.generatedLine;
      return M !== 0 || (M = N.generatedColumn - _.generatedColumn, M !== 0 || R) || (M = x(N.source, _.source), M !== 0) || (M = N.originalLine - _.originalLine, M !== 0) || (M = N.originalColumn - _.originalColumn, M !== 0) ? M : x(N.name, _.name);
    }
    t.compareByGeneratedPositionsDeflated = S;
    function x(N, _) {
      return N === _ ? 0 : N === null ? 1 : _ === null ? -1 : N > _ ? 1 : -1;
    }
    function v(N, _) {
      var R = N.generatedLine - _.generatedLine;
      return R !== 0 || (R = N.generatedColumn - _.generatedColumn, R !== 0) || (R = x(N.source, _.source), R !== 0) || (R = N.originalLine - _.originalLine, R !== 0) || (R = N.originalColumn - _.originalColumn, R !== 0) ? R : x(N.name, _.name);
    }
    t.compareByGeneratedPositionsInflated = v;
    function P(N) {
      return JSON.parse(N.replace(/^\)]}'[^\n]*\n/, ""));
    }
    t.parseSourceMapInput = P;
    function A(N, _, R) {
      if (_ = _ || "", N && (N[N.length - 1] !== "/" && _[0] !== "/" && (N += "/"), _ = N + _), R) {
        var M = n(R);
        if (!M)
          throw new Error("sourceMapURL could not be parsed");
        if (M.path) {
          var O = M.path.lastIndexOf("/");
          O >= 0 && (M.path = M.path.substring(0, O + 1));
        }
        _ = h(u(M), _);
      }
      return l(_);
    }
    t.computeSourceURL = A;
  }(zo)), zo;
}
var Wo = {}, qp;
function k1() {
  if (qp) return Wo;
  qp = 1;
  var t = /* @__PURE__ */ ci(), e = Object.prototype.hasOwnProperty, r = typeof Map < "u";
  function i() {
    this._array = [], this._set = r ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return i.fromArray = function(u, l) {
    for (var h = new i(), c = 0, p = u.length; c < p; c++)
      h.add(u[c], l);
    return h;
  }, i.prototype.size = function() {
    return r ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, i.prototype.add = function(u, l) {
    var h = r ? u : t.toSetString(u), c = r ? this.has(u) : e.call(this._set, h), p = this._array.length;
    (!c || l) && this._array.push(u), c || (r ? this._set.set(u, p) : this._set[h] = p);
  }, i.prototype.has = function(u) {
    if (r)
      return this._set.has(u);
    var l = t.toSetString(u);
    return e.call(this._set, l);
  }, i.prototype.indexOf = function(u) {
    if (r) {
      var l = this._set.get(u);
      if (l >= 0)
        return l;
    } else {
      var h = t.toSetString(u);
      if (e.call(this._set, h))
        return this._set[h];
    }
    throw new Error('"' + u + '" is not in the set.');
  }, i.prototype.at = function(u) {
    if (u >= 0 && u < this._array.length)
      return this._array[u];
    throw new Error("No element indexed by " + u);
  }, i.prototype.toArray = function() {
    return this._array.slice();
  }, Wo.ArraySet = i, Wo;
}
var Ho = {}, jp;
function tT() {
  if (jp) return Ho;
  jp = 1;
  var t = /* @__PURE__ */ ci();
  function e(i, n) {
    var u = i.generatedLine, l = n.generatedLine, h = i.generatedColumn, c = n.generatedColumn;
    return l > u || l == u && c >= h || t.compareByGeneratedPositionsInflated(i, n) <= 0;
  }
  function r() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return r.prototype.unsortedForEach = function(n, u) {
    this._array.forEach(n, u);
  }, r.prototype.add = function(n) {
    e(this._last, n) ? (this._last = n, this._array.push(n)) : (this._sorted = !1, this._array.push(n));
  }, r.prototype.toArray = function() {
    return this._sorted || (this._array.sort(t.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, Ho.MappingList = r, Ho;
}
var Vp;
function L1() {
  if (Vp) return Vo;
  Vp = 1;
  var t = /* @__PURE__ */ O1(), e = /* @__PURE__ */ ci(), r = k1().ArraySet, i = tT().MappingList;
  function n(u) {
    u || (u = {}), this._file = e.getArg(u, "file", null), this._sourceRoot = e.getArg(u, "sourceRoot", null), this._skipValidation = e.getArg(u, "skipValidation", !1), this._sources = new r(), this._names = new r(), this._mappings = new i(), this._sourcesContents = null;
  }
  return n.prototype._version = 3, n.fromSourceMap = function(l) {
    var h = l.sourceRoot, c = new n({
      file: l.file,
      sourceRoot: h
    });
    return l.eachMapping(function(p) {
      var d = {
        generated: {
          line: p.generatedLine,
          column: p.generatedColumn
        }
      };
      p.source != null && (d.source = p.source, h != null && (d.source = e.relative(h, d.source)), d.original = {
        line: p.originalLine,
        column: p.originalColumn
      }, p.name != null && (d.name = p.name)), c.addMapping(d);
    }), l.sources.forEach(function(p) {
      var d = p;
      h !== null && (d = e.relative(h, p)), c._sources.has(d) || c._sources.add(d);
      var m = l.sourceContentFor(p);
      m != null && c.setSourceContent(p, m);
    }), c;
  }, n.prototype.addMapping = function(l) {
    var h = e.getArg(l, "generated"), c = e.getArg(l, "original", null), p = e.getArg(l, "source", null), d = e.getArg(l, "name", null);
    this._skipValidation || this._validateMapping(h, c, p, d), p != null && (p = String(p), this._sources.has(p) || this._sources.add(p)), d != null && (d = String(d), this._names.has(d) || this._names.add(d)), this._mappings.add({
      generatedLine: h.line,
      generatedColumn: h.column,
      originalLine: c != null && c.line,
      originalColumn: c != null && c.column,
      source: p,
      name: d
    });
  }, n.prototype.setSourceContent = function(l, h) {
    var c = l;
    this._sourceRoot != null && (c = e.relative(this._sourceRoot, c)), h != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[e.toSetString(c)] = h) : this._sourcesContents && (delete this._sourcesContents[e.toSetString(c)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, n.prototype.applySourceMap = function(l, h, c) {
    var p = h;
    if (h == null) {
      if (l.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      p = l.file;
    }
    var d = this._sourceRoot;
    d != null && (p = e.relative(d, p));
    var m = new r(), y = new r();
    this._mappings.unsortedForEach(function(g) {
      if (g.source === p && g.originalLine != null) {
        var E = l.originalPositionFor({
          line: g.originalLine,
          column: g.originalColumn
        });
        E.source != null && (g.source = E.source, c != null && (g.source = e.join(c, g.source)), d != null && (g.source = e.relative(d, g.source)), g.originalLine = E.line, g.originalColumn = E.column, E.name != null && (g.name = E.name));
      }
      var S = g.source;
      S != null && !m.has(S) && m.add(S);
      var x = g.name;
      x != null && !y.has(x) && y.add(x);
    }, this), this._sources = m, this._names = y, l.sources.forEach(function(g) {
      var E = l.sourceContentFor(g);
      E != null && (c != null && (g = e.join(c, g)), d != null && (g = e.relative(d, g)), this.setSourceContent(g, E));
    }, this);
  }, n.prototype._validateMapping = function(l, h, c, p) {
    if (h && typeof h.line != "number" && typeof h.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(l && "line" in l && "column" in l && l.line > 0 && l.column >= 0 && !h && !c && !p)) {
      if (l && "line" in l && "column" in l && h && "line" in h && "column" in h && l.line > 0 && l.column >= 0 && h.line > 0 && h.column >= 0 && c)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: l,
        source: c,
        original: h,
        name: p
      }));
    }
  }, n.prototype._serializeMappings = function() {
    for (var l = 0, h = 1, c = 0, p = 0, d = 0, m = 0, y = "", g, E, S, x, v = this._mappings.toArray(), P = 0, A = v.length; P < A; P++) {
      if (E = v[P], g = "", E.generatedLine !== h)
        for (l = 0; E.generatedLine !== h; )
          g += ";", h++;
      else if (P > 0) {
        if (!e.compareByGeneratedPositionsInflated(E, v[P - 1]))
          continue;
        g += ",";
      }
      g += t.encode(E.generatedColumn - l), l = E.generatedColumn, E.source != null && (x = this._sources.indexOf(E.source), g += t.encode(x - m), m = x, g += t.encode(E.originalLine - 1 - p), p = E.originalLine - 1, g += t.encode(E.originalColumn - c), c = E.originalColumn, E.name != null && (S = this._names.indexOf(E.name), g += t.encode(S - d), d = S)), y += g;
    }
    return y;
  }, n.prototype._generateSourcesContent = function(l, h) {
    return l.map(function(c) {
      if (!this._sourcesContents)
        return null;
      h != null && (c = e.relative(h, c));
      var p = e.toSetString(c);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, p) ? this._sourcesContents[p] : null;
    }, this);
  }, n.prototype.toJSON = function() {
    var l = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (l.file = this._file), this._sourceRoot != null && (l.sourceRoot = this._sourceRoot), this._sourcesContents && (l.sourcesContent = this._generateSourcesContent(l.sources, l.sourceRoot)), l;
  }, n.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Vo.SourceMapGenerator = n, Vo;
}
var As = {}, Go = {}, zp;
function rT() {
  return zp || (zp = 1, function(t) {
    t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2;
    function e(r, i, n, u, l, h) {
      var c = Math.floor((i - r) / 2) + r, p = l(n, u[c], !0);
      return p === 0 ? c : p > 0 ? i - c > 1 ? e(c, i, n, u, l, h) : h == t.LEAST_UPPER_BOUND ? i < u.length ? i : -1 : c : c - r > 1 ? e(r, c, n, u, l, h) : h == t.LEAST_UPPER_BOUND ? c : r < 0 ? -1 : r;
    }
    t.search = function(i, n, u, l) {
      if (n.length === 0)
        return -1;
      var h = e(
        -1,
        n.length,
        i,
        n,
        u,
        l || t.GREATEST_LOWER_BOUND
      );
      if (h < 0)
        return -1;
      for (; h - 1 >= 0 && u(n[h], n[h - 1], !0) === 0; )
        --h;
      return h;
    };
  }(Go)), Go;
}
var Xo = {}, Wp;
function sT() {
  if (Wp) return Xo;
  Wp = 1;
  function t(i, n, u) {
    var l = i[n];
    i[n] = i[u], i[u] = l;
  }
  function e(i, n) {
    return Math.round(i + Math.random() * (n - i));
  }
  function r(i, n, u, l) {
    if (u < l) {
      var h = e(u, l), c = u - 1;
      t(i, h, l);
      for (var p = i[l], d = u; d < l; d++)
        n(i[d], p) <= 0 && (c += 1, t(i, c, d));
      t(i, c + 1, d);
      var m = c + 1;
      r(i, n, u, m - 1), r(i, n, m + 1, l);
    }
  }
  return Xo.quickSort = function(i, n) {
    r(i, n, 0, i.length - 1);
  }, Xo;
}
var Hp;
function iT() {
  if (Hp) return As;
  Hp = 1;
  var t = /* @__PURE__ */ ci(), e = /* @__PURE__ */ rT(), r = k1().ArraySet, i = /* @__PURE__ */ O1(), n = sT().quickSort;
  function u(p, d) {
    var m = p;
    return typeof p == "string" && (m = t.parseSourceMapInput(p)), m.sections != null ? new c(m, d) : new l(m, d);
  }
  u.fromSourceMap = function(p, d) {
    return l.fromSourceMap(p, d);
  }, u.prototype._version = 3, u.prototype.__generatedMappings = null, Object.defineProperty(u.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), u.prototype.__originalMappings = null, Object.defineProperty(u.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), u.prototype._charIsMappingSeparator = function(d, m) {
    var y = d.charAt(m);
    return y === ";" || y === ",";
  }, u.prototype._parseMappings = function(d, m) {
    throw new Error("Subclasses must implement _parseMappings");
  }, u.GENERATED_ORDER = 1, u.ORIGINAL_ORDER = 2, u.GREATEST_LOWER_BOUND = 1, u.LEAST_UPPER_BOUND = 2, u.prototype.eachMapping = function(d, m, y) {
    var g = m || null, E = y || u.GENERATED_ORDER, S;
    switch (E) {
      case u.GENERATED_ORDER:
        S = this._generatedMappings;
        break;
      case u.ORIGINAL_ORDER:
        S = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var x = this.sourceRoot;
    S.map(function(v) {
      var P = v.source === null ? null : this._sources.at(v.source);
      return P = t.computeSourceURL(x, P, this._sourceMapURL), {
        source: P,
        generatedLine: v.generatedLine,
        generatedColumn: v.generatedColumn,
        originalLine: v.originalLine,
        originalColumn: v.originalColumn,
        name: v.name === null ? null : this._names.at(v.name)
      };
    }, this).forEach(d, g);
  }, u.prototype.allGeneratedPositionsFor = function(d) {
    var m = t.getArg(d, "line"), y = {
      source: t.getArg(d, "source"),
      originalLine: m,
      originalColumn: t.getArg(d, "column", 0)
    };
    if (y.source = this._findSourceIndex(y.source), y.source < 0)
      return [];
    var g = [], E = this._findMapping(
      y,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      e.LEAST_UPPER_BOUND
    );
    if (E >= 0) {
      var S = this._originalMappings[E];
      if (d.column === void 0)
        for (var x = S.originalLine; S && S.originalLine === x; )
          g.push({
            line: t.getArg(S, "generatedLine", null),
            column: t.getArg(S, "generatedColumn", null),
            lastColumn: t.getArg(S, "lastGeneratedColumn", null)
          }), S = this._originalMappings[++E];
      else
        for (var v = S.originalColumn; S && S.originalLine === m && S.originalColumn == v; )
          g.push({
            line: t.getArg(S, "generatedLine", null),
            column: t.getArg(S, "generatedColumn", null),
            lastColumn: t.getArg(S, "lastGeneratedColumn", null)
          }), S = this._originalMappings[++E];
    }
    return g;
  }, As.SourceMapConsumer = u;
  function l(p, d) {
    var m = p;
    typeof p == "string" && (m = t.parseSourceMapInput(p));
    var y = t.getArg(m, "version"), g = t.getArg(m, "sources"), E = t.getArg(m, "names", []), S = t.getArg(m, "sourceRoot", null), x = t.getArg(m, "sourcesContent", null), v = t.getArg(m, "mappings"), P = t.getArg(m, "file", null);
    if (y != this._version)
      throw new Error("Unsupported version: " + y);
    S && (S = t.normalize(S)), g = g.map(String).map(t.normalize).map(function(A) {
      return S && t.isAbsolute(S) && t.isAbsolute(A) ? t.relative(S, A) : A;
    }), this._names = r.fromArray(E.map(String), !0), this._sources = r.fromArray(g, !0), this._absoluteSources = this._sources.toArray().map(function(A) {
      return t.computeSourceURL(S, A, d);
    }), this.sourceRoot = S, this.sourcesContent = x, this._mappings = v, this._sourceMapURL = d, this.file = P;
  }
  l.prototype = Object.create(u.prototype), l.prototype.consumer = u, l.prototype._findSourceIndex = function(p) {
    var d = p;
    if (this.sourceRoot != null && (d = t.relative(this.sourceRoot, d)), this._sources.has(d))
      return this._sources.indexOf(d);
    var m;
    for (m = 0; m < this._absoluteSources.length; ++m)
      if (this._absoluteSources[m] == p)
        return m;
    return -1;
  }, l.fromSourceMap = function(d, m) {
    var y = Object.create(l.prototype), g = y._names = r.fromArray(d._names.toArray(), !0), E = y._sources = r.fromArray(d._sources.toArray(), !0);
    y.sourceRoot = d._sourceRoot, y.sourcesContent = d._generateSourcesContent(
      y._sources.toArray(),
      y.sourceRoot
    ), y.file = d._file, y._sourceMapURL = m, y._absoluteSources = y._sources.toArray().map(function(R) {
      return t.computeSourceURL(y.sourceRoot, R, m);
    });
    for (var S = d._mappings.toArray().slice(), x = y.__generatedMappings = [], v = y.__originalMappings = [], P = 0, A = S.length; P < A; P++) {
      var N = S[P], _ = new h();
      _.generatedLine = N.generatedLine, _.generatedColumn = N.generatedColumn, N.source && (_.source = E.indexOf(N.source), _.originalLine = N.originalLine, _.originalColumn = N.originalColumn, N.name && (_.name = g.indexOf(N.name)), v.push(_)), x.push(_);
    }
    return n(y.__originalMappings, t.compareByOriginalPositions), y;
  }, l.prototype._version = 3, Object.defineProperty(l.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function h() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  l.prototype._parseMappings = function(d, m) {
    for (var y = 1, g = 0, E = 0, S = 0, x = 0, v = 0, P = d.length, A = 0, N = {}, _ = {}, R = [], M = [], O, I, k, L, V; A < P; )
      if (d.charAt(A) === ";")
        y++, A++, g = 0;
      else if (d.charAt(A) === ",")
        A++;
      else {
        for (O = new h(), O.generatedLine = y, L = A; L < P && !this._charIsMappingSeparator(d, L); L++)
          ;
        if (I = d.slice(A, L), k = N[I], k)
          A += I.length;
        else {
          for (k = []; A < L; )
            i.decode(d, A, _), V = _.value, A = _.rest, k.push(V);
          if (k.length === 2)
            throw new Error("Found a source, but no line and column");
          if (k.length === 3)
            throw new Error("Found a source and line, but no column");
          N[I] = k;
        }
        O.generatedColumn = g + k[0], g = O.generatedColumn, k.length > 1 && (O.source = x + k[1], x += k[1], O.originalLine = E + k[2], E = O.originalLine, O.originalLine += 1, O.originalColumn = S + k[3], S = O.originalColumn, k.length > 4 && (O.name = v + k[4], v += k[4])), M.push(O), typeof O.originalLine == "number" && R.push(O);
      }
    n(M, t.compareByGeneratedPositionsDeflated), this.__generatedMappings = M, n(R, t.compareByOriginalPositions), this.__originalMappings = R;
  }, l.prototype._findMapping = function(d, m, y, g, E, S) {
    if (d[y] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + d[y]);
    if (d[g] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + d[g]);
    return e.search(d, m, E, S);
  }, l.prototype.computeColumnSpans = function() {
    for (var d = 0; d < this._generatedMappings.length; ++d) {
      var m = this._generatedMappings[d];
      if (d + 1 < this._generatedMappings.length) {
        var y = this._generatedMappings[d + 1];
        if (m.generatedLine === y.generatedLine) {
          m.lastGeneratedColumn = y.generatedColumn - 1;
          continue;
        }
      }
      m.lastGeneratedColumn = 1 / 0;
    }
  }, l.prototype.originalPositionFor = function(d) {
    var m = {
      generatedLine: t.getArg(d, "line"),
      generatedColumn: t.getArg(d, "column")
    }, y = this._findMapping(
      m,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      t.compareByGeneratedPositionsDeflated,
      t.getArg(d, "bias", u.GREATEST_LOWER_BOUND)
    );
    if (y >= 0) {
      var g = this._generatedMappings[y];
      if (g.generatedLine === m.generatedLine) {
        var E = t.getArg(g, "source", null);
        E !== null && (E = this._sources.at(E), E = t.computeSourceURL(this.sourceRoot, E, this._sourceMapURL));
        var S = t.getArg(g, "name", null);
        return S !== null && (S = this._names.at(S)), {
          source: E,
          line: t.getArg(g, "originalLine", null),
          column: t.getArg(g, "originalColumn", null),
          name: S
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, l.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(d) {
      return d == null;
    }) : !1;
  }, l.prototype.sourceContentFor = function(d, m) {
    if (!this.sourcesContent)
      return null;
    var y = this._findSourceIndex(d);
    if (y >= 0)
      return this.sourcesContent[y];
    var g = d;
    this.sourceRoot != null && (g = t.relative(this.sourceRoot, g));
    var E;
    if (this.sourceRoot != null && (E = t.urlParse(this.sourceRoot))) {
      var S = g.replace(/^file:\/\//, "");
      if (E.scheme == "file" && this._sources.has(S))
        return this.sourcesContent[this._sources.indexOf(S)];
      if ((!E.path || E.path == "/") && this._sources.has("/" + g))
        return this.sourcesContent[this._sources.indexOf("/" + g)];
    }
    if (m)
      return null;
    throw new Error('"' + g + '" is not in the SourceMap.');
  }, l.prototype.generatedPositionFor = function(d) {
    var m = t.getArg(d, "source");
    if (m = this._findSourceIndex(m), m < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var y = {
      source: m,
      originalLine: t.getArg(d, "line"),
      originalColumn: t.getArg(d, "column")
    }, g = this._findMapping(
      y,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      t.getArg(d, "bias", u.GREATEST_LOWER_BOUND)
    );
    if (g >= 0) {
      var E = this._originalMappings[g];
      if (E.source === y.source)
        return {
          line: t.getArg(E, "generatedLine", null),
          column: t.getArg(E, "generatedColumn", null),
          lastColumn: t.getArg(E, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, As.BasicSourceMapConsumer = l;
  function c(p, d) {
    var m = p;
    typeof p == "string" && (m = t.parseSourceMapInput(p));
    var y = t.getArg(m, "version"), g = t.getArg(m, "sections");
    if (y != this._version)
      throw new Error("Unsupported version: " + y);
    this._sources = new r(), this._names = new r();
    var E = {
      line: -1,
      column: 0
    };
    this._sections = g.map(function(S) {
      if (S.url)
        throw new Error("Support for url field in sections not implemented.");
      var x = t.getArg(S, "offset"), v = t.getArg(x, "line"), P = t.getArg(x, "column");
      if (v < E.line || v === E.line && P < E.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return E = x, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: v + 1,
          generatedColumn: P + 1
        },
        consumer: new u(t.getArg(S, "map"), d)
      };
    });
  }
  return c.prototype = Object.create(u.prototype), c.prototype.constructor = u, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", {
    get: function() {
      for (var p = [], d = 0; d < this._sections.length; d++)
        for (var m = 0; m < this._sections[d].consumer.sources.length; m++)
          p.push(this._sections[d].consumer.sources[m]);
      return p;
    }
  }), c.prototype.originalPositionFor = function(d) {
    var m = {
      generatedLine: t.getArg(d, "line"),
      generatedColumn: t.getArg(d, "column")
    }, y = e.search(
      m,
      this._sections,
      function(E, S) {
        var x = E.generatedLine - S.generatedOffset.generatedLine;
        return x || E.generatedColumn - S.generatedOffset.generatedColumn;
      }
    ), g = this._sections[y];
    return g ? g.consumer.originalPositionFor({
      line: m.generatedLine - (g.generatedOffset.generatedLine - 1),
      column: m.generatedColumn - (g.generatedOffset.generatedLine === m.generatedLine ? g.generatedOffset.generatedColumn - 1 : 0),
      bias: d.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, c.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(d) {
      return d.consumer.hasContentsOfAllSources();
    });
  }, c.prototype.sourceContentFor = function(d, m) {
    for (var y = 0; y < this._sections.length; y++) {
      var g = this._sections[y], E = g.consumer.sourceContentFor(d, !0);
      if (E)
        return E;
    }
    if (m)
      return null;
    throw new Error('"' + d + '" is not in the SourceMap.');
  }, c.prototype.generatedPositionFor = function(d) {
    for (var m = 0; m < this._sections.length; m++) {
      var y = this._sections[m];
      if (y.consumer._findSourceIndex(t.getArg(d, "source")) !== -1) {
        var g = y.consumer.generatedPositionFor(d);
        if (g) {
          var E = {
            line: g.line + (y.generatedOffset.generatedLine - 1),
            column: g.column + (y.generatedOffset.generatedLine === g.line ? y.generatedOffset.generatedColumn - 1 : 0)
          };
          return E;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, c.prototype._parseMappings = function(d, m) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var y = 0; y < this._sections.length; y++)
      for (var g = this._sections[y], E = g.consumer._generatedMappings, S = 0; S < E.length; S++) {
        var x = E[S], v = g.consumer._sources.at(x.source);
        v = t.computeSourceURL(g.consumer.sourceRoot, v, this._sourceMapURL), this._sources.add(v), v = this._sources.indexOf(v);
        var P = null;
        x.name && (P = g.consumer._names.at(x.name), this._names.add(P), P = this._names.indexOf(P));
        var A = {
          source: v,
          generatedLine: x.generatedLine + (g.generatedOffset.generatedLine - 1),
          generatedColumn: x.generatedColumn + (g.generatedOffset.generatedLine === x.generatedLine ? g.generatedOffset.generatedColumn - 1 : 0),
          originalLine: x.originalLine,
          originalColumn: x.originalColumn,
          name: P
        };
        this.__generatedMappings.push(A), typeof A.originalLine == "number" && this.__originalMappings.push(A);
      }
    n(this.__generatedMappings, t.compareByGeneratedPositionsDeflated), n(this.__originalMappings, t.compareByOriginalPositions);
  }, As.IndexedSourceMapConsumer = c, As;
}
var Jo = {}, Gp;
function nT() {
  if (Gp) return Jo;
  Gp = 1;
  var t = L1().SourceMapGenerator, e = /* @__PURE__ */ ci(), r = /(\r?\n)/, i = 10, n = "$$$isSourceNode$$$";
  function u(l, h, c, p, d) {
    this.children = [], this.sourceContents = {}, this.line = l ?? null, this.column = h ?? null, this.source = c ?? null, this.name = d ?? null, this[n] = !0, p != null && this.add(p);
  }
  return u.fromStringWithSourceMap = function(h, c, p) {
    var d = new u(), m = h.split(r), y = 0, g = function() {
      var P = N(), A = N() || "";
      return P + A;
      function N() {
        return y < m.length ? m[y++] : void 0;
      }
    }, E = 1, S = 0, x = null;
    return c.eachMapping(function(P) {
      if (x !== null)
        if (E < P.generatedLine)
          v(x, g()), E++, S = 0;
        else {
          var A = m[y] || "", N = A.substr(0, P.generatedColumn - S);
          m[y] = A.substr(P.generatedColumn - S), S = P.generatedColumn, v(x, N), x = P;
          return;
        }
      for (; E < P.generatedLine; )
        d.add(g()), E++;
      if (S < P.generatedColumn) {
        var A = m[y] || "";
        d.add(A.substr(0, P.generatedColumn)), m[y] = A.substr(P.generatedColumn), S = P.generatedColumn;
      }
      x = P;
    }, this), y < m.length && (x && v(x, g()), d.add(m.splice(y).join(""))), c.sources.forEach(function(P) {
      var A = c.sourceContentFor(P);
      A != null && (p != null && (P = e.join(p, P)), d.setSourceContent(P, A));
    }), d;
    function v(P, A) {
      if (P === null || P.source === void 0)
        d.add(A);
      else {
        var N = p ? e.join(p, P.source) : P.source;
        d.add(new u(
          P.originalLine,
          P.originalColumn,
          N,
          A,
          P.name
        ));
      }
    }
  }, u.prototype.add = function(h) {
    if (Array.isArray(h))
      h.forEach(function(c) {
        this.add(c);
      }, this);
    else if (h[n] || typeof h == "string")
      h && this.children.push(h);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + h
      );
    return this;
  }, u.prototype.prepend = function(h) {
    if (Array.isArray(h))
      for (var c = h.length - 1; c >= 0; c--)
        this.prepend(h[c]);
    else if (h[n] || typeof h == "string")
      this.children.unshift(h);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + h
      );
    return this;
  }, u.prototype.walk = function(h) {
    for (var c, p = 0, d = this.children.length; p < d; p++)
      c = this.children[p], c[n] ? c.walk(h) : c !== "" && h(c, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, u.prototype.join = function(h) {
    var c, p, d = this.children.length;
    if (d > 0) {
      for (c = [], p = 0; p < d - 1; p++)
        c.push(this.children[p]), c.push(h);
      c.push(this.children[p]), this.children = c;
    }
    return this;
  }, u.prototype.replaceRight = function(h, c) {
    var p = this.children[this.children.length - 1];
    return p[n] ? p.replaceRight(h, c) : typeof p == "string" ? this.children[this.children.length - 1] = p.replace(h, c) : this.children.push("".replace(h, c)), this;
  }, u.prototype.setSourceContent = function(h, c) {
    this.sourceContents[e.toSetString(h)] = c;
  }, u.prototype.walkSourceContents = function(h) {
    for (var c = 0, p = this.children.length; c < p; c++)
      this.children[c][n] && this.children[c].walkSourceContents(h);
    for (var d = Object.keys(this.sourceContents), c = 0, p = d.length; c < p; c++)
      h(e.fromSetString(d[c]), this.sourceContents[d[c]]);
  }, u.prototype.toString = function() {
    var h = "";
    return this.walk(function(c) {
      h += c;
    }), h;
  }, u.prototype.toStringWithSourceMap = function(h) {
    var c = {
      code: "",
      line: 1,
      column: 0
    }, p = new t(h), d = !1, m = null, y = null, g = null, E = null;
    return this.walk(function(S, x) {
      c.code += S, x.source !== null && x.line !== null && x.column !== null ? ((m !== x.source || y !== x.line || g !== x.column || E !== x.name) && p.addMapping({
        source: x.source,
        original: {
          line: x.line,
          column: x.column
        },
        generated: {
          line: c.line,
          column: c.column
        },
        name: x.name
      }), m = x.source, y = x.line, g = x.column, E = x.name, d = !0) : d && (p.addMapping({
        generated: {
          line: c.line,
          column: c.column
        }
      }), m = null, d = !1);
      for (var v = 0, P = S.length; v < P; v++)
        S.charCodeAt(v) === i ? (c.line++, c.column = 0, v + 1 === P ? (m = null, d = !1) : d && p.addMapping({
          source: x.source,
          original: {
            line: x.line,
            column: x.column
          },
          generated: {
            line: c.line,
            column: c.column
          },
          name: x.name
        })) : c.column++;
    }), this.walkSourceContents(function(S, x) {
      p.setSourceContent(S, x);
    }), { code: c.code, map: p };
  }, Jo.SourceNode = u, Jo;
}
var Xp;
function aT() {
  return Xp || (Xp = 1, _s.SourceMapGenerator = L1().SourceMapGenerator, _s.SourceMapConsumer = iT().SourceMapConsumer, _s.SourceNode = nT().SourceNode), _s;
}
var Ko, Jp;
function oT() {
  if (Jp) return Ko;
  Jp = 1;
  var t = /* @__PURE__ */ aT(), e = t.SourceMapConsumer, r = t.SourceMapGenerator;
  Ko = i;
  function i(n, u) {
    if (!n) return u;
    if (!u) return n;
    var l = new e(n), h = new e(u), c = new r();
    h.eachMapping(function(d) {
      if (d.originalLine != null) {
        var m = l.originalPositionFor({
          line: d.originalLine,
          column: d.originalColumn
        });
        m.source != null && c.addMapping({
          original: {
            line: m.line,
            column: m.column
          },
          generated: {
            line: d.generatedLine,
            column: d.generatedColumn
          },
          source: m.source,
          name: m.name
        });
      }
    });
    var p = [l, h];
    return p.forEach(function(d) {
      d.sources.forEach(function(m) {
        c._sources.add(m);
        var y = d.sourceContentFor(m);
        y != null && c.setSourceContent(m, y);
      });
    }), c._sourceRoot = n.sourceRoot, c._file = n.file, JSON.parse(c.toString());
  }
  return Ko;
}
var uT = /* @__PURE__ */ oT(), tc = /* @__PURE__ */ Zn(uT), lT = Object.defineProperty, cT = Object.defineProperties, hT = Object.getOwnPropertyDescriptors, Kp = Object.getOwnPropertySymbols, fT = Object.prototype.hasOwnProperty, pT = Object.prototype.propertyIsEnumerable, Yp = (t, e, r) => e in t ? lT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ln = (t, e) => {
  for (var r in e || (e = {}))
    fT.call(e, r) && Yp(t, r, e[r]);
  if (Kp)
    for (var r of Kp(e))
      pT.call(e, r) && Yp(t, r, e[r]);
  return t;
}, Rn = (t, e) => cT(t, hT(e));
const R1 = (t, e, r, i = require) => {
  const n = i("sass"), { compileString: u, renderSync: l } = n, h = D1(t, r.filename, r.additionalData);
  let c, p, d;
  try {
    if (u) {
      const { pathToFileURL: m, fileURLToPath: y } = i("url"), g = u(h, Rn(Ln({}, r), {
        url: m(r.filename),
        sourceMap: !!e
      }));
      c = g.css, p = g.loadedUrls.map((E) => y(E)), d = e ? g.sourceMap : void 0;
    } else {
      const m = l(Rn(Ln({}, r), {
        data: h,
        file: r.filename,
        outFile: r.filename,
        sourceMap: !!e
      }));
      c = m.css.toString(), p = m.stats.includedFiles, d = e ? JSON.parse(m.map.toString()) : void 0;
    }
    return e ? {
      code: c,
      errors: [],
      dependencies: p,
      map: tc(e, d)
    } : { code: c, errors: [], dependencies: p };
  } catch (m) {
    return { code: "", errors: [m], dependencies: [] };
  }
}, dT = (t, e, r, i) => R1(
  t,
  e,
  Rn(Ln({}, r), {
    indentedSyntax: !0
  }),
  i
), mT = (t, e, r, i = require) => {
  const n = i("less");
  let u, l = null;
  if (n.render(
    D1(t, r.filename, r.additionalData),
    Rn(Ln({}, r), { syncImport: !0 }),
    (c, p) => {
      l = c, u = p;
    }
  ), l) return { code: "", errors: [l], dependencies: [] };
  const h = u.imports;
  return e ? {
    code: u.css.toString(),
    map: tc(e, u.map),
    errors: [],
    dependencies: h
  } : {
    code: u.css.toString(),
    errors: [],
    dependencies: h
  };
}, Qp = (t, e, r, i = require) => {
  const n = i("stylus");
  try {
    const u = n(t, r);
    e && u.set("sourcemap", { inline: !1, comment: !1 });
    const l = u.render(), h = u.deps();
    return e ? {
      code: l,
      map: tc(e, u.sourcemap),
      errors: [],
      dependencies: h
    } : { code: l, errors: [], dependencies: h };
  } catch (u) {
    return { code: "", errors: [u], dependencies: [] };
  }
};
function D1(t, e, r) {
  return r ? Nd(r) ? r(t, e) : r + t : t;
}
const yT = {
  less: mT,
  sass: dT,
  scss: R1,
  styl: Qp,
  stylus: Qp
};
var gT = Object.defineProperty, bT = Object.defineProperties, ST = Object.getOwnPropertyDescriptors, Zp = Object.getOwnPropertySymbols, vT = Object.prototype.hasOwnProperty, xT = Object.prototype.propertyIsEnumerable, ed = (t, e, r) => e in t ? gT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, rc = (t, e) => {
  for (var r in e || (e = {}))
    vT.call(e, r) && ed(t, r, e[r]);
  if (Zp)
    for (var r of Zp(e))
      xT.call(e, r) && ed(t, r, e[r]);
  return t;
}, M1 = (t, e) => bT(t, ST(e));
function ET(t) {
  return TT(M1(rc({}, t), {
    isAsync: !1
  }));
}
function TT(t) {
  const {
    filename: e,
    id: r,
    scoped: i = !1,
    trim: n = !0,
    isProd: u = !1,
    modules: l = !1,
    modulesOptions: h = {},
    preprocessLang: c,
    postcssOptions: p,
    postcssPlugins: d
  } = t, m = c && yT[c], y = m && wT(t, m), g = y ? y.map : t.inMap || t.map, E = y ? y.code : t.source, S = r.replace(/^data-v-/, ""), x = `data-v-${S}`, v = (d || []).slice();
  v.unshift(D0({ id: S, isProd: u })), n && v.push(d1()), i && v.push(N1(x));
  let P;
  if (l)
    throw new Error(
      "[@vue/compiler-sfc] `modules` option is not supported in the browser build."
    );
  const A = M1(rc({}, p), {
    to: e,
    from: e
  });
  g && (A.map = {
    inline: !1,
    annotation: !1,
    prev: g
  });
  let N, _, R;
  const M = new Set(
    y ? y.dependencies : []
  );
  M.delete(e);
  const O = [];
  y && y.errors.length && O.push(...y.errors);
  const I = (k) => (k.forEach((L) => {
    L.type === "dependency" && M.add(L.file);
  }), M);
  try {
    if (N = Oe(v).process(E, A), t.isAsync)
      return N.then((k) => ({
        code: k.css || "",
        map: k.map && k.map.toJSON(),
        errors: O,
        modules: P,
        rawResult: k,
        dependencies: I(k.messages)
      })).catch((k) => ({
        code: "",
        map: void 0,
        errors: [...O, k],
        rawResult: void 0,
        dependencies: M
      }));
    I(N.messages), _ = N.css, R = N.map;
  } catch (k) {
    O.push(k);
  }
  return {
    code: _ || "",
    map: R && R.toJSON(),
    errors: O,
    rawResult: N,
    dependencies: M
  };
}
function wT(t, e) {
  if (!t.preprocessCustomRequire)
    throw new Error(
      "[@vue/compiler-sfc] Style preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor."
    );
  return e(
    t.source,
    t.inMap || t.map,
    rc({
      filename: t.filename
    }, t.preprocessOptions),
    t.preprocessCustomRequire
  );
}
const kt = "Unknown";
function sc(t, e) {
  switch (t.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(t.value);
    case "Identifier":
      if (!e) return t.name;
  }
}
function td(t) {
  return t.filter((e) => !!e).join(", ");
}
function F1(t) {
  return t.type.endsWith("Literal");
}
function st(t, e) {
  return !!(t && e && t.type === "CallExpression" && t.callee.type === "Identifier" && (typeof e == "string" ? t.callee.name === e : e(t.callee.name)));
}
function Qr(t) {
  return t.length > 1 ? `[${t.join(", ")}]` : t[0];
}
function Au(t) {
  return t.type === "ImportSpecifier" ? t.imported.type === "Identifier" ? t.imported.name : t.imported.value : t.type === "ImportNamespaceSpecifier" ? "*" : "default";
}
function Rr(t) {
  return t.type === "Identifier" ? t.name : t.type === "StringLiteral" ? t.value : null;
}
const PT = (Yt.posix || Yt).normalize, _T = /\\/g;
function B1(t) {
  return PT(t.replace(_T, "/"));
}
const qs = (Yt.posix || Yt).join, AT = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function $1(t) {
  return AT.test(t) ? JSON.stringify(t) : t;
}
function U1(t) {
  for (const e of t)
    if (e.type === "ExportDefaultDeclaration" && e.declaration.type === "ObjectExpression")
      return CT(e.declaration);
  return {};
}
function CT(t) {
  const e = {};
  Object.defineProperty(e, "__isScriptSetup", {
    enumerable: !1,
    value: !1
  });
  for (const r of t.properties)
    if (r.type === "ObjectProperty" && !r.computed && r.key.type === "Identifier") {
      if (r.key.name === "props")
        for (const i of Iu(r.value))
          e[i] = "props";
      else if (r.key.name === "inject")
        for (const i of Iu(r.value))
          e[i] = "options";
      else if (r.value.type === "ObjectExpression" && (r.key.name === "computed" || r.key.name === "methods"))
        for (const i of Cu(r.value))
          e[i] = "options";
    } else if (r.type === "ObjectMethod" && r.key.type === "Identifier" && (r.key.name === "setup" || r.key.name === "data")) {
      for (const i of r.body.body)
        if (i.type === "ReturnStatement" && i.argument && i.argument.type === "ObjectExpression")
          for (const n of Cu(i.argument))
            e[n] = r.key.name === "setup" ? "setup-maybe-ref" : "data";
    }
  return e;
}
function Cu(t) {
  const e = [];
  for (const r of t.properties) {
    if (r.type === "SpreadElement") continue;
    const i = sc(r.key, r.computed);
    i && e.push(String(i));
  }
  return e;
}
function IT(t) {
  const e = [];
  for (const r of t.elements)
    r && r.type === "StringLiteral" && e.push(r.value);
  return e;
}
function Iu(t) {
  return t.type === "ArrayExpression" ? IT(t) : t.type === "ObjectExpression" ? Cu(t) : [];
}
const NT = 44, OT = 59, rd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", q1 = new Uint8Array(64), kT = new Uint8Array(128);
for (let t = 0; t < rd.length; t++) {
  const e = rd.charCodeAt(t);
  q1[t] = e, kT[e] = t;
}
function Cs(t, e, r) {
  let i = e - r;
  i = i < 0 ? -i << 1 | 1 : i << 1;
  do {
    let n = i & 31;
    i >>>= 5, i > 0 && (n |= 32), t.write(q1[n]);
  } while (i > 0);
  return e;
}
const sd = 1024 * 16, id = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
  decode(t) {
    return Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString();
  }
} : {
  decode(t) {
    let e = "";
    for (let r = 0; r < t.length; r++)
      e += String.fromCharCode(t[r]);
    return e;
  }
};
class LT {
  constructor() {
    this.pos = 0, this.out = "", this.buffer = new Uint8Array(sd);
  }
  write(e) {
    const { buffer: r } = this;
    r[this.pos++] = e, this.pos === sd && (this.out += id.decode(r), this.pos = 0);
  }
  flush() {
    const { buffer: e, out: r, pos: i } = this;
    return i > 0 ? r + id.decode(e.subarray(0, i)) : r;
  }
}
function RT(t) {
  const e = new LT();
  let r = 0, i = 0, n = 0, u = 0;
  for (let l = 0; l < t.length; l++) {
    const h = t[l];
    if (l > 0 && e.write(OT), h.length === 0)
      continue;
    let c = 0;
    for (let p = 0; p < h.length; p++) {
      const d = h[p];
      p > 0 && e.write(NT), c = Cs(e, d[0], c), d.length !== 1 && (r = Cs(e, d[1], r), i = Cs(e, d[2], i), n = Cs(e, d[3], n), d.length !== 4 && (u = Cs(e, d[4], u)));
    }
  }
  return e.flush();
}
class Dn {
  constructor(e) {
    this.bits = e instanceof Dn ? e.bits.slice() : [];
  }
  add(e) {
    this.bits[e >> 5] |= 1 << (e & 31);
  }
  has(e) {
    return !!(this.bits[e >> 5] & 1 << (e & 31));
  }
}
class ei {
  constructor(e, r, i) {
    this.start = e, this.end = r, this.original = i, this.intro = "", this.outro = "", this.content = i, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
  }
  appendLeft(e) {
    this.outro += e;
  }
  appendRight(e) {
    this.intro = this.intro + e;
  }
  clone() {
    const e = new ei(this.start, this.end, this.original);
    return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e;
  }
  contains(e) {
    return this.start < e && e < this.end;
  }
  eachNext(e) {
    let r = this;
    for (; r; )
      e(r), r = r.next;
  }
  eachPrevious(e) {
    let r = this;
    for (; r; )
      e(r), r = r.previous;
  }
  edit(e, r, i) {
    return this.content = e, i || (this.intro = "", this.outro = ""), this.storeName = r, this.edited = !0, this;
  }
  prependLeft(e) {
    this.outro = e + this.outro;
  }
  prependRight(e) {
    this.intro = e + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(e) {
    const r = e - this.start, i = this.original.slice(0, r), n = this.original.slice(r);
    this.original = i;
    const u = new ei(e, this.end, n);
    return u.outro = this.outro, this.outro = "", this.end = e, this.edited ? (u.edit("", !1), this.content = "") : this.content = i, u.next = this.next, u.next && (u.next.previous = u), u.previous = this, this.next = u, u;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(e) {
    if (this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
    const r = this.content.replace(e, "");
    if (r.length)
      return r !== this.content && (this.split(this.start + r.length).edit("", void 0, !0), this.edited && this.edit(r, this.storeName, !0)), !0;
    if (this.edit("", void 0, !0), this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
  }
  trimStart(e) {
    if (this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
    const r = this.content.replace(e, "");
    if (r.length) {
      if (r !== this.content) {
        const i = this.split(this.end - r.length);
        this.edited && i.edit(r, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
  }
}
function DT() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (t) => globalThis.btoa(unescape(encodeURIComponent(t))) : typeof Buffer == "function" ? (t) => Buffer.from(t, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
const MT = /* @__PURE__ */ DT();
class FT {
  constructor(e) {
    this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings = RT(e.mappings), typeof e.x_google_ignoreList < "u" && (this.x_google_ignoreList = e.x_google_ignoreList), typeof e.debugId < "u" && (this.debugId = e.debugId);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + MT(this.toString());
  }
}
function BT(t) {
  const e = t.split(`
`), r = e.filter((u) => /^\t+/.test(u)), i = e.filter((u) => /^ {2,}/.test(u));
  if (r.length === 0 && i.length === 0)
    return null;
  if (r.length >= i.length)
    return "	";
  const n = i.reduce((u, l) => {
    const h = /^ +/.exec(l)[0].length;
    return Math.min(h, u);
  }, 1 / 0);
  return new Array(n + 1).join(" ");
}
function $T(t, e) {
  const r = t.split(/[/\\]/), i = e.split(/[/\\]/);
  for (r.pop(); r[0] === i[0]; )
    r.shift(), i.shift();
  if (r.length) {
    let n = r.length;
    for (; n--; ) r[n] = "..";
  }
  return r.concat(i).join("/");
}
const UT = Object.prototype.toString;
function qT(t) {
  return UT.call(t) === "[object Object]";
}
function nd(t) {
  const e = t.split(`
`), r = [];
  for (let i = 0, n = 0; i < e.length; i++)
    r.push(n), n += e[i].length + 1;
  return function(n) {
    let u = 0, l = r.length;
    for (; u < l; ) {
      const p = u + l >> 1;
      n < r[p] ? l = p : u = p + 1;
    }
    const h = u - 1, c = n - r[h];
    return { line: h, column: c };
  };
}
const jT = /\w/;
class VT {
  constructor(e) {
    this.hires = e, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(e, r, i, n) {
    if (r.length) {
      const u = r.length - 1;
      let l = r.indexOf(`
`, 0), h = -1;
      for (; l >= 0 && u > l; ) {
        const p = [this.generatedCodeColumn, e, i.line, i.column];
        n >= 0 && p.push(n), this.rawSegments.push(p), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, h = l, l = r.indexOf(`
`, l + 1);
      }
      const c = [this.generatedCodeColumn, e, i.line, i.column];
      n >= 0 && c.push(n), this.rawSegments.push(c), this.advance(r.slice(h + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(r));
    this.pending = null;
  }
  addUneditedChunk(e, r, i, n, u) {
    let l = r.start, h = !0, c = !1;
    for (; l < r.end; ) {
      if (i[l] === `
`)
        n.line += 1, n.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, h = !0, c = !1;
      else {
        if (this.hires || h || u.has(l)) {
          const p = [this.generatedCodeColumn, e, n.line, n.column];
          this.hires === "boundary" ? jT.test(i[l]) ? c || (this.rawSegments.push(p), c = !0) : (this.rawSegments.push(p), c = !1) : this.rawSegments.push(p);
        }
        n.column += 1, this.generatedCodeColumn += 1, h = !1;
      }
      l += 1;
    }
    this.pending = null;
  }
  advance(e) {
    if (!e) return;
    const r = e.split(`
`);
    if (r.length > 1) {
      for (let i = 0; i < r.length - 1; i++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += r[r.length - 1].length;
  }
}
const Is = `
`, Xr = {
  insertLeft: !1,
  insertRight: !1,
  storeName: !1
};
class hi {
  constructor(e, r = {}) {
    const i = new ei(0, e.length, e);
    Object.defineProperties(this, {
      original: { writable: !0, value: e },
      outro: { writable: !0, value: "" },
      intro: { writable: !0, value: "" },
      firstChunk: { writable: !0, value: i },
      lastChunk: { writable: !0, value: i },
      lastSearchedChunk: { writable: !0, value: i },
      byStart: { writable: !0, value: {} },
      byEnd: { writable: !0, value: {} },
      filename: { writable: !0, value: r.filename },
      indentExclusionRanges: { writable: !0, value: r.indentExclusionRanges },
      sourcemapLocations: { writable: !0, value: new Dn() },
      storedNames: { writable: !0, value: {} },
      indentStr: { writable: !0, value: void 0 },
      ignoreList: { writable: !0, value: r.ignoreList },
      offset: { writable: !0, value: r.offset || 0 }
    }), this.byStart[0] = i, this.byEnd[e.length] = i;
  }
  addSourcemapLocation(e) {
    this.sourcemapLocations.add(e);
  }
  append(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.outro += e, this;
  }
  appendLeft(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const i = this.byEnd[e];
    return i ? i.appendLeft(r) : this.intro += r, this;
  }
  appendRight(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const i = this.byStart[e];
    return i ? i.appendRight(r) : this.outro += r, this;
  }
  clone() {
    const e = new hi(this.original, { filename: this.filename, offset: this.offset });
    let r = this.firstChunk, i = e.firstChunk = e.lastSearchedChunk = r.clone();
    for (; r; ) {
      e.byStart[i.start] = i, e.byEnd[i.end] = i;
      const n = r.next, u = n && n.clone();
      u && (i.next = u, u.previous = i, i = u), r = n;
    }
    return e.lastChunk = i, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), e.sourcemapLocations = new Dn(this.sourcemapLocations), e.intro = this.intro, e.outro = this.outro, e;
  }
  generateDecodedMap(e) {
    e = e || {};
    const r = 0, i = Object.keys(this.storedNames), n = new VT(e.hires), u = nd(this.original);
    return this.intro && n.advance(this.intro), this.firstChunk.eachNext((l) => {
      const h = u(l.start);
      l.intro.length && n.advance(l.intro), l.edited ? n.addEdit(
        r,
        l.content,
        h,
        l.storeName ? i.indexOf(l.original) : -1
      ) : n.addUneditedChunk(r, l, this.original, h, this.sourcemapLocations), l.outro.length && n.advance(l.outro);
    }), {
      file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
      sources: [
        e.source ? $T(e.file || "", e.source) : e.file || ""
      ],
      sourcesContent: e.includeContent ? [this.original] : void 0,
      names: i,
      mappings: n.raw,
      x_google_ignoreList: this.ignoreList ? [r] : void 0
    };
  }
  generateMap(e) {
    return new FT(this.generateDecodedMap(e));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = BT(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(e, r) {
    const i = /^[^\r\n]/gm;
    if (qT(e) && (r = e, e = void 0), e === void 0 && (this._ensureindentStr(), e = this.indentStr || "	"), e === "") return this;
    r = r || {};
    const n = {};
    r.exclude && (typeof r.exclude[0] == "number" ? [r.exclude] : r.exclude).forEach((d) => {
      for (let m = d[0]; m < d[1]; m += 1)
        n[m] = !0;
    });
    let u = r.indentStart !== !1;
    const l = (p) => u ? `${e}${p}` : (u = !0, p);
    this.intro = this.intro.replace(i, l);
    let h = 0, c = this.firstChunk;
    for (; c; ) {
      const p = c.end;
      if (c.edited)
        n[h] || (c.content = c.content.replace(i, l), c.content.length && (u = c.content[c.content.length - 1] === `
`));
      else
        for (h = c.start; h < p; ) {
          if (!n[h]) {
            const d = this.original[h];
            d === `
` ? u = !0 : d !== "\r" && u && (u = !1, h === c.start || (this._splitChunk(c, h), c = c.next), c.prependRight(e));
          }
          h += 1;
        }
      h = c.end, c = c.next;
    }
    return this.outro = this.outro.replace(i, l), this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(e, r) {
    return Xr.insertLeft || (console.warn(
      "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
    ), Xr.insertLeft = !0), this.appendLeft(e, r);
  }
  insertRight(e, r) {
    return Xr.insertRight || (console.warn(
      "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
    ), Xr.insertRight = !0), this.prependRight(e, r);
  }
  move(e, r, i) {
    if (e = e + this.offset, r = r + this.offset, i = i + this.offset, i >= e && i <= r) throw new Error("Cannot move a selection inside itself");
    this._split(e), this._split(r), this._split(i);
    const n = this.byStart[e], u = this.byEnd[r], l = n.previous, h = u.next, c = this.byStart[i];
    if (!c && u === this.lastChunk) return this;
    const p = c ? c.previous : this.lastChunk;
    return l && (l.next = h), h && (h.previous = l), p && (p.next = n), c && (c.previous = u), n.previous || (this.firstChunk = u.next), u.next || (this.lastChunk = n.previous, this.lastChunk.next = null), n.previous = p, u.next = c || null, p || (this.firstChunk = n), c || (this.lastChunk = u), this;
  }
  overwrite(e, r, i, n) {
    return n = n || {}, this.update(e, r, i, { ...n, overwrite: !n.contentOnly });
  }
  update(e, r, i, n) {
    if (e = e + this.offset, r = r + this.offset, typeof i != "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (r > this.original.length) throw new Error("end is out of bounds");
    if (e === r)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(e), this._split(r), n === !0 && (Xr.storeName || (console.warn(
      "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
    ), Xr.storeName = !0), n = { storeName: !0 });
    const u = n !== void 0 ? n.storeName : !1, l = n !== void 0 ? n.overwrite : !1;
    if (u) {
      const p = this.original.slice(e, r);
      Object.defineProperty(this.storedNames, p, {
        writable: !0,
        value: !0,
        enumerable: !0
      });
    }
    const h = this.byStart[e], c = this.byEnd[r];
    if (h) {
      let p = h;
      for (; p !== c; ) {
        if (p.next !== this.byStart[p.end])
          throw new Error("Cannot overwrite across a split point");
        p = p.next, p.edit("", !1);
      }
      h.edit(i, u, !l);
    } else {
      const p = new ei(e, r, "").edit(i, u);
      c.next = p, p.previous = c;
    }
    return this;
  }
  prepend(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.intro = e + this.intro, this;
  }
  prependLeft(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const i = this.byEnd[e];
    return i ? i.prependLeft(r) : this.intro = r + this.intro, this;
  }
  prependRight(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const i = this.byStart[e];
    return i ? i.prependRight(r) : this.outro = r + this.outro, this;
  }
  remove(e, r) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (e === r) return this;
    if (e < 0 || r > this.original.length) throw new Error("Character is out of bounds");
    if (e > r) throw new Error("end must be greater than start");
    this._split(e), this._split(r);
    let i = this.byStart[e];
    for (; i; )
      i.intro = "", i.outro = "", i.edit(""), i = r > i.end ? this.byStart[i.end] : null;
    return this;
  }
  reset(e, r) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (e === r) return this;
    if (e < 0 || r > this.original.length) throw new Error("Character is out of bounds");
    if (e > r) throw new Error("end must be greater than start");
    this._split(e), this._split(r);
    let i = this.byStart[e];
    for (; i; )
      i.reset(), i = r > i.end ? this.byStart[i.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let e = this.lastChunk;
    do {
      if (e.outro.length) return e.outro[e.outro.length - 1];
      if (e.content.length) return e.content[e.content.length - 1];
      if (e.intro.length) return e.intro[e.intro.length - 1];
    } while (e = e.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let e = this.outro.lastIndexOf(Is);
    if (e !== -1) return this.outro.substr(e + 1);
    let r = this.outro, i = this.lastChunk;
    do {
      if (i.outro.length > 0) {
        if (e = i.outro.lastIndexOf(Is), e !== -1) return i.outro.substr(e + 1) + r;
        r = i.outro + r;
      }
      if (i.content.length > 0) {
        if (e = i.content.lastIndexOf(Is), e !== -1) return i.content.substr(e + 1) + r;
        r = i.content + r;
      }
      if (i.intro.length > 0) {
        if (e = i.intro.lastIndexOf(Is), e !== -1) return i.intro.substr(e + 1) + r;
        r = i.intro + r;
      }
    } while (i = i.previous);
    return e = this.intro.lastIndexOf(Is), e !== -1 ? this.intro.substr(e + 1) + r : this.intro + r;
  }
  slice(e = 0, r = this.original.length - this.offset) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    let i = "", n = this.firstChunk;
    for (; n && (n.start > e || n.end <= e); ) {
      if (n.start < r && n.end >= r)
        return i;
      n = n.next;
    }
    if (n && n.edited && n.start !== e)
      throw new Error(`Cannot use replaced character ${e} as slice start anchor.`);
    const u = n;
    for (; n; ) {
      n.intro && (u !== n || n.start === e) && (i += n.intro);
      const l = n.start < r && n.end >= r;
      if (l && n.edited && n.end !== r)
        throw new Error(`Cannot use replaced character ${r} as slice end anchor.`);
      const h = u === n ? e - n.start : 0, c = l ? n.content.length + r - n.end : n.content.length;
      if (i += n.content.slice(h, c), n.outro && (!l || n.end === r) && (i += n.outro), l)
        break;
      n = n.next;
    }
    return i;
  }
  // TODO deprecate this? not really very useful
  snip(e, r) {
    const i = this.clone();
    return i.remove(0, e), i.remove(r, i.original.length), i;
  }
  _split(e) {
    if (this.byStart[e] || this.byEnd[e]) return;
    let r = this.lastSearchedChunk;
    const i = e > r.end;
    for (; r; ) {
      if (r.contains(e)) return this._splitChunk(r, e);
      r = i ? this.byStart[r.end] : this.byEnd[r.start];
    }
  }
  _splitChunk(e, r) {
    if (e.edited && e.content.length) {
      const n = nd(this.original)(r);
      throw new Error(
        `Cannot split a chunk that has already been edited (${n.line}:${n.column} – "${e.original}")`
      );
    }
    const i = e.split(r);
    return this.byEnd[r] = e, this.byStart[r] = i, this.byEnd[i.end] = i, e === this.lastChunk && (this.lastChunk = i), this.lastSearchedChunk = e, !0;
  }
  toString() {
    let e = this.intro, r = this.firstChunk;
    for (; r; )
      e += r.toString(), r = r.next;
    return e + this.outro;
  }
  isEmpty() {
    let e = this.firstChunk;
    do
      if (e.intro.length && e.intro.trim() || e.content.length && e.content.trim() || e.outro.length && e.outro.trim())
        return !1;
    while (e = e.next);
    return !0;
  }
  length() {
    let e = this.firstChunk, r = 0;
    do
      r += e.intro.length + e.content.length + e.outro.length;
    while (e = e.next);
    return r;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(e) {
    return this.trimStart(e).trimEnd(e);
  }
  trimEndAborted(e) {
    const r = new RegExp((e || "\\s") + "+$");
    if (this.outro = this.outro.replace(r, ""), this.outro.length) return !0;
    let i = this.lastChunk;
    do {
      const n = i.end, u = i.trimEnd(r);
      if (i.end !== n && (this.lastChunk === i && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.byEnd[i.next.end] = i.next), u) return !0;
      i = i.previous;
    } while (i);
    return !1;
  }
  trimEnd(e) {
    return this.trimEndAborted(e), this;
  }
  trimStartAborted(e) {
    const r = new RegExp("^" + (e || "\\s") + "+");
    if (this.intro = this.intro.replace(r, ""), this.intro.length) return !0;
    let i = this.firstChunk;
    do {
      const n = i.end, u = i.trimStart(r);
      if (i.end !== n && (i === this.lastChunk && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.byEnd[i.next.end] = i.next), u) return !0;
      i = i.next;
    } while (i);
    return !1;
  }
  trimStart(e) {
    return this.trimStartAborted(e), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(e, r) {
    function i(u, l) {
      return typeof r == "string" ? r.replace(/\$(\$|&|\d+)/g, (h, c) => c === "$" ? "$" : c === "&" ? u[0] : +c < u.length ? u[+c] : `$${c}`) : r(...u, u.index, l, u.groups);
    }
    function n(u, l) {
      let h;
      const c = [];
      for (; h = u.exec(l); )
        c.push(h);
      return c;
    }
    if (e.global)
      n(e, this.original).forEach((l) => {
        if (l.index != null) {
          const h = i(l, this.original);
          h !== l[0] && this.overwrite(l.index, l.index + l[0].length, h);
        }
      });
    else {
      const u = this.original.match(e);
      if (u && u.index != null) {
        const l = i(u, this.original);
        l !== u[0] && this.overwrite(u.index, u.index + u[0].length, l);
      }
    }
    return this;
  }
  _replaceString(e, r) {
    const { original: i } = this, n = i.indexOf(e);
    return n !== -1 && this.overwrite(n, n + e.length, r), this;
  }
  replace(e, r) {
    return typeof e == "string" ? this._replaceString(e, r) : this._replaceRegexp(e, r);
  }
  _replaceAllString(e, r) {
    const { original: i } = this, n = e.length;
    for (let u = i.indexOf(e); u !== -1; u = i.indexOf(e, u + n))
      i.slice(u, u + n) !== r && this.overwrite(u, u + n, r);
    return this;
  }
  replaceAll(e, r) {
    if (typeof e == "string")
      return this._replaceAllString(e, r);
    if (!e.global)
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    return this._replaceRegexp(e, r);
  }
}
var ad, od;
class zT {
  constructor(e, r) {
    this.descriptor = e, this.options = r, this.isCE = !1, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new hi(this.source), this.startOffset = (ad = this.descriptor.scriptSetup) == null ? void 0 : ad.loc.start.offset, this.endOffset = (od = this.descriptor.scriptSetup) == null ? void 0 : od.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = !1, this.hasDefineEmitCall = !1, this.hasDefineExposeCall = !1, this.hasDefaultExportName = !1, this.hasDefaultExportRender = !1, this.hasDefineOptionsCall = !1, this.hasDefineSlotsCall = !1, this.hasDefineModelCall = !1, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
    const { script: i, scriptSetup: n } = e, u = i && i.lang, l = n && n.lang;
    this.isJS = u === "js" || u === "jsx" || l === "js" || l === "jsx", this.isTS = u === "ts" || u === "tsx" || l === "ts" || l === "tsx";
    const h = r.customElement, c = this.descriptor.filename;
    h && (this.isCE = typeof h == "boolean" ? h : h(c));
    const p = hn(
      u || l,
      r.babelParserPlugins
    );
    function d(m, y) {
      try {
        return It.parse(m, {
          plugins: p,
          sourceType: "module"
        }).program;
      } catch (g) {
        throw g.message = `[vue/compiler-sfc] ${g.message}

${e.filename}
${ti(
          e.source,
          g.pos + y,
          g.pos + y + 1
        )}`, g;
      }
    }
    this.scriptAst = e.script && d(e.script.content, e.script.loc.start.offset), this.scriptSetupAst = e.scriptSetup && d(e.scriptSetup.content, this.startOffset);
  }
  helper(e) {
    return this.helperImports.add(e), `_${e}`;
  }
  getString(e, r = !0) {
    return (r ? this.descriptor.scriptSetup : this.descriptor.script).content.slice(e.start, e.end);
  }
  warn(e, r, i) {
    On(ud(e, r, this, i));
  }
  error(e, r, i) {
    throw new Error(
      `[@vue/compiler-sfc] ${ud(e, r, this, i)}`
    );
  }
}
function ud(t, e, r, i) {
  const n = i ? i.offset : r.startOffset;
  return `${t}

${(i || r.descriptor).filename}
${ti(
    (i || r.descriptor).source,
    e.start + n,
    e.end + n
  )}`;
}
function hn(t, e, r = !1) {
  const i = [];
  return (!e || !e.some(
    (n) => n === "importAssertions" || n === "importAttributes" || $e(n) && n[0] === "importAttributes"
  )) && i.push("importAttributes"), t === "jsx" || t === "tsx" || t === "mtsx" ? i.push("jsx") : e && (e = e.filter((n) => n !== "jsx")), (t === "ts" || t === "mts" || t === "tsx" || t === "mtsx") && (i.push(["typescript", { dts: r }], "explicitResourceManagement"), (!e || !e.includes("decorators")) && i.push("decorators-legacy")), e && i.push(...e), i;
}
function WT(t, e, r) {
  if (!HT(t)) {
    e.append(`
const ${r} = {}`);
    return;
  }
  t.forEach((i) => {
    if (i.type === "ExportDefaultDeclaration")
      if (i.declaration.type === "ClassDeclaration" && i.declaration.id) {
        const n = i.declaration.decorators && i.declaration.decorators.length > 0 ? i.declaration.decorators[i.declaration.decorators.length - 1].end : i.start;
        e.overwrite(n, i.declaration.id.start, " class "), e.append(`
const ${r} = ${i.declaration.id.name}`);
      } else
        e.overwrite(i.start, i.declaration.start, `const ${r} = `);
    else if (i.type === "ExportNamedDeclaration") {
      for (const n of i.specifiers)
        if (n.type === "ExportSpecifier" && n.exported.type === "Identifier" && n.exported.name === "default") {
          if (i.source)
            if (n.local.name === "default") {
              e.prepend(
                `import { default as __VUE_DEFAULT__ } from '${i.source.value}'
`
              );
              const l = Yo(e, n.local.end, i.end);
              e.remove(n.start, l), e.append(`
const ${r} = __VUE_DEFAULT__`);
              continue;
            } else {
              e.prepend(
                `import { ${e.slice(
                  n.local.start,
                  n.local.end
                )} as __VUE_DEFAULT__ } from '${i.source.value}'
`
              );
              const l = Yo(e, n.exported.end, i.end);
              e.remove(n.start, l), e.append(`
const ${r} = __VUE_DEFAULT__`);
              continue;
            }
          const u = Yo(e, n.end, i.end);
          e.remove(n.start, u), e.append(`
const ${r} = ${n.local.name}`);
        }
    }
  });
}
function HT(t) {
  for (const e of t) {
    if (e.type === "ExportDefaultDeclaration")
      return !0;
    if (e.type === "ExportNamedDeclaration" && e.specifiers.some(
      (r) => r.exported.name === "default"
    ))
      return !0;
  }
  return !1;
}
function Yo(t, e, r) {
  let i = !1, n = e;
  for (; e < r; )
    if (/\s/.test(t.slice(e, e + 1)))
      e++;
    else if (t.slice(e, e + 1) === ",") {
      e++, i = !0;
      break;
    } else if (t.slice(e, e + 1) === "}")
      break;
  return i ? e : n;
}
var GT = Object.defineProperty, XT = Object.defineProperties, JT = Object.getOwnPropertyDescriptors, ld = Object.getOwnPropertySymbols, KT = Object.prototype.hasOwnProperty, YT = Object.prototype.propertyIsEnumerable, cd = (t, e, r) => e in t ? GT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, QT = (t, e) => {
  for (var r in e || (e = {}))
    KT.call(e, r) && cd(t, r, e[r]);
  if (ld)
    for (var r of ld(e))
      YT.call(e, r) && cd(t, r, e[r]);
  return t;
}, ZT = (t, e) => XT(t, JT(e));
const Kr = "__default__";
function ew(t, e) {
  var r;
  const i = t.descriptor.script;
  if (i.lang && !t.isJS && !t.isTS)
    return i;
  try {
    let n = i.content, u = i.map;
    const l = t.scriptAst, h = U1(l.body), { cssVars: c } = t.descriptor, { genDefaultAs: p, isProd: d } = t.options;
    if (c.length || p) {
      const m = p || Kr, y = new hi(n);
      WT(l.body, y, m), n = y.toString(), c.length && !((r = t.options.templateOptions) != null && r.ssr) && (n += rS(
        c,
        h,
        e,
        !!d,
        m
      )), p || (n += `
export default ${m}`);
    }
    return ZT(QT({}, i), {
      content: n,
      map: u,
      bindings: h,
      scriptAst: l.body
    });
  } catch {
    return i;
  }
}
var tw = Object.defineProperty, rw = Object.defineProperties, sw = Object.getOwnPropertyDescriptors, hd = Object.getOwnPropertySymbols, iw = Object.prototype.hasOwnProperty, nw = Object.prototype.propertyIsEnumerable, fd = (t, e, r) => e in t ? tw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Mn = (t, e) => {
  for (var r in e || (e = {}))
    iw.call(e, r) && fd(t, r, e[r]);
  if (hd)
    for (var r of hd(e))
      nw.call(e, r) && fd(t, r, e[r]);
  return t;
}, Fn = (t, e) => rw(t, sw(e));
class ic {
  constructor(e, r, i = 0, n = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null)) {
    this.filename = e, this.source = r, this.offset = i, this.imports = n, this.types = u, this.declares = l, this.isGenericScope = !1, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function Ye(t, e, r, i) {
  const n = !i;
  if (n && e._resolvedElements)
    return e._resolvedElements;
  const u = aw(
    t,
    e,
    e._ownerScope || r || Aa(t),
    i
  );
  return n ? e._resolvedElements = u : u;
}
function aw(t, e, r, i) {
  var n, u;
  if (e.leadingComments && e.leadingComments.some((l) => l.value.includes("@vue-ignore")))
    return { props: {} };
  switch (e.type) {
    case "TSTypeLiteral":
      return j1(t, e.members, r, i);
    case "TSInterfaceDeclaration":
      return ow(t, e, r, i);
    case "TSTypeAliasDeclaration":
    case "TSTypeAnnotation":
    case "TSParenthesizedType":
      return Ye(
        t,
        e.typeAnnotation,
        r,
        i
      );
    case "TSFunctionType":
      return { props: {}, calls: [e] };
    case "TSUnionType":
    case "TSIntersectionType":
      return pd(
        e.types.map((l) => Ye(t, l, r, i)),
        e.type
      );
    case "TSMappedType":
      return uw(t, e, r, i);
    case "TSIndexedAccessType": {
      const l = V1(t, e, r);
      return pd(
        l.map((h) => Ye(t, h, h._ownerScope)),
        "TSUnionType"
      );
    }
    case "TSExpressionWithTypeArguments":
    case "TSTypeReference": {
      const l = ac(e);
      if ((l === "ExtractPropTypes" || l === "ExtractPublicPropTypes") && e.typeParameters && ((n = r.imports[l]) == null ? void 0 : n.source) === "vue")
        return gd(
          Ye(
            t,
            e.typeParameters.params[0],
            r,
            i
          ),
          r
        );
      const h = Ut(t, e, r);
      if (h) {
        let c;
        return (h.type === "TSTypeAliasDeclaration" || h.type === "TSInterfaceDeclaration") && h.typeParameters && e.typeParameters && (c = /* @__PURE__ */ Object.create(null), h.typeParameters.params.forEach((p, d) => {
          let m = i && i[p.name];
          m || (m = e.typeParameters.params[d]), c[p.name] = m;
        })), Ye(
          t,
          h,
          h._ownerScope,
          c
        );
      } else {
        if (typeof l == "string") {
          if (i && i[l])
            return Ye(
              t,
              i[l],
              r,
              i
            );
          if (
            // @ts-expect-error
            lw.has(l)
          )
            return cw(
              t,
              e,
              l,
              r,
              i
            );
          if (l === "ReturnType" && e.typeParameters) {
            const c = Sw(
              t,
              e.typeParameters.params[0],
              r
            );
            if (c)
              return Ye(t, c, r);
          }
        }
        return t.error(
          "Unresolvable type reference or unsupported built-in utility type",
          e,
          r
        );
      }
    }
    case "TSImportType": {
      if (Rr(e.argument) === "vue" && ((u = e.qualifier) == null ? void 0 : u.type) === "Identifier" && e.qualifier.name === "ExtractPropTypes" && e.typeParameters)
        return gd(
          Ye(t, e.typeParameters.params[0], r),
          r
        );
      const l = _a(
        t,
        e.argument,
        r,
        e.argument.value
      ), h = Ut(t, e, l);
      if (h)
        return Ye(t, h, h._ownerScope);
      break;
    }
    case "TSTypeQuery":
      {
        const l = Ut(t, e, r);
        if (l)
          return Ye(t, l, l._ownerScope);
      }
      break;
  }
  return t.error(`Unresolvable type: ${e.type}`, e, r);
}
function j1(t, e, r = Aa(t), i) {
  const n = { props: {} };
  for (const u of e)
    if (u.type === "TSPropertySignature" || u.type === "TSMethodSignature") {
      i && (r = uc(r), r.isGenericScope = !0, Object.assign(r.types, i)), u._ownerScope = r;
      const l = Rr(u.key);
      if (l && !u.computed)
        n.props[l] = u;
      else if (u.key.type === "TemplateLiteral")
        for (const h of nc(t, u.key, r))
          n.props[h] = u;
      else
        t.error(
          "Unsupported computed key in type referenced by a macro",
          u.key,
          r
        );
    } else u.type === "TSCallSignatureDeclaration" && (n.calls || (n.calls = [])).push(u);
  return n;
}
function pd(t, e) {
  if (t.length === 1) return t[0];
  const r = { props: {} }, { props: i } = r;
  for (const { props: n, calls: u } of t) {
    for (const l in n)
      Lu(i, l) ? i[l] = js(
        i[l].key,
        {
          type: e,
          // @ts-expect-error
          types: [i[l], n[l]]
        },
        i[l]._ownerScope,
        i[l].optional || n[l].optional
      ) : i[l] = n[l];
    u && (r.calls || (r.calls = [])).push(...u);
  }
  return r;
}
function js(t, e, r, i) {
  return {
    type: "TSPropertySignature",
    key: t,
    kind: "get",
    optional: i,
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    },
    _ownerScope: r
  };
}
function ow(t, e, r, i) {
  const n = j1(
    t,
    e.body.body,
    e._ownerScope,
    i
  );
  if (e.extends)
    for (const u of e.extends)
      try {
        const { props: l, calls: h } = Ye(t, u, r);
        for (const c in l)
          Lu(n.props, c) || (n.props[c] = l[c]);
        h && (n.calls || (n.calls = [])).push(...h);
      } catch {
        t.error(
          `Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`,
          u,
          r
        );
      }
  return n;
}
function uw(t, e, r, i) {
  const n = { props: {} };
  let u;
  if (e.nameType) {
    const { name: l, constraint: h } = e.typeParameter;
    r = uc(r), Object.assign(r.types, Fn(Mn({}, i), { [l]: h })), u = At(t, e.nameType, r);
  } else
    u = At(t, e.typeParameter.constraint, r);
  for (const l of u)
    n.props[l] = js(
      {
        type: "Identifier",
        name: l
      },
      e.typeAnnotation,
      r,
      !!e.optional
    );
  return n;
}
function V1(t, e, r) {
  var i, n;
  if (e.indexType.type === "TSNumberKeyword")
    return z1(t, e.objectType, r);
  const { indexType: u, objectType: l } = e, h = [];
  let c, p;
  u.type === "TSStringKeyword" ? (p = Ye(t, l, r), c = Object.keys(p.props)) : (c = At(t, u, r), p = Ye(t, l, r));
  for (const d of c) {
    const m = (n = (i = p.props[d]) == null ? void 0 : i.typeAnnotation) == null ? void 0 : n.typeAnnotation;
    m && (m._ownerScope = p.props[d]._ownerScope, h.push(m));
  }
  return h;
}
function z1(t, e, r) {
  if (e.type === "TSArrayType")
    return [e.elementType];
  if (e.type === "TSTupleType")
    return e.elementTypes.map(
      (i) => i.type === "TSNamedTupleMember" ? i.elementType : i
    );
  if (e.type === "TSTypeReference") {
    if (ac(e) === "Array" && e.typeParameters)
      return e.typeParameters.params;
    {
      const i = Ut(t, e, r);
      if (i)
        return z1(t, i, r);
    }
  }
  return t.error(
    "Failed to resolve element type from target type",
    e,
    r
  );
}
function At(t, e, r, i) {
  switch (e.type) {
    case "StringLiteral":
      return [e.value];
    case "TSLiteralType":
      return At(t, e.literal, r, i);
    case "TSUnionType":
      return e.types.map((n) => At(t, n, r, i)).flat();
    case "TemplateLiteral":
      return nc(t, e, r);
    case "TSTypeReference": {
      const n = Ut(t, e, r);
      if (n)
        return At(t, n, r, i);
      if (e.typeName.type === "Identifier") {
        const u = e.typeName.name;
        if (i && i[u])
          return At(
            t,
            i[u],
            r,
            i
          );
        const l = (h = 0) => At(
          t,
          e.typeParameters.params[h],
          r,
          i
        );
        switch (u) {
          case "Extract":
            return l(1);
          case "Exclude": {
            const h = l(1);
            return l().filter((c) => !h.includes(c));
          }
          case "Uppercase":
            return l().map((h) => h.toUpperCase());
          case "Lowercase":
            return l().map((h) => h.toLowerCase());
          case "Capitalize":
            return l().map(lr);
          case "Uncapitalize":
            return l().map((h) => h[0].toLowerCase() + h.slice(1));
          default:
            t.error(
              "Unsupported type when resolving index type",
              e.typeName,
              r
            );
        }
      }
    }
  }
  return t.error("Failed to resolve index type into finite keys", e, r);
}
function nc(t, e, r) {
  if (!e.expressions.length)
    return [e.quasis[0].value.raw];
  const i = [], n = e.expressions[0], u = e.quasis[0], l = u ? u.value.raw : "", h = At(t, n, r), c = nc(
    t,
    Fn(Mn({}, e), {
      expressions: e.expressions.slice(1),
      quasis: u ? e.quasis.slice(1) : e.quasis
    }),
    r
  );
  for (const p of h)
    for (const d of c)
      i.push(l + p + d);
  return i;
}
const lw = /* @__PURE__ */ new Set([
  "Partial",
  "Required",
  "Readonly",
  "Pick",
  "Omit"
]);
function cw(t, e, r, i, n) {
  const u = Ye(
    t,
    e.typeParameters.params[0],
    i,
    n
  );
  switch (r) {
    case "Partial": {
      const c = { props: {}, calls: u.calls };
      return Object.keys(u.props).forEach((p) => {
        c.props[p] = Fn(Mn({}, u.props[p]), { optional: !0 });
      }), c;
    }
    case "Required": {
      const c = { props: {}, calls: u.calls };
      return Object.keys(u.props).forEach((p) => {
        c.props[p] = Fn(Mn({}, u.props[p]), { optional: !1 });
      }), c;
    }
    case "Readonly":
      return u;
    case "Pick": {
      const c = At(
        t,
        e.typeParameters.params[1],
        i,
        n
      ), p = { props: {}, calls: u.calls };
      for (const d of c)
        p.props[d] = u.props[d];
      return p;
    }
    case "Omit":
      const l = At(
        t,
        e.typeParameters.params[1],
        i,
        n
      ), h = { props: {}, calls: u.calls };
      for (const c in u.props)
        l.includes(c) || (h.props[c] = u.props[c]);
      return h;
  }
}
function Ut(t, e, r, i, n = !1) {
  const u = !(r != null && r.isGenericScope);
  if (u && e._resolvedReference)
    return e._resolvedReference;
  const l = Nu(
    t,
    r || Aa(t),
    i || ac(e),
    e,
    n
  );
  return u ? e._resolvedReference = l : l;
}
function Nu(t, e, r, i, n) {
  if (typeof r == "string") {
    if (e.imports[r])
      return fw(t, i, r, e);
    {
      const u = i.type === "TSTypeQuery" ? n ? e.exportedDeclares : e.declares : n ? e.exportedTypes : e.types;
      if (u[r])
        return u[r];
      {
        const l = hw(t);
        if (l)
          for (const h of l) {
            const c = i.type === "TSTypeQuery" ? h.declares : h.types;
            if (c[r])
              return (t.deps || (t.deps = /* @__PURE__ */ new Set())).add(h.filename), c[r];
          }
      }
    }
  } else {
    let u = Nu(t, e, r[0], i, n);
    if (u && (u.type !== "TSModuleDeclaration" && (u = u._ns), u)) {
      const l = dw(t, u, u._ownerScope || e);
      return Nu(
        t,
        l,
        r.length > 2 ? r.slice(1) : r[r.length - 1],
        i,
        !u.declare
      );
    }
  }
}
function ac(t) {
  const e = t.type === "TSTypeReference" ? t.typeName : t.type === "TSExpressionWithTypeArguments" ? t.expression : t.type === "TSImportType" ? t.qualifier : t.exprName;
  return (e == null ? void 0 : e.type) === "Identifier" ? e.name : (e == null ? void 0 : e.type) === "TSQualifiedName" ? W1(e) : "default";
}
function W1(t) {
  return t.type === "Identifier" ? [t.name] : [...W1(t.left), t.right.name];
}
function hw(t) {
  if (t.options.globalTypeFiles) {
    if (!oc(t))
      throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
    return t.options.globalTypeFiles.map(
      (r) => H1(t, B1(r), !0)
    );
  }
}
function oc(t) {
  if (t.fs)
    return t.fs;
  const e = t.options.fs || void 0;
  if (e)
    return t.fs = {
      fileExists(r) {
        return r.endsWith(".vue.ts") && !r.endsWith(".d.vue.ts") && (r = r.replace(/\.ts$/, "")), e.fileExists(r);
      },
      readFile(r) {
        return r.endsWith(".vue.ts") && !r.endsWith(".d.vue.ts") && (r = r.replace(/\.ts$/, "")), e.readFile(r);
      },
      realpath: e.realpath
    };
}
function fw(t, e, r, i) {
  const { source: n, imported: u } = i.imports[r], l = _a(t, e, i, n);
  return Ut(t, e, l, u, !0);
}
function _a(t, e, r, i) {
  let n;
  try {
    n = oc(t);
  } catch (l) {
    return t.error(l.message, e, r);
  }
  if (!n)
    return t.error(
      "No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.",
      e,
      r
    );
  let u = r.resolvedImportSources[i];
  if (!u) {
    if (i.startsWith("..")) {
      const h = qs(Tn(r.filename), i);
      u = dd(h, n);
    } else if (i[0] === ".") {
      const l = qs(Tn(r.filename), i);
      u = dd(l, n);
    } else
      return t.error(
        "Type import from non-relative sources is not supported in the browser build.",
        e,
        r
      );
    u && (u = r.resolvedImportSources[i] = B1(u));
  }
  return u ? ((t.deps || (t.deps = /* @__PURE__ */ new Set())).add(u), H1(t, u)) : t.error(
    `Failed to resolve import source ${JSON.stringify(i)}.`,
    e,
    r
  );
}
function dd(t, e) {
  t = t.replace(/\.js$/, "");
  const r = (i) => {
    if (e.fileExists(i)) return i;
  };
  return r(t) || r(t + ".ts") || r(t + ".tsx") || r(t + ".d.ts") || r(qs(t, "index.ts")) || r(qs(t, "index.tsx")) || r(qs(t, "index.d.ts"));
}
const md = wl();
function H1(t, e, r = !1) {
  const i = md.get(e);
  if (i)
    return i;
  const n = oc(t), u = n.readFile(e) || "", l = pw(e, u, n, t.options.babelParserPlugins), h = new ic(e, u, 0, G1(l));
  return lc(t, l, h, r), md.set(e, h), h;
}
function pw(t, e, r, i) {
  const n = Cl(t);
  if (n === ".ts" || n === ".mts" || n === ".tsx" || n === ".mtsx")
    return It.parse(e, {
      plugins: hn(
        n.slice(1),
        i,
        /\.d\.m?ts$/.test(t)
      ),
      sourceType: "module"
    }).program.body;
  const u = !/\.[cm]?[tj]sx?$/.test(t), l = `${t.slice(0, -n.length)}.d${n}.ts`;
  if (u && r.fileExists(l))
    return It.parse(r.readFile(l), {
      plugins: hn("ts", i, !0),
      sourceType: "module"
    }).program.body;
  if (n === ".vue") {
    const {
      descriptor: { script: c, scriptSetup: p }
    } = z0(e);
    if (!c && !p)
      return [];
    const d = c ? c.loc.start.offset : 1 / 0, m = p ? p.loc.start.offset : 1 / 0, y = d < m ? c : p, g = d < m ? p : c;
    let E = " ".repeat(Math.min(d, m)) + y.content;
    g && (E += " ".repeat(g.loc.start.offset - c.loc.end.offset) + g.content);
    const S = (c == null ? void 0 : c.lang) || (p == null ? void 0 : p.lang);
    return It.parse(E, {
      plugins: hn(S, i),
      sourceType: "module"
    }).program.body;
  }
  return [];
}
function Aa(t) {
  if (t.scope)
    return t.scope;
  const e = "ast" in t ? t.ast : t.scriptAst ? [...t.scriptAst.body, ...t.scriptSetupAst.body] : t.scriptSetupAst.body, r = new ic(
    t.filename,
    t.source,
    "startOffset" in t ? t.startOffset : 0,
    "userImports" in t ? Object.create(t.userImports) : G1(e)
  );
  return lc(t, e, r), t.scope = r;
}
function dw(t, e, r) {
  if (e._resolvedChildScope)
    return e._resolvedChildScope;
  const i = uc(r);
  if (e.body.type === "TSModuleDeclaration") {
    const n = e.body;
    n._ownerScope = i;
    const u = Rr(n.id);
    i.types[u] = i.exportedTypes[u] = n;
  } else
    lc(t, e.body.body, i);
  return e._resolvedChildScope = i;
}
function uc(t) {
  return new ic(
    t.filename,
    t.source,
    t.offset,
    Object.create(t.imports),
    Object.create(t.types),
    Object.create(t.declares)
  );
}
const mw = /^Import|^Export/;
function lc(t, e, r, i = !1) {
  const { types: n, declares: u, exportedTypes: l, exportedDeclares: h, imports: c } = r, p = i ? !e.some((d) => mw.test(d.type)) : !1;
  for (const d of e)
    if (i) {
      if (p)
        d.declare && br(d, n, u);
      else if (d.type === "TSModuleDeclaration" && d.global)
        for (const m of d.body.body)
          br(m, n, u);
    } else
      br(d, n, u);
  if (!i)
    for (const d of e)
      if (d.type === "ExportNamedDeclaration") {
        if (d.declaration)
          br(d.declaration, n, u), br(d.declaration, l, h);
        else
          for (const m of d.specifiers)
            if (m.type === "ExportSpecifier") {
              const y = m.local.name, g = Rr(m.exported);
              d.source ? (c[g] = {
                source: d.source.value,
                imported: y
              }, l[g] = {
                type: "TSTypeReference",
                typeName: {
                  type: "Identifier",
                  name: y
                },
                _ownerScope: r
              }) : n[y] && (l[g] = n[y]);
            }
      } else if (d.type === "ExportAllDeclaration") {
        const m = _a(
          t,
          d.source,
          r,
          d.source.value
        );
        Object.assign(r.exportedTypes, m.exportedTypes);
      } else d.type === "ExportDefaultDeclaration" && d.declaration && (d.declaration.type !== "Identifier" ? (br(d.declaration, n, u, "default"), br(
        d.declaration,
        l,
        h,
        "default"
      )) : n[d.declaration.name] && (l.default = n[d.declaration.name]));
  for (const d of Object.keys(n)) {
    const m = n[d];
    m._ownerScope = r, m._ns && (m._ns._ownerScope = r);
  }
  for (const d of Object.keys(u))
    u[d]._ownerScope = r;
}
function br(t, e, r, i) {
  switch (t.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const n = i || Rr(t.id);
      let u = e[n];
      if (u) {
        if (t.type === "TSModuleDeclaration") {
          u.type === "TSModuleDeclaration" ? cc(u, t) : yd(u, t);
          break;
        }
        if (u.type === "TSModuleDeclaration") {
          e[n] = t, yd(t, u);
          break;
        }
        if (u.type !== t.type)
          break;
        t.type === "TSInterfaceDeclaration" ? u.body.body.push(...t.body.body) : u.members.push(...t.members);
      } else
        e[n] = t;
      break;
    }
    case "ClassDeclaration":
      (i || t.id) && (e[i || Rr(t.id)] = t);
      break;
    case "TSTypeAliasDeclaration":
      e[t.id.name] = t.typeParameters ? t : t.typeAnnotation;
      break;
    case "TSDeclareFunction":
      t.id && (r[t.id.name] = t);
      break;
    case "VariableDeclaration": {
      if (t.declare)
        for (const n of t.declarations)
          n.id.type === "Identifier" && n.id.typeAnnotation && (r[n.id.name] = n.id.typeAnnotation.typeAnnotation);
      break;
    }
  }
}
function cc(t, e) {
  const r = t.body, i = e.body;
  r.type === "TSModuleDeclaration" ? i.type === "TSModuleDeclaration" ? cc(r, i) : i.body.push({
    type: "ExportNamedDeclaration",
    declaration: r,
    exportKind: "type",
    specifiers: []
  }) : i.type === "TSModuleDeclaration" ? r.body.push({
    type: "ExportNamedDeclaration",
    declaration: i,
    exportKind: "type",
    specifiers: []
  }) : r.body.push(...i.body);
}
function yd(t, e) {
  t._ns ? cc(t._ns, e) : t._ns = e;
}
function G1(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r of t)
    yw(r, e);
  return e;
}
function yw(t, e) {
  if (t.type === "ImportDeclaration")
    for (const r of t.specifiers)
      e[r.local.name] = {
        imported: Au(r),
        source: t.source.value
      };
}
function Ke(t, e, r = e._ownerScope || Aa(t), i = !1) {
  try {
    switch (e.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const n = /* @__PURE__ */ new Set(), u = e.type === "TSTypeLiteral" ? e.members : e.body.body;
        for (const l of u)
          if (i)
            if (l.type === "TSPropertySignature" && l.key.type === "NumericLiteral")
              n.add("Number");
            else if (l.type === "TSIndexSignature") {
              const h = l.parameters[0].typeAnnotation;
              if (h && h.type !== "Noop") {
                const c = Ke(
                  t,
                  h.typeAnnotation,
                  r
                )[0];
                if (c === kt) return [kt];
                n.add(c);
              }
            } else
              n.add("String");
          else l.type === "TSCallSignatureDeclaration" || l.type === "TSConstructSignatureDeclaration" ? n.add("Function") : n.add("Object");
        return n.size ? Array.from(n) : [i ? kt : "Object"];
      }
      case "TSPropertySignature":
        if (e.typeAnnotation)
          return Ke(
            t,
            e.typeAnnotation.typeAnnotation,
            r
          );
        break;
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (e.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [kt];
        }
      case "TSTypeReference": {
        const n = Ut(t, e, r);
        if (n)
          return n.type === "TSTypeAliasDeclaration" && n.typeAnnotation.type === "TSFunctionType" ? ["Function"] : Ke(t, n, n._ownerScope, i);
        if (e.typeName.type === "Identifier")
          if (i)
            switch (e.typeName.name) {
              case "String":
              case "Array":
              case "ArrayLike":
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["String", "Number"];
              case "Record":
              case "Partial":
              case "Required":
              case "Readonly":
                if (e.typeParameters && e.typeParameters.params[0])
                  return Ke(
                    t,
                    e.typeParameters.params[0],
                    r,
                    !0
                  );
                break;
              case "Pick":
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return Ke(
                    t,
                    e.typeParameters.params[1],
                    r
                  );
                break;
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
              case "ReadonlyMap":
              case "ReadonlySet":
                return ["String"];
            }
          else
            switch (e.typeName.name) {
              case "Array":
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
                return [e.typeName.name];
              case "Partial":
              case "Required":
              case "Readonly":
              case "Record":
              case "Pick":
              case "Omit":
              case "InstanceType":
                return ["Object"];
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
                return ["String"];
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["Array"];
              case "ReadonlyMap":
                return ["Map"];
              case "ReadonlySet":
                return ["Set"];
              case "NonNullable":
                if (e.typeParameters && e.typeParameters.params[0])
                  return Ke(
                    t,
                    e.typeParameters.params[0],
                    r
                  ).filter((u) => u !== "null");
                break;
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return Ke(
                    t,
                    e.typeParameters.params[1],
                    r
                  );
                break;
              case "Exclude":
              case "OmitThisParameter":
                if (e.typeParameters && e.typeParameters.params[0])
                  return Ke(
                    t,
                    e.typeParameters.params[0],
                    r
                  );
                break;
            }
        break;
      }
      case "TSParenthesizedType":
        return Ke(t, e.typeAnnotation, r);
      case "TSUnionType":
        return Qo(t, e.types, r, i);
      case "TSIntersectionType":
        return Qo(t, e.types, r, i).filter(
          (n) => n !== kt
        );
      case "TSEnumDeclaration":
        return gw(e);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType": {
        const n = V1(t, e, r);
        return Qo(t, n, r, i);
      }
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const n = _a(
          t,
          e.argument,
          r,
          e.argument.value
        ), u = Ut(t, e, n);
        if (u)
          return Ke(t, u, u._ownerScope);
        break;
      }
      case "TSTypeQuery": {
        const n = e.exprName;
        if (n.type === "Identifier") {
          const u = r.declares[n.name];
          if (u)
            return Ke(t, u, u._ownerScope, i);
        }
        break;
      }
      case "TSTypeOperator":
        return Ke(
          t,
          e.typeAnnotation,
          r,
          e.operator === "keyof"
        );
      case "TSAnyKeyword": {
        if (i)
          return ["String", "Number", "Symbol"];
        break;
      }
    }
  } catch {
  }
  return [kt];
}
function Qo(t, e, r, i = !1) {
  return e.length === 1 ? Ke(t, e[0], r, i) : [
    ...new Set(
      [].concat(
        ...e.map((n) => Ke(t, n, r, i))
      )
    )
  ];
}
function gw(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.members)
    if (r.initializer)
      switch (r.initializer.type) {
        case "StringLiteral":
          e.add("String");
          break;
        case "NumericLiteral":
          e.add("Number");
          break;
      }
  return e.size ? [...e] : ["Number"];
}
function gd({ props: t }, e) {
  const r = { props: {} };
  for (const i in t) {
    const n = t[i];
    r.props[i] = Ou(
      n.key,
      n.typeAnnotation.typeAnnotation,
      e
    );
  }
  return r;
}
function Ou(t, e, r, i = !0, n = !0) {
  if (n && e.type === "TSTypeLiteral") {
    const u = bd(e, "type");
    if (u) {
      const l = bd(e, "required"), h = l && l.type === "TSLiteralType" && l.literal.type === "BooleanLiteral" ? !l.literal.value : !0;
      return Ou(t, u, r, h, !1);
    }
  } else if (e.type === "TSTypeReference" && e.typeName.type === "Identifier") {
    if (e.typeName.name.endsWith("Constructor"))
      return js(
        t,
        bw(e.typeName.name),
        r,
        i
      );
    if (e.typeName.name === "PropType" && e.typeParameters)
      return js(t, e.typeParameters.params[0], r, i);
  }
  if ((e.type === "TSTypeReference" || e.type === "TSImportType") && e.typeParameters)
    for (const u of e.typeParameters.params) {
      const l = Ou(t, u, r, i);
      if (l) return l;
    }
  return js(t, { type: "TSNullKeyword" }, r, i);
}
function bw(t) {
  const e = t.slice(0, -11);
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
      return { type: `TS${e}Keyword` };
    case "Array":
    case "Function":
    case "Object":
    case "Set":
    case "Map":
    case "WeakSet":
    case "WeakMap":
    case "Date":
    case "Promise":
      return {
        type: "TSTypeReference",
        typeName: { type: "Identifier", name: e }
      };
  }
  return { type: "TSNullKeyword" };
}
function bd(t, e) {
  const r = t.members.find(
    (i) => i.type === "TSPropertySignature" && !i.computed && Rr(i.key) === e && i.typeAnnotation
  );
  return r && r.typeAnnotation.typeAnnotation;
}
function Sw(t, e, r) {
  var i;
  let n = e;
  if ((e.type === "TSTypeReference" || e.type === "TSTypeQuery" || e.type === "TSImportType") && (n = Ut(t, e, r)), !!n) {
    if (n.type === "TSFunctionType")
      return (i = n.typeAnnotation) == null ? void 0 : i.typeAnnotation;
    if (n.type === "TSDeclareFunction")
      return n.returnType;
  }
}
function X1(t, e, r) {
  if (e.type === "TSTypeReference") {
    const n = Ut(t, e, r);
    n && (e = n);
  }
  let i;
  return e.type === "TSUnionType" ? i = e.types.flatMap((n) => X1(t, n, r)) : i = [e], i;
}
const Ca = "defineModel";
function Sd(t, e, r) {
  if (!st(e, Ca))
    return !1;
  t.hasDefineModelCall = !0;
  const i = e.typeParameters && e.typeParameters.params[0] || void 0;
  let n, u;
  const l = e.arguments[0] && vt(e.arguments[0]), h = l && l.type === "StringLiteral";
  h ? (n = l.value, u = e.arguments[1]) : (n = "modelValue", u = l), t.modelDecls[n] && t.error(`duplicate model name ${JSON.stringify(n)}`, e);
  let c = u && t.getString(u), p = !u;
  const d = [];
  if (u && u.type === "ObjectExpression" && !u.properties.some((m) => m.type === "SpreadElement" || m.computed)) {
    let m = 0;
    for (let y = u.properties.length - 1; y >= 0; y--) {
      const g = u.properties[y], E = u.properties[y + 1], S = g.start, x = E ? E.start : u.end - 1;
      (g.type === "ObjectProperty" || g.type === "ObjectMethod") && (g.key.type === "Identifier" && (g.key.name === "get" || g.key.name === "set") || g.key.type === "StringLiteral" && (g.key.value === "get" || g.key.value === "set")) ? c = c.slice(0, S - u.start) + c.slice(x - u.start) : (m++, t.s.remove(t.startOffset + S, t.startOffset + x), d.push(g));
    }
    m === u.properties.length && (p = !0, t.s.remove(
      t.startOffset + (h ? l.end : u.start),
      t.startOffset + u.end
    ));
  }
  return t.modelDecls[n] = {
    type: i,
    options: c,
    runtimeOptionNodes: d,
    identifier: r && r.type === "Identifier" ? r.name : void 0
  }, t.bindingMetadata[n] = "props", t.s.overwrite(
    t.startOffset + e.callee.start,
    t.startOffset + e.callee.end,
    t.helper("useModel")
  ), t.s.appendLeft(
    t.startOffset + (e.arguments.length ? e.arguments[0].start : e.end - 1),
    "__props, " + (h ? "" : `${JSON.stringify(n)}${p ? "" : ", "}`)
  ), !0;
}
function vw(t) {
  if (!t.hasDefineModelCall) return;
  const e = !!t.options.isProd;
  let r = "";
  for (const [i, { type: n, options: u }] of Object.entries(
    t.modelDecls
  )) {
    let l = !1, h = "", c = n && Ke(t, n);
    if (c) {
      const m = c.includes("Boolean"), y = c.includes("Function");
      c.includes(kt) && (m || y ? (c = c.filter((E) => E !== kt), l = !0) : c = ["null"]), e ? (m || u && y) && (h = `type: ${Qr(c)}`) : h = `type: ${Qr(c)}` + (l ? ", skipCheck: true" : "");
    }
    let p;
    h && u ? p = t.isTS ? `{ ${h}, ...${u} }` : `Object.assign({ ${h} }, ${u})` : h ? p = `{ ${h} }` : u ? p = u : p = "{}", r += `
    ${JSON.stringify(i)}: ${p},`;
    const d = JSON.stringify(
      i === "modelValue" ? "modelModifiers" : `${i}Modifiers`
    );
    r += `
    ${d}: {},`;
  }
  return `{${r}
  }`;
}
const Ge = "defineProps", Er = "withDefaults";
function ku(t, e, r, i = !1) {
  if (!st(e, Ge))
    return xw(t, e, r);
  if (t.hasDefinePropsCall && t.error(`duplicate ${Ge}() call`, e), t.hasDefinePropsCall = !0, t.propsRuntimeDecl = e.arguments[0], t.propsRuntimeDecl)
    for (const n of Iu(t.propsRuntimeDecl))
      n in t.bindingMetadata || (t.bindingMetadata[n] = "props");
  return e.typeParameters && (t.propsRuntimeDecl && t.error(
    `${Ge}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), t.propsTypeDecl = e.typeParameters.params[0]), !i && r && r.type === "ObjectPattern" && Cw(t, r), t.propsCall = e, t.propsDecl = r, !0;
}
function xw(t, e, r) {
  return st(e, Er) ? (ku(
    t,
    e.arguments[0],
    r,
    !0
  ) || t.error(
    `${Er}' first argument must be a ${Ge} call.`,
    e.arguments[0] || e
  ), t.propsRuntimeDecl && t.error(
    `${Er} can only be used with type-based ${Ge} declaration.`,
    e
  ), r && r.type === "ObjectPattern" && t.warn(
    `${Er}() is unnecessary when using destructure with ${Ge}().
Reactive destructure will be disabled when using withDefaults().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...). `,
    e.callee
  ), t.propsRuntimeDefaults = e.arguments[1], t.propsRuntimeDefaults || t.error(`The 2nd argument of ${Er} is required.`, e), t.propsCall = e, !0) : !1;
}
function Ew(t) {
  let e;
  if (t.propsRuntimeDecl) {
    if (e = t.getString(t.propsRuntimeDecl).trim(), t.propsDestructureDecl) {
      const i = [];
      for (const n in t.propsDestructuredBindings) {
        const u = J1(t, n), l = $1(n);
        u && i.push(
          `${l}: ${u.valueString}${u.needSkipFactory ? `, __skip_${l}: true` : ""}`
        );
      }
      i.length && (e = `/*@__PURE__*/${t.helper(
        "mergeDefaults"
      )}(${e}, {
  ${i.join(`,
  `)}
})`);
    }
  } else t.propsTypeDecl && (e = Tw(t));
  const r = vw(t);
  return e && r ? `/*@__PURE__*/${t.helper(
    "mergeModels"
  )}(${e}, ${r})` : r || e;
}
function Tw(t) {
  const e = ww(t, t.propsTypeDecl);
  if (!e.length)
    return;
  const r = [], i = _w(t);
  for (const u of e)
    r.push(Pw(t, u, i)), "bindingMetadata" in t && !(u.key in t.bindingMetadata) && (t.bindingMetadata[u.key] = "props");
  let n = `{
    ${r.join(`,
    `)}
  }`;
  return t.propsRuntimeDefaults && !i && (n = `/*@__PURE__*/${t.helper(
    "mergeDefaults"
  )}(${n}, ${t.getString(t.propsRuntimeDefaults)})`), n;
}
function ww(t, e) {
  const r = [], i = Ye(t, e);
  for (const n in i.props) {
    const u = i.props[n];
    let l = Ke(t, u), h = !1;
    l.includes(kt) && (l.includes("Boolean") || l.includes("Function") ? (l = l.filter((c) => c !== kt), h = !0) : l = ["null"]), r.push({
      key: n,
      required: !u.optional,
      type: l || ["null"],
      skipCheck: h
    });
  }
  return r;
}
function Pw(t, { key: e, required: r, type: i, skipCheck: n }, u) {
  let l;
  const h = J1(t, e, i);
  if (h)
    l = `default: ${h.valueString}${h.needSkipFactory ? ", skipFactory: true" : ""}`;
  else if (u) {
    const p = t.propsRuntimeDefaults.properties.find(
      (d) => d.type === "SpreadElement" ? !1 : sc(d.key, d.computed) === e
    );
    p && (p.type === "ObjectProperty" ? l = `default: ${t.getString(p.value)}` : l = `${p.async ? "async " : ""}${p.kind !== "method" ? `${p.kind} ` : ""}default() ${t.getString(p.body)}`);
  }
  const c = $1(e);
  return t.options.isProd ? i.some(
    (p) => p === "Boolean" || (!u || l) && p === "Function"
  ) ? `${c}: { ${td([
    `type: ${Qr(i)}`,
    l
  ])} }` : t.isCE ? l ? `${c}: ${`{ ${l}, type: ${Qr(
    i
  )} }`}` : `${c}: {type: ${Qr(i)}}` : `${c}: ${l ? `{ ${l} }` : "{}"}` : `${c}: { ${td([
    `type: ${Qr(i)}`,
    `required: ${r}`,
    n && "skipCheck: true",
    l
  ])} }`;
}
function _w(t) {
  return !!(t.propsRuntimeDefaults && t.propsRuntimeDefaults.type === "ObjectExpression" && t.propsRuntimeDefaults.properties.every(
    (e) => e.type !== "SpreadElement" && (!e.computed || e.key.type.endsWith("Literal"))
  ));
}
function J1(t, e, r) {
  const i = t.propsDestructuredBindings[e], n = i && i.default;
  if (n) {
    const u = t.getString(n), l = vt(n);
    if (r && r.length && !r.includes("null")) {
      const p = Aw(l);
      p && !r.includes(p) && t.error(
        `Default value of prop "${e}" does not match declared type.`,
        l
      );
    }
    const h = !r && (ur(l) || l.type === "Identifier");
    return {
      valueString: !h && !F1(l) && !(r != null && r.includes("Function")) ? `() => (${u})` : u,
      needSkipFactory: h
    };
  }
}
function Aw(t) {
  switch (t.type) {
    case "StringLiteral":
      return "String";
    case "NumericLiteral":
      return "Number";
    case "BooleanLiteral":
      return "Boolean";
    case "ObjectExpression":
      return "Object";
    case "ArrayExpression":
      return "Array";
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return "Function";
  }
}
function Cw(t, e) {
  if (t.options.propsDestructure === "error")
    t.error("Props destructure is explicitly prohibited via config.", e);
  else if (t.options.propsDestructure === !1)
    return;
  t.propsDestructureDecl = e;
  const r = (i, n, u) => {
    t.propsDestructuredBindings[i] = { local: n, default: u }, n !== i && (t.bindingMetadata[n] = "props-aliased", (t.bindingMetadata.__propsAliases || (t.bindingMetadata.__propsAliases = {}))[n] = i);
  };
  for (const i of e.properties)
    if (i.type === "ObjectProperty") {
      const n = sc(i.key, i.computed);
      if (n || t.error(
        `${Ge}() destructure cannot use computed key.`,
        i.key
      ), i.value.type === "AssignmentPattern") {
        const { left: u, right: l } = i.value;
        u.type !== "Identifier" && t.error(
          `${Ge}() destructure does not support nested patterns.`,
          u
        ), r(n, u.name, l);
      } else i.value.type === "Identifier" ? r(n, i.value.name) : t.error(
        `${Ge}() destructure does not support nested patterns.`,
        i.value
      );
    } else
      t.propsDestructureRestId = i.argument.name, t.bindingMetadata[t.propsDestructureRestId] = "setup-reactive-const";
}
function Iw(t, e) {
  if (t.options.propsDestructure === !1)
    return;
  const r = /* @__PURE__ */ Object.create(null), i = [r];
  let n = r;
  const u = /* @__PURE__ */ new WeakSet(), l = [], h = /* @__PURE__ */ Object.create(null);
  for (const x in t.propsDestructuredBindings) {
    const { local: v } = t.propsDestructuredBindings[x];
    r[v] = !0, h[v] = x;
  }
  function c() {
    i.push(n = Object.create(n));
  }
  function p() {
    i.pop(), n = i[i.length - 1] || null;
  }
  function d(x) {
    u.add(x), n ? n[x.name] = !1 : t.error(
      "registerBinding called without active scope, something is wrong.",
      x
    );
  }
  function m(x, v = !1) {
    for (const P of x.body)
      if (P.type === "VariableDeclaration")
        y(P, v);
      else if (P.type === "FunctionDeclaration" || P.type === "ClassDeclaration") {
        if (P.declare || !P.id) continue;
        d(P.id);
      } else (P.type === "ForOfStatement" || P.type === "ForInStatement") && P.left.type === "VariableDeclaration" ? y(P.left) : P.type === "ExportNamedDeclaration" && P.declaration && P.declaration.type === "VariableDeclaration" ? y(P.declaration, v) : P.type === "LabeledStatement" && P.body.type === "VariableDeclaration" && y(P.body, v);
  }
  function y(x, v = !1) {
    if (!x.declare)
      for (const P of x.declarations) {
        const A = v && P.init && st(vt(P.init), "defineProps");
        for (const N of _t(P.id))
          A ? u.add(N) : d(N);
      }
  }
  function g(x, v, P) {
    (v.type === "AssignmentExpression" && x === v.left || v.type === "UpdateExpression") && t.error("Cannot assign to destructured props as they are readonly.", x), ra(v) && v.shorthand ? (!v.inPattern || Gs(v, P)) && t.s.appendLeft(
      x.end + t.startOffset,
      `: ${pn(h[x.name])}`
    ) : t.s.overwrite(
      x.start + t.startOffset,
      x.end + t.startOffset,
      pn(h[x.name])
    );
  }
  function E(x, v, P = v) {
    if (st(x, P)) {
      const A = vt(x.arguments[0]);
      A.type === "Identifier" && n[A.name] && t.error(
        `"${A.name}" is a destructured prop and should not be passed directly to ${v}(). Pass a getter () => ${A.name} instead.`,
        A
      );
    }
  }
  const S = t.scriptSetupAst;
  m(S, !0), Hu(S, {
    enter(x, v) {
      if (v && l.push(v), v && v.type.startsWith("TS") && !sa.includes(v.type))
        return this.skip();
      if (E(x, "watch", e.watch), E(x, "toRef", e.toRef), ur(x)) {
        c(), Xu(x, d), x.body.type === "BlockStatement" && m(x.body);
        return;
      }
      if (x.type === "CatchClause") {
        c(), x.param && x.param.type === "Identifier" && d(x.param), m(x.body);
        return;
      }
      if (x.type === "BlockStatement" && !ur(v)) {
        c(), m(x);
        return;
      }
      x.type === "Identifier" && Gu(x, v, l) && !u.has(x) && n[x.name] && g(x, v, l);
    },
    leave(x, v) {
      v && l.pop(), (x.type === "BlockStatement" && !ur(v) || ur(x) || x.type === "CatchClause") && p();
    }
  });
}
const Nr = "defineEmits";
function vd(t, e, r) {
  return st(e, Nr) ? (t.hasDefineEmitCall && t.error(`duplicate ${Nr}() call`, e), t.hasDefineEmitCall = !0, t.emitsRuntimeDecl = e.arguments[0], e.typeParameters && (t.emitsRuntimeDecl && t.error(
    `${Nr}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), t.emitsTypeDecl = e.typeParameters.params[0]), t.emitDecl = r, !0) : !1;
}
function Nw(t) {
  let e = "";
  if (t.emitsRuntimeDecl)
    e = t.getString(t.emitsRuntimeDecl).trim();
  else if (t.emitsTypeDecl) {
    const r = Ow(t);
    e = r.size ? `[${Array.from(r).map((i) => JSON.stringify(i)).join(", ")}]` : "";
  }
  if (t.hasDefineModelCall) {
    let r = `[${Object.keys(t.modelDecls).map((i) => JSON.stringify(`update:${i}`)).join(", ")}]`;
    e = e ? `/*@__PURE__*/${t.helper(
      "mergeModels"
    )}(${e}, ${r})` : r;
  }
  return e;
}
function Ow(t) {
  const e = /* @__PURE__ */ new Set(), r = t.emitsTypeDecl;
  if (r.type === "TSFunctionType")
    return xd(t, r.parameters[0], e), e;
  const { props: i, calls: n } = Ye(t, r);
  let u = !1;
  for (const l in i)
    e.add(l), u = !0;
  if (n) {
    u && t.error(
      "defineEmits() type cannot mixed call signature and property syntax.",
      r
    );
    for (const l of n)
      xd(t, l.parameters[0], e);
  }
  return e;
}
function xd(t, e, r) {
  if (e.type === "Identifier" && e.typeAnnotation && e.typeAnnotation.type === "TSTypeAnnotation") {
    const i = X1(t, e.typeAnnotation.typeAnnotation);
    for (const n of i)
      n.type === "TSLiteralType" && n.literal.type !== "UnaryExpression" && n.literal.type !== "TemplateLiteral" && r.add(String(n.literal.value));
  }
}
const Bn = "defineExpose";
function kw(t, e) {
  return st(e, Bn) ? (t.hasDefineExposeCall && t.error(`duplicate ${Bn}() call`, e), t.hasDefineExposeCall = !0, !0) : !1;
}
const ts = "defineSlots";
function Ed(t, e, r) {
  return st(e, ts) ? (t.hasDefineSlotsCall && t.error(`duplicate ${ts}() call`, e), t.hasDefineSlotsCall = !0, e.arguments.length > 0 && t.error(`${ts}() cannot accept arguments`, e), r && t.s.overwrite(
    t.startOffset + e.start,
    t.startOffset + e.end,
    `${t.helper("useSlots")}()`
  ), !0) : !1;
}
const Ot = "defineOptions";
function Td(t, e) {
  if (!st(e, Ot))
    return !1;
  if (t.hasDefineOptionsCall && t.error(`duplicate ${Ot}() call`, e), e.typeParameters && t.error(`${Ot}() cannot accept type arguments`, e), !e.arguments[0]) return !0;
  t.hasDefineOptionsCall = !0, t.optionsRuntimeDecl = vt(e.arguments[0]);
  let r, i, n, u;
  if (t.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const l of t.optionsRuntimeDecl.properties)
      if ((l.type === "ObjectProperty" || l.type === "ObjectMethod") && l.key.type === "Identifier")
        switch (l.key.name) {
          case "props":
            r = l;
            break;
          case "emits":
            i = l;
            break;
          case "expose":
            n = l;
            break;
          case "slots":
            u = l;
            break;
        }
  }
  return r && t.error(
    `${Ot}() cannot be used to declare props. Use ${Ge}() instead.`,
    r
  ), i && t.error(
    `${Ot}() cannot be used to declare emits. Use ${Nr}() instead.`,
    i
  ), n && t.error(
    `${Ot}() cannot be used to declare expose. Use ${Bn}() instead.`,
    n
  ), u && t.error(
    `${Ot}() cannot be used to declare slots. Use ${ts}() instead.`,
    u
  ), !0;
}
function Lw(t, e, r, i) {
  const n = e.argument.extra && e.argument.extra.parenthesized ? e.argument.extra.parenStart : e.argument.start, u = t.startOffset, l = t.descriptor.source.slice(
    n + u,
    e.argument.end + u
  ), h = /\bawait\b/.test(l);
  t.s.overwrite(
    e.start + u,
    n + u,
    `${r ? ";" : ""}(
  ([__temp,__restore] = ${t.helper(
      "withAsyncContext"
    )}(${h ? "async " : ""}() => `
  ), t.s.appendLeft(
    e.end + u,
    `)),
  ${i ? "" : "__temp = "}await __temp,
  __restore()${i ? "" : `,
  __temp`}
)`
  );
}
var Rw = Object.defineProperty, Dw = Object.defineProperties, Mw = Object.getOwnPropertyDescriptors, wd = Object.getOwnPropertySymbols, Fw = Object.prototype.hasOwnProperty, Bw = Object.prototype.propertyIsEnumerable, Pd = (t, e, r) => e in t ? Rw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ns = (t, e) => {
  for (var r in e || (e = {}))
    Fw.call(e, r) && Pd(t, r, e[r]);
  if (wd)
    for (var r of wd(e))
      Bw.call(e, r) && Pd(t, r, e[r]);
  return t;
}, Zo = (t, e) => Dw(t, Mw(e));
const $w = [
  Ge,
  Nr,
  Bn,
  Ot,
  ts,
  Ca,
  Er
];
function Uw(t, e) {
  var r, i, n;
  e.id || Us(
    "compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals."
  );
  const u = new zT(t, e), { script: l, scriptSetup: h, source: c, filename: p } = t, d = e.hoistStatic !== !1 && !l, m = e.id ? e.id.replace(/^data-v-/, "") : "", y = l && l.lang, g = h && h.lang;
  if (!h) {
    if (!l)
      throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
    return ew(u, m);
  }
  if (l && y !== g)
    throw new Error(
      "[@vue/compiler-sfc] <script> and <script setup> must have the same language type."
    );
  if (g && !u.isJS && !u.isTS)
    return h;
  const E = /* @__PURE__ */ Object.create(null), S = /* @__PURE__ */ Object.create(null);
  let x, v = !1, P = !1;
  const A = u.startOffset, N = u.endOffset, _ = l && l.loc.start.offset, R = l && l.loc.end.offset;
  function M(U) {
    const G = U.start + A;
    let B = U.end + A;
    for (U.trailingComments && U.trailingComments.length > 0 && (B = U.trailingComments[U.trailingComments.length - 1].end + A); B <= c.length && /\s/.test(c.charAt(B)); )
      B++;
    u.s.move(G, B, 0);
  }
  function O(U, G, B, W, ce, Q) {
    let Z = Q;
    Q && u.isTS && t.template && !t.template.src && !t.template.lang && (Z = j0(G, t)), u.userImports[G] = {
      isType: W,
      imported: B,
      local: G,
      source: U,
      isFromSetup: ce,
      isUsedInTemplate: Z
    };
  }
  function I(U, G) {
    U && ta(U, (B) => {
      const W = S[B.name];
      W && W !== "literal-const" && u.error(
        `\`${G}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`,
        B
      );
    });
  }
  const k = u.scriptAst, L = u.scriptSetupAst;
  if (k) {
    for (const U of k.body)
      if (U.type === "ImportDeclaration")
        for (const G of U.specifiers) {
          const B = Au(G);
          O(
            U.source.value,
            G.local.name,
            B,
            U.importKind === "type" || G.type === "ImportSpecifier" && G.importKind === "type",
            !1,
            !e.inlineTemplate
          );
        }
  }
  for (const U of L.body)
    if (U.type === "ImportDeclaration") {
      M(U);
      let G = 0;
      const B = (W) => {
        const ce = W > G;
        G++;
        const Q = U.specifiers[W], Z = U.specifiers[W + 1];
        u.s.remove(
          ce ? U.specifiers[W - 1].end + A : Q.start + A,
          Z && !ce ? Z.start + A : Q.end + A
        );
      };
      for (let W = 0; W < U.specifiers.length; W++) {
        const ce = U.specifiers[W], Q = ce.local.name, Z = Au(ce), le = U.source.value, ve = u.userImports[Q];
        le === "vue" && $w.includes(Z) ? (Q === Z ? Us(
          `\`${Z}\` is a compiler macro and no longer needs to be imported.`
        ) : u.error(
          `\`${Z}\` is a compiler macro and cannot be aliased to a different name.`,
          ce
        ), B(W)) : ve ? ve.source === le && ve.imported === Z ? B(W) : u.error(
          "different imports aliased to same local name.",
          ce
        ) : O(
          le,
          Q,
          Z,
          U.importKind === "type" || ce.type === "ImportSpecifier" && ce.importKind === "type",
          !0,
          !e.inlineTemplate
        );
      }
      U.specifiers.length && G === U.specifiers.length && u.s.remove(U.start + A, U.end + A);
    }
  const V = {};
  for (const U in u.userImports) {
    const { source: G, imported: B, local: W } = u.userImports[U];
    G === "vue" && (V[B] = W);
  }
  if (l && k) {
    for (const U of k.body)
      if (U.type === "ExportDefaultDeclaration") {
        x = U;
        let G;
        if (x.declaration.type === "ObjectExpression" ? G = x.declaration.properties : x.declaration.type === "CallExpression" && x.declaration.arguments[0] && x.declaration.arguments[0].type === "ObjectExpression" && (G = x.declaration.arguments[0].properties), G)
          for (const ce of G)
            ce.type === "ObjectProperty" && ce.key.type === "Identifier" && ce.key.name === "name" && (u.hasDefaultExportName = !0), (ce.type === "ObjectMethod" || ce.type === "ObjectProperty") && ce.key.type === "Identifier" && ce.key.name === "render" && (u.hasDefaultExportRender = !0);
        const B = U.start + _, W = U.declaration.start + _;
        u.s.overwrite(B, W, `const ${Kr} = `);
      } else if (U.type === "ExportNamedDeclaration") {
        const G = U.specifiers.find(
          (B) => B.exported.type === "Identifier" && B.exported.name === "default"
        );
        G && (x = U, U.specifiers.length > 1 ? u.s.remove(
          G.start + _,
          G.end + _
        ) : u.s.remove(
          U.start + _,
          U.end + _
        ), U.source ? u.s.prepend(
          `import { ${G.local.name} as ${Kr} } from '${U.source.value}'
`
        ) : u.s.appendLeft(
          R,
          `
const ${Kr} = ${G.local.name}
`
        )), U.declaration && eu(
          "script",
          U.declaration,
          E,
          V,
          d
        );
      } else (U.type === "VariableDeclaration" || U.type === "FunctionDeclaration" || U.type === "ClassDeclaration" || U.type === "TSEnumDeclaration") && !U.declare && eu(
        "script",
        U,
        E,
        V,
        d
      );
    _ > A && (/\n$/.test(l.content.trim()) || u.s.appendLeft(R, `
`), u.s.move(_, R, 0));
  }
  for (const U of L.body) {
    if (U.type === "ExpressionStatement") {
      const B = vt(U.expression);
      if (ku(u, B) || vd(u, B) || Td(u, B) || Ed(u, B))
        u.s.remove(U.start + A, U.end + A);
      else if (kw(u, B)) {
        const W = B.callee;
        u.s.overwrite(
          W.start + A,
          W.end + A,
          "__expose"
        );
      } else
        Sd(u, B);
    }
    if (U.type === "VariableDeclaration" && !U.declare) {
      const B = U.declarations.length;
      let W = B, ce;
      for (let Q = 0; Q < B; Q++) {
        const Z = U.declarations[Q], le = Z.init && vt(Z.init);
        if (le) {
          Td(u, le) && u.error(
            `${Ot}() has no returning value, it cannot be assigned.`,
            U
          );
          const ve = ku(u, le, Z.id);
          u.propsDestructureRestId && (S[u.propsDestructureRestId] = "setup-reactive-const");
          const de = !ve && vd(u, le, Z.id);
          if (!de && (Ed(u, le, Z.id) || Sd(u, le, Z.id)), ve && !u.propsDestructureRestId && u.propsDestructureDecl)
            if (W === 1)
              u.s.remove(U.start + A, U.end + A);
            else {
              let we = Z.start + A, it = Z.end + A;
              Q === B - 1 ? we = U.declarations[ce].end + A : it = U.declarations[Q + 1].start + A, u.s.remove(we, it), W--;
            }
          else de ? u.s.overwrite(
            A + le.start,
            A + le.end,
            "__emit"
          ) : ce = Q;
        }
      }
    }
    let G = !1;
    if ((U.type === "VariableDeclaration" || U.type === "FunctionDeclaration" || U.type === "ClassDeclaration" || U.type === "TSEnumDeclaration") && !U.declare && (G = eu(
      "scriptSetup",
      U,
      S,
      V,
      d,
      !!u.propsDestructureDecl
    )), d && G && M(U), U.type === "VariableDeclaration" && !U.declare || U.type.endsWith("Statement")) {
      const B = [L.body];
      Hu(U, {
        enter(W, ce) {
          if (ur(W) && this.skip(), W.type === "BlockStatement" && B.push(W.body), W.type === "AwaitExpression") {
            v = !0;
            const Z = B[B.length - 1].some((le, ve) => (B.length === 1 || ve > 0) && le.type === "ExpressionStatement" && le.start === W.start);
            Lw(
              u,
              W,
              Z,
              ce.type === "ExpressionStatement"
            );
          }
        },
        exit(W) {
          W.type === "BlockStatement" && B.pop();
        }
      });
    }
    (U.type === "ExportNamedDeclaration" && U.exportKind !== "type" || U.type === "ExportAllDeclaration" || U.type === "ExportDefaultDeclaration") && u.error(
      "<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.",
      U
    ), u.isTS && (U.type.startsWith("TS") || U.type === "ExportNamedDeclaration" && U.exportKind === "type" || U.type === "VariableDeclaration" && U.declare) && U.type !== "TSEnumDeclaration" && M(U);
  }
  u.propsDestructureDecl && Iw(u, V), I(u.propsRuntimeDecl, Ge), I(u.propsRuntimeDefaults, Ge), I(u.propsDestructureDecl, Ge), I(u.emitsRuntimeDecl, Nr), I(u.optionsRuntimeDecl, Ot);
  for (const { runtimeOptionNodes: U } of Object.values(u.modelDecls))
    for (const G of U)
      I(G, Ca);
  l ? A < _ ? (u.s.remove(0, A), u.s.remove(N, _), u.s.remove(R, c.length)) : (u.s.remove(0, _), u.s.remove(R, A), u.s.remove(N, c.length)) : (u.s.remove(0, A), u.s.remove(N, c.length)), k && Object.assign(u.bindingMetadata, U1(k.body));
  for (const [U, { isType: G, imported: B, source: W }] of Object.entries(
    u.userImports
  ))
    G || (u.bindingMetadata[U] = B === "*" || B === "default" && W.endsWith(".vue") || W === "vue" ? "setup-const" : "setup-maybe-ref");
  for (const U in E)
    u.bindingMetadata[U] = E[U];
  for (const U in S)
    u.bindingMetadata[U] = S[U];
  t.cssVars.length && // no need to do this when targeting SSR
  !((r = e.templateOptions) != null && r.ssr) && (u.helperImports.add(xn), u.helperImports.add("unref"), u.s.prependLeft(
    A,
    `
${M0(
      t.cssVars,
      u.bindingMetadata,
      m,
      !!e.isProd
    )}
`
  ));
  let K = "__props";
  if (u.propsTypeDecl && (K += ": any"), u.propsDecl && (u.propsDestructureRestId ? (u.s.overwrite(
    A + u.propsCall.start,
    A + u.propsCall.end,
    `${u.helper("createPropsRestProxy")}(__props, ${JSON.stringify(
      Object.keys(u.propsDestructuredBindings)
    )})`
  ), u.s.overwrite(
    A + u.propsDestructureDecl.start,
    A + u.propsDestructureDecl.end,
    u.propsDestructureRestId
  )) : u.propsDestructureDecl || u.s.overwrite(
    A + u.propsCall.start,
    A + u.propsCall.end,
    "__props"
  )), v) {
    const U = u.isTS ? ": any" : "";
    u.s.prependLeft(A, `
let __temp${U}, __restore${U}
`);
  }
  const re = u.hasDefineExposeCall || !e.inlineTemplate ? ["expose: __expose"] : [];
  u.emitDecl && re.push("emit: __emit"), re.length && (K += `, { ${re.join(", ")} }`);
  let z, se;
  if (!e.inlineTemplate || !t.template && u.hasDefaultExportRender) {
    const U = Ns(Ns({}, E), S);
    for (const G in u.userImports)
      !u.userImports[G].isType && u.userImports[G].isUsedInTemplate && (U[G] = !0);
    se = "{ ";
    for (const G in U)
      if (U[G] === !0 && u.userImports[G].source !== "vue" && !u.userImports[G].source.endsWith(".vue"))
        se += `get ${G}() { return ${G} }, `;
      else if (u.bindingMetadata[G] === "setup-let") {
        const B = G === "v" ? "_v" : "v";
        se += `get ${G}() { return ${G} }, set ${G}(${B}) { ${G} = ${B} }, `;
      } else
        se += `${G}, `;
    se = se.replace(/, $/, "") + " }";
  } else if (t.template && !t.template.src) {
    e.templateOptions && e.templateOptions.ssr && (P = !0);
    const { code: U, ast: G, preamble: B, tips: W, errors: ce, map: Q } = r1(Zo(Ns({
      filename: p,
      ast: t.template.ast,
      source: t.template.content,
      inMap: t.template.map
    }, e.templateOptions), {
      id: m,
      scoped: t.styles.some((le) => le.scoped),
      isProd: e.isProd,
      ssrCssVars: t.cssVars,
      compilerOptions: Zo(Ns({}, e.templateOptions && e.templateOptions.compilerOptions), {
        inline: !0,
        isTS: u.isTS,
        bindingMetadata: u.bindingMetadata
      })
    }));
    z = Q, W.length && W.forEach(Us);
    const Z = ce[0];
    if (typeof Z == "string")
      throw new Error(Z);
    if (Z)
      throw Z.loc && (Z.message += `

` + t.filename + `
` + ti(
        c,
        Z.loc.start.offset,
        Z.loc.end.offset
      ) + `
`), Z;
    B && u.s.prepend(B), G && G.helpers.has(ns) && u.helperImports.delete("unref"), se = U;
  } else
    se = "() => {}";
  e.inlineTemplate ? u.s.appendRight(N, `
return ${se}
}

`) : u.s.appendRight(
    N,
    `
const __returned__ = ${se}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`
  );
  const he = e.genDefaultAs ? `const ${e.genDefaultAs} =` : "export default";
  let ne = "";
  if (!u.hasDefaultExportName && p && p !== V0) {
    const U = p.match(/([^/\\]+)\.\w+$/);
    U && (ne += `
  __name: '${U[1]}',`);
  }
  P && (ne += `
  __ssrInlineRender: true,`);
  const ge = Ew(u);
  ge && (ne += `
  props: ${ge},`);
  const be = Nw(u);
  be && (ne += `
  emits: ${be},`);
  let Y = "";
  u.optionsRuntimeDecl && (Y = h.content.slice(u.optionsRuntimeDecl.start, u.optionsRuntimeDecl.end).trim());
  const ie = u.hasDefineExposeCall || e.inlineTemplate ? "" : `  __expose();
`;
  if (u.isTS) {
    const U = (x ? `
  ...${Kr},` : "") + (Y ? `
  ...${Y},` : "");
    u.s.prependLeft(
      A,
      `
${he} /*@__PURE__*/${u.helper(
        "defineComponent"
      )}({${U}${ne}
  ${v ? "async " : ""}setup(${K}) {
${ie}`
    ), u.s.appendRight(N, "})");
  } else
    x || Y ? (u.s.prependLeft(
      A,
      `
${he} /*@__PURE__*/Object.assign(${x ? `${Kr}, ` : ""}${Y ? `${Y}, ` : ""}{${ne}
  ${v ? "async " : ""}setup(${K}) {
${ie}`
    ), u.s.appendRight(N, "})")) : (u.s.prependLeft(
      A,
      `
${he} {${ne}
  ${v ? "async " : ""}setup(${K}) {
${ie}`
    ), u.s.appendRight(N, "}"));
  if (u.helperImports.size > 0) {
    const U = (n = (i = e.templateOptions) == null ? void 0 : i.compilerOptions) == null ? void 0 : n.runtimeModuleName, G = U ? JSON.stringify(U) : "'vue'";
    u.s.prepend(
      `import { ${[...u.helperImports].map((B) => `${B} as _${B}`).join(", ")} } from ${G}
`
    );
  }
  const H = u.s.toString();
  let j = e.sourceMap !== !1 ? u.s.generateMap({
    source: p,
    hires: !0,
    includeContent: !0
  }) : void 0;
  if (z && j) {
    const U = H.indexOf(se), G = H.slice(0, U).split(/\r?\n/).length - 1;
    j = qw(j, z, G);
  }
  return Zo(Ns({}, h), {
    bindings: u.bindingMetadata,
    imports: u.userImports,
    content: H,
    map: j,
    scriptAst: k == null ? void 0 : k.body,
    scriptSetupAst: L == null ? void 0 : L.body,
    deps: u.deps ? [...u.deps] : void 0
  });
}
function rs(t, e, r) {
  t[e.name] = r;
}
function eu(t, e, r, i, n, u = !1) {
  let l = !1;
  if (e.type === "VariableDeclaration") {
    const h = e.kind === "const";
    l = h && e.declarations.every(
      (c) => c.id.type === "Identifier" && Pt(c.init)
    );
    for (const { id: c, init: p } of e.declarations) {
      const d = p && vt(p), m = h && st(
        d,
        (y) => y === Ge || y === Nr || y === Er || y === ts
      );
      if (c.type === "Identifier") {
        let y;
        const g = i.reactive;
        (n || t === "script") && (l || h && Pt(d)) ? y = "literal-const" : st(d, g) ? y = h ? "setup-reactive-const" : "setup-let" : /* if a declaration is a const literal, we can mark it so that */ /* the generated render fn code doesn't need to unref() it */ m || h && Q1(d, g) ? y = st(d, Ge) ? "setup-reactive-const" : "setup-const" : h ? st(
          d,
          (E) => E === i.ref || E === i.computed || E === i.shallowRef || E === i.customRef || E === i.toRef || E === i.useTemplateRef || E === Ca
        ) ? y = "setup-ref" : y = "setup-maybe-ref" : y = "setup-let", rs(r, c, y);
      } else {
        if (st(d, Ge) && u)
          continue;
        c.type === "ObjectPattern" ? K1(c, r, h, m) : c.type === "ArrayPattern" && Y1(c, r, h, m);
      }
    }
  } else e.type === "TSEnumDeclaration" ? (l = e.members.every(
    (h) => !h.initializer || Pt(h.initializer)
  ), r[e.id.name] = l ? "literal-const" : "setup-const") : (e.type === "FunctionDeclaration" || e.type === "ClassDeclaration") && (r[e.id.name] = "setup-const");
  return l;
}
function K1(t, e, r, i = !1) {
  for (const n of t.properties)
    if (n.type === "ObjectProperty")
      if (n.key.type === "Identifier" && n.key === n.value) {
        const u = i ? "setup-const" : r ? "setup-maybe-ref" : "setup-let";
        rs(e, n.key, u);
      } else
        hc(n.value, e, r, i);
    else {
      const u = r ? "setup-const" : "setup-let";
      rs(e, n.argument, u);
    }
}
function Y1(t, e, r, i = !1) {
  for (const n of t.elements)
    n && hc(n, e, r, i);
}
function hc(t, e, r, i = !1) {
  if (t.type === "Identifier")
    rs(e, t, i ? "setup-const" : r ? "setup-maybe-ref" : "setup-let");
  else if (t.type === "RestElement") {
    const n = r ? "setup-const" : "setup-let";
    rs(e, t.argument, n);
  } else if (t.type === "ObjectPattern")
    K1(t, e, r);
  else if (t.type === "ArrayPattern")
    Y1(t, e, r);
  else if (t.type === "AssignmentPattern")
    if (t.left.type === "Identifier") {
      const n = i ? "setup-const" : r ? "setup-maybe-ref" : "setup-let";
      rs(e, t.left, n);
    } else
      hc(t.left, e, r);
}
function Q1(t, e) {
  if (st(t, e))
    return !0;
  switch (t.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return !0;
    case "SequenceExpression":
      return Q1(
        t.expressions[t.expressions.length - 1],
        e
      );
    default:
      return !!F1(t);
  }
}
function Pt(t) {
  switch (t = vt(t), t.type) {
    case "UnaryExpression":
      return Pt(t.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return Pt(t.left) && Pt(t.right);
    case "ConditionalExpression":
      return Pt(t.test) && Pt(t.consequent) && Pt(t.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return t.expressions.every((e) => Pt(e));
    case "ParenthesizedExpression":
      return Pt(t.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return !0;
  }
  return !1;
}
function qw(t, e, r) {
  const i = new Ar.SourceMapGenerator(), n = (u, l = 0) => {
    const h = new Ar.SourceMapConsumer(u);
    h.sources.forEach((c) => {
      i._sources.add(c);
      const p = h.sourceContentFor(c);
      p != null && i.setSourceContent(c, p);
    }), h.eachMapping((c) => {
      c.originalLine != null && i.addMapping({
        generated: {
          line: c.generatedLine + l,
          column: c.generatedColumn
        },
        original: {
          line: c.originalLine,
          column: c.originalColumn
        },
        source: c.source,
        name: c.name
      });
    });
  };
  return n(t), n(e, r), i._sourceRoot = t.sourceRoot, i._file = t.file, i.toJSON();
}
var jw = Object.defineProperty, _d = Object.getOwnPropertySymbols, Vw = Object.prototype.hasOwnProperty, zw = Object.prototype.propertyIsEnumerable, Ad = (t, e, r) => e in t ? jw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Cd = (t, e) => {
  for (var r in e || (e = {}))
    Vw.call(e, r) && Ad(t, r, e[r]);
  if (_d)
    for (var r of _d(e))
      zw.call(e, r) && Ad(t, r, e[r]);
  return t;
};
Cd(Cd({}, Wu), vl);
var Z1 = It.parse;
const ey = (t) => {
  var r, i;
  const e = ((r = t.script) == null ? void 0 : r.lang) || ((i = t == null ? void 0 : t.scriptSetup) == null ? void 0 : i.lang) || "";
  return /jsx$/.test(e);
}, ty = (t) => {
  var e;
  return (e = hg(t, {
    babelrc: !1,
    plugins: [fg],
    sourceMaps: !1,
    configFile: !1
  })) == null ? void 0 : e.code;
}, Ww = (t, e) => t.styles.map((i) => ET({
  id: e,
  filename: t.filename,
  source: i.content,
  scoped: i.scoped
}).code || "").join(`
`), Hw = (t, e, r) => {
  var c, p;
  const i = ey(t), n = [];
  i && n.push("jsx");
  const u = r1({
    id: e,
    ast: (c = t.template) == null ? void 0 : c.ast,
    source: (p = t.template) == null ? void 0 : p.content,
    filename: t.filename,
    scoped: t.styles.some((d) => d.scoped),
    slotted: t.slotted,
    compilerOptions: {
      bindingMetadata: r,
      expressionPlugins: n
    }
  }), { errors: l } = u;
  let { code: h } = u;
  return i && (h = ty(h) || ""), { code: h, errors: l };
}, Gw = (t, e = "loadBlockComponent") => {
  var l, h;
  const r = new hi(t), i = Z1(t, { sourceType: "module", plugins: ["jsx"] }).program.body;
  let n = null, u = !1;
  for (const c of i)
    if (c.type === "ImportDeclaration") {
      const p = c.source.value;
      if (p === "vue" && !c.specifiers.find((d) => d.type === "ImportNamespaceSpecifier") && (n = c), p.startsWith("./") && c.source.value.endsWith(".vue")) {
        u = !0;
        const d = c.source.value.replace(/^(\.\/+)/, "").slice(0, -4), m = (h = (l = c.specifiers.find((y) => y.type === "ImportDefaultSpecifier")) == null ? void 0 : l.local) == null ? void 0 : h.name;
        if (!m)
          continue;
        r.appendLeft(
          c.start,
          `const ${m} = defineAsyncComponent(() => window.${e}('${d}'))`
        ), r.remove(c.start, c.end);
      }
    }
  if (u)
    if (n) {
      if (!n.specifiers.find(
        (p) => p.type === "ImportSpecifier" && p.local.name === "defineAsyncComponent"
      )) {
        const p = n.specifiers.find((d) => d.type === "ImportSpecifier");
        p ? r.appendLeft(p.start, "defineAsyncComponent, ") : r.appendRight(n.specifiers[0].end, ", { defineAsyncComponent }");
      }
    } else
      r.appendLeft(i[0].start, `import { defineAsyncComponent } from 'vue'
`);
  return r.toString();
}, fn = "__sfc__", Xw = (t, e) => {
  const r = ey(t), i = [];
  r && i.push("jsx");
  const n = Uw(t, {
    genDefaultAs: fn,
    inlineTemplate: !0,
    id: e,
    templateOptions: {
      compilerOptions: {
        expressionPlugins: i
      }
    }
  });
  let u = n.content;
  return r && (u = ty(u) || ""), [u, n.bindings];
}, Jw = (t) => {
  const e = t.compilerParseResult.descriptor, [r, i] = Xw(e, t.fileName);
  let n = `${r}`;
  if (!e.scriptSetup && e.template) {
    const { code: h } = Hw(e, t.fileName, i);
    n += `
 ${h} 
 ${fn}.render = render`;
  }
  e.styles.some((h) => h.scoped) && (n += `
${fn}.__scopeId='data-v-${t.fileName}'`);
  const l = Ww(e, t.fileName);
  return {
    js: `${n}
export default ${fn}`,
    style: l
  };
}, Kw = (t) => {
  let e = "";
  if (t.script ? e = t.script.content : t.scriptSetup && (e = t.scriptSetup.content), !e)
    return [];
  const r = Z1(e, { sourceFilename: t.filename, sourceType: "module", plugins: ["jsx"] }).program.body, i = [];
  for (const n of r)
    n.type === "ImportDeclaration" && n.source.value.startsWith("./") && i.push(n.source.value);
  return i;
}, Yw = (t) => {
  const e = new Blob([t], { type: "application/javascript" });
  return URL.createObjectURL(e);
}, aP = (t, e) => {
  const r = t.map((l) => {
    const { fileName: h, sourceCode: c } = l, { descriptor: p, errors: d } = z0(c, { filename: h }), m = Kw(p);
    return {
      fileName: h,
      sourceCode: c,
      compilerParseResult: {
        descriptor: p,
        errors: d
      },
      importedFiles: m,
      fileNameWithRelativePath: `./${h}.vue`
    };
  }), i = /* @__PURE__ */ new Set(), n = {}, u = (e == null ? void 0 : e.compileCache) || /* @__PURE__ */ new Map();
  for (const l of r) {
    const h = l.fileName, c = u.get(h);
    let p = "", d = "";
    if (c != null && c.js && (c != null && c.style))
      p = c.js, d = c.style;
    else {
      const y = Jw(l);
      p = y.js, d = y.style;
    }
    const m = Gw(p, e == null ? void 0 : e.globalGetterName);
    n[h] = {
      js: m,
      style: d,
      blobURL: Yw(m)
    }, u.set(h, n[h]), i.add(l.fileNameWithRelativePath);
  }
  return n;
};
export {
  aP as compile
};
//# sourceMappingURL=index.js.map
