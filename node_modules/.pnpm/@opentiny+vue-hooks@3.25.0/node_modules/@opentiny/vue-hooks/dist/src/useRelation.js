import { noop as y } from "@opentiny/utils";
import { onMountedOrActivated as C } from "./useEventListener.js";
const V = ({
  computed: l,
  getCurrentInstance: i,
  inject: c,
  markRaw: a,
  nextTick: f,
  onMounted: v,
  onActivated: E,
  onUnmounted: h,
  provide: M,
  reactive: m,
  toRef: k
}) => ({ relationKey: p, relationContainer: x, onChange: P, childrenKey: r, delivery: b } = {}) => {
  if (!p)
    throw new Error("[TINY Error]<relationKey> must exist.");
  const u = i(), e = m({ children: [], indexInParent: -1 }), j = c(p, null);
  let o = [];
  if (j) {
    const { link: t, unlink: n, callbacks: s, childrenKey: d, delivery: O } = j;
    o = s, r = r || d || "instanceChildren", b = O, e.indexInParent = t(u), h(() => n(u));
  } else {
    r = r || "instanceChildren";
    const t = C({ onMounted: v, onActivated: E, nextTick: f }), n = P ? () => f(P) : y;
    let s;
    f(() => {
      const d = typeof x == "function" ? x() : x;
      d && (s = new MutationObserver((O, $) => {
        const I = [];
        g(d.childNodes, I), o.forEach((A) => A(I, O, $)), n();
      }), s.observe(d, { attributes: !0, childList: !0, subtree: !0 }));
    }), t(() => n()), h(() => {
      s && (s.disconnect(), s = null), o = null;
    });
  }
  const w = (t) => {
    const n = t.proxy;
    return e.children.push(a(n)), l(() => e.children.indexOf(n));
  }, N = (t) => {
    const n = e.children.indexOf(t.proxy);
    n > -1 && e.children.splice(n, 1);
  };
  return o.push((t) => D(e.children, t)), M(p, { link: w, unlink: N, callbacks: o, childrenKey: r, delivery: b }), Object.defineProperty(u.proxy, r, { configurable: !0, get: () => e.children }), h(() => delete u.proxy[r]), { children: k(e, "children"), index: k(e, "indexInParent"), delivery: b };
}, g = (l, i) => {
  l.length && l.forEach((c) => {
    i.push(c), c.childNodes && g(c.childNodes, i);
  });
}, D = (l, i) => {
  l.sort((c, a) => i.indexOf(c.$el) - i.indexOf(a.$el));
};
export {
  V as useRelation
};
