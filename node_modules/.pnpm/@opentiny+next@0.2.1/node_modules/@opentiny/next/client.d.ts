import { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
import { AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';

/**
 * MessageChannelTransport 是一个用于在浏览器上下文之间传输消息的类。
 * 它使用 MessageChannel API 来实现不同上下文（如 iframe、worker、标签页、窗口等）之间的通信。
 * 该类提供了初始化、发送消息、关闭通道等功能。
 */
declare class MessageChannelTransport {
    protected _port: MessagePort | undefined;
    protected _sessionId: string | undefined;
    protected _started: boolean;
    protected _closed: boolean;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage, extra?: {
        authInfo?: AuthInfo;
    }) => void;
    /**
     * 构造函数，初始化 MessageChannelTransport。
     *
     * @param port - 用于通信的 MessagePort。
     * @param sessionId - 会话 ID。
     */
    constructor(port?: MessagePort, sessionId?: string);
    /**
     * 初始化 MessageChannelTransport。
     * 该方法会创建一个新的 MessageChannel，并将其端口传递给指定的全局对象。
     * 如果传输已关闭，则抛出错误。
     */
    start(): Promise<void>;
    /**
     * 发送消息到 MessagePort。
     * 如果传输已关闭，则抛出错误。
     *
     * @param message - 要发送的 JSON-RPC 消息。
     */
    send(message: JSONRPCMessage): Promise<void>;
    /**
     * 关闭 MessageChannelTransport。
     * 该方法会关闭 MessagePort，并触发关闭回调。
     * 如果传输已关闭，则不执行任何操作。
     */
    close(): Promise<void>;
    /**
     * 获取当前会话的 sessionId。
     */
    get sessionId(): string;
}
/**
 * 在浏览器端实现基于 MessageChannel API 的客户端传输类，
 * 用于不同浏览器上下文（如 iframe、worker、标签页、窗口等）之间通信。
 */
declare class MessageChannelClientTransport extends MessageChannelTransport {
    private _endpoint;
    private _globalObject;
    /**
     * 创建一个监听通信的服务端实例。
     *
     * @param endpoint - 用于通信的端点。
     * @param [globalObject] - 用于通信的全局对象（可选，默认当前全局对象）。
     */
    constructor(endpoint: string, globalObject?: object);
}
/**
 * 在浏览器端实现基于 MessageChannel API 的服务端传输类，
 * 用于不同浏览器上下文（如 iframe、worker、标签页、窗口等）之间通信。
 */
declare class MessageChannelServerTransport extends MessageChannelTransport {
    private _endpoint;
    private _globalObject;
    private _listen;
    /**
     * 创建一个监听通信的服务端实例。
     *
     * @param endpoint - 用于通信的端点。
     * @param [globalObject] - 用于通信的全局对象（可选，默认当前全局对象）。
     */
    constructor(endpoint: string, globalObject?: object);
    /**
     * 监听等待客户端连接。
     * 该方法会返回一个 Promise，当客户端连接时解析。
     */
    listen(): Promise<void>;
}
/**
 * 创建一对 MessageChannelTransport 实例，返回两个端口的传输实例。
 * 这两个实例可以用于在不同的浏览器上下文之间进行通信。
 *
 * @returns 返回一对 MessageChannelTransport 实例。
 */
declare const createTransportPair: () => [MessageChannelTransport, MessageChannelTransport];

declare module '@modelcontextprotocol/sdk/client/sse.js' {
    interface SSEClientTransport {
        sessionId: string;
    }
}
/**
 * 客户端代理选项接口
 */
interface ClientProxyOption {
    /**
     * MCP 客户端实例
     */
    client: Client;
    /**
     * 代理服务器的 URL
     */
    url: string;
    /**
     * 代理服务器的身份验证令牌
     */
    token: string;
    /**
     * 可选的会话 ID，用于标识当前会话
     */
    sessionId?: string;
}
/**
 * 创建一个 SSE 客户端代理
 *
 * @param options - 客户端代理选项
 * @returns - 返回一个包含 transport 和 sessionId 的对象
 */
declare const createSseProxy: (option: ClientProxyOption) => Promise<{
    transport: SSEClientTransport;
    sessionId: string;
}>;
/**
 * 创建一个 Streamable HTTP 客户端代理
 *
 * @param options - 客户端代理选项
 * @returns - 返回一个包含 transport 和 sessionId 的对象
 */
declare const createStreamProxy: (option: ClientProxyOption) => Promise<{
    transport: StreamableHTTPClientTransport;
    sessionId: string;
}>;

/**
 * 生成 SSEClientTransport 构造函数所需的第二个可选参数（传输配置）。
 * 用于为 SSE 连接和 HTTP 请求统一设置认证头（Authorization）。
 *
 * @param token - 用于认证的 Bearer Token。
 * @param sessionId - 可选的 sessionId，用于标识会话。
 * @returns 返回传输配置对象，包含 requestInit 和 eventSourceInit 两部分：
 *   - requestInit：fetch 请求的初始化配置，自动带上认证头。
 *   - eventSourceInit：自定义 fetch 方法，确保 SSE 连接也带上认证头。
 */
declare const sseOptions: (token: string, sessionId?: string) => {
    requestInit: {
        headers: {
            Authorization: string;
            "sse-session-id": string;
        };
    };
    eventSourceInit: {
        fetch: (input: string | URL, init?: RequestInit) => Promise<Response>;
    };
};
/**
 * 生成 StreamableHTTPServerTransport 构造函数所需的第二个可选参数（传输配置）。
 * 用于为 Streamable HTTP 连接和 HTTP 请求统一设置认证头（Authorization）。
 *
 * @param token - 用于认证的 Bearer Token。
 * @param sessionId - 可选的 sessionId，用于标识会话。
 * @returns 返回传输配置对象，包含以下内容：
 *   - requestInit：fetch 请求的初始化配置，自动带上认证头，并设置 Streamable HTTP 代理的会话 ID。
 */
declare const streamOptions: (token: string, sessionId?: string) => {
    requestInit: {
        headers: {
            Authorization: string;
            "stream-session-id": string;
        };
    };
};

/**
 * 兼容安全策略的 UUID 生成方法，支持浏览器和 Node.js 环境
 *
 * @returns 返回一个 UUID 字符串
 */
declare const generateUUID: () => string;

export { MessageChannelClientTransport, MessageChannelServerTransport, MessageChannelTransport, createSseProxy, createStreamProxy, createTransportPair, generateUUID, sseOptions, streamOptions };
export type { ClientProxyOption };
