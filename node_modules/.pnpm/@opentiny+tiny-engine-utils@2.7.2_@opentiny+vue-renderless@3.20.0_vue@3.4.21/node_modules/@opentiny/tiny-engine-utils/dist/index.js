import { isRef as Vt, unref as $t, isProxy as qt, toRaw as Tt } from "vue";
import { isArray as Qt, isObject as te } from "@opentiny/vue-renderless/grid/static";
const At = Function;
function ee(O, U = {}) {
  try {
    return At(`return (${O})`).call(U);
  } catch (u) {
    console.error(`parseExpression error: ${u}`);
    return;
  }
}
function re(O, U = {}) {
  try {
    return At(`return (${O})`).call(U).bind(U);
  } catch (u) {
    return console.error(`parseFunction error: ${JSON.stringify(u)}`), null;
  }
}
const ne = (O) => {
  const U = /[\\^$.*+?()[\]{}|]/g;
  return String(O).replace(U, "\\$&");
}, ie = (O) => btoa(unescape(encodeURIComponent(O))), ae = (O) => decodeURIComponent(escape(atob(O)));
function Ct(O) {
  const U = /* @__PURE__ */ Object.create(null);
  return function(S) {
    return U[S] || (U[S] = O(S)), U[S];
  };
}
const se = /-(\w)/g, oe = Ct((O) => O.replace(se, (U, u) => u ? u.toUpperCase() : "")), le = Ct((O) => O.charAt(0).toUpperCase() + O.slice(1)), Rt = /\B([A-Z])/g, ue = Ct((O) => O.replace(Rt, "-$1").toLowerCase()), Bt = () => "xxxxxxxx".replace(/[x]/g, (O) => {
  const u = parseFloat("0." + crypto.getRandomValues(new Uint32Array(1))[0]) * 16 | 0;
  return (O === "x" ? u : u & 3 | 8).toString(16);
}), ce = (O) => {
  if (O.enum && O.enumNames)
    return O.enum.map((U, u) => ({ value: U, text: O.enumNames[u] }));
}, Dt = (O = {}, U, u = "children") => {
  const S = O[u], d = U(O);
  return Array.isArray(S) && (d[u] = S.map((i) => Dt(i, U))), d;
}, Ft = (O, U, u) => {
  const S = (d, i) => {
    const { item: o, deep: r } = U(d, i);
    return r ? Ft(o, U, i) : o;
  };
  return Qt(O) ? O.map((d) => S(d, u)) : O && te(O) ? Object.keys(O).reduce((d, i) => (d[i] = S(O[i], u || i), d), {}) : O;
}, Nt = (O = []) => {
  const U = {};
  return O.forEach(({ content: u = [] }) => {
    u.forEach(({ defaultValue: S, schema: d, property: i }) => {
      const o = Array.isArray(d) ? Nt(d) : S;
      o && (U[i] = o);
    });
  }), U;
};
function he(O = 1) {
  let U = "";
  const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  for (let S = 0; S < O; S++) {
    const d = parseFloat("0." + crypto.getRandomValues(new Uint32Array(1))[0]);
    U += u.charAt(Math.floor(d * u.length));
  }
  return U;
}
function Pt(O) {
  let U = O;
  return Vt(U) && (U = $t(U)), qt(U) ? Tt(U) : U;
}
function Ut(O) {
  const U = typeof O;
  return U !== "object" ? U : Object.prototype.toString.call(O).replace(/\[object (.*)\]/, "$1");
}
function fe(O, U, u) {
  const S = [];
  return U.set(O, S), O.forEach((d, i) => {
    S[i] = u(d, U);
  }), S;
}
function de(O, U, u) {
  const S = /* @__PURE__ */ new Map();
  return U.set(O, S), O.forEach((d, i) => {
    S.set(i, u(d, U));
  }), S;
}
function pe(O, U, u) {
  const S = /* @__PURE__ */ new Set();
  return U.set(O, S), O.forEach((d) => {
    S.add(u(d, U));
  }), S;
}
function me(O, U, u) {
  const S = {};
  return U.set(O, S), Object.entries(O).forEach(([d, i]) => {
    S[d] = u(i, U);
  }), S;
}
function Lt(O) {
  try {
    return structuredClone(O);
  } catch {
    return;
  }
}
function _e(O, U) {
  try {
    JSON.parse(JSON.stringify(O));
  } catch {
    typeof U == "function" && U();
  }
}
const It = {
  Array: fe,
  Map: de,
  Set: pe,
  Object: me
};
function jt(O, U) {
  if (U.has(O))
    return U.get(O);
  const u = Pt(O), S = ["undefined", "number", "string", "boolean", "function", "bigint", "symbol", "Null"], d = Ut(u);
  if (S.includes(d))
    return O;
  let i = Lt(u);
  return i ? (U.set(O, i), i) : It[d] ? (i = It[d](O, U, jt), i) : u;
}
function ge(O) {
  return jt(O, /* @__PURE__ */ new WeakMap());
}
const ye = (O, { keyTo: U = "id", orderKey: u = "_order" }) => typeof O != "object" || O === null ? [] : Object.entries(O).filter(([, d]) => typeof d == "object" && O !== null).map(([d, i]) => ({ ...i, [U]: d })).map(({ [u]: d, ...i }) => ({ ...i, [u]: d ?? Number.MAX_SAFE_INTEGER })).sort((d, i) => d[u] - i[u]), be = (O) => {
  let U = null;
  try {
    U = JSON.stringify(Tt(O), null, 2);
  } catch {
  }
  return U;
}, ve = (O) => {
  let U = null;
  try {
    U = JSON.parse(O);
  } catch {
  }
  return U;
}, Zt = (O) => O.replace(/[-\s]+(.)?/g, (U, u) => u ? u.toUpperCase() : ""), Wt = (O) => O.replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), we = (O) => !O || typeof O != "string" ? {} : O.trim().split(";").reduce((S, d) => {
  const i = d.indexOf(":");
  if (i === -1) return S;
  const o = d.slice(0, i), r = d.slice(i + 1);
  return o && r && (S[Zt(o.trim())] = r.trim()), S;
}, {}), ke = (O) => !O || typeof O != "object" ? "" : Object.entries(O).filter(([, U]) => U != null).map(([U, u]) => `${Wt(U)}: ${u}`).join("; "), ir = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  atou: ae,
  camelize: oe,
  capitalize: le,
  convertCamelToKebab: Wt,
  deepClone: ge,
  escapeRegExp: ne,
  fun_ctor: At,
  generateRandomLetters: he,
  getDefaultProps: Nt,
  getEnumData: ce,
  getRawValue: Pt,
  getType: Ut,
  guid: Bt,
  hyphenate: ue,
  hyphenateRE: Rt,
  jsonDeepClone: _e,
  mapObj: Ft,
  mapTree: Dt,
  nativeDeepClone: Lt,
  obj2StyleString: ke,
  objectToArray: ye,
  parseExpression: ee,
  parseFunction: re,
  reactiveObj2String: be,
  string2Obj: ve,
  styleString2Obj: we,
  toCamelCase: Zt,
  utoa: ie
}, Symbol.toStringTag, { value: "Module" })), xe = {
  Component: "component",
  Block: "block"
}, Se = {
  Inside: "inside",
  After: "after",
  Before: "before",
  Replace: "replace"
}, Ee = {
  I18N: "i18n",
  VARIABLE: "variable",
  JSEXPRESSION: "JSExpression",
  JSRESOURCE: "JSResource",
  JSSLOT: "JSSlot"
}, Ae = {
  JS_FUNCTION: "JSFunction",
  JS_EXPRESSION: "JSExpression"
}, Ce = {
  zh_CN: "zh_CN",
  en_US: "en_US"
}, ze = {
  Page: "Page",
  Block: "Block",
  Folder: "Folder"
}, Oe = {
  Body: "body",
  Div: "div"
}, Ie = {
  JSFunction: "JSFunction",
  JSExpression: "JSExpression",
  I18n: "i18n"
}, Te = {
  Release: "release",
  Occupy: "occupy",
  Lock: "lock",
  Guest: "guest",
  Empty: "empty",
  SuperAdmin: "p_webcenter",
  Developer: "developer"
}, Re = {
  Private: 0,
  Open: 1,
  Special: 2
}, Be = {
  Default: 500
};
let yt = "";
typeof sessionStorage < "u" && (yt = (sessionStorage == null ? void 0 : sessionStorage.getItem("BROADCAST_CHANNEL_UID")) || Bt(), sessionStorage == null || sessionStorage.setItem("BROADCAST_CHANNEL_UID", yt));
const De = {
  CanvasLang: `tiny-lowcode-canvas-lang-${yt}`,
  Notify: `global-notify-${yt}`,
  CanvasRouterViewSetting: `tiny-lowcode-canvas-router-view-setting-${yt}`
}, Fe = "tiny-engine-left-fixed-panels", Ne = "tiny-engine-right-fixed-panels", Pe = "tiny-engine-canvas-router-view-setting-view-mode", Ue = "tiny-engine-auto-saved", Le = {
  ErrorType: "error",
  ObjectType: "object",
  RegExpType: "regExp",
  DateType: "date",
  ArrayType: "array",
  FunctionType: "function",
  StringType: "string",
  NumberType: "number",
  BooleanType: "boolean"
}, je = {
  INDEX: "index",
  ITEM: "item"
}, Ze = {
  App: "app",
  Block: "block"
}, We = {
  Alpha: ["alpha"],
  Prod: ["prod"],
  Development: ["development"]
}, Me = {
  dataHandler: {
    type: "JSFunction",
    value: `function dataHandler(res){
  return res
}`
  },
  willFetch: {
    type: "JSFunction",
    value: `function willFetch(option) {
  return option
}`
  },
  errorHandler: {
    type: "JSFunction",
    value: `function errorHandler(err) {
  return Promise.reject(err)
}`
  },
  shouldFetch: {
    type: "JSFunction",
    value: `function shouldFetch(option) {
  return true 
}`
  }
}, He = {
  // 时间顺序
  timeAsc: "timeAsc",
  // 时间倒序
  timeDesc: "timeDesc",
  // 字母正序
  alphabetAsc: "alphabetAsc",
  // 字母倒序
  alphabetDesc: "alphabetDesc"
}, Ge = 280, ar = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AUTO_SAVED: Ue,
  BLOCK_OPENNESS: Re,
  BROADCAST_CHANNEL: De,
  CANVAS_ROUTER_VIEW_SETTING_VIEW_MODE_KEY: Pe,
  COMPONENT_NAME: ze,
  DEFAULT_INTERCEPTOR: Me,
  DEFAULT_LOOP_NAME: je,
  ELEMENT_TAG: Oe,
  ENVIRONMENTS: We,
  EXPRESSION_TYPE: Ae,
  HOST_TYPE: Ze,
  LOCALE: Ce,
  MATERIAL_TYPE: xe,
  NODE_INSERT_TYPE: Se,
  OPEN_DELAY: Be,
  PAGE_STATUS: Te,
  PLUGIN_DEFAULT_WIDTH: Ge,
  PROP_DATA_TYPE: Ee,
  SCHEMA_DATA_TYPE: Ie,
  SORT_TYPE: He,
  STORAGE_KEY_LEFT_FIXED_PANELS: Fe,
  STORAGE_KEY_RIGHT_FIXED_PANELS: Ne,
  TYPES: Le
}, Symbol.toStringTag, { value: "Module" }));
var wt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Je(O) {
  return O && O.__esModule && Object.prototype.hasOwnProperty.call(O, "default") ? O.default : O;
}
function kt(O) {
  throw new Error('Could not dynamically require "' + O + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Mt = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(O, U) {
  (function(u) {
    O.exports = u();
  })(function() {
    return function u(S, d, i) {
      function o(y, w) {
        if (!d[y]) {
          if (!S[y]) {
            var _ = typeof kt == "function" && kt;
            if (!w && _) return _(y, !0);
            if (r) return r(y, !0);
            var b = new Error("Cannot find module '" + y + "'");
            throw b.code = "MODULE_NOT_FOUND", b;
          }
          var a = d[y] = { exports: {} };
          S[y][0].call(a.exports, function(p) {
            var n = S[y][1][p];
            return o(n || p);
          }, a, a.exports, u, S, d, i);
        }
        return d[y].exports;
      }
      for (var r = typeof kt == "function" && kt, c = 0; c < i.length; c++) o(i[c]);
      return o;
    }({ 1: [function(u, S, d) {
      var i = u("./utils"), o = u("./support"), r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      d.encode = function(c) {
        for (var y, w, _, b, a, p, n, h = [], s = 0, m = c.length, v = m, E = i.getTypeOf(c) !== "string"; s < c.length; ) v = m - s, _ = E ? (y = c[s++], w = s < m ? c[s++] : 0, s < m ? c[s++] : 0) : (y = c.charCodeAt(s++), w = s < m ? c.charCodeAt(s++) : 0, s < m ? c.charCodeAt(s++) : 0), b = y >> 2, a = (3 & y) << 4 | w >> 4, p = 1 < v ? (15 & w) << 2 | _ >> 6 : 64, n = 2 < v ? 63 & _ : 64, h.push(r.charAt(b) + r.charAt(a) + r.charAt(p) + r.charAt(n));
        return h.join("");
      }, d.decode = function(c) {
        var y, w, _, b, a, p, n = 0, h = 0, s = "data:";
        if (c.substr(0, s.length) === s) throw new Error("Invalid base64 input, it looks like a data url.");
        var m, v = 3 * (c = c.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (c.charAt(c.length - 1) === r.charAt(64) && v--, c.charAt(c.length - 2) === r.charAt(64) && v--, v % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (m = o.uint8array ? new Uint8Array(0 | v) : new Array(0 | v); n < c.length; ) y = r.indexOf(c.charAt(n++)) << 2 | (b = r.indexOf(c.charAt(n++))) >> 4, w = (15 & b) << 4 | (a = r.indexOf(c.charAt(n++))) >> 2, _ = (3 & a) << 6 | (p = r.indexOf(c.charAt(n++))), m[h++] = y, a !== 64 && (m[h++] = w), p !== 64 && (m[h++] = _);
        return m;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(u, S, d) {
      var i = u("./external"), o = u("./stream/DataWorker"), r = u("./stream/Crc32Probe"), c = u("./stream/DataLengthProbe");
      function y(w, _, b, a, p) {
        this.compressedSize = w, this.uncompressedSize = _, this.crc32 = b, this.compression = a, this.compressedContent = p;
      }
      y.prototype = { getContentWorker: function() {
        var w = new o(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new c("data_length")), _ = this;
        return w.on("end", function() {
          if (this.streamInfo.data_length !== _.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), w;
      }, getCompressedWorker: function() {
        return new o(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, y.createWorkerFrom = function(w, _, b) {
        return w.pipe(new r()).pipe(new c("uncompressedSize")).pipe(_.compressWorker(b)).pipe(new c("compressedSize")).withStreamInfo("compression", _);
      }, S.exports = y;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(u, S, d) {
      var i = u("./stream/GenericWorker");
      d.STORE = { magic: "\0\0", compressWorker: function() {
        return new i("STORE compression");
      }, uncompressWorker: function() {
        return new i("STORE decompression");
      } }, d.DEFLATE = u("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(u, S, d) {
      var i = u("./utils"), o = function() {
        for (var r, c = [], y = 0; y < 256; y++) {
          r = y;
          for (var w = 0; w < 8; w++) r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
          c[y] = r;
        }
        return c;
      }();
      S.exports = function(r, c) {
        return r !== void 0 && r.length ? i.getTypeOf(r) !== "string" ? function(y, w, _, b) {
          var a = o, p = b + _;
          y ^= -1;
          for (var n = b; n < p; n++) y = y >>> 8 ^ a[255 & (y ^ w[n])];
          return -1 ^ y;
        }(0 | c, r, r.length, 0) : function(y, w, _, b) {
          var a = o, p = b + _;
          y ^= -1;
          for (var n = b; n < p; n++) y = y >>> 8 ^ a[255 & (y ^ w.charCodeAt(n))];
          return -1 ^ y;
        }(0 | c, r, r.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(u, S, d) {
      d.base64 = !1, d.binary = !1, d.dir = !1, d.createFolders = !0, d.date = null, d.compression = null, d.compressionOptions = null, d.comment = null, d.unixPermissions = null, d.dosPermissions = null;
    }, {}], 6: [function(u, S, d) {
      var i = null;
      i = typeof Promise < "u" ? Promise : u("lie"), S.exports = { Promise: i };
    }, { lie: 37 }], 7: [function(u, S, d) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = u("pako"), r = u("./utils"), c = u("./stream/GenericWorker"), y = i ? "uint8array" : "array";
      function w(_, b) {
        c.call(this, "FlateWorker/" + _), this._pako = null, this._pakoAction = _, this._pakoOptions = b, this.meta = {};
      }
      d.magic = "\b\0", r.inherits(w, c), w.prototype.processChunk = function(_) {
        this.meta = _.meta, this._pako === null && this._createPako(), this._pako.push(r.transformTo(y, _.data), !1);
      }, w.prototype.flush = function() {
        c.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, w.prototype.cleanUp = function() {
        c.prototype.cleanUp.call(this), this._pako = null;
      }, w.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var _ = this;
        this._pako.onData = function(b) {
          _.push({ data: b, meta: _.meta });
        };
      }, d.compressWorker = function(_) {
        return new w("Deflate", _);
      }, d.uncompressWorker = function() {
        return new w("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(u, S, d) {
      function i(a, p) {
        var n, h = "";
        for (n = 0; n < p; n++) h += String.fromCharCode(255 & a), a >>>= 8;
        return h;
      }
      function o(a, p, n, h, s, m) {
        var v, E, x = a.file, N = a.compression, R = m !== y.utf8encode, Z = r.transformTo("string", m(x.name)), T = r.transformTo("string", y.utf8encode(x.name)), H = x.comment, $ = r.transformTo("string", m(H)), g = r.transformTo("string", y.utf8encode(H)), B = T.length !== x.name.length, e = g.length !== H.length, F = "", Q = "", j = "", tt = x.dir, W = x.date, q = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        p && !n || (q.crc32 = a.crc32, q.compressedSize = a.compressedSize, q.uncompressedSize = a.uncompressedSize);
        var z = 0;
        p && (z |= 8), R || !B && !e || (z |= 2048);
        var C = 0, V = 0;
        tt && (C |= 16), s === "UNIX" ? (V = 798, C |= function(J, at) {
          var ut = J;
          return J || (ut = at ? 16893 : 33204), (65535 & ut) << 16;
        }(x.unixPermissions, tt)) : (V = 20, C |= function(J) {
          return 63 & (J || 0);
        }(x.dosPermissions)), v = W.getUTCHours(), v <<= 6, v |= W.getUTCMinutes(), v <<= 5, v |= W.getUTCSeconds() / 2, E = W.getUTCFullYear() - 1980, E <<= 4, E |= W.getUTCMonth() + 1, E <<= 5, E |= W.getUTCDate(), B && (Q = i(1, 1) + i(w(Z), 4) + T, F += "up" + i(Q.length, 2) + Q), e && (j = i(1, 1) + i(w($), 4) + g, F += "uc" + i(j.length, 2) + j);
        var Y = "";
        return Y += `
\0`, Y += i(z, 2), Y += N.magic, Y += i(v, 2), Y += i(E, 2), Y += i(q.crc32, 4), Y += i(q.compressedSize, 4), Y += i(q.uncompressedSize, 4), Y += i(Z.length, 2), Y += i(F.length, 2), { fileRecord: _.LOCAL_FILE_HEADER + Y + Z + F, dirRecord: _.CENTRAL_FILE_HEADER + i(V, 2) + Y + i($.length, 2) + "\0\0\0\0" + i(C, 4) + i(h, 4) + Z + F + $ };
      }
      var r = u("../utils"), c = u("../stream/GenericWorker"), y = u("../utf8"), w = u("../crc32"), _ = u("../signature");
      function b(a, p, n, h) {
        c.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = p, this.zipPlatform = n, this.encodeFileName = h, this.streamFiles = a, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      r.inherits(b, c), b.prototype.push = function(a) {
        var p = a.meta.percent || 0, n = this.entriesCount, h = this._sources.length;
        this.accumulate ? this.contentBuffer.push(a) : (this.bytesWritten += a.data.length, c.prototype.push.call(this, { data: a.data, meta: { currentFile: this.currentFile, percent: n ? (p + 100 * (n - h - 1)) / n : 100 } }));
      }, b.prototype.openedSource = function(a) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = a.file.name;
        var p = this.streamFiles && !a.file.dir;
        if (p) {
          var n = o(a, p, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: n.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, b.prototype.closedSource = function(a) {
        this.accumulate = !1;
        var p = this.streamFiles && !a.file.dir, n = o(a, p, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(n.dirRecord), p) this.push({ data: function(h) {
          return _.DATA_DESCRIPTOR + i(h.crc32, 4) + i(h.compressedSize, 4) + i(h.uncompressedSize, 4);
        }(a), meta: { percent: 100 } });
        else for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, b.prototype.flush = function() {
        for (var a = this.bytesWritten, p = 0; p < this.dirRecords.length; p++) this.push({ data: this.dirRecords[p], meta: { percent: 100 } });
        var n = this.bytesWritten - a, h = function(s, m, v, E, x) {
          var N = r.transformTo("string", x(E));
          return _.CENTRAL_DIRECTORY_END + "\0\0\0\0" + i(s, 2) + i(s, 2) + i(m, 4) + i(v, 4) + i(N.length, 2) + N;
        }(this.dirRecords.length, n, a, this.zipComment, this.encodeFileName);
        this.push({ data: h, meta: { percent: 100 } });
      }, b.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, b.prototype.registerPrevious = function(a) {
        this._sources.push(a);
        var p = this;
        return a.on("data", function(n) {
          p.processChunk(n);
        }), a.on("end", function() {
          p.closedSource(p.previous.streamInfo), p._sources.length ? p.prepareNextSource() : p.end();
        }), a.on("error", function(n) {
          p.error(n);
        }), this;
      }, b.prototype.resume = function() {
        return !!c.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, b.prototype.error = function(a) {
        var p = this._sources;
        if (!c.prototype.error.call(this, a)) return !1;
        for (var n = 0; n < p.length; n++) try {
          p[n].error(a);
        } catch {
        }
        return !0;
      }, b.prototype.lock = function() {
        c.prototype.lock.call(this);
        for (var a = this._sources, p = 0; p < a.length; p++) a[p].lock();
      }, S.exports = b;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(u, S, d) {
      var i = u("../compressions"), o = u("./ZipFileWorker");
      d.generateWorker = function(r, c, y) {
        var w = new o(c.streamFiles, y, c.platform, c.encodeFileName), _ = 0;
        try {
          r.forEach(function(b, a) {
            _++;
            var p = function(m, v) {
              var E = m || v, x = i[E];
              if (!x) throw new Error(E + " is not a valid compression method !");
              return x;
            }(a.options.compression, c.compression), n = a.options.compressionOptions || c.compressionOptions || {}, h = a.dir, s = a.date;
            a._compressWorker(p, n).withStreamInfo("file", { name: b, dir: h, date: s, comment: a.comment || "", unixPermissions: a.unixPermissions, dosPermissions: a.dosPermissions }).pipe(w);
          }), w.entriesCount = _;
        } catch (b) {
          w.error(b);
        }
        return w;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(u, S, d) {
      function i() {
        if (!(this instanceof i)) return new i();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new i();
          for (var r in this) typeof this[r] != "function" && (o[r] = this[r]);
          return o;
        };
      }
      (i.prototype = u("./object")).loadAsync = u("./load"), i.support = u("./support"), i.defaults = u("./defaults"), i.version = "3.10.1", i.loadAsync = function(o, r) {
        return new i().loadAsync(o, r);
      }, i.external = u("./external"), S.exports = i;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(u, S, d) {
      var i = u("./utils"), o = u("./external"), r = u("./utf8"), c = u("./zipEntries"), y = u("./stream/Crc32Probe"), w = u("./nodejsUtils");
      function _(b) {
        return new o.Promise(function(a, p) {
          var n = b.decompressed.getContentWorker().pipe(new y());
          n.on("error", function(h) {
            p(h);
          }).on("end", function() {
            n.streamInfo.crc32 !== b.decompressed.crc32 ? p(new Error("Corrupted zip : CRC32 mismatch")) : a();
          }).resume();
        });
      }
      S.exports = function(b, a) {
        var p = this;
        return a = i.extend(a || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: r.utf8decode }), w.isNode && w.isStream(b) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", b, !0, a.optimizedBinaryString, a.base64).then(function(n) {
          var h = new c(a);
          return h.load(n), h;
        }).then(function(n) {
          var h = [o.Promise.resolve(n)], s = n.files;
          if (a.checkCRC32) for (var m = 0; m < s.length; m++) h.push(_(s[m]));
          return o.Promise.all(h);
        }).then(function(n) {
          for (var h = n.shift(), s = h.files, m = 0; m < s.length; m++) {
            var v = s[m], E = v.fileNameStr, x = i.resolve(v.fileNameStr);
            p.file(x, v.decompressed, { binary: !0, optimizedBinaryString: !0, date: v.date, dir: v.dir, comment: v.fileCommentStr.length ? v.fileCommentStr : null, unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions, createFolders: a.createFolders }), v.dir || (p.file(x).unsafeOriginalName = E);
          }
          return h.zipComment.length && (p.comment = h.zipComment), p;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(u, S, d) {
      var i = u("../utils"), o = u("../stream/GenericWorker");
      function r(c, y) {
        o.call(this, "Nodejs stream input adapter for " + c), this._upstreamEnded = !1, this._bindStream(y);
      }
      i.inherits(r, o), r.prototype._bindStream = function(c) {
        var y = this;
        (this._stream = c).pause(), c.on("data", function(w) {
          y.push({ data: w, meta: { percent: 0 } });
        }).on("error", function(w) {
          y.isPaused ? this.generatedError = w : y.error(w);
        }).on("end", function() {
          y.isPaused ? y._upstreamEnded = !0 : y.end();
        });
      }, r.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, r.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, S.exports = r;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(u, S, d) {
      var i = u("readable-stream").Readable;
      function o(r, c, y) {
        i.call(this, c), this._helper = r;
        var w = this;
        r.on("data", function(_, b) {
          w.push(_) || w._helper.pause(), y && y(b);
        }).on("error", function(_) {
          w.emit("error", _);
        }).on("end", function() {
          w.push(null);
        });
      }
      u("../utils").inherits(o, i), o.prototype._read = function() {
        this._helper.resume();
      }, S.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(u, S, d) {
      S.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(i, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(i, o);
        if (typeof i == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(i, o);
      }, allocBuffer: function(i) {
        if (Buffer.alloc) return Buffer.alloc(i);
        var o = new Buffer(i);
        return o.fill(0), o;
      }, isBuffer: function(i) {
        return Buffer.isBuffer(i);
      }, isStream: function(i) {
        return i && typeof i.on == "function" && typeof i.pause == "function" && typeof i.resume == "function";
      } };
    }, {}], 15: [function(u, S, d) {
      function i(x, N, R) {
        var Z, T = r.getTypeOf(N), H = r.extend(R || {}, w);
        H.date = H.date || /* @__PURE__ */ new Date(), H.compression !== null && (H.compression = H.compression.toUpperCase()), typeof H.unixPermissions == "string" && (H.unixPermissions = parseInt(H.unixPermissions, 8)), H.unixPermissions && 16384 & H.unixPermissions && (H.dir = !0), H.dosPermissions && 16 & H.dosPermissions && (H.dir = !0), H.dir && (x = s(x)), H.createFolders && (Z = h(x)) && m.call(this, Z, !0);
        var $ = T === "string" && H.binary === !1 && H.base64 === !1;
        R && R.binary !== void 0 || (H.binary = !$), (N instanceof _ && N.uncompressedSize === 0 || H.dir || !N || N.length === 0) && (H.base64 = !1, H.binary = !0, N = "", H.compression = "STORE", T = "string");
        var g = null;
        g = N instanceof _ || N instanceof c ? N : p.isNode && p.isStream(N) ? new n(x, N) : r.prepareContent(x, N, H.binary, H.optimizedBinaryString, H.base64);
        var B = new b(x, g, H);
        this.files[x] = B;
      }
      var o = u("./utf8"), r = u("./utils"), c = u("./stream/GenericWorker"), y = u("./stream/StreamHelper"), w = u("./defaults"), _ = u("./compressedObject"), b = u("./zipObject"), a = u("./generate"), p = u("./nodejsUtils"), n = u("./nodejs/NodejsStreamInputAdapter"), h = function(x) {
        x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
        var N = x.lastIndexOf("/");
        return 0 < N ? x.substring(0, N) : "";
      }, s = function(x) {
        return x.slice(-1) !== "/" && (x += "/"), x;
      }, m = function(x, N) {
        return N = N !== void 0 ? N : w.createFolders, x = s(x), this.files[x] || i.call(this, x, null, { dir: !0, createFolders: N }), this.files[x];
      };
      function v(x) {
        return Object.prototype.toString.call(x) === "[object RegExp]";
      }
      var E = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(x) {
        var N, R, Z;
        for (N in this.files) Z = this.files[N], (R = N.slice(this.root.length, N.length)) && N.slice(0, this.root.length) === this.root && x(R, Z);
      }, filter: function(x) {
        var N = [];
        return this.forEach(function(R, Z) {
          x(R, Z) && N.push(Z);
        }), N;
      }, file: function(x, N, R) {
        if (arguments.length !== 1) return x = this.root + x, i.call(this, x, N, R), this;
        if (v(x)) {
          var Z = x;
          return this.filter(function(H, $) {
            return !$.dir && Z.test(H);
          });
        }
        var T = this.files[this.root + x];
        return T && !T.dir ? T : null;
      }, folder: function(x) {
        if (!x) return this;
        if (v(x)) return this.filter(function(T, H) {
          return H.dir && x.test(T);
        });
        var N = this.root + x, R = m.call(this, N), Z = this.clone();
        return Z.root = R.name, Z;
      }, remove: function(x) {
        x = this.root + x;
        var N = this.files[x];
        if (N || (x.slice(-1) !== "/" && (x += "/"), N = this.files[x]), N && !N.dir) delete this.files[x];
        else for (var R = this.filter(function(T, H) {
          return H.name.slice(0, x.length) === x;
        }), Z = 0; Z < R.length; Z++) delete this.files[R[Z].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(x) {
        var N, R = {};
        try {
          if ((R = r.extend(x || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = R.type.toLowerCase(), R.compression = R.compression.toUpperCase(), R.type === "binarystring" && (R.type = "string"), !R.type) throw new Error("No output type specified.");
          r.checkSupport(R.type), R.platform !== "darwin" && R.platform !== "freebsd" && R.platform !== "linux" && R.platform !== "sunos" || (R.platform = "UNIX"), R.platform === "win32" && (R.platform = "DOS");
          var Z = R.comment || this.comment || "";
          N = a.generateWorker(this, R, Z);
        } catch (T) {
          (N = new c("error")).error(T);
        }
        return new y(N, R.type || "string", R.mimeType);
      }, generateAsync: function(x, N) {
        return this.generateInternalStream(x).accumulate(N);
      }, generateNodeStream: function(x, N) {
        return (x = x || {}).type || (x.type = "nodebuffer"), this.generateInternalStream(x).toNodejsStream(N);
      } };
      S.exports = E;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(u, S, d) {
      S.exports = u("stream");
    }, { stream: void 0 }], 17: [function(u, S, d) {
      var i = u("./DataReader");
      function o(r) {
        i.call(this, r);
        for (var c = 0; c < this.data.length; c++) r[c] = 255 & r[c];
      }
      u("../utils").inherits(o, i), o.prototype.byteAt = function(r) {
        return this.data[this.zero + r];
      }, o.prototype.lastIndexOfSignature = function(r) {
        for (var c = r.charCodeAt(0), y = r.charCodeAt(1), w = r.charCodeAt(2), _ = r.charCodeAt(3), b = this.length - 4; 0 <= b; --b) if (this.data[b] === c && this.data[b + 1] === y && this.data[b + 2] === w && this.data[b + 3] === _) return b - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(r) {
        var c = r.charCodeAt(0), y = r.charCodeAt(1), w = r.charCodeAt(2), _ = r.charCodeAt(3), b = this.readData(4);
        return c === b[0] && y === b[1] && w === b[2] && _ === b[3];
      }, o.prototype.readData = function(r) {
        if (this.checkOffset(r), r === 0) return [];
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + r);
        return this.index += r, c;
      }, S.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(u, S, d) {
      var i = u("../utils");
      function o(r) {
        this.data = r, this.length = r.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(r) {
        this.checkIndex(this.index + r);
      }, checkIndex: function(r) {
        if (this.length < this.zero + r || r < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + r + "). Corrupted zip ?");
      }, setIndex: function(r) {
        this.checkIndex(r), this.index = r;
      }, skip: function(r) {
        this.setIndex(this.index + r);
      }, byteAt: function() {
      }, readInt: function(r) {
        var c, y = 0;
        for (this.checkOffset(r), c = this.index + r - 1; c >= this.index; c--) y = (y << 8) + this.byteAt(c);
        return this.index += r, y;
      }, readString: function(r) {
        return i.transformTo("string", this.readData(r));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var r = this.readInt(4);
        return new Date(Date.UTC(1980 + (r >> 25 & 127), (r >> 21 & 15) - 1, r >> 16 & 31, r >> 11 & 31, r >> 5 & 63, (31 & r) << 1));
      } }, S.exports = o;
    }, { "../utils": 32 }], 19: [function(u, S, d) {
      var i = u("./Uint8ArrayReader");
      function o(r) {
        i.call(this, r);
      }
      u("../utils").inherits(o, i), o.prototype.readData = function(r) {
        this.checkOffset(r);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + r);
        return this.index += r, c;
      }, S.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(u, S, d) {
      var i = u("./DataReader");
      function o(r) {
        i.call(this, r);
      }
      u("../utils").inherits(o, i), o.prototype.byteAt = function(r) {
        return this.data.charCodeAt(this.zero + r);
      }, o.prototype.lastIndexOfSignature = function(r) {
        return this.data.lastIndexOf(r) - this.zero;
      }, o.prototype.readAndCheckSignature = function(r) {
        return r === this.readData(4);
      }, o.prototype.readData = function(r) {
        this.checkOffset(r);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + r);
        return this.index += r, c;
      }, S.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(u, S, d) {
      var i = u("./ArrayReader");
      function o(r) {
        i.call(this, r);
      }
      u("../utils").inherits(o, i), o.prototype.readData = function(r) {
        if (this.checkOffset(r), r === 0) return new Uint8Array(0);
        var c = this.data.subarray(this.zero + this.index, this.zero + this.index + r);
        return this.index += r, c;
      }, S.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(u, S, d) {
      var i = u("../utils"), o = u("../support"), r = u("./ArrayReader"), c = u("./StringReader"), y = u("./NodeBufferReader"), w = u("./Uint8ArrayReader");
      S.exports = function(_) {
        var b = i.getTypeOf(_);
        return i.checkSupport(b), b !== "string" || o.uint8array ? b === "nodebuffer" ? new y(_) : o.uint8array ? new w(i.transformTo("uint8array", _)) : new r(i.transformTo("array", _)) : new c(_);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(u, S, d) {
      d.LOCAL_FILE_HEADER = "PK", d.CENTRAL_FILE_HEADER = "PK", d.CENTRAL_DIRECTORY_END = "PK", d.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", d.ZIP64_CENTRAL_DIRECTORY_END = "PK", d.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(u, S, d) {
      var i = u("./GenericWorker"), o = u("../utils");
      function r(c) {
        i.call(this, "ConvertWorker to " + c), this.destType = c;
      }
      o.inherits(r, i), r.prototype.processChunk = function(c) {
        this.push({ data: o.transformTo(this.destType, c.data), meta: c.meta });
      }, S.exports = r;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(u, S, d) {
      var i = u("./GenericWorker"), o = u("../crc32");
      function r() {
        i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      u("../utils").inherits(r, i), r.prototype.processChunk = function(c) {
        this.streamInfo.crc32 = o(c.data, this.streamInfo.crc32 || 0), this.push(c);
      }, S.exports = r;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(u, S, d) {
      var i = u("../utils"), o = u("./GenericWorker");
      function r(c) {
        o.call(this, "DataLengthProbe for " + c), this.propName = c, this.withStreamInfo(c, 0);
      }
      i.inherits(r, o), r.prototype.processChunk = function(c) {
        if (c) {
          var y = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = y + c.data.length;
        }
        o.prototype.processChunk.call(this, c);
      }, S.exports = r;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(u, S, d) {
      var i = u("../utils"), o = u("./GenericWorker");
      function r(c) {
        o.call(this, "DataWorker");
        var y = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, c.then(function(w) {
          y.dataIsReady = !0, y.data = w, y.max = w && w.length || 0, y.type = i.getTypeOf(w), y.isPaused || y._tickAndRepeat();
        }, function(w) {
          y.error(w);
        });
      }
      i.inherits(r, o), r.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, r.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, i.delay(this._tickAndRepeat, [], this)), !0);
      }, r.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, r.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var c = null, y = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, y);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, y);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, y);
        }
        return this.index = y, this.push({ data: c, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, S.exports = r;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(u, S, d) {
      function i(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      i.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, r) {
        return this._listeners[o].push(r), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, r) {
        if (this._listeners[o]) for (var c = 0; c < this._listeners[o].length; c++) this._listeners[o][c].call(this, r);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var r = this;
        return o.on("data", function(c) {
          r.processChunk(c);
        }), o.on("end", function() {
          r.end();
        }), o.on("error", function(c) {
          r.error(c);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, r) {
        return this.extraStreamInfo[o] = r, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, S.exports = i;
    }, {}], 29: [function(u, S, d) {
      var i = u("../utils"), o = u("./ConvertWorker"), r = u("./GenericWorker"), c = u("../base64"), y = u("../support"), w = u("../external"), _ = null;
      if (y.nodestream) try {
        _ = u("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function b(p, n) {
        return new w.Promise(function(h, s) {
          var m = [], v = p._internalType, E = p._outputType, x = p._mimeType;
          p.on("data", function(N, R) {
            m.push(N), n && n(R);
          }).on("error", function(N) {
            m = [], s(N);
          }).on("end", function() {
            try {
              var N = function(R, Z, T) {
                switch (R) {
                  case "blob":
                    return i.newBlob(i.transformTo("arraybuffer", Z), T);
                  case "base64":
                    return c.encode(Z);
                  default:
                    return i.transformTo(R, Z);
                }
              }(E, function(R, Z) {
                var T, H = 0, $ = null, g = 0;
                for (T = 0; T < Z.length; T++) g += Z[T].length;
                switch (R) {
                  case "string":
                    return Z.join("");
                  case "array":
                    return Array.prototype.concat.apply([], Z);
                  case "uint8array":
                    for ($ = new Uint8Array(g), T = 0; T < Z.length; T++) $.set(Z[T], H), H += Z[T].length;
                    return $;
                  case "nodebuffer":
                    return Buffer.concat(Z);
                  default:
                    throw new Error("concat : unsupported type '" + R + "'");
                }
              }(v, m), x);
              h(N);
            } catch (R) {
              s(R);
            }
            m = [];
          }).resume();
        });
      }
      function a(p, n, h) {
        var s = n;
        switch (n) {
          case "blob":
          case "arraybuffer":
            s = "uint8array";
            break;
          case "base64":
            s = "string";
        }
        try {
          this._internalType = s, this._outputType = n, this._mimeType = h, i.checkSupport(s), this._worker = p.pipe(new o(s)), p.lock();
        } catch (m) {
          this._worker = new r("error"), this._worker.error(m);
        }
      }
      a.prototype = { accumulate: function(p) {
        return b(this, p);
      }, on: function(p, n) {
        var h = this;
        return p === "data" ? this._worker.on(p, function(s) {
          n.call(h, s.data, s.meta);
        }) : this._worker.on(p, function() {
          i.delay(n, arguments, h);
        }), this;
      }, resume: function() {
        return i.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(p) {
        if (i.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new _(this, { objectMode: this._outputType !== "nodebuffer" }, p);
      } }, S.exports = a;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(u, S, d) {
      if (d.base64 = !0, d.array = !0, d.string = !0, d.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", d.nodebuffer = typeof Buffer < "u", d.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") d.blob = !1;
      else {
        var i = new ArrayBuffer(0);
        try {
          d.blob = new Blob([i], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(i), d.blob = o.getBlob("application/zip").size === 0;
          } catch {
            d.blob = !1;
          }
        }
      }
      try {
        d.nodestream = !!u("readable-stream").Readable;
      } catch {
        d.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(u, S, d) {
      for (var i = u("./utils"), o = u("./support"), r = u("./nodejsUtils"), c = u("./stream/GenericWorker"), y = new Array(256), w = 0; w < 256; w++) y[w] = 252 <= w ? 6 : 248 <= w ? 5 : 240 <= w ? 4 : 224 <= w ? 3 : 192 <= w ? 2 : 1;
      y[254] = y[254] = 1;
      function _() {
        c.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function b() {
        c.call(this, "utf-8 encode");
      }
      d.utf8encode = function(a) {
        return o.nodebuffer ? r.newBufferFrom(a, "utf-8") : function(p) {
          var n, h, s, m, v, E = p.length, x = 0;
          for (m = 0; m < E; m++) (64512 & (h = p.charCodeAt(m))) == 55296 && m + 1 < E && (64512 & (s = p.charCodeAt(m + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (s - 56320), m++), x += h < 128 ? 1 : h < 2048 ? 2 : h < 65536 ? 3 : 4;
          for (n = o.uint8array ? new Uint8Array(x) : new Array(x), m = v = 0; v < x; m++) (64512 & (h = p.charCodeAt(m))) == 55296 && m + 1 < E && (64512 & (s = p.charCodeAt(m + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (s - 56320), m++), h < 128 ? n[v++] = h : (h < 2048 ? n[v++] = 192 | h >>> 6 : (h < 65536 ? n[v++] = 224 | h >>> 12 : (n[v++] = 240 | h >>> 18, n[v++] = 128 | h >>> 12 & 63), n[v++] = 128 | h >>> 6 & 63), n[v++] = 128 | 63 & h);
          return n;
        }(a);
      }, d.utf8decode = function(a) {
        return o.nodebuffer ? i.transformTo("nodebuffer", a).toString("utf-8") : function(p) {
          var n, h, s, m, v = p.length, E = new Array(2 * v);
          for (n = h = 0; n < v; ) if ((s = p[n++]) < 128) E[h++] = s;
          else if (4 < (m = y[s])) E[h++] = 65533, n += m - 1;
          else {
            for (s &= m === 2 ? 31 : m === 3 ? 15 : 7; 1 < m && n < v; ) s = s << 6 | 63 & p[n++], m--;
            1 < m ? E[h++] = 65533 : s < 65536 ? E[h++] = s : (s -= 65536, E[h++] = 55296 | s >> 10 & 1023, E[h++] = 56320 | 1023 & s);
          }
          return E.length !== h && (E.subarray ? E = E.subarray(0, h) : E.length = h), i.applyFromCharCode(E);
        }(a = i.transformTo(o.uint8array ? "uint8array" : "array", a));
      }, i.inherits(_, c), _.prototype.processChunk = function(a) {
        var p = i.transformTo(o.uint8array ? "uint8array" : "array", a.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var n = p;
            (p = new Uint8Array(n.length + this.leftOver.length)).set(this.leftOver, 0), p.set(n, this.leftOver.length);
          } else p = this.leftOver.concat(p);
          this.leftOver = null;
        }
        var h = function(m, v) {
          var E;
          for ((v = v || m.length) > m.length && (v = m.length), E = v - 1; 0 <= E && (192 & m[E]) == 128; ) E--;
          return E < 0 || E === 0 ? v : E + y[m[E]] > v ? E : v;
        }(p), s = p;
        h !== p.length && (o.uint8array ? (s = p.subarray(0, h), this.leftOver = p.subarray(h, p.length)) : (s = p.slice(0, h), this.leftOver = p.slice(h, p.length))), this.push({ data: d.utf8decode(s), meta: a.meta });
      }, _.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: d.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, d.Utf8DecodeWorker = _, i.inherits(b, c), b.prototype.processChunk = function(a) {
        this.push({ data: d.utf8encode(a.data), meta: a.meta });
      }, d.Utf8EncodeWorker = b;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(u, S, d) {
      var i = u("./support"), o = u("./base64"), r = u("./nodejsUtils"), c = u("./external");
      function y(n) {
        return n;
      }
      function w(n, h) {
        for (var s = 0; s < n.length; ++s) h[s] = 255 & n.charCodeAt(s);
        return h;
      }
      u("setimmediate"), d.newBlob = function(n, h) {
        d.checkSupport("blob");
        try {
          return new Blob([n], { type: h });
        } catch {
          try {
            var s = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return s.append(n), s.getBlob(h);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var _ = { stringifyByChunk: function(n, h, s) {
        var m = [], v = 0, E = n.length;
        if (E <= s) return String.fromCharCode.apply(null, n);
        for (; v < E; ) h === "array" || h === "nodebuffer" ? m.push(String.fromCharCode.apply(null, n.slice(v, Math.min(v + s, E)))) : m.push(String.fromCharCode.apply(null, n.subarray(v, Math.min(v + s, E)))), v += s;
        return m.join("");
      }, stringifyByChar: function(n) {
        for (var h = "", s = 0; s < n.length; s++) h += String.fromCharCode(n[s]);
        return h;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return i.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return i.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function b(n) {
        var h = 65536, s = d.getTypeOf(n), m = !0;
        if (s === "uint8array" ? m = _.applyCanBeUsed.uint8array : s === "nodebuffer" && (m = _.applyCanBeUsed.nodebuffer), m) for (; 1 < h; ) try {
          return _.stringifyByChunk(n, s, h);
        } catch {
          h = Math.floor(h / 2);
        }
        return _.stringifyByChar(n);
      }
      function a(n, h) {
        for (var s = 0; s < n.length; s++) h[s] = n[s];
        return h;
      }
      d.applyFromCharCode = b;
      var p = {};
      p.string = { string: y, array: function(n) {
        return w(n, new Array(n.length));
      }, arraybuffer: function(n) {
        return p.string.uint8array(n).buffer;
      }, uint8array: function(n) {
        return w(n, new Uint8Array(n.length));
      }, nodebuffer: function(n) {
        return w(n, r.allocBuffer(n.length));
      } }, p.array = { string: b, array: y, arraybuffer: function(n) {
        return new Uint8Array(n).buffer;
      }, uint8array: function(n) {
        return new Uint8Array(n);
      }, nodebuffer: function(n) {
        return r.newBufferFrom(n);
      } }, p.arraybuffer = { string: function(n) {
        return b(new Uint8Array(n));
      }, array: function(n) {
        return a(new Uint8Array(n), new Array(n.byteLength));
      }, arraybuffer: y, uint8array: function(n) {
        return new Uint8Array(n);
      }, nodebuffer: function(n) {
        return r.newBufferFrom(new Uint8Array(n));
      } }, p.uint8array = { string: b, array: function(n) {
        return a(n, new Array(n.length));
      }, arraybuffer: function(n) {
        return n.buffer;
      }, uint8array: y, nodebuffer: function(n) {
        return r.newBufferFrom(n);
      } }, p.nodebuffer = { string: b, array: function(n) {
        return a(n, new Array(n.length));
      }, arraybuffer: function(n) {
        return p.nodebuffer.uint8array(n).buffer;
      }, uint8array: function(n) {
        return a(n, new Uint8Array(n.length));
      }, nodebuffer: y }, d.transformTo = function(n, h) {
        if (h = h || "", !n) return h;
        d.checkSupport(n);
        var s = d.getTypeOf(h);
        return p[s][n](h);
      }, d.resolve = function(n) {
        for (var h = n.split("/"), s = [], m = 0; m < h.length; m++) {
          var v = h[m];
          v === "." || v === "" && m !== 0 && m !== h.length - 1 || (v === ".." ? s.pop() : s.push(v));
        }
        return s.join("/");
      }, d.getTypeOf = function(n) {
        return typeof n == "string" ? "string" : Object.prototype.toString.call(n) === "[object Array]" ? "array" : i.nodebuffer && r.isBuffer(n) ? "nodebuffer" : i.uint8array && n instanceof Uint8Array ? "uint8array" : i.arraybuffer && n instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, d.checkSupport = function(n) {
        if (!i[n.toLowerCase()]) throw new Error(n + " is not supported by this platform");
      }, d.MAX_VALUE_16BITS = 65535, d.MAX_VALUE_32BITS = -1, d.pretty = function(n) {
        var h, s, m = "";
        for (s = 0; s < (n || "").length; s++) m += "\\x" + ((h = n.charCodeAt(s)) < 16 ? "0" : "") + h.toString(16).toUpperCase();
        return m;
      }, d.delay = function(n, h, s) {
        setImmediate(function() {
          n.apply(s || null, h || []);
        });
      }, d.inherits = function(n, h) {
        function s() {
        }
        s.prototype = h.prototype, n.prototype = new s();
      }, d.extend = function() {
        var n, h, s = {};
        for (n = 0; n < arguments.length; n++) for (h in arguments[n]) Object.prototype.hasOwnProperty.call(arguments[n], h) && s[h] === void 0 && (s[h] = arguments[n][h]);
        return s;
      }, d.prepareContent = function(n, h, s, m, v) {
        return c.Promise.resolve(h).then(function(E) {
          return i.blob && (E instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(E)) !== -1) && typeof FileReader < "u" ? new c.Promise(function(x, N) {
            var R = new FileReader();
            R.onload = function(Z) {
              x(Z.target.result);
            }, R.onerror = function(Z) {
              N(Z.target.error);
            }, R.readAsArrayBuffer(E);
          }) : E;
        }).then(function(E) {
          var x = d.getTypeOf(E);
          return x ? (x === "arraybuffer" ? E = d.transformTo("uint8array", E) : x === "string" && (v ? E = o.decode(E) : s && m !== !0 && (E = function(N) {
            return w(N, i.uint8array ? new Uint8Array(N.length) : new Array(N.length));
          }(E))), E) : c.Promise.reject(new Error("Can't read the data of '" + n + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(u, S, d) {
      var i = u("./reader/readerFor"), o = u("./utils"), r = u("./signature"), c = u("./zipEntry"), y = u("./support");
      function w(_) {
        this.files = [], this.loadOptions = _;
      }
      w.prototype = { checkSignature: function(_) {
        if (!this.reader.readAndCheckSignature(_)) {
          this.reader.index -= 4;
          var b = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(b) + ", expected " + o.pretty(_) + ")");
        }
      }, isSignature: function(_, b) {
        var a = this.reader.index;
        this.reader.setIndex(_);
        var p = this.reader.readString(4) === b;
        return this.reader.setIndex(a), p;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var _ = this.reader.readData(this.zipCommentLength), b = y.uint8array ? "uint8array" : "array", a = o.transformTo(b, _);
        this.zipComment = this.loadOptions.decodeFileName(a);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var _, b, a, p = this.zip64EndOfCentralSize - 44; 0 < p; ) _ = this.reader.readInt(2), b = this.reader.readInt(4), a = this.reader.readData(b), this.zip64ExtensibleData[_] = { id: _, length: b, value: a };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var _, b;
        for (_ = 0; _ < this.files.length; _++) b = this.files[_], this.reader.setIndex(b.localHeaderOffset), this.checkSignature(r.LOCAL_FILE_HEADER), b.readLocalPart(this.reader), b.handleUTF8(), b.processAttributes();
      }, readCentralDir: function() {
        var _;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(r.CENTRAL_FILE_HEADER); ) (_ = new c({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(_);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var _ = this.reader.lastIndexOfSignature(r.CENTRAL_DIRECTORY_END);
        if (_ < 0) throw this.isSignature(0, r.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(_);
        var b = _;
        if (this.checkSignature(r.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (_ = this.reader.lastIndexOfSignature(r.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(_), this.checkSignature(r.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, r.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(r.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(r.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var a = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (a += 20, a += 12 + this.zip64EndOfCentralSize);
        var p = b - a;
        if (0 < p) this.isSignature(b, r.CENTRAL_FILE_HEADER) || (this.reader.zero = p);
        else if (p < 0) throw new Error("Corrupted zip: missing " + Math.abs(p) + " bytes.");
      }, prepareReader: function(_) {
        this.reader = i(_);
      }, load: function(_) {
        this.prepareReader(_), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, S.exports = w;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(u, S, d) {
      var i = u("./reader/readerFor"), o = u("./utils"), r = u("./compressedObject"), c = u("./crc32"), y = u("./utf8"), w = u("./compressions"), _ = u("./support");
      function b(a, p) {
        this.options = a, this.loadOptions = p;
      }
      b.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(a) {
        var p, n;
        if (a.skip(22), this.fileNameLength = a.readInt(2), n = a.readInt(2), this.fileName = a.readData(this.fileNameLength), a.skip(n), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((p = function(h) {
          for (var s in w) if (Object.prototype.hasOwnProperty.call(w, s) && w[s].magic === h) return w[s];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new r(this.compressedSize, this.uncompressedSize, this.crc32, p, a.readData(this.compressedSize));
      }, readCentralPart: function(a) {
        this.versionMadeBy = a.readInt(2), a.skip(2), this.bitFlag = a.readInt(2), this.compressionMethod = a.readString(2), this.date = a.readDate(), this.crc32 = a.readInt(4), this.compressedSize = a.readInt(4), this.uncompressedSize = a.readInt(4);
        var p = a.readInt(2);
        if (this.extraFieldsLength = a.readInt(2), this.fileCommentLength = a.readInt(2), this.diskNumberStart = a.readInt(2), this.internalFileAttributes = a.readInt(2), this.externalFileAttributes = a.readInt(4), this.localHeaderOffset = a.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        a.skip(p), this.readExtraFields(a), this.parseZIP64ExtraField(a), this.fileComment = a.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var a = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), a == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), a == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var a = i(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = a.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = a.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = a.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = a.readInt(4));
        }
      }, readExtraFields: function(a) {
        var p, n, h, s = a.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); a.index + 4 < s; ) p = a.readInt(2), n = a.readInt(2), h = a.readData(n), this.extraFields[p] = { id: p, length: n, value: h };
        a.setIndex(s);
      }, handleUTF8: function() {
        var a = _.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = y.utf8decode(this.fileName), this.fileCommentStr = y.utf8decode(this.fileComment);
        else {
          var p = this.findExtraFieldUnicodePath();
          if (p !== null) this.fileNameStr = p;
          else {
            var n = o.transformTo(a, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(n);
          }
          var h = this.findExtraFieldUnicodeComment();
          if (h !== null) this.fileCommentStr = h;
          else {
            var s = o.transformTo(a, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(s);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var a = this.extraFields[28789];
        if (a) {
          var p = i(a.value);
          return p.readInt(1) !== 1 || c(this.fileName) !== p.readInt(4) ? null : y.utf8decode(p.readData(a.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var a = this.extraFields[25461];
        if (a) {
          var p = i(a.value);
          return p.readInt(1) !== 1 || c(this.fileComment) !== p.readInt(4) ? null : y.utf8decode(p.readData(a.length - 5));
        }
        return null;
      } }, S.exports = b;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(u, S, d) {
      function i(p, n, h) {
        this.name = p, this.dir = h.dir, this.date = h.date, this.comment = h.comment, this.unixPermissions = h.unixPermissions, this.dosPermissions = h.dosPermissions, this._data = n, this._dataBinary = h.binary, this.options = { compression: h.compression, compressionOptions: h.compressionOptions };
      }
      var o = u("./stream/StreamHelper"), r = u("./stream/DataWorker"), c = u("./utf8"), y = u("./compressedObject"), w = u("./stream/GenericWorker");
      i.prototype = { internalStream: function(p) {
        var n = null, h = "string";
        try {
          if (!p) throw new Error("No output type specified.");
          var s = (h = p.toLowerCase()) === "string" || h === "text";
          h !== "binarystring" && h !== "text" || (h = "string"), n = this._decompressWorker();
          var m = !this._dataBinary;
          m && !s && (n = n.pipe(new c.Utf8EncodeWorker())), !m && s && (n = n.pipe(new c.Utf8DecodeWorker()));
        } catch (v) {
          (n = new w("error")).error(v);
        }
        return new o(n, h, "");
      }, async: function(p, n) {
        return this.internalStream(p).accumulate(n);
      }, nodeStream: function(p, n) {
        return this.internalStream(p || "nodebuffer").toNodejsStream(n);
      }, _compressWorker: function(p, n) {
        if (this._data instanceof y && this._data.compression.magic === p.magic) return this._data.getCompressedWorker();
        var h = this._decompressWorker();
        return this._dataBinary || (h = h.pipe(new c.Utf8EncodeWorker())), y.createWorkerFrom(h, p, n);
      }, _decompressWorker: function() {
        return this._data instanceof y ? this._data.getContentWorker() : this._data instanceof w ? this._data : new r(this._data);
      } };
      for (var _ = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], b = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, a = 0; a < _.length; a++) i.prototype[_[a]] = b;
      S.exports = i;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(u, S, d) {
      (function(i) {
        var o, r, c = i.MutationObserver || i.WebKitMutationObserver;
        if (c) {
          var y = 0, w = new c(p), _ = i.document.createTextNode("");
          w.observe(_, { characterData: !0 }), o = function() {
            _.data = y = ++y % 2;
          };
        } else if (i.setImmediate || i.MessageChannel === void 0) o = "document" in i && "onreadystatechange" in i.document.createElement("script") ? function() {
          var n = i.document.createElement("script");
          n.onreadystatechange = function() {
            p(), n.onreadystatechange = null, n.parentNode.removeChild(n), n = null;
          }, i.document.documentElement.appendChild(n);
        } : function() {
          setTimeout(p, 0);
        };
        else {
          var b = new i.MessageChannel();
          b.port1.onmessage = p, o = function() {
            b.port2.postMessage(0);
          };
        }
        var a = [];
        function p() {
          var n, h;
          r = !0;
          for (var s = a.length; s; ) {
            for (h = a, a = [], n = -1; ++n < s; ) h[n]();
            s = a.length;
          }
          r = !1;
        }
        S.exports = function(n) {
          a.push(n) !== 1 || r || o();
        };
      }).call(this, typeof wt < "u" ? wt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(u, S, d) {
      var i = u("immediate");
      function o() {
      }
      var r = {}, c = ["REJECTED"], y = ["FULFILLED"], w = ["PENDING"];
      function _(s) {
        if (typeof s != "function") throw new TypeError("resolver must be a function");
        this.state = w, this.queue = [], this.outcome = void 0, s !== o && n(this, s);
      }
      function b(s, m, v) {
        this.promise = s, typeof m == "function" && (this.onFulfilled = m, this.callFulfilled = this.otherCallFulfilled), typeof v == "function" && (this.onRejected = v, this.callRejected = this.otherCallRejected);
      }
      function a(s, m, v) {
        i(function() {
          var E;
          try {
            E = m(v);
          } catch (x) {
            return r.reject(s, x);
          }
          E === s ? r.reject(s, new TypeError("Cannot resolve promise with itself")) : r.resolve(s, E);
        });
      }
      function p(s) {
        var m = s && s.then;
        if (s && (typeof s == "object" || typeof s == "function") && typeof m == "function") return function() {
          m.apply(s, arguments);
        };
      }
      function n(s, m) {
        var v = !1;
        function E(R) {
          v || (v = !0, r.reject(s, R));
        }
        function x(R) {
          v || (v = !0, r.resolve(s, R));
        }
        var N = h(function() {
          m(x, E);
        });
        N.status === "error" && E(N.value);
      }
      function h(s, m) {
        var v = {};
        try {
          v.value = s(m), v.status = "success";
        } catch (E) {
          v.status = "error", v.value = E;
        }
        return v;
      }
      (S.exports = _).prototype.finally = function(s) {
        if (typeof s != "function") return this;
        var m = this.constructor;
        return this.then(function(v) {
          return m.resolve(s()).then(function() {
            return v;
          });
        }, function(v) {
          return m.resolve(s()).then(function() {
            throw v;
          });
        });
      }, _.prototype.catch = function(s) {
        return this.then(null, s);
      }, _.prototype.then = function(s, m) {
        if (typeof s != "function" && this.state === y || typeof m != "function" && this.state === c) return this;
        var v = new this.constructor(o);
        return this.state !== w ? a(v, this.state === y ? s : m, this.outcome) : this.queue.push(new b(v, s, m)), v;
      }, b.prototype.callFulfilled = function(s) {
        r.resolve(this.promise, s);
      }, b.prototype.otherCallFulfilled = function(s) {
        a(this.promise, this.onFulfilled, s);
      }, b.prototype.callRejected = function(s) {
        r.reject(this.promise, s);
      }, b.prototype.otherCallRejected = function(s) {
        a(this.promise, this.onRejected, s);
      }, r.resolve = function(s, m) {
        var v = h(p, m);
        if (v.status === "error") return r.reject(s, v.value);
        var E = v.value;
        if (E) n(s, E);
        else {
          s.state = y, s.outcome = m;
          for (var x = -1, N = s.queue.length; ++x < N; ) s.queue[x].callFulfilled(m);
        }
        return s;
      }, r.reject = function(s, m) {
        s.state = c, s.outcome = m;
        for (var v = -1, E = s.queue.length; ++v < E; ) s.queue[v].callRejected(m);
        return s;
      }, _.resolve = function(s) {
        return s instanceof this ? s : r.resolve(new this(o), s);
      }, _.reject = function(s) {
        var m = new this(o);
        return r.reject(m, s);
      }, _.all = function(s) {
        var m = this;
        if (Object.prototype.toString.call(s) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var v = s.length, E = !1;
        if (!v) return this.resolve([]);
        for (var x = new Array(v), N = 0, R = -1, Z = new this(o); ++R < v; ) T(s[R], R);
        return Z;
        function T(H, $) {
          m.resolve(H).then(function(g) {
            x[$] = g, ++N !== v || E || (E = !0, r.resolve(Z, x));
          }, function(g) {
            E || (E = !0, r.reject(Z, g));
          });
        }
      }, _.race = function(s) {
        var m = this;
        if (Object.prototype.toString.call(s) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var v = s.length, E = !1;
        if (!v) return this.resolve([]);
        for (var x = -1, N = new this(o); ++x < v; ) R = s[x], m.resolve(R).then(function(Z) {
          E || (E = !0, r.resolve(N, Z));
        }, function(Z) {
          E || (E = !0, r.reject(N, Z));
        });
        var R;
        return N;
      };
    }, { immediate: 36 }], 38: [function(u, S, d) {
      var i = {};
      (0, u("./lib/utils/common").assign)(i, u("./lib/deflate"), u("./lib/inflate"), u("./lib/zlib/constants")), S.exports = i;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(u, S, d) {
      var i = u("./zlib/deflate"), o = u("./utils/common"), r = u("./utils/strings"), c = u("./zlib/messages"), y = u("./zlib/zstream"), w = Object.prototype.toString, _ = 0, b = -1, a = 0, p = 8;
      function n(s) {
        if (!(this instanceof n)) return new n(s);
        this.options = o.assign({ level: b, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: a, to: "" }, s || {});
        var m = this.options;
        m.raw && 0 < m.windowBits ? m.windowBits = -m.windowBits : m.gzip && 0 < m.windowBits && m.windowBits < 16 && (m.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
        var v = i.deflateInit2(this.strm, m.level, m.method, m.windowBits, m.memLevel, m.strategy);
        if (v !== _) throw new Error(c[v]);
        if (m.header && i.deflateSetHeader(this.strm, m.header), m.dictionary) {
          var E;
          if (E = typeof m.dictionary == "string" ? r.string2buf(m.dictionary) : w.call(m.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(m.dictionary) : m.dictionary, (v = i.deflateSetDictionary(this.strm, E)) !== _) throw new Error(c[v]);
          this._dict_set = !0;
        }
      }
      function h(s, m) {
        var v = new n(m);
        if (v.push(s, !0), v.err) throw v.msg || c[v.err];
        return v.result;
      }
      n.prototype.push = function(s, m) {
        var v, E, x = this.strm, N = this.options.chunkSize;
        if (this.ended) return !1;
        E = m === ~~m ? m : m === !0 ? 4 : 0, typeof s == "string" ? x.input = r.string2buf(s) : w.call(s) === "[object ArrayBuffer]" ? x.input = new Uint8Array(s) : x.input = s, x.next_in = 0, x.avail_in = x.input.length;
        do {
          if (x.avail_out === 0 && (x.output = new o.Buf8(N), x.next_out = 0, x.avail_out = N), (v = i.deflate(x, E)) !== 1 && v !== _) return this.onEnd(v), !(this.ended = !0);
          x.avail_out !== 0 && (x.avail_in !== 0 || E !== 4 && E !== 2) || (this.options.to === "string" ? this.onData(r.buf2binstring(o.shrinkBuf(x.output, x.next_out))) : this.onData(o.shrinkBuf(x.output, x.next_out)));
        } while ((0 < x.avail_in || x.avail_out === 0) && v !== 1);
        return E === 4 ? (v = i.deflateEnd(this.strm), this.onEnd(v), this.ended = !0, v === _) : E !== 2 || (this.onEnd(_), !(x.avail_out = 0));
      }, n.prototype.onData = function(s) {
        this.chunks.push(s);
      }, n.prototype.onEnd = function(s) {
        s === _ && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg;
      }, d.Deflate = n, d.deflate = h, d.deflateRaw = function(s, m) {
        return (m = m || {}).raw = !0, h(s, m);
      }, d.gzip = function(s, m) {
        return (m = m || {}).gzip = !0, h(s, m);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(u, S, d) {
      var i = u("./zlib/inflate"), o = u("./utils/common"), r = u("./utils/strings"), c = u("./zlib/constants"), y = u("./zlib/messages"), w = u("./zlib/zstream"), _ = u("./zlib/gzheader"), b = Object.prototype.toString;
      function a(n) {
        if (!(this instanceof a)) return new a(n);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, n || {});
        var h = this.options;
        h.raw && 0 <= h.windowBits && h.windowBits < 16 && (h.windowBits = -h.windowBits, h.windowBits === 0 && (h.windowBits = -15)), !(0 <= h.windowBits && h.windowBits < 16) || n && n.windowBits || (h.windowBits += 32), 15 < h.windowBits && h.windowBits < 48 && !(15 & h.windowBits) && (h.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new w(), this.strm.avail_out = 0;
        var s = i.inflateInit2(this.strm, h.windowBits);
        if (s !== c.Z_OK) throw new Error(y[s]);
        this.header = new _(), i.inflateGetHeader(this.strm, this.header);
      }
      function p(n, h) {
        var s = new a(h);
        if (s.push(n, !0), s.err) throw s.msg || y[s.err];
        return s.result;
      }
      a.prototype.push = function(n, h) {
        var s, m, v, E, x, N, R = this.strm, Z = this.options.chunkSize, T = this.options.dictionary, H = !1;
        if (this.ended) return !1;
        m = h === ~~h ? h : h === !0 ? c.Z_FINISH : c.Z_NO_FLUSH, typeof n == "string" ? R.input = r.binstring2buf(n) : b.call(n) === "[object ArrayBuffer]" ? R.input = new Uint8Array(n) : R.input = n, R.next_in = 0, R.avail_in = R.input.length;
        do {
          if (R.avail_out === 0 && (R.output = new o.Buf8(Z), R.next_out = 0, R.avail_out = Z), (s = i.inflate(R, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && T && (N = typeof T == "string" ? r.string2buf(T) : b.call(T) === "[object ArrayBuffer]" ? new Uint8Array(T) : T, s = i.inflateSetDictionary(this.strm, N)), s === c.Z_BUF_ERROR && H === !0 && (s = c.Z_OK, H = !1), s !== c.Z_STREAM_END && s !== c.Z_OK) return this.onEnd(s), !(this.ended = !0);
          R.next_out && (R.avail_out !== 0 && s !== c.Z_STREAM_END && (R.avail_in !== 0 || m !== c.Z_FINISH && m !== c.Z_SYNC_FLUSH) || (this.options.to === "string" ? (v = r.utf8border(R.output, R.next_out), E = R.next_out - v, x = r.buf2string(R.output, v), R.next_out = E, R.avail_out = Z - E, E && o.arraySet(R.output, R.output, v, E, 0), this.onData(x)) : this.onData(o.shrinkBuf(R.output, R.next_out)))), R.avail_in === 0 && R.avail_out === 0 && (H = !0);
        } while ((0 < R.avail_in || R.avail_out === 0) && s !== c.Z_STREAM_END);
        return s === c.Z_STREAM_END && (m = c.Z_FINISH), m === c.Z_FINISH ? (s = i.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, s === c.Z_OK) : m !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), !(R.avail_out = 0));
      }, a.prototype.onData = function(n) {
        this.chunks.push(n);
      }, a.prototype.onEnd = function(n) {
        n === c.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
      }, d.Inflate = a, d.inflate = p, d.inflateRaw = function(n, h) {
        return (h = h || {}).raw = !0, p(n, h);
      }, d.ungzip = p;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(u, S, d) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      d.assign = function(c) {
        for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
          var w = y.shift();
          if (w) {
            if (typeof w != "object") throw new TypeError(w + "must be non-object");
            for (var _ in w) w.hasOwnProperty(_) && (c[_] = w[_]);
          }
        }
        return c;
      }, d.shrinkBuf = function(c, y) {
        return c.length === y ? c : c.subarray ? c.subarray(0, y) : (c.length = y, c);
      };
      var o = { arraySet: function(c, y, w, _, b) {
        if (y.subarray && c.subarray) c.set(y.subarray(w, w + _), b);
        else for (var a = 0; a < _; a++) c[b + a] = y[w + a];
      }, flattenChunks: function(c) {
        var y, w, _, b, a, p;
        for (y = _ = 0, w = c.length; y < w; y++) _ += c[y].length;
        for (p = new Uint8Array(_), y = b = 0, w = c.length; y < w; y++) a = c[y], p.set(a, b), b += a.length;
        return p;
      } }, r = { arraySet: function(c, y, w, _, b) {
        for (var a = 0; a < _; a++) c[b + a] = y[w + a];
      }, flattenChunks: function(c) {
        return [].concat.apply([], c);
      } };
      d.setTyped = function(c) {
        c ? (d.Buf8 = Uint8Array, d.Buf16 = Uint16Array, d.Buf32 = Int32Array, d.assign(d, o)) : (d.Buf8 = Array, d.Buf16 = Array, d.Buf32 = Array, d.assign(d, r));
      }, d.setTyped(i);
    }, {}], 42: [function(u, S, d) {
      var i = u("./common"), o = !0, r = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        r = !1;
      }
      for (var c = new i.Buf8(256), y = 0; y < 256; y++) c[y] = 252 <= y ? 6 : 248 <= y ? 5 : 240 <= y ? 4 : 224 <= y ? 3 : 192 <= y ? 2 : 1;
      function w(_, b) {
        if (b < 65537 && (_.subarray && r || !_.subarray && o)) return String.fromCharCode.apply(null, i.shrinkBuf(_, b));
        for (var a = "", p = 0; p < b; p++) a += String.fromCharCode(_[p]);
        return a;
      }
      c[254] = c[254] = 1, d.string2buf = function(_) {
        var b, a, p, n, h, s = _.length, m = 0;
        for (n = 0; n < s; n++) (64512 & (a = _.charCodeAt(n))) == 55296 && n + 1 < s && (64512 & (p = _.charCodeAt(n + 1))) == 56320 && (a = 65536 + (a - 55296 << 10) + (p - 56320), n++), m += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
        for (b = new i.Buf8(m), n = h = 0; h < m; n++) (64512 & (a = _.charCodeAt(n))) == 55296 && n + 1 < s && (64512 & (p = _.charCodeAt(n + 1))) == 56320 && (a = 65536 + (a - 55296 << 10) + (p - 56320), n++), a < 128 ? b[h++] = a : (a < 2048 ? b[h++] = 192 | a >>> 6 : (a < 65536 ? b[h++] = 224 | a >>> 12 : (b[h++] = 240 | a >>> 18, b[h++] = 128 | a >>> 12 & 63), b[h++] = 128 | a >>> 6 & 63), b[h++] = 128 | 63 & a);
        return b;
      }, d.buf2binstring = function(_) {
        return w(_, _.length);
      }, d.binstring2buf = function(_) {
        for (var b = new i.Buf8(_.length), a = 0, p = b.length; a < p; a++) b[a] = _.charCodeAt(a);
        return b;
      }, d.buf2string = function(_, b) {
        var a, p, n, h, s = b || _.length, m = new Array(2 * s);
        for (a = p = 0; a < s; ) if ((n = _[a++]) < 128) m[p++] = n;
        else if (4 < (h = c[n])) m[p++] = 65533, a += h - 1;
        else {
          for (n &= h === 2 ? 31 : h === 3 ? 15 : 7; 1 < h && a < s; ) n = n << 6 | 63 & _[a++], h--;
          1 < h ? m[p++] = 65533 : n < 65536 ? m[p++] = n : (n -= 65536, m[p++] = 55296 | n >> 10 & 1023, m[p++] = 56320 | 1023 & n);
        }
        return w(m, p);
      }, d.utf8border = function(_, b) {
        var a;
        for ((b = b || _.length) > _.length && (b = _.length), a = b - 1; 0 <= a && (192 & _[a]) == 128; ) a--;
        return a < 0 || a === 0 ? b : a + c[_[a]] > b ? a : b;
      };
    }, { "./common": 41 }], 43: [function(u, S, d) {
      S.exports = function(i, o, r, c) {
        for (var y = 65535 & i | 0, w = i >>> 16 & 65535 | 0, _ = 0; r !== 0; ) {
          for (r -= _ = 2e3 < r ? 2e3 : r; w = w + (y = y + o[c++] | 0) | 0, --_; ) ;
          y %= 65521, w %= 65521;
        }
        return y | w << 16 | 0;
      };
    }, {}], 44: [function(u, S, d) {
      S.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(u, S, d) {
      var i = function() {
        for (var o, r = [], c = 0; c < 256; c++) {
          o = c;
          for (var y = 0; y < 8; y++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          r[c] = o;
        }
        return r;
      }();
      S.exports = function(o, r, c, y) {
        var w = i, _ = y + c;
        o ^= -1;
        for (var b = y; b < _; b++) o = o >>> 8 ^ w[255 & (o ^ r[b])];
        return -1 ^ o;
      };
    }, {}], 46: [function(u, S, d) {
      var i, o = u("../utils/common"), r = u("./trees"), c = u("./adler32"), y = u("./crc32"), w = u("./messages"), _ = 0, b = 4, a = 0, p = -2, n = -1, h = 4, s = 2, m = 8, v = 9, E = 286, x = 30, N = 19, R = 2 * E + 1, Z = 15, T = 3, H = 258, $ = H + T + 1, g = 42, B = 113, e = 1, F = 2, Q = 3, j = 4;
      function tt(t, D) {
        return t.msg = w[D], D;
      }
      function W(t) {
        return (t << 1) - (4 < t ? 9 : 0);
      }
      function q(t) {
        for (var D = t.length; 0 <= --D; ) t[D] = 0;
      }
      function z(t) {
        var D = t.state, I = D.pending;
        I > t.avail_out && (I = t.avail_out), I !== 0 && (o.arraySet(t.output, D.pending_buf, D.pending_out, I, t.next_out), t.next_out += I, D.pending_out += I, t.total_out += I, t.avail_out -= I, D.pending -= I, D.pending === 0 && (D.pending_out = 0));
      }
      function C(t, D) {
        r._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, D), t.block_start = t.strstart, z(t.strm);
      }
      function V(t, D) {
        t.pending_buf[t.pending++] = D;
      }
      function Y(t, D) {
        t.pending_buf[t.pending++] = D >>> 8 & 255, t.pending_buf[t.pending++] = 255 & D;
      }
      function J(t, D) {
        var I, f, l = t.max_chain_length, k = t.strstart, P = t.prev_length, L = t.nice_match, A = t.strstart > t.w_size - $ ? t.strstart - (t.w_size - $) : 0, M = t.window, X = t.w_mask, G = t.prev, K = t.strstart + H, it = M[k + P - 1], rt = M[k + P];
        t.prev_length >= t.good_match && (l >>= 2), L > t.lookahead && (L = t.lookahead);
        do
          if (M[(I = D) + P] === rt && M[I + P - 1] === it && M[I] === M[k] && M[++I] === M[k + 1]) {
            k += 2, I++;
            do
              ;
            while (M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && M[++k] === M[++I] && k < K);
            if (f = H - (K - k), k = K - H, P < f) {
              if (t.match_start = D, L <= (P = f)) break;
              it = M[k + P - 1], rt = M[k + P];
            }
          }
        while ((D = G[D & X]) > A && --l != 0);
        return P <= t.lookahead ? P : t.lookahead;
      }
      function at(t) {
        var D, I, f, l, k, P, L, A, M, X, G = t.w_size;
        do {
          if (l = t.window_size - t.lookahead - t.strstart, t.strstart >= G + (G - $)) {
            for (o.arraySet(t.window, t.window, G, G, 0), t.match_start -= G, t.strstart -= G, t.block_start -= G, D = I = t.hash_size; f = t.head[--D], t.head[D] = G <= f ? f - G : 0, --I; ) ;
            for (D = I = G; f = t.prev[--D], t.prev[D] = G <= f ? f - G : 0, --I; ) ;
            l += G;
          }
          if (t.strm.avail_in === 0) break;
          if (P = t.strm, L = t.window, A = t.strstart + t.lookahead, M = l, X = void 0, X = P.avail_in, M < X && (X = M), I = X === 0 ? 0 : (P.avail_in -= X, o.arraySet(L, P.input, P.next_in, X, A), P.state.wrap === 1 ? P.adler = c(P.adler, L, X, A) : P.state.wrap === 2 && (P.adler = y(P.adler, L, X, A)), P.next_in += X, P.total_in += X, X), t.lookahead += I, t.lookahead + t.insert >= T) for (k = t.strstart - t.insert, t.ins_h = t.window[k], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[k + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[k + T - 1]) & t.hash_mask, t.prev[k & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = k, k++, t.insert--, !(t.lookahead + t.insert < T)); ) ;
        } while (t.lookahead < $ && t.strm.avail_in !== 0);
      }
      function ut(t, D) {
        for (var I, f; ; ) {
          if (t.lookahead < $) {
            if (at(t), t.lookahead < $ && D === _) return e;
            if (t.lookahead === 0) break;
          }
          if (I = 0, t.lookahead >= T && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, I = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), I !== 0 && t.strstart - I <= t.w_size - $ && (t.match_length = J(t, I)), t.match_length >= T) if (f = r._tr_tally(t, t.strstart - t.match_start, t.match_length - T), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= T) {
            for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, I = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, --t.match_length != 0; ) ;
            t.strstart++;
          } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
          else f = r._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
          if (f && (C(t, !1), t.strm.avail_out === 0)) return e;
        }
        return t.insert = t.strstart < T - 1 ? t.strstart : T - 1, D === b ? (C(t, !0), t.strm.avail_out === 0 ? Q : j) : t.last_lit && (C(t, !1), t.strm.avail_out === 0) ? e : F;
      }
      function et(t, D) {
        for (var I, f, l; ; ) {
          if (t.lookahead < $) {
            if (at(t), t.lookahead < $ && D === _) return e;
            if (t.lookahead === 0) break;
          }
          if (I = 0, t.lookahead >= T && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, I = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = T - 1, I !== 0 && t.prev_length < t.max_lazy_match && t.strstart - I <= t.w_size - $ && (t.match_length = J(t, I), t.match_length <= 5 && (t.strategy === 1 || t.match_length === T && 4096 < t.strstart - t.match_start) && (t.match_length = T - 1)), t.prev_length >= T && t.match_length <= t.prev_length) {
            for (l = t.strstart + t.lookahead - T, f = r._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - T), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= l && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, I = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), --t.prev_length != 0; ) ;
            if (t.match_available = 0, t.match_length = T - 1, t.strstart++, f && (C(t, !1), t.strm.avail_out === 0)) return e;
          } else if (t.match_available) {
            if ((f = r._tr_tally(t, 0, t.window[t.strstart - 1])) && C(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return e;
          } else t.match_available = 1, t.strstart++, t.lookahead--;
        }
        return t.match_available && (f = r._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < T - 1 ? t.strstart : T - 1, D === b ? (C(t, !0), t.strm.avail_out === 0 ? Q : j) : t.last_lit && (C(t, !1), t.strm.avail_out === 0) ? e : F;
      }
      function nt(t, D, I, f, l) {
        this.good_length = t, this.max_lazy = D, this.nice_length = I, this.max_chain = f, this.func = l;
      }
      function lt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = m, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * R), this.dyn_dtree = new o.Buf16(2 * (2 * x + 1)), this.bl_tree = new o.Buf16(2 * (2 * N + 1)), q(this.dyn_ltree), q(this.dyn_dtree), q(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(Z + 1), this.heap = new o.Buf16(2 * E + 1), q(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * E + 1), q(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function st(t) {
        var D;
        return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = s, (D = t.state).pending = 0, D.pending_out = 0, D.wrap < 0 && (D.wrap = -D.wrap), D.status = D.wrap ? g : B, t.adler = D.wrap === 2 ? 0 : 1, D.last_flush = _, r._tr_init(D), a) : tt(t, p);
      }
      function ft(t) {
        var D = st(t);
        return D === a && function(I) {
          I.window_size = 2 * I.w_size, q(I.head), I.max_lazy_match = i[I.level].max_lazy, I.good_match = i[I.level].good_length, I.nice_match = i[I.level].nice_length, I.max_chain_length = i[I.level].max_chain, I.strstart = 0, I.block_start = 0, I.lookahead = 0, I.insert = 0, I.match_length = I.prev_length = T - 1, I.match_available = 0, I.ins_h = 0;
        }(t.state), D;
      }
      function ht(t, D, I, f, l, k) {
        if (!t) return p;
        var P = 1;
        if (D === n && (D = 6), f < 0 ? (P = 0, f = -f) : 15 < f && (P = 2, f -= 16), l < 1 || v < l || I !== m || f < 8 || 15 < f || D < 0 || 9 < D || k < 0 || h < k) return tt(t, p);
        f === 8 && (f = 9);
        var L = new lt();
        return (t.state = L).strm = t, L.wrap = P, L.gzhead = null, L.w_bits = f, L.w_size = 1 << L.w_bits, L.w_mask = L.w_size - 1, L.hash_bits = l + 7, L.hash_size = 1 << L.hash_bits, L.hash_mask = L.hash_size - 1, L.hash_shift = ~~((L.hash_bits + T - 1) / T), L.window = new o.Buf8(2 * L.w_size), L.head = new o.Buf16(L.hash_size), L.prev = new o.Buf16(L.w_size), L.lit_bufsize = 1 << l + 6, L.pending_buf_size = 4 * L.lit_bufsize, L.pending_buf = new o.Buf8(L.pending_buf_size), L.d_buf = 1 * L.lit_bufsize, L.l_buf = 3 * L.lit_bufsize, L.level = D, L.strategy = k, L.method = I, ft(t);
      }
      i = [new nt(0, 0, 0, 0, function(t, D) {
        var I = 65535;
        for (I > t.pending_buf_size - 5 && (I = t.pending_buf_size - 5); ; ) {
          if (t.lookahead <= 1) {
            if (at(t), t.lookahead === 0 && D === _) return e;
            if (t.lookahead === 0) break;
          }
          t.strstart += t.lookahead, t.lookahead = 0;
          var f = t.block_start + I;
          if ((t.strstart === 0 || t.strstart >= f) && (t.lookahead = t.strstart - f, t.strstart = f, C(t, !1), t.strm.avail_out === 0) || t.strstart - t.block_start >= t.w_size - $ && (C(t, !1), t.strm.avail_out === 0)) return e;
        }
        return t.insert = 0, D === b ? (C(t, !0), t.strm.avail_out === 0 ? Q : j) : (t.strstart > t.block_start && (C(t, !1), t.strm.avail_out), e);
      }), new nt(4, 4, 8, 4, ut), new nt(4, 5, 16, 8, ut), new nt(4, 6, 32, 32, ut), new nt(4, 4, 16, 16, et), new nt(8, 16, 32, 32, et), new nt(8, 16, 128, 128, et), new nt(8, 32, 128, 256, et), new nt(32, 128, 258, 1024, et), new nt(32, 258, 258, 4096, et)], d.deflateInit = function(t, D) {
        return ht(t, D, m, 15, 8, 0);
      }, d.deflateInit2 = ht, d.deflateReset = ft, d.deflateResetKeep = st, d.deflateSetHeader = function(t, D) {
        return t && t.state ? t.state.wrap !== 2 ? p : (t.state.gzhead = D, a) : p;
      }, d.deflate = function(t, D) {
        var I, f, l, k;
        if (!t || !t.state || 5 < D || D < 0) return t ? tt(t, p) : p;
        if (f = t.state, !t.output || !t.input && t.avail_in !== 0 || f.status === 666 && D !== b) return tt(t, t.avail_out === 0 ? -5 : p);
        if (f.strm = t, I = f.last_flush, f.last_flush = D, f.status === g) if (f.wrap === 2) t.adler = 0, V(f, 31), V(f, 139), V(f, 8), f.gzhead ? (V(f, (f.gzhead.text ? 1 : 0) + (f.gzhead.hcrc ? 2 : 0) + (f.gzhead.extra ? 4 : 0) + (f.gzhead.name ? 8 : 0) + (f.gzhead.comment ? 16 : 0)), V(f, 255 & f.gzhead.time), V(f, f.gzhead.time >> 8 & 255), V(f, f.gzhead.time >> 16 & 255), V(f, f.gzhead.time >> 24 & 255), V(f, f.level === 9 ? 2 : 2 <= f.strategy || f.level < 2 ? 4 : 0), V(f, 255 & f.gzhead.os), f.gzhead.extra && f.gzhead.extra.length && (V(f, 255 & f.gzhead.extra.length), V(f, f.gzhead.extra.length >> 8 & 255)), f.gzhead.hcrc && (t.adler = y(t.adler, f.pending_buf, f.pending, 0)), f.gzindex = 0, f.status = 69) : (V(f, 0), V(f, 0), V(f, 0), V(f, 0), V(f, 0), V(f, f.level === 9 ? 2 : 2 <= f.strategy || f.level < 2 ? 4 : 0), V(f, 3), f.status = B);
        else {
          var P = m + (f.w_bits - 8 << 4) << 8;
          P |= (2 <= f.strategy || f.level < 2 ? 0 : f.level < 6 ? 1 : f.level === 6 ? 2 : 3) << 6, f.strstart !== 0 && (P |= 32), P += 31 - P % 31, f.status = B, Y(f, P), f.strstart !== 0 && (Y(f, t.adler >>> 16), Y(f, 65535 & t.adler)), t.adler = 1;
        }
        if (f.status === 69) if (f.gzhead.extra) {
          for (l = f.pending; f.gzindex < (65535 & f.gzhead.extra.length) && (f.pending !== f.pending_buf_size || (f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), z(t), l = f.pending, f.pending !== f.pending_buf_size)); ) V(f, 255 & f.gzhead.extra[f.gzindex]), f.gzindex++;
          f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), f.gzindex === f.gzhead.extra.length && (f.gzindex = 0, f.status = 73);
        } else f.status = 73;
        if (f.status === 73) if (f.gzhead.name) {
          l = f.pending;
          do {
            if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), z(t), l = f.pending, f.pending === f.pending_buf_size)) {
              k = 1;
              break;
            }
            k = f.gzindex < f.gzhead.name.length ? 255 & f.gzhead.name.charCodeAt(f.gzindex++) : 0, V(f, k);
          } while (k !== 0);
          f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), k === 0 && (f.gzindex = 0, f.status = 91);
        } else f.status = 91;
        if (f.status === 91) if (f.gzhead.comment) {
          l = f.pending;
          do {
            if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), z(t), l = f.pending, f.pending === f.pending_buf_size)) {
              k = 1;
              break;
            }
            k = f.gzindex < f.gzhead.comment.length ? 255 & f.gzhead.comment.charCodeAt(f.gzindex++) : 0, V(f, k);
          } while (k !== 0);
          f.gzhead.hcrc && f.pending > l && (t.adler = y(t.adler, f.pending_buf, f.pending - l, l)), k === 0 && (f.status = 103);
        } else f.status = 103;
        if (f.status === 103 && (f.gzhead.hcrc ? (f.pending + 2 > f.pending_buf_size && z(t), f.pending + 2 <= f.pending_buf_size && (V(f, 255 & t.adler), V(f, t.adler >> 8 & 255), t.adler = 0, f.status = B)) : f.status = B), f.pending !== 0) {
          if (z(t), t.avail_out === 0) return f.last_flush = -1, a;
        } else if (t.avail_in === 0 && W(D) <= W(I) && D !== b) return tt(t, -5);
        if (f.status === 666 && t.avail_in !== 0) return tt(t, -5);
        if (t.avail_in !== 0 || f.lookahead !== 0 || D !== _ && f.status !== 666) {
          var L = f.strategy === 2 ? function(A, M) {
            for (var X; ; ) {
              if (A.lookahead === 0 && (at(A), A.lookahead === 0)) {
                if (M === _) return e;
                break;
              }
              if (A.match_length = 0, X = r._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++, X && (C(A, !1), A.strm.avail_out === 0)) return e;
            }
            return A.insert = 0, M === b ? (C(A, !0), A.strm.avail_out === 0 ? Q : j) : A.last_lit && (C(A, !1), A.strm.avail_out === 0) ? e : F;
          }(f, D) : f.strategy === 3 ? function(A, M) {
            for (var X, G, K, it, rt = A.window; ; ) {
              if (A.lookahead <= H) {
                if (at(A), A.lookahead <= H && M === _) return e;
                if (A.lookahead === 0) break;
              }
              if (A.match_length = 0, A.lookahead >= T && 0 < A.strstart && (G = rt[K = A.strstart - 1]) === rt[++K] && G === rt[++K] && G === rt[++K]) {
                it = A.strstart + H;
                do
                  ;
                while (G === rt[++K] && G === rt[++K] && G === rt[++K] && G === rt[++K] && G === rt[++K] && G === rt[++K] && G === rt[++K] && G === rt[++K] && K < it);
                A.match_length = H - (it - K), A.match_length > A.lookahead && (A.match_length = A.lookahead);
              }
              if (A.match_length >= T ? (X = r._tr_tally(A, 1, A.match_length - T), A.lookahead -= A.match_length, A.strstart += A.match_length, A.match_length = 0) : (X = r._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++), X && (C(A, !1), A.strm.avail_out === 0)) return e;
            }
            return A.insert = 0, M === b ? (C(A, !0), A.strm.avail_out === 0 ? Q : j) : A.last_lit && (C(A, !1), A.strm.avail_out === 0) ? e : F;
          }(f, D) : i[f.level].func(f, D);
          if (L !== Q && L !== j || (f.status = 666), L === e || L === Q) return t.avail_out === 0 && (f.last_flush = -1), a;
          if (L === F && (D === 1 ? r._tr_align(f) : D !== 5 && (r._tr_stored_block(f, 0, 0, !1), D === 3 && (q(f.head), f.lookahead === 0 && (f.strstart = 0, f.block_start = 0, f.insert = 0))), z(t), t.avail_out === 0)) return f.last_flush = -1, a;
        }
        return D !== b ? a : f.wrap <= 0 ? 1 : (f.wrap === 2 ? (V(f, 255 & t.adler), V(f, t.adler >> 8 & 255), V(f, t.adler >> 16 & 255), V(f, t.adler >> 24 & 255), V(f, 255 & t.total_in), V(f, t.total_in >> 8 & 255), V(f, t.total_in >> 16 & 255), V(f, t.total_in >> 24 & 255)) : (Y(f, t.adler >>> 16), Y(f, 65535 & t.adler)), z(t), 0 < f.wrap && (f.wrap = -f.wrap), f.pending !== 0 ? a : 1);
      }, d.deflateEnd = function(t) {
        var D;
        return t && t.state ? (D = t.state.status) !== g && D !== 69 && D !== 73 && D !== 91 && D !== 103 && D !== B && D !== 666 ? tt(t, p) : (t.state = null, D === B ? tt(t, -3) : a) : p;
      }, d.deflateSetDictionary = function(t, D) {
        var I, f, l, k, P, L, A, M, X = D.length;
        if (!t || !t.state || (k = (I = t.state).wrap) === 2 || k === 1 && I.status !== g || I.lookahead) return p;
        for (k === 1 && (t.adler = c(t.adler, D, X, 0)), I.wrap = 0, X >= I.w_size && (k === 0 && (q(I.head), I.strstart = 0, I.block_start = 0, I.insert = 0), M = new o.Buf8(I.w_size), o.arraySet(M, D, X - I.w_size, I.w_size, 0), D = M, X = I.w_size), P = t.avail_in, L = t.next_in, A = t.input, t.avail_in = X, t.next_in = 0, t.input = D, at(I); I.lookahead >= T; ) {
          for (f = I.strstart, l = I.lookahead - (T - 1); I.ins_h = (I.ins_h << I.hash_shift ^ I.window[f + T - 1]) & I.hash_mask, I.prev[f & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = f, f++, --l; ) ;
          I.strstart = f, I.lookahead = T - 1, at(I);
        }
        return I.strstart += I.lookahead, I.block_start = I.strstart, I.insert = I.lookahead, I.lookahead = 0, I.match_length = I.prev_length = T - 1, I.match_available = 0, t.next_in = L, t.input = A, t.avail_in = P, I.wrap = k, a;
      }, d.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(u, S, d) {
      S.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(u, S, d) {
      S.exports = function(i, o) {
        var r, c, y, w, _, b, a, p, n, h, s, m, v, E, x, N, R, Z, T, H, $, g, B, e, F;
        r = i.state, c = i.next_in, e = i.input, y = c + (i.avail_in - 5), w = i.next_out, F = i.output, _ = w - (o - i.avail_out), b = w + (i.avail_out - 257), a = r.dmax, p = r.wsize, n = r.whave, h = r.wnext, s = r.window, m = r.hold, v = r.bits, E = r.lencode, x = r.distcode, N = (1 << r.lenbits) - 1, R = (1 << r.distbits) - 1;
        t: do {
          v < 15 && (m += e[c++] << v, v += 8, m += e[c++] << v, v += 8), Z = E[m & N];
          e: for (; ; ) {
            if (m >>>= T = Z >>> 24, v -= T, (T = Z >>> 16 & 255) === 0) F[w++] = 65535 & Z;
            else {
              if (!(16 & T)) {
                if (!(64 & T)) {
                  Z = E[(65535 & Z) + (m & (1 << T) - 1)];
                  continue e;
                }
                if (32 & T) {
                  r.mode = 12;
                  break t;
                }
                i.msg = "invalid literal/length code", r.mode = 30;
                break t;
              }
              H = 65535 & Z, (T &= 15) && (v < T && (m += e[c++] << v, v += 8), H += m & (1 << T) - 1, m >>>= T, v -= T), v < 15 && (m += e[c++] << v, v += 8, m += e[c++] << v, v += 8), Z = x[m & R];
              r: for (; ; ) {
                if (m >>>= T = Z >>> 24, v -= T, !(16 & (T = Z >>> 16 & 255))) {
                  if (!(64 & T)) {
                    Z = x[(65535 & Z) + (m & (1 << T) - 1)];
                    continue r;
                  }
                  i.msg = "invalid distance code", r.mode = 30;
                  break t;
                }
                if ($ = 65535 & Z, v < (T &= 15) && (m += e[c++] << v, (v += 8) < T && (m += e[c++] << v, v += 8)), a < ($ += m & (1 << T) - 1)) {
                  i.msg = "invalid distance too far back", r.mode = 30;
                  break t;
                }
                if (m >>>= T, v -= T, (T = w - _) < $) {
                  if (n < (T = $ - T) && r.sane) {
                    i.msg = "invalid distance too far back", r.mode = 30;
                    break t;
                  }
                  if (B = s, (g = 0) === h) {
                    if (g += p - T, T < H) {
                      for (H -= T; F[w++] = s[g++], --T; ) ;
                      g = w - $, B = F;
                    }
                  } else if (h < T) {
                    if (g += p + h - T, (T -= h) < H) {
                      for (H -= T; F[w++] = s[g++], --T; ) ;
                      if (g = 0, h < H) {
                        for (H -= T = h; F[w++] = s[g++], --T; ) ;
                        g = w - $, B = F;
                      }
                    }
                  } else if (g += h - T, T < H) {
                    for (H -= T; F[w++] = s[g++], --T; ) ;
                    g = w - $, B = F;
                  }
                  for (; 2 < H; ) F[w++] = B[g++], F[w++] = B[g++], F[w++] = B[g++], H -= 3;
                  H && (F[w++] = B[g++], 1 < H && (F[w++] = B[g++]));
                } else {
                  for (g = w - $; F[w++] = F[g++], F[w++] = F[g++], F[w++] = F[g++], 2 < (H -= 3); ) ;
                  H && (F[w++] = F[g++], 1 < H && (F[w++] = F[g++]));
                }
                break;
              }
            }
            break;
          }
        } while (c < y && w < b);
        c -= H = v >> 3, m &= (1 << (v -= H << 3)) - 1, i.next_in = c, i.next_out = w, i.avail_in = c < y ? y - c + 5 : 5 - (c - y), i.avail_out = w < b ? b - w + 257 : 257 - (w - b), r.hold = m, r.bits = v;
      };
    }, {}], 49: [function(u, S, d) {
      var i = u("../utils/common"), o = u("./adler32"), r = u("./crc32"), c = u("./inffast"), y = u("./inftrees"), w = 1, _ = 2, b = 0, a = -2, p = 1, n = 852, h = 592;
      function s(g) {
        return (g >>> 24 & 255) + (g >>> 8 & 65280) + ((65280 & g) << 8) + ((255 & g) << 24);
      }
      function m() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function v(g) {
        var B;
        return g && g.state ? (B = g.state, g.total_in = g.total_out = B.total = 0, g.msg = "", B.wrap && (g.adler = 1 & B.wrap), B.mode = p, B.last = 0, B.havedict = 0, B.dmax = 32768, B.head = null, B.hold = 0, B.bits = 0, B.lencode = B.lendyn = new i.Buf32(n), B.distcode = B.distdyn = new i.Buf32(h), B.sane = 1, B.back = -1, b) : a;
      }
      function E(g) {
        var B;
        return g && g.state ? ((B = g.state).wsize = 0, B.whave = 0, B.wnext = 0, v(g)) : a;
      }
      function x(g, B) {
        var e, F;
        return g && g.state ? (F = g.state, B < 0 ? (e = 0, B = -B) : (e = 1 + (B >> 4), B < 48 && (B &= 15)), B && (B < 8 || 15 < B) ? a : (F.window !== null && F.wbits !== B && (F.window = null), F.wrap = e, F.wbits = B, E(g))) : a;
      }
      function N(g, B) {
        var e, F;
        return g ? (F = new m(), (g.state = F).window = null, (e = x(g, B)) !== b && (g.state = null), e) : a;
      }
      var R, Z, T = !0;
      function H(g) {
        if (T) {
          var B;
          for (R = new i.Buf32(512), Z = new i.Buf32(32), B = 0; B < 144; ) g.lens[B++] = 8;
          for (; B < 256; ) g.lens[B++] = 9;
          for (; B < 280; ) g.lens[B++] = 7;
          for (; B < 288; ) g.lens[B++] = 8;
          for (y(w, g.lens, 0, 288, R, 0, g.work, { bits: 9 }), B = 0; B < 32; ) g.lens[B++] = 5;
          y(_, g.lens, 0, 32, Z, 0, g.work, { bits: 5 }), T = !1;
        }
        g.lencode = R, g.lenbits = 9, g.distcode = Z, g.distbits = 5;
      }
      function $(g, B, e, F) {
        var Q, j = g.state;
        return j.window === null && (j.wsize = 1 << j.wbits, j.wnext = 0, j.whave = 0, j.window = new i.Buf8(j.wsize)), F >= j.wsize ? (i.arraySet(j.window, B, e - j.wsize, j.wsize, 0), j.wnext = 0, j.whave = j.wsize) : (F < (Q = j.wsize - j.wnext) && (Q = F), i.arraySet(j.window, B, e - F, Q, j.wnext), (F -= Q) ? (i.arraySet(j.window, B, e - F, F, 0), j.wnext = F, j.whave = j.wsize) : (j.wnext += Q, j.wnext === j.wsize && (j.wnext = 0), j.whave < j.wsize && (j.whave += Q))), 0;
      }
      d.inflateReset = E, d.inflateReset2 = x, d.inflateResetKeep = v, d.inflateInit = function(g) {
        return N(g, 15);
      }, d.inflateInit2 = N, d.inflate = function(g, B) {
        var e, F, Q, j, tt, W, q, z, C, V, Y, J, at, ut, et, nt, lt, st, ft, ht, t, D, I, f, l = 0, k = new i.Buf8(4), P = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!g || !g.state || !g.output || !g.input && g.avail_in !== 0) return a;
        (e = g.state).mode === 12 && (e.mode = 13), tt = g.next_out, Q = g.output, q = g.avail_out, j = g.next_in, F = g.input, W = g.avail_in, z = e.hold, C = e.bits, V = W, Y = q, D = b;
        t: for (; ; ) switch (e.mode) {
          case p:
            if (e.wrap === 0) {
              e.mode = 13;
              break;
            }
            for (; C < 16; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if (2 & e.wrap && z === 35615) {
              k[e.check = 0] = 255 & z, k[1] = z >>> 8 & 255, e.check = r(e.check, k, 2, 0), C = z = 0, e.mode = 2;
              break;
            }
            if (e.flags = 0, e.head && (e.head.done = !1), !(1 & e.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
              g.msg = "incorrect header check", e.mode = 30;
              break;
            }
            if ((15 & z) != 8) {
              g.msg = "unknown compression method", e.mode = 30;
              break;
            }
            if (C -= 4, t = 8 + (15 & (z >>>= 4)), e.wbits === 0) e.wbits = t;
            else if (t > e.wbits) {
              g.msg = "invalid window size", e.mode = 30;
              break;
            }
            e.dmax = 1 << t, g.adler = e.check = 1, e.mode = 512 & z ? 10 : 12, C = z = 0;
            break;
          case 2:
            for (; C < 16; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if (e.flags = z, (255 & e.flags) != 8) {
              g.msg = "unknown compression method", e.mode = 30;
              break;
            }
            if (57344 & e.flags) {
              g.msg = "unknown header flags set", e.mode = 30;
              break;
            }
            e.head && (e.head.text = z >> 8 & 1), 512 & e.flags && (k[0] = 255 & z, k[1] = z >>> 8 & 255, e.check = r(e.check, k, 2, 0)), C = z = 0, e.mode = 3;
          case 3:
            for (; C < 32; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            e.head && (e.head.time = z), 512 & e.flags && (k[0] = 255 & z, k[1] = z >>> 8 & 255, k[2] = z >>> 16 & 255, k[3] = z >>> 24 & 255, e.check = r(e.check, k, 4, 0)), C = z = 0, e.mode = 4;
          case 4:
            for (; C < 16; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            e.head && (e.head.xflags = 255 & z, e.head.os = z >> 8), 512 & e.flags && (k[0] = 255 & z, k[1] = z >>> 8 & 255, e.check = r(e.check, k, 2, 0)), C = z = 0, e.mode = 5;
          case 5:
            if (1024 & e.flags) {
              for (; C < 16; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              e.length = z, e.head && (e.head.extra_len = z), 512 & e.flags && (k[0] = 255 & z, k[1] = z >>> 8 & 255, e.check = r(e.check, k, 2, 0)), C = z = 0;
            } else e.head && (e.head.extra = null);
            e.mode = 6;
          case 6:
            if (1024 & e.flags && (W < (J = e.length) && (J = W), J && (e.head && (t = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Array(e.head.extra_len)), i.arraySet(e.head.extra, F, j, J, t)), 512 & e.flags && (e.check = r(e.check, F, J, j)), W -= J, j += J, e.length -= J), e.length)) break t;
            e.length = 0, e.mode = 7;
          case 7:
            if (2048 & e.flags) {
              if (W === 0) break t;
              for (J = 0; t = F[j + J++], e.head && t && e.length < 65536 && (e.head.name += String.fromCharCode(t)), t && J < W; ) ;
              if (512 & e.flags && (e.check = r(e.check, F, J, j)), W -= J, j += J, t) break t;
            } else e.head && (e.head.name = null);
            e.length = 0, e.mode = 8;
          case 8:
            if (4096 & e.flags) {
              if (W === 0) break t;
              for (J = 0; t = F[j + J++], e.head && t && e.length < 65536 && (e.head.comment += String.fromCharCode(t)), t && J < W; ) ;
              if (512 & e.flags && (e.check = r(e.check, F, J, j)), W -= J, j += J, t) break t;
            } else e.head && (e.head.comment = null);
            e.mode = 9;
          case 9:
            if (512 & e.flags) {
              for (; C < 16; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              if (z !== (65535 & e.check)) {
                g.msg = "header crc mismatch", e.mode = 30;
                break;
              }
              C = z = 0;
            }
            e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = !0), g.adler = e.check = 0, e.mode = 12;
            break;
          case 10:
            for (; C < 32; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            g.adler = e.check = s(z), C = z = 0, e.mode = 11;
          case 11:
            if (e.havedict === 0) return g.next_out = tt, g.avail_out = q, g.next_in = j, g.avail_in = W, e.hold = z, e.bits = C, 2;
            g.adler = e.check = 1, e.mode = 12;
          case 12:
            if (B === 5 || B === 6) break t;
          case 13:
            if (e.last) {
              z >>>= 7 & C, C -= 7 & C, e.mode = 27;
              break;
            }
            for (; C < 3; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            switch (e.last = 1 & z, C -= 1, 3 & (z >>>= 1)) {
              case 0:
                e.mode = 14;
                break;
              case 1:
                if (H(e), e.mode = 20, B !== 6) break;
                z >>>= 2, C -= 2;
                break t;
              case 2:
                e.mode = 17;
                break;
              case 3:
                g.msg = "invalid block type", e.mode = 30;
            }
            z >>>= 2, C -= 2;
            break;
          case 14:
            for (z >>>= 7 & C, C -= 7 & C; C < 32; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if ((65535 & z) != (z >>> 16 ^ 65535)) {
              g.msg = "invalid stored block lengths", e.mode = 30;
              break;
            }
            if (e.length = 65535 & z, C = z = 0, e.mode = 15, B === 6) break t;
          case 15:
            e.mode = 16;
          case 16:
            if (J = e.length) {
              if (W < J && (J = W), q < J && (J = q), J === 0) break t;
              i.arraySet(Q, F, j, J, tt), W -= J, j += J, q -= J, tt += J, e.length -= J;
              break;
            }
            e.mode = 12;
            break;
          case 17:
            for (; C < 14; ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if (e.nlen = 257 + (31 & z), z >>>= 5, C -= 5, e.ndist = 1 + (31 & z), z >>>= 5, C -= 5, e.ncode = 4 + (15 & z), z >>>= 4, C -= 4, 286 < e.nlen || 30 < e.ndist) {
              g.msg = "too many length or distance symbols", e.mode = 30;
              break;
            }
            e.have = 0, e.mode = 18;
          case 18:
            for (; e.have < e.ncode; ) {
              for (; C < 3; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              e.lens[P[e.have++]] = 7 & z, z >>>= 3, C -= 3;
            }
            for (; e.have < 19; ) e.lens[P[e.have++]] = 0;
            if (e.lencode = e.lendyn, e.lenbits = 7, I = { bits: e.lenbits }, D = y(0, e.lens, 0, 19, e.lencode, 0, e.work, I), e.lenbits = I.bits, D) {
              g.msg = "invalid code lengths set", e.mode = 30;
              break;
            }
            e.have = 0, e.mode = 19;
          case 19:
            for (; e.have < e.nlen + e.ndist; ) {
              for (; nt = (l = e.lencode[z & (1 << e.lenbits) - 1]) >>> 16 & 255, lt = 65535 & l, !((et = l >>> 24) <= C); ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              if (lt < 16) z >>>= et, C -= et, e.lens[e.have++] = lt;
              else {
                if (lt === 16) {
                  for (f = et + 2; C < f; ) {
                    if (W === 0) break t;
                    W--, z += F[j++] << C, C += 8;
                  }
                  if (z >>>= et, C -= et, e.have === 0) {
                    g.msg = "invalid bit length repeat", e.mode = 30;
                    break;
                  }
                  t = e.lens[e.have - 1], J = 3 + (3 & z), z >>>= 2, C -= 2;
                } else if (lt === 17) {
                  for (f = et + 3; C < f; ) {
                    if (W === 0) break t;
                    W--, z += F[j++] << C, C += 8;
                  }
                  C -= et, t = 0, J = 3 + (7 & (z >>>= et)), z >>>= 3, C -= 3;
                } else {
                  for (f = et + 7; C < f; ) {
                    if (W === 0) break t;
                    W--, z += F[j++] << C, C += 8;
                  }
                  C -= et, t = 0, J = 11 + (127 & (z >>>= et)), z >>>= 7, C -= 7;
                }
                if (e.have + J > e.nlen + e.ndist) {
                  g.msg = "invalid bit length repeat", e.mode = 30;
                  break;
                }
                for (; J--; ) e.lens[e.have++] = t;
              }
            }
            if (e.mode === 30) break;
            if (e.lens[256] === 0) {
              g.msg = "invalid code -- missing end-of-block", e.mode = 30;
              break;
            }
            if (e.lenbits = 9, I = { bits: e.lenbits }, D = y(w, e.lens, 0, e.nlen, e.lencode, 0, e.work, I), e.lenbits = I.bits, D) {
              g.msg = "invalid literal/lengths set", e.mode = 30;
              break;
            }
            if (e.distbits = 6, e.distcode = e.distdyn, I = { bits: e.distbits }, D = y(_, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, I), e.distbits = I.bits, D) {
              g.msg = "invalid distances set", e.mode = 30;
              break;
            }
            if (e.mode = 20, B === 6) break t;
          case 20:
            e.mode = 21;
          case 21:
            if (6 <= W && 258 <= q) {
              g.next_out = tt, g.avail_out = q, g.next_in = j, g.avail_in = W, e.hold = z, e.bits = C, c(g, Y), tt = g.next_out, Q = g.output, q = g.avail_out, j = g.next_in, F = g.input, W = g.avail_in, z = e.hold, C = e.bits, e.mode === 12 && (e.back = -1);
              break;
            }
            for (e.back = 0; nt = (l = e.lencode[z & (1 << e.lenbits) - 1]) >>> 16 & 255, lt = 65535 & l, !((et = l >>> 24) <= C); ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if (nt && !(240 & nt)) {
              for (st = et, ft = nt, ht = lt; nt = (l = e.lencode[ht + ((z & (1 << st + ft) - 1) >> st)]) >>> 16 & 255, lt = 65535 & l, !(st + (et = l >>> 24) <= C); ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              z >>>= st, C -= st, e.back += st;
            }
            if (z >>>= et, C -= et, e.back += et, e.length = lt, nt === 0) {
              e.mode = 26;
              break;
            }
            if (32 & nt) {
              e.back = -1, e.mode = 12;
              break;
            }
            if (64 & nt) {
              g.msg = "invalid literal/length code", e.mode = 30;
              break;
            }
            e.extra = 15 & nt, e.mode = 22;
          case 22:
            if (e.extra) {
              for (f = e.extra; C < f; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              e.length += z & (1 << e.extra) - 1, z >>>= e.extra, C -= e.extra, e.back += e.extra;
            }
            e.was = e.length, e.mode = 23;
          case 23:
            for (; nt = (l = e.distcode[z & (1 << e.distbits) - 1]) >>> 16 & 255, lt = 65535 & l, !((et = l >>> 24) <= C); ) {
              if (W === 0) break t;
              W--, z += F[j++] << C, C += 8;
            }
            if (!(240 & nt)) {
              for (st = et, ft = nt, ht = lt; nt = (l = e.distcode[ht + ((z & (1 << st + ft) - 1) >> st)]) >>> 16 & 255, lt = 65535 & l, !(st + (et = l >>> 24) <= C); ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              z >>>= st, C -= st, e.back += st;
            }
            if (z >>>= et, C -= et, e.back += et, 64 & nt) {
              g.msg = "invalid distance code", e.mode = 30;
              break;
            }
            e.offset = lt, e.extra = 15 & nt, e.mode = 24;
          case 24:
            if (e.extra) {
              for (f = e.extra; C < f; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              e.offset += z & (1 << e.extra) - 1, z >>>= e.extra, C -= e.extra, e.back += e.extra;
            }
            if (e.offset > e.dmax) {
              g.msg = "invalid distance too far back", e.mode = 30;
              break;
            }
            e.mode = 25;
          case 25:
            if (q === 0) break t;
            if (J = Y - q, e.offset > J) {
              if ((J = e.offset - J) > e.whave && e.sane) {
                g.msg = "invalid distance too far back", e.mode = 30;
                break;
              }
              at = J > e.wnext ? (J -= e.wnext, e.wsize - J) : e.wnext - J, J > e.length && (J = e.length), ut = e.window;
            } else ut = Q, at = tt - e.offset, J = e.length;
            for (q < J && (J = q), q -= J, e.length -= J; Q[tt++] = ut[at++], --J; ) ;
            e.length === 0 && (e.mode = 21);
            break;
          case 26:
            if (q === 0) break t;
            Q[tt++] = e.length, q--, e.mode = 21;
            break;
          case 27:
            if (e.wrap) {
              for (; C < 32; ) {
                if (W === 0) break t;
                W--, z |= F[j++] << C, C += 8;
              }
              if (Y -= q, g.total_out += Y, e.total += Y, Y && (g.adler = e.check = e.flags ? r(e.check, Q, Y, tt - Y) : o(e.check, Q, Y, tt - Y)), Y = q, (e.flags ? z : s(z)) !== e.check) {
                g.msg = "incorrect data check", e.mode = 30;
                break;
              }
              C = z = 0;
            }
            e.mode = 28;
          case 28:
            if (e.wrap && e.flags) {
              for (; C < 32; ) {
                if (W === 0) break t;
                W--, z += F[j++] << C, C += 8;
              }
              if (z !== (4294967295 & e.total)) {
                g.msg = "incorrect length check", e.mode = 30;
                break;
              }
              C = z = 0;
            }
            e.mode = 29;
          case 29:
            D = 1;
            break t;
          case 30:
            D = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return a;
        }
        return g.next_out = tt, g.avail_out = q, g.next_in = j, g.avail_in = W, e.hold = z, e.bits = C, (e.wsize || Y !== g.avail_out && e.mode < 30 && (e.mode < 27 || B !== 4)) && $(g, g.output, g.next_out, Y - g.avail_out) ? (e.mode = 31, -4) : (V -= g.avail_in, Y -= g.avail_out, g.total_in += V, g.total_out += Y, e.total += Y, e.wrap && Y && (g.adler = e.check = e.flags ? r(e.check, Q, Y, g.next_out - Y) : o(e.check, Q, Y, g.next_out - Y)), g.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === 12 ? 128 : 0) + (e.mode === 20 || e.mode === 15 ? 256 : 0), (V == 0 && Y === 0 || B === 4) && D === b && (D = -5), D);
      }, d.inflateEnd = function(g) {
        if (!g || !g.state) return a;
        var B = g.state;
        return B.window && (B.window = null), g.state = null, b;
      }, d.inflateGetHeader = function(g, B) {
        var e;
        return g && g.state && 2 & (e = g.state).wrap ? ((e.head = B).done = !1, b) : a;
      }, d.inflateSetDictionary = function(g, B) {
        var e, F = B.length;
        return g && g.state ? (e = g.state).wrap !== 0 && e.mode !== 11 ? a : e.mode === 11 && o(1, B, F, 0) !== e.check ? -3 : $(g, B, F, F) ? (e.mode = 31, -4) : (e.havedict = 1, b) : a;
      }, d.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(u, S, d) {
      var i = u("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], c = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], y = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      S.exports = function(w, _, b, a, p, n, h, s) {
        var m, v, E, x, N, R, Z, T, H, $ = s.bits, g = 0, B = 0, e = 0, F = 0, Q = 0, j = 0, tt = 0, W = 0, q = 0, z = 0, C = null, V = 0, Y = new i.Buf16(16), J = new i.Buf16(16), at = null, ut = 0;
        for (g = 0; g <= 15; g++) Y[g] = 0;
        for (B = 0; B < a; B++) Y[_[b + B]]++;
        for (Q = $, F = 15; 1 <= F && Y[F] === 0; F--) ;
        if (F < Q && (Q = F), F === 0) return p[n++] = 20971520, p[n++] = 20971520, s.bits = 1, 0;
        for (e = 1; e < F && Y[e] === 0; e++) ;
        for (Q < e && (Q = e), g = W = 1; g <= 15; g++) if (W <<= 1, (W -= Y[g]) < 0) return -1;
        if (0 < W && (w === 0 || F !== 1)) return -1;
        for (J[1] = 0, g = 1; g < 15; g++) J[g + 1] = J[g] + Y[g];
        for (B = 0; B < a; B++) _[b + B] !== 0 && (h[J[_[b + B]]++] = B);
        if (R = w === 0 ? (C = at = h, 19) : w === 1 ? (C = o, V -= 257, at = r, ut -= 257, 256) : (C = c, at = y, -1), g = e, N = n, tt = B = z = 0, E = -1, x = (q = 1 << (j = Q)) - 1, w === 1 && 852 < q || w === 2 && 592 < q) return 1;
        for (; ; ) {
          for (Z = g - tt, H = h[B] < R ? (T = 0, h[B]) : h[B] > R ? (T = at[ut + h[B]], C[V + h[B]]) : (T = 96, 0), m = 1 << g - tt, e = v = 1 << j; p[N + (z >> tt) + (v -= m)] = Z << 24 | T << 16 | H | 0, v !== 0; ) ;
          for (m = 1 << g - 1; z & m; ) m >>= 1;
          if (m !== 0 ? (z &= m - 1, z += m) : z = 0, B++, --Y[g] == 0) {
            if (g === F) break;
            g = _[b + h[B]];
          }
          if (Q < g && (z & x) !== E) {
            for (tt === 0 && (tt = Q), N += e, W = 1 << (j = g - tt); j + tt < F && !((W -= Y[j + tt]) <= 0); ) j++, W <<= 1;
            if (q += 1 << j, w === 1 && 852 < q || w === 2 && 592 < q) return 1;
            p[E = z & x] = Q << 24 | j << 16 | N - n | 0;
          }
        }
        return z !== 0 && (p[N + z] = g - tt << 24 | 64 << 16 | 0), s.bits = Q, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(u, S, d) {
      S.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(u, S, d) {
      var i = u("../utils/common"), o = 0, r = 1;
      function c(l) {
        for (var k = l.length; 0 <= --k; ) l[k] = 0;
      }
      var y = 0, w = 29, _ = 256, b = _ + 1 + w, a = 30, p = 19, n = 2 * b + 1, h = 15, s = 16, m = 7, v = 256, E = 16, x = 17, N = 18, R = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], Z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], H = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], $ = new Array(2 * (b + 2));
      c($);
      var g = new Array(2 * a);
      c(g);
      var B = new Array(512);
      c(B);
      var e = new Array(256);
      c(e);
      var F = new Array(w);
      c(F);
      var Q, j, tt, W = new Array(a);
      function q(l, k, P, L, A) {
        this.static_tree = l, this.extra_bits = k, this.extra_base = P, this.elems = L, this.max_length = A, this.has_stree = l && l.length;
      }
      function z(l, k) {
        this.dyn_tree = l, this.max_code = 0, this.stat_desc = k;
      }
      function C(l) {
        return l < 256 ? B[l] : B[256 + (l >>> 7)];
      }
      function V(l, k) {
        l.pending_buf[l.pending++] = 255 & k, l.pending_buf[l.pending++] = k >>> 8 & 255;
      }
      function Y(l, k, P) {
        l.bi_valid > s - P ? (l.bi_buf |= k << l.bi_valid & 65535, V(l, l.bi_buf), l.bi_buf = k >> s - l.bi_valid, l.bi_valid += P - s) : (l.bi_buf |= k << l.bi_valid & 65535, l.bi_valid += P);
      }
      function J(l, k, P) {
        Y(l, P[2 * k], P[2 * k + 1]);
      }
      function at(l, k) {
        for (var P = 0; P |= 1 & l, l >>>= 1, P <<= 1, 0 < --k; ) ;
        return P >>> 1;
      }
      function ut(l, k, P) {
        var L, A, M = new Array(h + 1), X = 0;
        for (L = 1; L <= h; L++) M[L] = X = X + P[L - 1] << 1;
        for (A = 0; A <= k; A++) {
          var G = l[2 * A + 1];
          G !== 0 && (l[2 * A] = at(M[G]++, G));
        }
      }
      function et(l) {
        var k;
        for (k = 0; k < b; k++) l.dyn_ltree[2 * k] = 0;
        for (k = 0; k < a; k++) l.dyn_dtree[2 * k] = 0;
        for (k = 0; k < p; k++) l.bl_tree[2 * k] = 0;
        l.dyn_ltree[2 * v] = 1, l.opt_len = l.static_len = 0, l.last_lit = l.matches = 0;
      }
      function nt(l) {
        8 < l.bi_valid ? V(l, l.bi_buf) : 0 < l.bi_valid && (l.pending_buf[l.pending++] = l.bi_buf), l.bi_buf = 0, l.bi_valid = 0;
      }
      function lt(l, k, P, L) {
        var A = 2 * k, M = 2 * P;
        return l[A] < l[M] || l[A] === l[M] && L[k] <= L[P];
      }
      function st(l, k, P) {
        for (var L = l.heap[P], A = P << 1; A <= l.heap_len && (A < l.heap_len && lt(k, l.heap[A + 1], l.heap[A], l.depth) && A++, !lt(k, L, l.heap[A], l.depth)); ) l.heap[P] = l.heap[A], P = A, A <<= 1;
        l.heap[P] = L;
      }
      function ft(l, k, P) {
        var L, A, M, X, G = 0;
        if (l.last_lit !== 0) for (; L = l.pending_buf[l.d_buf + 2 * G] << 8 | l.pending_buf[l.d_buf + 2 * G + 1], A = l.pending_buf[l.l_buf + G], G++, L === 0 ? J(l, A, k) : (J(l, (M = e[A]) + _ + 1, k), (X = R[M]) !== 0 && Y(l, A -= F[M], X), J(l, M = C(--L), P), (X = Z[M]) !== 0 && Y(l, L -= W[M], X)), G < l.last_lit; ) ;
        J(l, v, k);
      }
      function ht(l, k) {
        var P, L, A, M = k.dyn_tree, X = k.stat_desc.static_tree, G = k.stat_desc.has_stree, K = k.stat_desc.elems, it = -1;
        for (l.heap_len = 0, l.heap_max = n, P = 0; P < K; P++) M[2 * P] !== 0 ? (l.heap[++l.heap_len] = it = P, l.depth[P] = 0) : M[2 * P + 1] = 0;
        for (; l.heap_len < 2; ) M[2 * (A = l.heap[++l.heap_len] = it < 2 ? ++it : 0)] = 1, l.depth[A] = 0, l.opt_len--, G && (l.static_len -= X[2 * A + 1]);
        for (k.max_code = it, P = l.heap_len >> 1; 1 <= P; P--) st(l, M, P);
        for (A = K; P = l.heap[1], l.heap[1] = l.heap[l.heap_len--], st(l, M, 1), L = l.heap[1], l.heap[--l.heap_max] = P, l.heap[--l.heap_max] = L, M[2 * A] = M[2 * P] + M[2 * L], l.depth[A] = (l.depth[P] >= l.depth[L] ? l.depth[P] : l.depth[L]) + 1, M[2 * P + 1] = M[2 * L + 1] = A, l.heap[1] = A++, st(l, M, 1), 2 <= l.heap_len; ) ;
        l.heap[--l.heap_max] = l.heap[1], function(rt, ct) {
          var mt, dt, _t, ot, bt, Et, pt = ct.dyn_tree, zt = ct.max_code, Yt = ct.stat_desc.static_tree, Xt = ct.stat_desc.has_stree, Kt = ct.stat_desc.extra_bits, Ot = ct.stat_desc.extra_base, gt = ct.stat_desc.max_length, vt = 0;
          for (ot = 0; ot <= h; ot++) rt.bl_count[ot] = 0;
          for (pt[2 * rt.heap[rt.heap_max] + 1] = 0, mt = rt.heap_max + 1; mt < n; mt++) gt < (ot = pt[2 * pt[2 * (dt = rt.heap[mt]) + 1] + 1] + 1) && (ot = gt, vt++), pt[2 * dt + 1] = ot, zt < dt || (rt.bl_count[ot]++, bt = 0, Ot <= dt && (bt = Kt[dt - Ot]), Et = pt[2 * dt], rt.opt_len += Et * (ot + bt), Xt && (rt.static_len += Et * (Yt[2 * dt + 1] + bt)));
          if (vt !== 0) {
            do {
              for (ot = gt - 1; rt.bl_count[ot] === 0; ) ot--;
              rt.bl_count[ot]--, rt.bl_count[ot + 1] += 2, rt.bl_count[gt]--, vt -= 2;
            } while (0 < vt);
            for (ot = gt; ot !== 0; ot--) for (dt = rt.bl_count[ot]; dt !== 0; ) zt < (_t = rt.heap[--mt]) || (pt[2 * _t + 1] !== ot && (rt.opt_len += (ot - pt[2 * _t + 1]) * pt[2 * _t], pt[2 * _t + 1] = ot), dt--);
          }
        }(l, k), ut(M, it, l.bl_count);
      }
      function t(l, k, P) {
        var L, A, M = -1, X = k[1], G = 0, K = 7, it = 4;
        for (X === 0 && (K = 138, it = 3), k[2 * (P + 1) + 1] = 65535, L = 0; L <= P; L++) A = X, X = k[2 * (L + 1) + 1], ++G < K && A === X || (G < it ? l.bl_tree[2 * A] += G : A !== 0 ? (A !== M && l.bl_tree[2 * A]++, l.bl_tree[2 * E]++) : G <= 10 ? l.bl_tree[2 * x]++ : l.bl_tree[2 * N]++, M = A, it = (G = 0) === X ? (K = 138, 3) : A === X ? (K = 6, 3) : (K = 7, 4));
      }
      function D(l, k, P) {
        var L, A, M = -1, X = k[1], G = 0, K = 7, it = 4;
        for (X === 0 && (K = 138, it = 3), L = 0; L <= P; L++) if (A = X, X = k[2 * (L + 1) + 1], !(++G < K && A === X)) {
          if (G < it) for (; J(l, A, l.bl_tree), --G != 0; ) ;
          else A !== 0 ? (A !== M && (J(l, A, l.bl_tree), G--), J(l, E, l.bl_tree), Y(l, G - 3, 2)) : G <= 10 ? (J(l, x, l.bl_tree), Y(l, G - 3, 3)) : (J(l, N, l.bl_tree), Y(l, G - 11, 7));
          M = A, it = (G = 0) === X ? (K = 138, 3) : A === X ? (K = 6, 3) : (K = 7, 4);
        }
      }
      c(W);
      var I = !1;
      function f(l, k, P, L) {
        Y(l, (y << 1) + (L ? 1 : 0), 3), function(A, M, X, G) {
          nt(A), V(A, X), V(A, ~X), i.arraySet(A.pending_buf, A.window, M, X, A.pending), A.pending += X;
        }(l, k, P);
      }
      d._tr_init = function(l) {
        I || (function() {
          var k, P, L, A, M, X = new Array(h + 1);
          for (A = L = 0; A < w - 1; A++) for (F[A] = L, k = 0; k < 1 << R[A]; k++) e[L++] = A;
          for (e[L - 1] = A, A = M = 0; A < 16; A++) for (W[A] = M, k = 0; k < 1 << Z[A]; k++) B[M++] = A;
          for (M >>= 7; A < a; A++) for (W[A] = M << 7, k = 0; k < 1 << Z[A] - 7; k++) B[256 + M++] = A;
          for (P = 0; P <= h; P++) X[P] = 0;
          for (k = 0; k <= 143; ) $[2 * k + 1] = 8, k++, X[8]++;
          for (; k <= 255; ) $[2 * k + 1] = 9, k++, X[9]++;
          for (; k <= 279; ) $[2 * k + 1] = 7, k++, X[7]++;
          for (; k <= 287; ) $[2 * k + 1] = 8, k++, X[8]++;
          for (ut($, b + 1, X), k = 0; k < a; k++) g[2 * k + 1] = 5, g[2 * k] = at(k, 5);
          Q = new q($, R, _ + 1, b, h), j = new q(g, Z, 0, a, h), tt = new q(new Array(0), T, 0, p, m);
        }(), I = !0), l.l_desc = new z(l.dyn_ltree, Q), l.d_desc = new z(l.dyn_dtree, j), l.bl_desc = new z(l.bl_tree, tt), l.bi_buf = 0, l.bi_valid = 0, et(l);
      }, d._tr_stored_block = f, d._tr_flush_block = function(l, k, P, L) {
        var A, M, X = 0;
        0 < l.level ? (l.strm.data_type === 2 && (l.strm.data_type = function(G) {
          var K, it = 4093624447;
          for (K = 0; K <= 31; K++, it >>>= 1) if (1 & it && G.dyn_ltree[2 * K] !== 0) return o;
          if (G.dyn_ltree[18] !== 0 || G.dyn_ltree[20] !== 0 || G.dyn_ltree[26] !== 0) return r;
          for (K = 32; K < _; K++) if (G.dyn_ltree[2 * K] !== 0) return r;
          return o;
        }(l)), ht(l, l.l_desc), ht(l, l.d_desc), X = function(G) {
          var K;
          for (t(G, G.dyn_ltree, G.l_desc.max_code), t(G, G.dyn_dtree, G.d_desc.max_code), ht(G, G.bl_desc), K = p - 1; 3 <= K && G.bl_tree[2 * H[K] + 1] === 0; K--) ;
          return G.opt_len += 3 * (K + 1) + 5 + 5 + 4, K;
        }(l), A = l.opt_len + 3 + 7 >>> 3, (M = l.static_len + 3 + 7 >>> 3) <= A && (A = M)) : A = M = P + 5, P + 4 <= A && k !== -1 ? f(l, k, P, L) : l.strategy === 4 || M === A ? (Y(l, 2 + (L ? 1 : 0), 3), ft(l, $, g)) : (Y(l, 4 + (L ? 1 : 0), 3), function(G, K, it, rt) {
          var ct;
          for (Y(G, K - 257, 5), Y(G, it - 1, 5), Y(G, rt - 4, 4), ct = 0; ct < rt; ct++) Y(G, G.bl_tree[2 * H[ct] + 1], 3);
          D(G, G.dyn_ltree, K - 1), D(G, G.dyn_dtree, it - 1);
        }(l, l.l_desc.max_code + 1, l.d_desc.max_code + 1, X + 1), ft(l, l.dyn_ltree, l.dyn_dtree)), et(l), L && nt(l);
      }, d._tr_tally = function(l, k, P) {
        return l.pending_buf[l.d_buf + 2 * l.last_lit] = k >>> 8 & 255, l.pending_buf[l.d_buf + 2 * l.last_lit + 1] = 255 & k, l.pending_buf[l.l_buf + l.last_lit] = 255 & P, l.last_lit++, k === 0 ? l.dyn_ltree[2 * P]++ : (l.matches++, k--, l.dyn_ltree[2 * (e[P] + _ + 1)]++, l.dyn_dtree[2 * C(k)]++), l.last_lit === l.lit_bufsize - 1;
      }, d._tr_align = function(l) {
        Y(l, 2, 3), J(l, v, $), function(k) {
          k.bi_valid === 16 ? (V(k, k.bi_buf), k.bi_buf = 0, k.bi_valid = 0) : 8 <= k.bi_valid && (k.pending_buf[k.pending++] = 255 & k.bi_buf, k.bi_buf >>= 8, k.bi_valid -= 8);
        }(l);
      };
    }, { "../utils/common": 41 }], 53: [function(u, S, d) {
      S.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(u, S, d) {
      (function(i) {
        (function(o, r) {
          if (!o.setImmediate) {
            var c, y, w, _, b = 1, a = {}, p = !1, n = o.document, h = Object.getPrototypeOf && Object.getPrototypeOf(o);
            h = h && h.setTimeout ? h : o, c = {}.toString.call(o.process) === "[object process]" ? function(E) {
              process.nextTick(function() {
                m(E);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var E = !0, x = o.onmessage;
                return o.onmessage = function() {
                  E = !1;
                }, o.postMessage("", "*"), o.onmessage = x, E;
              }
            }() ? (_ = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", v, !1) : o.attachEvent("onmessage", v), function(E) {
              o.postMessage(_ + E, "*");
            }) : o.MessageChannel ? ((w = new MessageChannel()).port1.onmessage = function(E) {
              m(E.data);
            }, function(E) {
              w.port2.postMessage(E);
            }) : n && "onreadystatechange" in n.createElement("script") ? (y = n.documentElement, function(E) {
              var x = n.createElement("script");
              x.onreadystatechange = function() {
                m(E), x.onreadystatechange = null, y.removeChild(x), x = null;
              }, y.appendChild(x);
            }) : function(E) {
              setTimeout(m, 0, E);
            }, h.setImmediate = function(E) {
              typeof E != "function" && (E = new Function("" + E));
              for (var x = new Array(arguments.length - 1), N = 0; N < x.length; N++) x[N] = arguments[N + 1];
              var R = { callback: E, args: x };
              return a[b] = R, c(b), b++;
            }, h.clearImmediate = s;
          }
          function s(E) {
            delete a[E];
          }
          function m(E) {
            if (p) setTimeout(m, 0, E);
            else {
              var x = a[E];
              if (x) {
                p = !0;
                try {
                  (function(N) {
                    var R = N.callback, Z = N.args;
                    switch (Z.length) {
                      case 0:
                        R();
                        break;
                      case 1:
                        R(Z[0]);
                        break;
                      case 2:
                        R(Z[0], Z[1]);
                        break;
                      case 3:
                        R(Z[0], Z[1], Z[2]);
                        break;
                      default:
                        R.apply(r, Z);
                    }
                  })(x);
                } finally {
                  s(E), p = !1;
                }
              }
            }
          }
          function v(E) {
            E.source === o && typeof E.data == "string" && E.data.indexOf(_) === 0 && m(+E.data.slice(_.length));
          }
        })(typeof self > "u" ? i === void 0 ? this : i : self);
      }).call(this, typeof wt < "u" ? wt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Mt);
var Ye = Mt.exports;
const Xe = /* @__PURE__ */ Je(Ye);
function Ke(O, U) {
  const u = document.createElement("a");
  u.download = U, u.style.display = "none", u.href = URL.createObjectURL(O), document.body.appendChild(u), u.click(), document.body.removeChild(u);
}
const Ht = () => new Xe(), Ve = (O, { zipHandle: U, zipName: u } = {}) => {
  let S = U;
  return U || (S = Ht()), O.forEach(({ filePath: d, fileContent: i }) => {
    const o = d.split("/"), r = o.pop(), c = o.join("/");
    c ? S.folder(c).file(r, i) : S.file(r, i);
  }), S.generateAsync({ type: "blob" }).then((d) => {
    Ke(d, `${u}.zip`);
  });
}, xt = Object.prototype.hasOwnProperty.call(window, "showDirectoryPicker") && window.self === window.top, $e = async (O = {}) => xt ? await window.showDirectoryPicker({ mode: "readwrite", ...O }) : Ht();
async function St(O, U = [], { create: u = !1 } = {}) {
  if (!O)
    return null;
  let S = O;
  for (const d of U)
    S = await S.getDirectoryHandle(d, { create: u });
  return S;
}
async function Gt(O, U, { create: u = !1 } = {}) {
  if (!O || !U)
    return null;
  const S = U.split("/"), d = S.pop();
  return await (await St(O, S, { create: u })).getFileHandle(d, { create: u });
}
const qe = async (O = {}) => {
  if (!xt)
    throw new Error("不支持的浏览器或处于iframe中");
  const [U] = await window.showOpenFilePicker({ mode: "readwrite", ...O });
  return U;
}, Qe = async (O, U) => !O || !U ? void 0 : await (await (await Gt(O, U)).getFile()).text(), tr = async (O, U) => {
  let u = O;
  if (!O)
    return;
  if (U) {
    const d = U.split("/");
    u = await St(O, d);
  }
  const S = [];
  for await (const d of u.values())
    S.push(d);
  return S;
}, Jt = async (O, { filePath: U, fileContent: u }) => {
  let S = null, d = null, i;
  if (!O || O.type === "directory" && !U)
    throw new Error("invalid handle.");
  if (O.type === "file")
    d = O, i = O.name;
  else {
    S = O;
    const r = U.split("/");
    i = r.pop(), d = await (await St(S, r, { create: !0 })).getFileHandle(i, { create: !0 });
  }
  const o = await d.createWritable();
  await o.write(u), await o.close();
}, er = async (O, U, u = "tiny-engine-generate-code", S = !1) => {
  if (!(U != null && U.length))
    return;
  if (!xt) {
    await Ve(U, { zipName: u, zipHandle: S && O });
    return;
  }
  let d = O;
  d || (d = await window.showDirectoryPicker({ mode: "readwrite" })), await Promise.all(U.map((i) => Jt(d, i)));
}, sr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDirectoryHandle: St,
  getFileHandle: Gt,
  getUserBaseDirHandle: $e,
  getUserFileHandle: qe,
  isSupportFileSystemAccess: xt,
  readDir: tr,
  readFile: Qe,
  writeFile: Jt,
  writeFiles: er
}, Symbol.toStringTag, { value: "Module" }));
export {
  ar as constants,
  sr as fs,
  ir as utils
};
//# sourceMappingURL=index.js.map
