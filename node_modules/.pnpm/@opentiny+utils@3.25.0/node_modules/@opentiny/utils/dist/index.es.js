var pr = Object.defineProperty;
var gr = (e, t, s) => t in e ? pr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var x = (e, t, s) => gr(e, typeof t != "symbol" ? t + "" : t, s);
var Ve = { exports: {} }, C = {}, Je = { exports: {} }, ye = {}, ds;
function nn() {
  if (ds) return ye;
  ds = 1;
  function e() {
    var r = {};
    return r["align-content"] = !1, r["align-items"] = !1, r["align-self"] = !1, r["alignment-adjust"] = !1, r["alignment-baseline"] = !1, r.all = !1, r["anchor-point"] = !1, r.animation = !1, r["animation-delay"] = !1, r["animation-direction"] = !1, r["animation-duration"] = !1, r["animation-fill-mode"] = !1, r["animation-iteration-count"] = !1, r["animation-name"] = !1, r["animation-play-state"] = !1, r["animation-timing-function"] = !1, r.azimuth = !1, r["backface-visibility"] = !1, r.background = !0, r["background-attachment"] = !0, r["background-clip"] = !0, r["background-color"] = !0, r["background-image"] = !0, r["background-origin"] = !0, r["background-position"] = !0, r["background-repeat"] = !0, r["background-size"] = !0, r["baseline-shift"] = !1, r.binding = !1, r.bleed = !1, r["bookmark-label"] = !1, r["bookmark-level"] = !1, r["bookmark-state"] = !1, r.border = !0, r["border-bottom"] = !0, r["border-bottom-color"] = !0, r["border-bottom-left-radius"] = !0, r["border-bottom-right-radius"] = !0, r["border-bottom-style"] = !0, r["border-bottom-width"] = !0, r["border-collapse"] = !0, r["border-color"] = !0, r["border-image"] = !0, r["border-image-outset"] = !0, r["border-image-repeat"] = !0, r["border-image-slice"] = !0, r["border-image-source"] = !0, r["border-image-width"] = !0, r["border-left"] = !0, r["border-left-color"] = !0, r["border-left-style"] = !0, r["border-left-width"] = !0, r["border-radius"] = !0, r["border-right"] = !0, r["border-right-color"] = !0, r["border-right-style"] = !0, r["border-right-width"] = !0, r["border-spacing"] = !0, r["border-style"] = !0, r["border-top"] = !0, r["border-top-color"] = !0, r["border-top-left-radius"] = !0, r["border-top-right-radius"] = !0, r["border-top-style"] = !0, r["border-top-width"] = !0, r["border-width"] = !0, r.bottom = !1, r["box-decoration-break"] = !0, r["box-shadow"] = !0, r["box-sizing"] = !0, r["box-snap"] = !0, r["box-suppress"] = !0, r["break-after"] = !0, r["break-before"] = !0, r["break-inside"] = !0, r["caption-side"] = !1, r.chains = !1, r.clear = !0, r.clip = !1, r["clip-path"] = !1, r["clip-rule"] = !1, r.color = !0, r["color-interpolation-filters"] = !0, r["column-count"] = !1, r["column-fill"] = !1, r["column-gap"] = !1, r["column-rule"] = !1, r["column-rule-color"] = !1, r["column-rule-style"] = !1, r["column-rule-width"] = !1, r["column-span"] = !1, r["column-width"] = !1, r.columns = !1, r.contain = !1, r.content = !1, r["counter-increment"] = !1, r["counter-reset"] = !1, r["counter-set"] = !1, r.crop = !1, r.cue = !1, r["cue-after"] = !1, r["cue-before"] = !1, r.cursor = !1, r.direction = !1, r.display = !0, r["display-inside"] = !0, r["display-list"] = !0, r["display-outside"] = !0, r["dominant-baseline"] = !1, r.elevation = !1, r["empty-cells"] = !1, r.filter = !1, r.flex = !1, r["flex-basis"] = !1, r["flex-direction"] = !1, r["flex-flow"] = !1, r["flex-grow"] = !1, r["flex-shrink"] = !1, r["flex-wrap"] = !1, r.float = !1, r["float-offset"] = !1, r["flood-color"] = !1, r["flood-opacity"] = !1, r["flow-from"] = !1, r["flow-into"] = !1, r.font = !0, r["font-family"] = !0, r["font-feature-settings"] = !0, r["font-kerning"] = !0, r["font-language-override"] = !0, r["font-size"] = !0, r["font-size-adjust"] = !0, r["font-stretch"] = !0, r["font-style"] = !0, r["font-synthesis"] = !0, r["font-variant"] = !0, r["font-variant-alternates"] = !0, r["font-variant-caps"] = !0, r["font-variant-east-asian"] = !0, r["font-variant-ligatures"] = !0, r["font-variant-numeric"] = !0, r["font-variant-position"] = !0, r["font-weight"] = !0, r.grid = !1, r["grid-area"] = !1, r["grid-auto-columns"] = !1, r["grid-auto-flow"] = !1, r["grid-auto-rows"] = !1, r["grid-column"] = !1, r["grid-column-end"] = !1, r["grid-column-start"] = !1, r["grid-row"] = !1, r["grid-row-end"] = !1, r["grid-row-start"] = !1, r["grid-template"] = !1, r["grid-template-areas"] = !1, r["grid-template-columns"] = !1, r["grid-template-rows"] = !1, r["hanging-punctuation"] = !1, r.height = !0, r.hyphens = !1, r.icon = !1, r["image-orientation"] = !1, r["image-resolution"] = !1, r["ime-mode"] = !1, r["initial-letters"] = !1, r["inline-box-align"] = !1, r["justify-content"] = !1, r["justify-items"] = !1, r["justify-self"] = !1, r.left = !1, r["letter-spacing"] = !0, r["lighting-color"] = !0, r["line-box-contain"] = !1, r["line-break"] = !1, r["line-grid"] = !1, r["line-height"] = !1, r["line-snap"] = !1, r["line-stacking"] = !1, r["line-stacking-ruby"] = !1, r["line-stacking-shift"] = !1, r["line-stacking-strategy"] = !1, r["list-style"] = !0, r["list-style-image"] = !0, r["list-style-position"] = !0, r["list-style-type"] = !0, r.margin = !0, r["margin-bottom"] = !0, r["margin-left"] = !0, r["margin-right"] = !0, r["margin-top"] = !0, r["marker-offset"] = !1, r["marker-side"] = !1, r.marks = !1, r.mask = !1, r["mask-box"] = !1, r["mask-box-outset"] = !1, r["mask-box-repeat"] = !1, r["mask-box-slice"] = !1, r["mask-box-source"] = !1, r["mask-box-width"] = !1, r["mask-clip"] = !1, r["mask-image"] = !1, r["mask-origin"] = !1, r["mask-position"] = !1, r["mask-repeat"] = !1, r["mask-size"] = !1, r["mask-source-type"] = !1, r["mask-type"] = !1, r["max-height"] = !0, r["max-lines"] = !1, r["max-width"] = !0, r["min-height"] = !0, r["min-width"] = !0, r["move-to"] = !1, r["nav-down"] = !1, r["nav-index"] = !1, r["nav-left"] = !1, r["nav-right"] = !1, r["nav-up"] = !1, r["object-fit"] = !1, r["object-position"] = !1, r.opacity = !1, r.order = !1, r.orphans = !1, r.outline = !1, r["outline-color"] = !1, r["outline-offset"] = !1, r["outline-style"] = !1, r["outline-width"] = !1, r.overflow = !1, r["overflow-wrap"] = !1, r["overflow-x"] = !1, r["overflow-y"] = !1, r.padding = !0, r["padding-bottom"] = !0, r["padding-left"] = !0, r["padding-right"] = !0, r["padding-top"] = !0, r.page = !1, r["page-break-after"] = !1, r["page-break-before"] = !1, r["page-break-inside"] = !1, r["page-policy"] = !1, r.pause = !1, r["pause-after"] = !1, r["pause-before"] = !1, r.perspective = !1, r["perspective-origin"] = !1, r.pitch = !1, r["pitch-range"] = !1, r["play-during"] = !1, r.position = !1, r["presentation-level"] = !1, r.quotes = !1, r["region-fragment"] = !1, r.resize = !1, r.rest = !1, r["rest-after"] = !1, r["rest-before"] = !1, r.richness = !1, r.right = !1, r.rotation = !1, r["rotation-point"] = !1, r["ruby-align"] = !1, r["ruby-merge"] = !1, r["ruby-position"] = !1, r["shape-image-threshold"] = !1, r["shape-outside"] = !1, r["shape-margin"] = !1, r.size = !1, r.speak = !1, r["speak-as"] = !1, r["speak-header"] = !1, r["speak-numeral"] = !1, r["speak-punctuation"] = !1, r["speech-rate"] = !1, r.stress = !1, r["string-set"] = !1, r["tab-size"] = !1, r["table-layout"] = !1, r["text-align"] = !0, r["text-align-last"] = !0, r["text-combine-upright"] = !0, r["text-decoration"] = !0, r["text-decoration-color"] = !0, r["text-decoration-line"] = !0, r["text-decoration-skip"] = !0, r["text-decoration-style"] = !0, r["text-emphasis"] = !0, r["text-emphasis-color"] = !0, r["text-emphasis-position"] = !0, r["text-emphasis-style"] = !0, r["text-height"] = !0, r["text-indent"] = !0, r["text-justify"] = !0, r["text-orientation"] = !0, r["text-overflow"] = !0, r["text-shadow"] = !0, r["text-space-collapse"] = !0, r["text-transform"] = !0, r["text-underline-position"] = !0, r["text-wrap"] = !0, r.top = !1, r.transform = !1, r["transform-origin"] = !1, r["transform-style"] = !1, r.transition = !1, r["transition-delay"] = !1, r["transition-duration"] = !1, r["transition-property"] = !1, r["transition-timing-function"] = !1, r["unicode-bidi"] = !1, r["vertical-align"] = !1, r.visibility = !1, r["voice-balance"] = !1, r["voice-duration"] = !1, r["voice-family"] = !1, r["voice-pitch"] = !1, r["voice-range"] = !1, r["voice-rate"] = !1, r["voice-stress"] = !1, r["voice-volume"] = !1, r.volume = !1, r["white-space"] = !1, r.widows = !1, r.width = !0, r["will-change"] = !1, r["word-break"] = !0, r["word-spacing"] = !0, r["word-wrap"] = !0, r["wrap-flow"] = !1, r["wrap-through"] = !1, r["writing-mode"] = !1, r["z-index"] = !1, r;
  }
  function t(r, o, a) {
  }
  function s(r, o, a) {
  }
  var n = /javascript\s*\:/img;
  function i(r, o) {
    return n.test(o) ? "" : o;
  }
  return ye.whiteList = e(), ye.getDefaultWhiteList = e, ye.onAttr = t, ye.onIgnoreAttr = s, ye.safeAttrValue = i, ye;
}
var St, hs;
function rn() {
  return hs || (hs = 1, St = {
    indexOf: function(e, t) {
      var s, n;
      if (Array.prototype.indexOf)
        return e.indexOf(t);
      for (s = 0, n = e.length; s < n; s++)
        if (e[s] === t)
          return s;
      return -1;
    },
    forEach: function(e, t, s) {
      var n, i;
      if (Array.prototype.forEach)
        return e.forEach(t, s);
      for (n = 0, i = e.length; n < i; n++)
        t.call(s, e[n], n, e);
    },
    trim: function(e) {
      return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
    },
    trimRight: function(e) {
      return String.prototype.trimRight ? e.trimRight() : e.replace(/(\s*$)/g, "");
    }
  }), St;
}
var xt, ps;
function mr() {
  if (ps) return xt;
  ps = 1;
  var e = rn();
  function t(s, n) {
    s = e.trimRight(s), s[s.length - 1] !== ";" && (s += ";");
    var i = s.length, r = !1, o = 0, a = 0, l = "";
    function f() {
      if (!r) {
        var h = e.trim(s.slice(o, a)), d = h.indexOf(":");
        if (d !== -1) {
          var y = e.trim(h.slice(0, d)), b = e.trim(h.slice(d + 1));
          if (y) {
            var p = n(o, l.length, y, b, h);
            p && (l += p + "; ");
          }
        }
      }
      o = a + 1;
    }
    for (; a < i; a++) {
      var u = s[a];
      if (u === "/" && s[a + 1] === "*") {
        var c = s.indexOf("*/", a + 2);
        if (c === -1) break;
        a = c + 1, o = a + 1, r = !1;
      } else u === "(" ? r = !0 : u === ")" ? r = !1 : u === ";" ? r || f() : u === `
` && f();
    }
    return e.trim(l);
  }
  return xt = t, xt;
}
var Nt, gs;
function yr() {
  if (gs) return Nt;
  gs = 1;
  var e = nn(), t = mr();
  rn();
  function s(r) {
    return r == null;
  }
  function n(r) {
    var o = {};
    for (var a in r)
      o[a] = r[a];
    return o;
  }
  function i(r) {
    r = n(r || {}), r.whiteList = r.whiteList || e.whiteList, r.onAttr = r.onAttr || e.onAttr, r.onIgnoreAttr = r.onIgnoreAttr || e.onIgnoreAttr, r.safeAttrValue = r.safeAttrValue || e.safeAttrValue, this.options = r;
  }
  return i.prototype.process = function(r) {
    if (r = r || "", r = r.toString(), !r) return "";
    var o = this, a = o.options, l = a.whiteList, f = a.onAttr, u = a.onIgnoreAttr, c = a.safeAttrValue, h = t(r, function(d, y, b, p, L) {
      var v = l[b], w = !1;
      if (v === !0 ? w = v : typeof v == "function" ? w = v(p) : v instanceof RegExp && (w = v.test(p)), w !== !0 && (w = !1), p = c(b, p), !!p) {
        var P = {
          position: y,
          sourcePosition: d,
          source: L,
          isWhite: w
        };
        if (w) {
          var M = f(b, p, P);
          return s(M) ? b + ":" + p : M;
        } else {
          var M = u(b, p, P);
          if (!s(M))
            return M;
        }
      }
    });
    return h;
  }, Nt = i, Nt;
}
var ms;
function Pt() {
  return ms || (ms = 1, function(e, t) {
    var s = nn(), n = yr();
    function i(o, a) {
      var l = new n(a);
      return l.process(o);
    }
    t = e.exports = i, t.FilterCSS = n;
    for (var r in s) t[r] = s[r];
    typeof window < "u" && (window.filterCSS = e.exports);
  }(Je, Je.exports)), Je.exports;
}
var Et, ys;
function es() {
  return ys || (ys = 1, Et = {
    indexOf: function(e, t) {
      var s, n;
      if (Array.prototype.indexOf)
        return e.indexOf(t);
      for (s = 0, n = e.length; s < n; s++)
        if (e[s] === t)
          return s;
      return -1;
    },
    forEach: function(e, t, s) {
      var n, i;
      if (Array.prototype.forEach)
        return e.forEach(t, s);
      for (n = 0, i = e.length; n < i; n++)
        t.call(s, e[n], n, e);
    },
    trim: function(e) {
      return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
    },
    spaceIndex: function(e) {
      var t = /\s|\n|\t/, s = t.exec(e);
      return s ? s.index : -1;
    }
  }), Et;
}
var bs;
function on() {
  if (bs) return C;
  bs = 1;
  var e = Pt().FilterCSS, t = Pt().getDefaultWhiteList, s = es();
  function n() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
      ],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height"],
      ins: ["datetime"],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "height",
        "width"
      ]
    };
  }
  var i = new e();
  function r(m, T, g) {
  }
  function o(m, T, g) {
  }
  function a(m, T, g) {
  }
  function l(m, T, g) {
  }
  function f(m) {
    return m.replace(c, "&lt;").replace(h, "&gt;");
  }
  function u(m, T, g, E) {
    if (g = W(g), T === "href" || T === "src") {
      if (g = s.trim(g), g === "#") return "#";
      if (!(g.substr(0, 7) === "http://" || g.substr(0, 8) === "https://" || g.substr(0, 7) === "mailto:" || g.substr(0, 4) === "tel:" || g.substr(0, 11) === "data:image/" || g.substr(0, 6) === "ftp://" || g.substr(0, 2) === "./" || g.substr(0, 3) === "../" || g[0] === "#" || g[0] === "/"))
        return "";
    } else if (T === "background") {
      if (v.lastIndex = 0, v.test(g))
        return "";
    } else if (T === "style") {
      if (w.lastIndex = 0, w.test(g) || (P.lastIndex = 0, P.test(g) && (v.lastIndex = 0, v.test(g))))
        return "";
      E !== !1 && (E = E || i, g = E.process(g));
    }
    return g = K(g), g;
  }
  var c = /</g, h = />/g, d = /"/g, y = /&quot;/g, b = /&#([a-zA-Z0-9]*);?/gim, p = /&colon;?/gim, L = /&newline;?/gim, v = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, w = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, P = /u\s*r\s*l\s*\(.*/gi;
  function M(m) {
    return m.replace(d, "&quot;");
  }
  function N(m) {
    return m.replace(y, '"');
  }
  function F(m) {
    return m.replace(b, function(g, E) {
      return E[0] === "x" || E[0] === "X" ? String.fromCharCode(parseInt(E.substr(1), 16)) : String.fromCharCode(parseInt(E, 10));
    });
  }
  function J(m) {
    return m.replace(p, ":").replace(L, " ");
  }
  function pe(m) {
    for (var T = "", g = 0, E = m.length; g < E; g++)
      T += m.charCodeAt(g) < 32 ? " " : m.charAt(g);
    return s.trim(T);
  }
  function W(m) {
    return m = N(m), m = F(m), m = J(m), m = pe(m), m;
  }
  function K(m) {
    return m = M(m), m = f(m), m;
  }
  function vt() {
    return "";
  }
  function Ee(m, T) {
    typeof T != "function" && (T = function() {
    });
    var g = !Array.isArray(m);
    function E(me) {
      return g ? !0 : s.indexOf(m, me) !== -1;
    }
    var re = [], Q = !1;
    return {
      onIgnoreTag: function(me, $e, ie) {
        if (E(me))
          if (ie.isClosing) {
            var ze = "[/removed]", hr = ie.position + ze.length;
            return re.push([
              Q !== !1 ? Q : ie.position,
              hr
            ]), Q = !1, ze;
          } else
            return Q || (Q = ie.position), "[removed]";
        else
          return T(me, $e, ie);
      },
      remove: function(me) {
        var $e = "", ie = 0;
        return s.forEach(re, function(ze) {
          $e += me.slice(ie, ze[0]), ie = ze[1];
        }), $e += me.slice(ie), $e;
      }
    };
  }
  function ge(m) {
    for (var T = "", g = 0; g < m.length; ) {
      var E = m.indexOf("<!--", g);
      if (E === -1) {
        T += m.slice(g);
        break;
      }
      T += m.slice(g, E);
      var re = m.indexOf("-->", E);
      if (re === -1)
        break;
      g = re + 3;
    }
    return T;
  }
  function Ze(m) {
    var T = m.split("");
    return T = T.filter(function(g) {
      var E = g.charCodeAt(0);
      return E === 127 ? !1 : E <= 31 ? E === 10 || E === 13 : !0;
    }), T.join("");
  }
  return C.whiteList = n(), C.getDefaultWhiteList = n, C.onTag = r, C.onIgnoreTag = o, C.onTagAttr = a, C.onIgnoreTagAttr = l, C.safeAttrValue = u, C.escapeHtml = f, C.escapeQuote = M, C.unescapeQuote = N, C.escapeHtmlEntities = F, C.escapeDangerHtml5Entities = J, C.clearNonPrintableCharacter = pe, C.friendlyAttrValue = W, C.escapeAttrValue = K, C.onIgnoreTagStripAll = vt, C.StripTagBody = Ee, C.stripCommentTag = ge, C.stripBlankChar = Ze, C.cssFilter = i, C.getDefaultCSSWhiteList = t, C;
}
var Qe = {}, ws;
function an() {
  if (ws) return Qe;
  ws = 1;
  var e = es();
  function t(c) {
    var h = e.spaceIndex(c), d;
    return h === -1 ? d = c.slice(1, -1) : d = c.slice(1, h + 1), d = e.trim(d).toLowerCase(), d.slice(0, 1) === "/" && (d = d.slice(1)), d.slice(-1) === "/" && (d = d.slice(0, -1)), d;
  }
  function s(c) {
    return c.slice(0, 2) === "</";
  }
  function n(c, h, d) {
    var y = "", b = 0, p = !1, L = !1, v = 0, w = c.length, P = "", M = "";
    e: for (v = 0; v < w; v++) {
      var N = c.charAt(v);
      if (p === !1) {
        if (N === "<") {
          p = v;
          continue;
        }
      } else if (L === !1) {
        if (N === "<") {
          y += d(c.slice(b, v)), p = v, b = v;
          continue;
        }
        if (N === ">" || v === w - 1) {
          y += d(c.slice(b, p)), M = c.slice(p, v + 1), P = t(M), y += h(
            p,
            y.length,
            P,
            M,
            s(M)
          ), b = v + 1, p = !1;
          continue;
        }
        if (N === '"' || N === "'")
          for (var F = 1, J = c.charAt(v - F); J.trim() === "" || J === "="; ) {
            if (J === "=") {
              L = N;
              continue e;
            }
            J = c.charAt(v - ++F);
          }
      } else if (N === L) {
        L = !1;
        continue;
      }
    }
    return b < w && (y += d(c.substr(b))), y;
  }
  var i = /[^a-zA-Z0-9\\_:.-]/gim;
  function r(c, h) {
    var d = 0, y = 0, b = [], p = !1, L = c.length;
    function v(F, J) {
      if (F = e.trim(F), F = F.replace(i, "").toLowerCase(), !(F.length < 1)) {
        var pe = h(F, J || "");
        pe && b.push(pe);
      }
    }
    for (var w = 0; w < L; w++) {
      var P = c.charAt(w), M, N;
      if (p === !1 && P === "=") {
        p = c.slice(d, w), d = w + 1, y = c.charAt(d) === '"' || c.charAt(d) === "'" ? d : a(c, w + 1);
        continue;
      }
      if (p !== !1 && w === y) {
        if (N = c.indexOf(P, w + 1), N === -1)
          break;
        M = e.trim(c.slice(y + 1, N)), v(p, M), p = !1, w = N, d = w + 1;
        continue;
      }
      if (/\s|\n|\t/.test(P))
        if (c = c.replace(/\s|\n|\t/g, " "), p === !1)
          if (N = o(c, w), N === -1) {
            M = e.trim(c.slice(d, w)), v(M), p = !1, d = w + 1;
            continue;
          } else {
            w = N - 1;
            continue;
          }
        else if (N = l(c, w - 1), N === -1) {
          M = e.trim(c.slice(d, w)), M = u(M), v(p, M), p = !1, d = w + 1;
          continue;
        } else
          continue;
    }
    return d < c.length && (p === !1 ? v(c.slice(d)) : v(p, u(e.trim(c.slice(d))))), e.trim(b.join(" "));
  }
  function o(c, h) {
    for (; h < c.length; h++) {
      var d = c[h];
      if (d !== " ")
        return d === "=" ? h : -1;
    }
  }
  function a(c, h) {
    for (; h < c.length; h++) {
      var d = c[h];
      if (d !== " ")
        return d === "'" || d === '"' ? h : -1;
    }
  }
  function l(c, h) {
    for (; h > 0; h--) {
      var d = c[h];
      if (d !== " ")
        return d === "=" ? h : -1;
    }
  }
  function f(c) {
    return c[0] === '"' && c[c.length - 1] === '"' || c[0] === "'" && c[c.length - 1] === "'";
  }
  function u(c) {
    return f(c) ? c.substr(1, c.length - 2) : c;
  }
  return Qe.parseTag = n, Qe.parseAttr = r, Qe;
}
var _t, vs;
function br() {
  if (vs) return _t;
  vs = 1;
  var e = Pt().FilterCSS, t = on(), s = an(), n = s.parseTag, i = s.parseAttr, r = es();
  function o(c) {
    return c == null;
  }
  function a(c) {
    var h = r.spaceIndex(c);
    if (h === -1)
      return {
        html: "",
        closing: c[c.length - 2] === "/"
      };
    c = r.trim(c.slice(h + 1, -1));
    var d = c[c.length - 1] === "/";
    return d && (c = r.trim(c.slice(0, -1))), {
      html: c,
      closing: d
    };
  }
  function l(c) {
    var h = {};
    for (var d in c)
      h[d] = c[d];
    return h;
  }
  function f(c) {
    var h = {};
    for (var d in c)
      Array.isArray(c[d]) ? h[d.toLowerCase()] = c[d].map(function(y) {
        return y.toLowerCase();
      }) : h[d.toLowerCase()] = c[d];
    return h;
  }
  function u(c) {
    c = l(c || {}), c.stripIgnoreTag && (c.onIgnoreTag && console.error(
      'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
    ), c.onIgnoreTag = t.onIgnoreTagStripAll), c.whiteList || c.allowList ? c.whiteList = f(c.whiteList || c.allowList) : c.whiteList = t.whiteList, c.onTag = c.onTag || t.onTag, c.onTagAttr = c.onTagAttr || t.onTagAttr, c.onIgnoreTag = c.onIgnoreTag || t.onIgnoreTag, c.onIgnoreTagAttr = c.onIgnoreTagAttr || t.onIgnoreTagAttr, c.safeAttrValue = c.safeAttrValue || t.safeAttrValue, c.escapeHtml = c.escapeHtml || t.escapeHtml, this.options = c, c.css === !1 ? this.cssFilter = !1 : (c.css = c.css || {}, this.cssFilter = new e(c.css));
  }
  return u.prototype.process = function(c) {
    if (c = c || "", c = c.toString(), !c) return "";
    var h = this, d = h.options, y = d.whiteList, b = d.onTag, p = d.onIgnoreTag, L = d.onTagAttr, v = d.onIgnoreTagAttr, w = d.safeAttrValue, P = d.escapeHtml, M = h.cssFilter;
    d.stripBlankChar && (c = t.stripBlankChar(c)), d.allowCommentTag || (c = t.stripCommentTag(c));
    var N = !1;
    d.stripIgnoreTagBody && (N = t.StripTagBody(
      d.stripIgnoreTagBody,
      p
    ), p = N.onIgnoreTag);
    var F = n(
      c,
      function(J, pe, W, K, vt) {
        var Ee = {
          sourcePosition: J,
          position: pe,
          isClosing: vt,
          isWhite: Object.prototype.hasOwnProperty.call(y, W)
        }, ge = b(W, K, Ee);
        if (!o(ge)) return ge;
        if (Ee.isWhite) {
          if (Ee.isClosing)
            return "</" + W + ">";
          var Ze = a(K), m = y[W], T = i(Ze.html, function(g, E) {
            var re = r.indexOf(m, g) !== -1, Q = L(W, g, E, re);
            return o(Q) ? re ? (E = w(W, g, E, M), E ? g + '="' + E + '"' : g) : (Q = v(W, g, E, re), o(Q) ? void 0 : Q) : Q;
          });
          return K = "<" + W, T && (K += " " + T), Ze.closing && (K += " /"), K += ">", K;
        } else
          return ge = p(W, K, Ee), o(ge) ? P(K) : ge;
      },
      P
    );
    return N && (F = N.remove(F)), F;
  }, _t = u, _t;
}
var Ss;
function wr() {
  return Ss || (Ss = 1, function(e, t) {
    var s = on(), n = an(), i = br();
    function r(a, l) {
      var f = new i(l);
      return f.process(a);
    }
    t = e.exports = r, t.filterXSS = r, t.FilterXSS = i, function() {
      for (var a in s)
        t[a] = s[a];
      for (var l in n)
        t[l] = n[l];
    }(), typeof window < "u" && (window.filterXSS = e.exports);
    function o() {
      return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
    }
    o() && (self.filterXSS = e.exports);
  }(Ve, Ve.exports)), Ve.exports;
}
var ut = wr();
let X = {
  enableAttrs: !0,
  enableHtml: !0,
  enableUrl: !0,
  html: {
    whiteList: {
      a: ["class", "style", "contenteditable", "data-id", "data-title", "data-size", "href", "data-last-modified"],
      address: ["class", "style"],
      area: ["class", "style"],
      article: ["class", "style"],
      aside: ["class", "style"],
      audio: ["class", "style"],
      b: ["class", "style"],
      bdi: ["class", "style"],
      bdo: ["class", "style"],
      big: ["class", "style"],
      blockquote: ["class", "style"],
      br: ["class", "style"],
      caption: ["class", "style"],
      center: ["class", "style"],
      cite: ["class", "style"],
      code: ["class", "style"],
      col: ["class", "style"],
      colgroup: ["class", "style"],
      dd: ["class", "style"],
      del: ["class", "style"],
      details: ["class", "style"],
      div: [
        "class",
        "style",
        "spellcheck",
        "data-gramm",
        "spellcheck",
        "data-mode",
        "data-position",
        "data-row",
        "data-cell",
        "data-rowspan",
        "data-colspan",
        "data-cell-bg",
        "data-parent-bg"
      ],
      dl: ["class", "style"],
      dt: ["class", "style"],
      em: ["class", "style"],
      figcaption: ["class", "style"],
      figure: ["class", "style"],
      font: ["class", "style"],
      footer: ["class", "style"],
      h1: ["class", "style"],
      h2: ["class", "style"],
      h3: ["class", "style"],
      h4: ["class", "style"],
      h5: ["class", "style"],
      h6: ["class", "style"],
      header: ["class", "style"],
      hr: ["class", "style"],
      i: ["class", "style", "data-image-id", "data-image"],
      img: ["class", "style", "data-image-id", "src"],
      input: ["class", "style", "data-formula", "data-link", "data-video"],
      ins: ["class", "style"],
      li: ["class", "style"],
      mark: ["class", "style"],
      nav: ["class", "style"],
      ol: ["class", "style"],
      p: ["class", "style"],
      pre: ["class", "style"],
      s: ["class", "style"],
      section: ["class", "style"],
      small: ["class", "style"],
      span: ["class", "style", "contenteditable", "color", "style"],
      sub: ["class", "style"],
      summary: ["class", "style"],
      sup: ["class", "style"],
      strong: ["class", "style"],
      strike: ["class", "style"],
      svg: ["class", "style", "t", "viewBox", "viewbox", "version", "xmlns", "p-id", "xmlns:xlink"],
      path: ["d", "p-id"],
      table: ["class", "style"],
      tbody: ["class", "style"],
      td: ["class", "style", "data-row", "data-cell", "data-cell-bg", "data-parent-bg"],
      tfoot: ["class", "style"],
      th: ["class", "style"],
      thead: ["class", "style"],
      tr: ["class", "style", "data-row"],
      tt: ["class", "style"],
      u: ["class", "style"],
      ul: ["class", "style"],
      video: ["class", "style"]
    }
  }
};
const vr = ut.getDefaultWhiteList && ut.getDefaultWhiteList() || {};
X.html.whiteList = Object.assign(vr, X.html.whiteList);
let ln = new ut.FilterXSS(X.html);
const Sr = () => X, xr = (e) => {
  var s;
  let t;
  (s = e == null ? void 0 : e.html) != null && s.whiteList && (t = Object.assign(X.html.whiteList, e.html.whiteList)), X = Object.assign(X, e), t && (X.html.whiteList = t), ln = new ut.FilterXSS(X.html);
};
let cn = (e) => !X.enableHtml || typeof e != "string" ? e : ln.process(e);
const Nr = (e) => {
  cn = e;
};
let fn = (e) => !X.enableAttrs || typeof e != "string" ? e : e.replace(/<.*?>/gi, "").replace(/on[a-z]+=/gi, "");
const Er = (e) => {
  fn = e;
};
let un = (e) => {
  if (!X.enableUrl || typeof e != "string")
    return e;
  const t = e.replace(/&#(\w+)(^\w|;)?/g, (n, i) => String.fromCharCode(i)).replace(/[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, "").trim();
  if (!t)
    return "";
  if ([".", "/"].includes(t[0]))
    return t;
  const s = t.match(/^([^:]+):/gm);
  return s && /^([^\w]*)(javascript|data|vbscript)/im.test(s[0]) ? "" : t;
};
const _r = (e) => {
  un = e;
}, Ar = {
  getXssOption: Sr,
  setXssOption: xr,
  filterHtml: cn,
  setFilterHtml: Nr,
  filterAttrs: fn,
  setFilterAttrs: Er,
  filterUrl: un,
  setFilterUrl: _r
}, Mr = globalThis, $t = Mr.console, dn = Object.prototype.toString, A = Object.prototype.hasOwnProperty, Tr = Object.getPrototypeOf, hn = A.toString, Dr = hn.call(Object), Cr = {
  "[object Error]": "error",
  "[object Object]": "object",
  "[object RegExp]": "regExp",
  "[object Date]": "date",
  "[object Array]": "array",
  "[object Function]": "function",
  "[object AsyncFunction]": "asyncFunction",
  "[object String]": "string",
  "[object Number]": "number",
  "[object Boolean]": "boolean"
}, V = (e) => e == null, B = (e) => V(e) ? String(e) : Cr[dn.call(e)] || "object", xe = (e) => B(e) === "object", zt = (e) => ["asyncFunction", "function"].includes(B(e)), ee = (e) => {
  if (!e || dn.call(e) !== "[object Object]")
    return !1;
  const t = Tr(e);
  if (!t)
    return !0;
  const s = A.call(t, "constructor") && t.constructor;
  return typeof s == "function" && hn.call(s) === Dr;
}, gl = (e) => {
  const t = B(e);
  if (t === "object" || t === "array") {
    for (const s in e)
      if (A.call(e, s))
        return !1;
  }
  return !0;
}, z = (e) => typeof e == "number" && isFinite(e), Te = (e) => e - parseFloat(e) >= 0, Le = (e) => B(e) === "date", pn = (e, t) => e === t || typeof e == "number" && typeof t == "number" && isNaN(e) && isNaN(t), ml = (e) => B(e) === "regExp", Or = (e) => xe(e) && zt(e.then) && zt(e.catch), ts = {
  viewportWindow: null
  // 获取真实视口的window，解决在微前端中某些bug
}, yl = () => ts.viewportWindow || window, S = typeof window > "u", Fr = () => {
  let e = 8;
  return document.addEventListener && window.performance && (e = 9, window.atob && window.matchMedia && (e = 10, !window.attachEvent && !document.all && (e = 11))), e;
}, kr = (e) => {
  e.chrome && ~navigator.userAgent.indexOf("Edg") ? (e.name = "edge", e.edge = !0, delete e.chrome) : !document.documentMode && window.StyleMedia && (e.name = "edge", e.edge = !0);
}, bl = (() => {
  if (S) return null;
  const e = {
    name: "",
    version: 0,
    isDoc: typeof document < "u",
    isMobile: !1,
    isPC: !0,
    isNode: S,
    chrome: !1,
    ie: !1,
    firefox: !1,
    safari: !1,
    opera: !1,
    edge: !1
  }, t = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
  e.isMobile = t, e.isPC = !t;
  let s;
  if (window.chrome && (window.chrome.webstore || /^Google\b/.test(window.navigator.vendor)) ? (e.name = "chrome", e.chrome = !0, s = navigator.userAgent.match(/chrome\/(\d+)/i), e.version = !!s && !!s[1] && parseInt(s[1], 10), s = void 0) : document.all || document.documentMode ? (e.name = "ie", e.version = Fr(), e.ie = !0) : typeof window.InstallTrigger < "u" ? (e.name = "firefox", e.firefox = !0) : Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0 ? (e.name = "safari", e.safari = !0) : (window.opr && window.opr.addons || window.opera) && (e.name = "opera", e.opera = !0), kr(e), !~["ie", "chrome"].indexOf(e.name)) {
    const n = e.name + "/(\\d+)";
    s = navigator.userAgent.match(new RegExp(n, "i")), e.version = !!s && !!s[1] && parseInt(s[1], 10), s = void 0;
  }
  if (e.isDoc) {
    const n = document.body || document.documentElement;
    ["webkit", "khtml", "moz", "ms", "o"].forEach((i) => {
      e["-" + i] = !!n[i + "MatchesSelector"];
    });
  }
  return e;
})(), Rr = /([:\-_]+(.))/g, Ir = /^moz([A-Z])/, gn = (e) => e.replace(
  Rr,
  (t, s, n, i) => i ? n.toUpperCase() : n
).replace(Ir, "Moz$1"), Z = (e, t, s, n = !1) => {
  e && t && s && e.addEventListener(t, s, n);
}, ne = (e, t, s, n = !1) => {
  e && t && e.removeEventListener(t, s, n);
}, wl = (e, t, s) => {
  const n = function(i) {
    s && s.call(this, i), ne(e, t, n);
  };
  Z(e, t, n);
}, vl = (e, t) => {
  if (!e || !t)
    return !1;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e.classList ? e.classList.contains(t) : !1;
}, et = (e, t = "") => {
  if (!e)
    return;
  t.split(" ").filter((n) => n).forEach((n) => e.classList.add(n));
}, tt = (e, t) => {
  if (!e || !t)
    return;
  t.split(" ").filter((n) => n).forEach((n) => e.classList.remove(n));
}, At = (e, t) => {
  if (!S) {
    if (!e || !t)
      return null;
    t = gn(t), t === "float" && (t = "cssFloat");
    try {
      if (e.style[t])
        return e.style[t];
      const s = window.getComputedStyle(e);
      return s ? s[t] : null;
    } catch {
      return e.style[t];
    }
  }
}, Lr = (e, t, s) => {
  if (!(!e || !t))
    if (typeof t == "object")
      for (const n in t)
        A.call(t, n) && Lr(e, n, t[n]);
    else
      t = gn(t), e.style[t] = s;
}, Pr = (e, t) => {
  if (S)
    return;
  const s = !V(t);
  let n;
  return s ? n = t ? At(e, "overflow-y") : At(e, "overflow-x") : n = At(e, "overflow"), n ? n.match(/(scroll|auto)/) : null;
}, Sl = (e, t) => {
  if (S)
    return;
  let s = e;
  for (; s; ) {
    if (~[window, document, document.documentElement].indexOf(s))
      return window;
    if (Pr(s, t))
      return s;
    s = s.parentNode;
  }
  return s;
}, xl = (e, t) => {
  if (S || !e || !t)
    return !1;
  const s = e.getBoundingClientRect();
  let n;
  return ~[window, document, document.documentElement].indexOf(t) || V(t) ? n = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  } : n = t.getBoundingClientRect(), s.top < n.bottom && s.bottom > n.top && s.right > n.left && s.left < n.right;
}, Nl = () => {
  const e = ts.viewportWindow || window;
  let t = e.document.documentElement, s = e.document.body;
  return {
    scrollTop: t.scrollTop || s.scrollTop,
    scrollLeft: t.scrollLeft || s.scrollLeft,
    visibleHeight: t.clientHeight || s.clientHeight,
    visibleWidth: t.clientWidth || s.clientWidth
  };
}, El = (e) => {
  const t = "scrollTop" in e ? e.scrollTop : e.pageYOffset;
  return Math.max(t, 0);
}, $r = (e) => e.stopPropagation(), _l = (e, t) => {
  (typeof e.cancelable != "boolean" || e.cancelable) && e.preventDefault(), t && $r(e);
}, zr = /scroll|auto|overlay/i, mn = S ? void 0 : window, qr = (e) => {
  const t = e;
  return t.tagName !== "HTML" && t.tagName !== "BODY" && e.nodeType === 1;
}, Hr = (e, t = mn) => {
  let s = e;
  for (; s && s !== t && qr(s); ) {
    const { overflowY: n } = window.getComputedStyle(s);
    if (zr.test(n))
      return s;
    s = s.parentNode;
  }
  return t || null;
}, Al = ({ onMounted: e, ref: t, watch: s }) => (n, i = mn) => {
  const r = t(), o = () => {
    r.value = n.value ? Hr(n.value, i) : null;
  };
  return s(n, o), e(() => n.value && o()), r;
}, yn = (e) => {
  if (S) return !1;
  if (e) {
    const t = getComputedStyle(e);
    if (t.getPropertyValue("position") === "fixed") {
      if (t.getPropertyValue("display") === "none")
        return !0;
      if (e.parentNode !== document.body)
        return yn(e.parentNode);
    } else
      return e.offsetParent === null;
  }
  return !1;
}, bn = function() {
  if (typeof Map < "u")
    return Map;
  const e = (t, s) => {
    let n = -1;
    return t.some((i, r) => i[0] === s ? (n = r, !0) : !1), n;
  };
  return function() {
    function t() {
      this.__entries__ = [];
    }
    return Object.defineProperty(t.prototype, "size", {
      get() {
        return this.__entries__.length;
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.get = function(s) {
      const n = e(this.__entries__, s), i = this.__entries__[n];
      return i && i[1];
    }, t.prototype.set = function(s, n) {
      const i = e(this.__entries__, s);
      ~i ? this.__entries__[i][1] = n : this.__entries__.push([s, n]);
    }, t.prototype.delete = function(s) {
      const n = this.__entries__, i = e(n, s);
      ~i && n.splice(i, 1);
    }, t.prototype.clear = function() {
      this.__entries__.splice(0);
    }, t.prototype.has = function(s) {
      return !!~e(this.__entries__, s);
    }, t.prototype.forEach = function(s, n) {
      n === void 0 && (n = null);
      for (let i = 0, r = this.__entries__; i < r.length; i++) {
        const o = r[i];
        s.call(n, o[1], o[0]);
      }
    }, t;
  }();
}(), jr = globalThis.Function, dt = function() {
  const e = (t) => t.Math === Math;
  return typeof global < "u" && e(global) ? global : typeof self < "u" && e(self) ? self : typeof window < "u" && e(window) ? window : jr("return this")();
}(), Br = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(dt) : function(e) {
    return setTimeout(() => e(Date.now()), 1e3 / 60);
  };
}();
let Wr = 2;
function Kr(e, t) {
  let s = !1, n = !1, i = 0, r;
  const o = () => {
    s && (s = !1, e()), n && r();
  }, a = () => {
    Br(o);
  };
  return r = () => {
    const l = Date.now();
    if (s) {
      if (l - i < Wr)
        return;
      n = !0;
    } else
      s = !0, n = !1, setTimeout(a, t);
    i = l;
  }, r;
}
const Yr = 20, Ur = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], Xr = typeof MutationObserver < "u", Gr = function() {
  function e() {
    this.observers_ = [], this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = Kr(this.refresh.bind(this), Yr);
  }
  return e.prototype.addObserver = function(t) {
    !~this.observers_.indexOf(t) && this.observers_.push(t), !this.connected_ && this.connect_();
  }, e.prototype.removeObserver = function(t) {
    const s = this.observers_, n = s.indexOf(t);
    ~n && s.splice(n, 1), !s.length && this.connected_ && this.disconnect_();
  }, e.prototype.refresh = function() {
    this.updateObservers_() && this.refresh();
  }, e.prototype.updateObservers_ = function() {
    const t = this.observers_.filter((s) => (s.gatherActive(), s.hasActive()));
    return t.forEach((s) => s.broadcastActive()), t.length > 0;
  }, e.prototype.connect_ = function() {
    if (!(S || this.connected_)) {
      if (Z(document, "transitionend", this.onTransitionEnd_), Z(window, "resize", this.refresh), Xr) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        const t = {
          attributes: !0,
          childList: !0,
          characterData: !0,
          subtree: !0
        };
        this.mutationsObserver_.observe(document, t);
      } else
        Z(document, "DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0;
      this.connected_ = !0;
    }
  }, e.prototype.disconnect_ = function() {
    S || !this.connected_ || (ne(document, "transitionend", this.onTransitionEnd_), ne(window, "resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && ne(document, "DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
  }, e.prototype.onTransitionEnd_ = function(t) {
    const s = t.propertyName, n = s === void 0 ? "" : s;
    Ur.some((r) => !!~n.indexOf(r)) && this.refresh();
  }, e.getInstance = function() {
    return this._instance || (this._instance = new e()), this._instance;
  }, e._instance = null, e;
}(), wn = function(e, t) {
  for (let s = 0, n = Object.keys(t); s < n.length; s++) {
    const i = n[s];
    Object.defineProperty(e, i, {
      value: t[i],
      configurable: !0,
      writable: !1,
      enumerable: !1
    });
  }
  return e;
}, bt = function(e, t, s, n) {
  return { x: e, y: t, width: s, height: n };
}, Fe = function(e) {
  return e && e.ownerDocument && e.ownerDocument.defaultView || dt;
}, vn = bt(0, 0, 0, 0), ht = (e) => parseFloat(e) || 0, xs = function(e) {
  let t = [];
  for (let s = 1; s < arguments.length; s++)
    t[s - 1] = arguments[s];
  return t.reduce((s, n) => {
    const i = e[`border-${n}-width`];
    return s + ht(i);
  }, 0);
}, Zr = function(e) {
  const t = ["top", "right", "bottom", "left"];
  let s = {};
  for (let n = 0, i = t; n < i.length; n++) {
    const r = i[n], o = e[`padding-${r}`];
    s[r] = ht(o);
  }
  return s;
}, Vr = function(e) {
  const t = e.getBBox();
  return bt(0, 0, t.width, t.height);
}, Jr = function(e) {
  return e === Fe(e).document.documentElement;
}, Qr = function(e) {
  const t = e.clientWidth, s = e.clientHeight;
  if (!s && !t)
    return vn;
  const n = Fe(e).getComputedStyle(e), i = Zr(n), r = i.top + i.bottom, o = i.left + i.right;
  let a = ht(n.width), l = ht(n.height);
  if (n.boxSizing === "border-box" && (Math.round(l + r) !== s && (l -= xs(n, "top", "bottom") + r), Math.round(a + o) !== t && (a -= xs(n, "left", "right") + o)), !Jr(e)) {
    const f = Math.round(l + r) - s, u = Math.round(a + o) - t;
    Math.abs(f) !== 1 && (l -= f), Math.abs(u) !== 1 && (a -= u);
  }
  return bt(i.left, i.top, a, l);
}, ei = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? (e) => e instanceof Fe(e).SVGGraphicsElement : (e) => e instanceof Fe(e).SVGElement && typeof e.getBBox == "function";
}(), ti = function(e) {
  return S ? vn : ei(e) ? Vr(e) : Qr(e);
}, si = function(e) {
  const t = e.x, s = e.y, n = e.width, i = e.height, o = Object.create((typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object).prototype);
  return wn(o, {
    x: t,
    y: s,
    width: n,
    height: i,
    top: s,
    right: t + n,
    bottom: i + s,
    left: t
  }), o;
}, ni = function() {
  function e(t) {
    this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = bt(0, 0, 0, 0), this.target = t;
  }
  return e.prototype.broadcastRect = function() {
    const t = this.contentRect_;
    return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
  }, e.prototype.isActive = function() {
    const t = ti(this.target);
    return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
  }, e;
}(), ri = /* @__PURE__ */ function() {
  function e(t, s) {
    const n = si(s);
    wn(this, { target: t, contentRect: n });
  }
  return e;
}(), ii = function() {
  function e(t, s, n) {
    if (this.observations_ = new bn(), this.activeObservations_ = [], typeof t != "function")
      throw new TypeError("[TINY-Resize] The callback provided as parameter 1 is not a function.");
    this.callback_ = t, this.controller_ = s, this.callbackCtx_ = n;
  }
  return e.prototype.observe = function(t) {
    if (!arguments.length)
      throw new TypeError("[TINY-Resize] 1 argument required, but only 0 present.");
    if (typeof Element > "u" || !(Element instanceof Object))
      return;
    if (!(t instanceof Fe(t).Element))
      throw new TypeError('[TINY-Resize] parameter 1 is not of type "Element".');
    const s = this.observations_;
    s.has(t) || (s.set(t, new ni(t)), this.controller_.addObserver(this), this.controller_.refresh());
  }, e.prototype.unobserve = function(t) {
    if (!arguments.length)
      throw new TypeError("[TINY-Resize]1 argument required, but only 0 present.");
    if (typeof Element > "u" || !(Element instanceof Object))
      return;
    if (!(t instanceof Fe(t).Element))
      throw new TypeError('[TINY-Resize] parameter 1 is not of type "Element".');
    const s = this.observations_;
    s.has(t) && (s.delete(t), !s.size && this.controller_.removeObserver(this));
  }, e.prototype.gatherActive = function() {
    const t = this;
    this.clearActive(), this.observations_.forEach((s) => {
      s.isActive() && t.activeObservations_.push(s);
    });
  }, e.prototype.disconnect = function() {
    this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
  }, e.prototype.broadcastActive = function() {
    if (!this.hasActive())
      return;
    const t = this.callbackCtx_, s = this.activeObservations_.map(
      (n) => new ri(n.target, n.broadcastRect())
    );
    this.callback_.call(t, s, t), this.clearActive();
  }, e.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  }, e.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  }, e;
}(), Sn = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new bn(), xn = /* @__PURE__ */ function() {
  function e(t) {
    if (!(this instanceof e))
      throw new TypeError("[TINY-Resize] Cannot call a class as a function.");
    if (!arguments.length)
      throw new TypeError("[TINY-Resize] 1 argument required, but only 0 present.");
    const s = Gr.getInstance(), n = new ii(t, s, this);
    Sn.set(this, n);
  }
  return e;
}();
["observe", "unobserve", "disconnect"].forEach((e) => {
  xn.prototype[e] = function() {
    let t;
    return (t = Sn.get(this))[e].apply(t, arguments);
  };
});
const oi = function() {
  return typeof dt.ResizeObserver < "u" ? dt.ResizeObserver : xn;
}(), ai = globalThis, li = "tcirzywvqlkjhgfbZQG_FLOWHSUBDNIMYREVKCAJxp57XP043891T62-modnaesu", Nn = li.split("").reverse().join("");
let fe, ue;
const ci = (e) => new Uint8Array(new ArrayBuffer(e)), Ns = (e) => ai.crypto.getRandomValues(e), En = (e) => {
  !fe || fe.length < e ? (fe = ci(e * 128), Ns(fe), ue = 0) : ue + e > fe.length && (Ns(fe), ue = 0), ue += e;
}, fi = (e = 21) => {
  En(e -= 0);
  let t = "";
  for (let s = ue - e; s < ue; s++)
    t += Nn[fe[s] & 63];
  return t;
}, ui = (e) => (En(e -= 0), fe.subarray(ue - e, ue)), di = (e, t, s) => {
  const n = (2 << 31 - Math.clz32(e.length - 1 | 1)) - 1, i = Math.ceil(1.6 * n * t / e.length);
  return (r = t) => {
    let o = "";
    for (; ; ) {
      const a = s(i);
      let l = i;
      for (; l--; )
        if (o += e[a[l] & n] || "", o.length === r) return o;
    }
  };
}, hi = (e, t = 21) => di(e, t, ui);
function pi(e) {
  return !S && (e.document.all || e.document.documentMode) && !e.crypto && e.msCrypto;
}
function gi(e) {
  if (pi(e)) {
    e.crypto = e.msCrypto;
    const t = e.crypto.getRandomValues;
    e.crypto.getRandomValues = function(s) {
      const n = t.call(e.crypto, s), i = [];
      for (let r = 0; r < s.length; r++)
        i[r] = n[r];
      return i;
    };
  }
}
const qt = globalThis;
gi(qt);
const mi = 4294967296, yi = Nn, bi = fi, wi = hi, vi = () => S ? 0 : qt.crypto.getRandomValues(new qt.Uint32Array(1))[0] / mi, Es = {
  urlAlphabet: yi,
  nanoid: bi,
  customAlphabet: wi
}, Ml = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  api: Es,
  default: Es,
  random: vi
}, Symbol.toStringTag, { value: "Module" }));
async function Tl(e) {
  const s = Object.prototype.toString.call(e) === "[object ArrayBuffer]" ? e : new TextEncoder().encode(e), n = await globalThis.crypto.subtle.digest("SHA-256", s);
  return Array.from(new Uint8Array(n)).map((o) => o.toString(16).padStart(2, "0")).join("");
}
const _s = (e, t) => {
  if (typeof t == "function") {
    for (const s in e)
      if (A.call(e, s) && t(s, e[s]) === !1)
        break;
  }
};
let ke;
const De = (e, t, s) => {
  if (!e || !ee(e) || !t || typeof t != "string")
    return;
  const n = t.split(".");
  let i = e;
  const r = n.length;
  if (r > 1) {
    const o = s ? 1 : 0;
    for (let a = o; a < r; a++)
      if (i = i[n[a]], V(i))
        return i;
    return i;
  } else
    return i[n[0]];
}, As = (e, t, s, n) => {
  if (!e || !ee(e) || !t || typeof t != "string")
    return e;
  const i = t.split("."), r = e;
  let o = i.length, a = i[0];
  if (o > 1) {
    o--;
    let l = r, f, u;
    for (let c = 0; c < o; c++)
      f = i[c], u = l[f], (u === null || !ee(u)) && (l[f] = {}, u = l[f]), l = u;
    a = i[o], n && ee(l[a]) ? ke(!0, l[a], s) : l[a] = s;
  } else
    n && ee(r[a]) ? ke(!0, r[a], s) : r[a] = s;
  return r;
}, Ht = (e, t, s, n) => {
  const i = (o, a, l, f, u) => {
    const c = f.indexOf(l) === 0, h = f.split(l), d = h[1] && h[1].indexOf(".") === 0;
    l === f || c && d ? l !== f && _s(De(o, l), (y) => (i(o, a, `${l}.${y}`, f), !0)) : t && !t.includes(l) && As(a, l, De(o, l), u);
  }, r = (o, a, l, f) => {
    const u = {};
    return f ? _s(o, (c) => a.forEach((h) => i(o, u, c, h, l))) : a.forEach((c) => As(u, c, De(o, c), l)), u;
  };
  return ee(e) ? Array.isArray(t) ? r(e, t, s, n) : ke(s !== !1, {}, e) : e;
}, Si = (e) => Array.isArray(e) ? e.map((t) => Ht(t)) : e, xi = (e, t, s, n, i) => {
  let r;
  if (s && n && (ee(n) || (r = Array.isArray(n))))
    if (r)
      r = !1, e[t] = Si(n);
    else {
      const o = i && ee(i) ? i : {};
      e[t] = ke(s, o, n);
    }
  else if (n !== void 0)
    try {
      e[t] = n;
    } catch {
    }
};
ke = function(...e) {
  const t = e.length;
  let s = e[0] || {}, n = 1, i = !1;
  for (B(s) === "boolean" && (i = s, s = e[n] || {}, n++), !xe(s) && B(s) !== "function" && (s = {}); n < t; n++) {
    const r = e[n];
    if (r !== null && xe(r)) {
      const o = Object.keys(r);
      for (const a of o) {
        const l = s[a], f = r[a];
        s !== f && xi(s, a, i, f, l);
      }
    }
  }
  return s;
};
let pt;
const _n = (e, t, s, n) => {
  if (B(e) === B(t)) {
    if (s = s !== !1, Array.isArray(n)) {
      const o = Ht(e, n), a = Ht(t, n);
      return _n(o, a, s);
    }
    const i = pt(e, t, s), r = pt(t, e, s);
    return i && r;
  }
  return !1;
};
pt = (e, t, s) => {
  if (!ee(e)) {
    if (!Array.isArray(e))
      return e === t;
    if (e.length !== t.length)
      return !1;
    for (let r = 0, o = e.length; r < o; r++)
      if (!_n(e[r], t[r], s))
        return !1;
    return !0;
  }
  let n = !0;
  const i = Object.keys(e);
  for (const r of i) {
    if (A.call(t, r)) {
      const o = e[r], a = t[r];
      s && xe(o) || Array.isArray(o) ? n = pt(o, a, s) : n = o === a;
    } else
      n = !1;
    if (n === !1)
      break;
  }
  return n;
};
const Ni = (e) => {
  try {
    return JSON.stringify(e);
  } catch {
    return;
  }
}, Ms = function(e, ...t) {
  for (let s = 0, n = t.length; s < n; s++) {
    const i = t[s] || {};
    for (const r in i)
      if (A.call(i, r)) {
        const o = i[r];
        o !== void 0 && (e[r] = o);
      }
  }
  return e;
};
function jt() {
  return typeof BigInt == "function";
}
function Ke(e) {
  let t = e.toString().trim(), s = t.startsWith("-");
  s && (t = t.slice(1)), t = t.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), t.startsWith(".") && (t = "0".concat(t));
  let n = t || "0", i = n.split("."), r = i[0] || "0", o = i[1] || "0";
  r === "0" && o === "0" && (s = !1);
  let a = s ? "-" : "";
  return {
    negative: s,
    negativeStr: a,
    trimStr: n,
    integerStr: r,
    decimalStr: o,
    fullStr: "".concat(a).concat(n)
  };
}
function ss(e) {
  let t = String(e);
  return !isNaN(Number(t)) && t.includes("e");
}
function An(e) {
  return typeof e == "number" ? !isNaN(e) : e ? (
    // 普通数字格式: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(e) || // 前置数字: 1.
    /^\s*-?\d+\.\s*$/.test(e) || // 后置数字: .1
    /^\s*-?\.\d+\s*$/.test(e)
  ) : !1;
}
function Bt(e) {
  let t = String(e);
  if (ss(e)) {
    let s = Number(t.slice(t.indexOf("e-") + 2)), n = t.match(/\.(\d+)/);
    return n != null && n[1] && (s += n[1].length), s;
  }
  return t.includes(".") && An(t) ? t.length - t.indexOf(".") - 1 : 0;
}
function Mn(e) {
  let t = String(e);
  if (ss(e)) {
    if (typeof e == "number" && e > Number.MAX_SAFE_INTEGER)
      return String(jt() ? BigInt(e).toString() : Number.MAX_SAFE_INTEGER);
    if (typeof e == "number" && e < Number.MIN_SAFE_INTEGER)
      return String(jt() ? BigInt(e).toString() : Number.MIN_SAFE_INTEGER);
    typeof e == "number" && (t = e.toFixed(Bt(t)));
  }
  return Ke(t).fullStr;
}
function Ei(e) {
  return e.add || Object.assign(e, {
    add: e.plus,
    lessEquals: e.isLessThan,
    equals: e.isEqualTo
  }), e;
}
const Wt = {
  CLS: null
};
function Ne(e, t) {
  return Wt.CLS || _i(t), Ei(new Wt.CLS(e));
}
class Ye {
  /**
   * 构造函数
   * @param {string | number} value 数值
   */
  constructor(t) {
    /** 是否为空 */
    x(this, "empty");
    /** 原始值 */
    x(this, "origin");
    /** 是否为负数 */
    x(this, "negative");
    /** 整数部分 */
    x(this, "integer");
    /** 小数部分 */
    x(this, "decimal");
    /** 小数长度 */
    x(this, "decimalLen");
    /** 是否为NaN */
    x(this, "nan");
    if (!t && t !== 0 || !String(t).trim()) {
      this.empty = !0, this.origin = String(t || "");
      return;
    }
    if (this.origin = String(t), this.negative = void 0, this.integer = void 0, this.decimal = void 0, this.decimalLen = void 0, this.empty = void 0, this.nan = void 0, t === "-") {
      this.nan = !0;
      return;
    }
    let s = ss(t) ? Number(t) : t;
    typeof s != "string" && Mn(s);
    const n = Function, i = (r) => {
      const o = r.replace(/^0+/, "") || "0";
      return n(`return BigInt(${o})`)();
    };
    if (An(s)) {
      const r = Ke(s);
      this.negative = r.negative;
      const o = r.trimStr.split(".");
      this.integer = o[0].includes("e") ? o[0] : BigInt(o[0]);
      const a = o[1] || "0";
      this.decimal = a.includes("e") ? i(a) : BigInt(a), this.decimalLen = a.length;
    } else
      this.nan = !0;
  }
  /**
   * 获取小数部分字符串
   * @returns {string} 小数部分字符串
   */
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * 获取整数部分字符串
   * @returns {string} 整数部分字符串
   */
  getIntegerStr() {
    return this.integer.toString();
  }
  /**
   * 获取数字符号
   * @returns {string} 负号或空字符串
   */
  getMark() {
    return this.negative ? "-" : "";
  }
  /**
   * 对齐小数位，例如：12.3 + 5 = 1230000
   * 这仅用于add函数
   * @param {number} decimalLength 小数长度
   * @returns {bigint} 对齐后的BigInt
   */
  alignDecimal(t) {
    const s = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(t, "0")}`;
    return BigInt(s);
  }
  /**
   * 加法操作
   * @param {string | number} value 要添加的值
   * @returns {BigIntDecimal} 计算结果
   */
  add(t) {
    if (this.isInvalidate())
      return new Ye(t);
    const s = new Ye(t);
    if (s.isInvalidate())
      return this;
    const n = Math.max(this.getDecimalStr().length, s.getDecimalStr().length), i = s.alignDecimal(n), o = `${this.alignDecimal(n) + i}`, { negativeStr: a, trimStr: l } = Ke(o), f = `${a}${l.padStart(n + 1, "0")}`;
    return Ne(
      `${f.slice(0, -n)}.${f.slice(-n)}`,
      void 0
    );
  }
  /**
   * 取反操作
   * @returns {BigIntDecimal} 取反后的值
   */
  negate() {
    const t = new Ye(this.toString());
    return t.negative = !t.negative, t;
  }
  /**
   * 检查是否为NaN
   * @returns {boolean} 是否为NaN
   */
  isNaN() {
    return this.nan === !0;
  }
  /**
   * 检查是否为空
   * @returns {boolean} 是否为空
   */
  isEmpty() {
    return this.empty === !0;
  }
  /**
   * 检查是否无效
   * @returns {boolean} 是否无效
   */
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  /**
   * 小于等于比较
   * @param {BigIntDecimal} target 比较目标
   * @returns {boolean} 是否小于等于
   */
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  /**
   * 相等比较
   * @param {BigIntDecimal | null | undefined} target 比较目标
   * @returns {boolean} 是否相等
   */
  equals(t) {
    return this.toString() === (t && t.toString());
  }
  /**
   * 转换为数字
   * @returns {number} 数字值
   */
  toNumber() {
    return this.isNaN() ? NaN : Number(this.toString());
  }
  /**
   * 转换为字符串
   * @param {boolean} safe 是否安全转换，默认为true
   * @returns {string} 字符串表示
   */
  toString(t = !0) {
    return t ? this.isInvalidate() ? "" : Ke(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr : this.origin;
  }
}
class we {
  /**
   * 构造函数
   * @param {string | number} value 数值
   */
  constructor(t = "") {
    /** 是否为空 */
    x(this, "empty");
    /** 原始值 */
    x(this, "origin", "");
    /** 数字值 */
    x(this, "number");
    if (!t && t !== 0 || !String(t).trim()) {
      this.empty = !0;
      return;
    }
    this.origin = String(t), this.number = Number(t);
  }
  /**
   * 取反操作
   * @returns {NumberDecimal} 取反后的值
   */
  negate() {
    return new we(String(-this.toNumber()));
  }
  /**
   * 加法操作
   * @param {string | number} value 要添加的值
   * @returns {NumberDecimal} 计算结果
   */
  add(t) {
    if (this.isInvalidate())
      return new we(t);
    const s = Number(t);
    if (isNaN(s))
      return this;
    const n = this.number + s;
    if (n < Number.MIN_SAFE_INTEGER)
      return new we(String(Number.MIN_SAFE_INTEGER));
    if (n > Number.MAX_SAFE_INTEGER)
      return new we(String(Number.MAX_SAFE_INTEGER));
    const i = Math.max(Bt(s), Bt(this.number));
    return new we(n.toFixed(i));
  }
  /**
   * 检查是否为NaN
   * @returns {boolean} 是否为NaN
   */
  isNaN() {
    return isNaN(this.number);
  }
  /**
   * 检查是否为空
   * @returns {boolean} 是否为空
   */
  isEmpty() {
    return this.empty === !0;
  }
  /**
   * 检查是否无效
   * @returns {boolean} 是否无效
   */
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  /**
   * 相等比较
   * @param {NumberDecimal | null | undefined} target 比较目标
   * @returns {boolean} 是否相等
   */
  equals(t) {
    return this.toNumber() === (t && t.toNumber());
  }
  /**
   * 小于等于比较
   * @param {NumberDecimal} target 比较目标
   * @returns {boolean} 是否小于等于
   */
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  /**
   * 转换为数字
   * @returns {number} 数字值
   */
  toNumber() {
    return this.number;
  }
  /**
   * 转换为字符串
   * @param {boolean} safe 是否安全转换，默认为true
   * @returns {string} 字符串表示
   */
  toString(t = !0) {
    return t ? this.isInvalidate() ? "" : Mn(this.number) : this.origin;
  }
}
const _i = function(e) {
  Wt.CLS = jt() ? Ye : typeof e == "function" ? e : we;
};
function Dl(e, t) {
  return Ne(e, void 0).lessEquals(Ne(t, void 0));
}
function Cl(e, t) {
  return Ne(e, void 0).equals(Ne(t, void 0));
}
function Tn(e, t, s = 5) {
  if (e === "")
    return "";
  const n = ".", { negativeStr: i, integerStr: r, decimalStr: o } = Ke(e), a = `${n}${o}`, l = `${i}${r}`;
  if (t >= 0) {
    const f = Number(o[t]);
    if (f >= s && s !== 0) {
      const c = Ne(`${r}${n}${o}`, void 0).add(
        `0.${Ut("", t, !0)}${10 - f}`
      );
      return Tn(i + c.toString(), t, 0);
    }
    return t === 0 ? l : `${l}${n}${Ut(o || "0", t, !0).slice(0, t)}`;
  }
  return a === ".0" ? l : `${l}${a}`;
}
const Kt = ".", Ai = (e) => {
  const t = e.split(Kt), s = t[0], n = t[1];
  let i, r;
  if (n)
    i = parseInt(e.split(Kt).join(""), 10), r = n.length * -1;
  else {
    const o = s.match(/0+$/);
    if (o) {
      const a = o[0].length;
      i = s.substr(0, s.length - a), r = a;
    } else
      i = s, r = 0;
  }
  return { value: i, exp: r };
}, Dn = (e) => {
  let t;
  return e <= 0 ? t = "" : t = "0".repeat(e), t;
}, Mi = (e, t) => {
  t = Math.abs(t);
  const s = t - e.length;
  let n = Kt;
  s >= 0 && (e = Dn(s) + e, n = "0.");
  const i = e.length, r = i - t, o = e.substr(0, r), a = e.substring(r, i);
  return o + n + a;
}, Ti = (e, t) => String(e + Dn(t)), Mt = (e, t) => (t >= 0 ? Ti : Mi)(String(e), t);
function O(e) {
  return !this || !(this instanceof O) ? new O(e) : e instanceof O ? e : (this.internal = String(e), this.asInt = Ai(this.internal), this.add = (t) => {
    const s = [this, new O(t)];
    s.sort((a, l) => a.asInt.exp - l.asInt.exp);
    const n = s[0].asInt.exp, i = s[1].asInt.exp, r = Number(Mt(s[1].asInt.value, i - n)), o = Number(s[0].asInt.value);
    return new O(Mt(String(r + o), n));
  }, this.sub = (t) => new O(this.add(t * -1)), this.mul = (t) => {
    t = new O(t);
    const s = String(this.asInt.value * t.asInt.value), n = this.asInt.exp + t.asInt.exp;
    return new O(Mt(s, n));
  }, this.div = (t) => {
    t = new O(t);
    const s = Math.min(this.asInt.exp, t.asInt.exp), n = 10 ** Math.abs(s), i = O.mul(n, this), r = O.mul(n, t);
    return new O(i.toNumber() / r.toNumber());
  }, this.toString = () => this.internal, this.toNumber = () => Number(this.internal), this);
}
O.add = (e, t) => new O(e).add(t);
O.mul = (e, t) => new O(e).mul(t);
O.sub = (e, t) => new O(e).sub(t);
O.div = (e, t) => new O(e).div(t);
const Ts = (e, t = 0) => {
  const s = e < 0 ? "-" : "";
  e = Math.abs(e);
  const n = e.toString().length < (2 ** 53).toString().length - 1 ? 10 ** t : 10 ** (t - 1), i = new O(Math.round(new O(e).mul(n))).div(n).toString(), r = Number(i);
  return r ? s + r.toFixed(t) : r.toFixed(t);
}, Di = (e, { secondaryGroupSize: t = 3, groupSize: s = 0, groupSeparator: n = "," }) => {
  const i = /^-\d+/.test(e);
  let r = i ? e.slice(1) : e;
  const o = t || s;
  if (s && r.length > s) {
    let a = r.slice(0, 0 - s);
    const l = r.slice(0 - s);
    a = a.replace(new RegExp(`\\B(?=(\\d{${o}})+(?!\\d))`, "g"), n), r = `${a}${n}${l}`;
  }
  return `${i ? "-" : ""}${r}`;
}, Ds = (e) => {
  const t = [];
  for (let s = 0; s < e.length; s++)
    t.push(e[s]);
  return t.reverse().join("");
}, Ci = (e, { fractionGroupSize: t = 0, fractionGroupSeparator: s = " " }) => {
  const n = new RegExp(`\\B(?=(\\d{${t}})+(?!\\d))`, "g");
  return Ds(Ds(e).replace(n, s));
}, Ol = (e, t = {}) => {
  const { fraction: s, rounding: n, prefix: i = "", decimalSeparator: r = ".", suffix: o = "" } = t;
  let a = Ne(e);
  if (a.isNaN() || !a.toString())
    return e;
  a = Tn(a.toString(), s, n), t.zeroize === !1 && a.match(/\./) && (a = a.replace(/\.?0+$/g, ""));
  const l = a.toString().split(".").slice(0, 2).map((f, u) => u ? Ci(f, t) : Di(f, t)).join(r);
  return `${i}${l}${o}`;
}, Fl = (e, t = {}) => {
  const { prefix: s = "", suffix: n = "", decimalSeparator: i = "." } = t;
  let r = e;
  return typeof e == "string" && (r = e.replace(new RegExp(`^${s}(.+)${n}$`), (o, a) => a).split(i).map((o) => o.replace(/[^\d]/g, "")).join(".")), Number(r);
}, G = {
  text: "text",
  url: "url",
  html: "html",
  tmpl: "tmpl"
}, Yt = {
  "&": "&#38;",
  "<": "&#60;",
  ">": "&#62;",
  '"': "&#34;",
  "'": "&#x27;",
  "[": "&#91;",
  "]": "&#93;"
}, R = (e) => e == null || typeof e == "string" && e.trim().length === 0;
function ns(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] || (t[n] = e(n));
  };
}
const Oi = /-(\w)/g, kl = ns((e) => e.replace(Oi, (t, s) => s ? s.toUpperCase() : "")), Rl = ns((e) => e.charAt(0).toUpperCase() + e.slice(1)), Fi = /\B([A-Z])/g, Il = ns((e) => e.replace(Fi, "-$1").toLowerCase()), Ll = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
};
function ki(e) {
  const t = e.length;
  let s = 0;
  for (let n = 0; n < t; n++)
    e.charCodeAt(n) <= 65535 ? s += 2 : s += 4;
  return s;
}
function Ri(e) {
  const t = e.length;
  let s = 0;
  for (let n = 0; n < t; n++) {
    let i = e.charCodeAt(n);
    i <= 127 ? s += 1 : i <= 2047 ? s += 2 : i <= 65535 ? s += 3 : s += 4;
  }
  return s;
}
function Ii(e) {
  const t = e.length;
  let s = 0;
  for (let n = 0; n < t; n++)
    s++, e.charCodeAt(n) >> 8 && s++;
  return s;
}
const Li = (e, t) => {
  if (!e || typeof e != "string")
    return 0;
  let s = 0;
  if (typeof t == "string")
    t = t.toLowerCase(), t === "utf-16" || t === "utf16" ? s = ki(e) : t === "utf-8" || t === "utf8" ? s = Ri(e) : s = e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  else {
    if (typeof t == "function")
      return t(e);
    s = Ii(e);
  }
  return s;
}, Ut = (e, t, s, n = "0") => {
  if (typeof e == "string" && typeof n == "string" && z(t)) {
    let i = e.length - t;
    if (i > 0)
      return s ? e.substr(0, t) : e.substr(i, t);
    {
      const r = [];
      for (i = Math.abs(i) / n.length; i > 0; i--)
        r.push(n);
      const o = r.join("");
      return s ? e + o : o + e;
    }
  }
}, Pi = () => globalThis.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296, Pl = (e = "", t = 8) => e + Pi().toString().substr(2, t), gt = (e, t) => !e || typeof e != "string" ? e : (e = e.replace(/[&<>"']/g, (s) => Yt[s]), t ? e.replace(/\s/g, "&#160;") : e), $l = (e, t, s) => !e || typeof e != "string" ? e : (typeof t == "boolean" && (s = !!t), t === "uri" ? encodeURIComponent(e) : t === "html" ? gt(e, s) : t === "prop" ? (e = gt(e, s), e.replace(/[[\]]/g, (n) => Yt[n])) : (e = e.replace(/[<>"]/g, (n) => Yt[n]), s ? e.replace(/\s/g, "&#160;") : e)), $i = ({ sign: e, format: t, hasSign: s }) => {
  switch (e) {
    case "#":
      t = G.text;
      break;
    case "@":
      t = G.url;
      break;
    case "$":
      t = G.html;
      break;
    case "%":
      t = G.tmpl;
      break;
    default:
      s = !1;
      break;
  }
  return { format: t, hasSign: s };
}, zi = (e, t, s = "html") => {
  if (typeof e == "string")
    return e.replace(/(\/)?\{\{([\s\S]*?)}}/g, (n, i = "", r = "") => {
      const o = r.substr(0, 1);
      let a = !0, l = G.html, f = $i({ sign: o, format: l, hasSign: a });
      l = f.format, a = f.hasSign, a ? r = (r || "").substring(1) : s && (l = s);
      let u = De(t, r);
      return V(u) && (u = ""), l === G.tmpl ? u = `{{${u}}}` : l === G.url ? u = encodeURIComponent(u) : u = l === G.html ? gt(u) : u, l === G.url && u.length === 0 ? "" : i + u;
    });
}, qi = () => (e, t, s, n) => e.replace(t, (i, r, o, a) => {
  if (!R(r) && !R(a))
    return `{${o}}`;
  const l = s[o], f = ee(l) ? Ni(l) : l;
  return R(l) ? "" : typeof l == "string" && typeof n == "function" ? n(f) : f;
}), Hi = ({ type: e, res: t, formatText: s, string: n, reg: i, args: r }) => (e === G.url ? t = s(n, i, r, encodeURIComponent) : e === G.html ? t = s(n, i, r, gt) : t = s(n, i, r), t), ji = (e, t, s) => {
  const n = e[e.length - 1];
  return n !== t.text && n !== t.url && n !== t.html ? e = Array.prototype.slice.call(e, 1) : (e = Array.prototype.slice.call(e, 1, e.length - 1), s = n), { args: e, type: s };
}, Bi = ({ data: e, args: t, type: s, _arguments: n }) => {
  if (Array.isArray(e))
    t = e;
  else {
    const i = ji(n, G, s);
    t = i.args, s = i.type;
  }
  return { args: t, type: s };
}, rs = function(e, t, s = "text") {
  if (typeof e != "string" || arguments.length < 2)
    return e;
  let n, i;
  if (ee(t))
    return zi(e, t, s);
  const r = Bi({ data: t, args: n, type: s, _arguments: arguments });
  n = r.args, s = r.type;
  const o = /(\\)?\{(\d+)(\\)?}/g, a = qi();
  return i = Hi({ type: s, res: i, formatText: a, string: e, reg: o, args: n }), i;
}, Wi = ({ string: e, length: t, ellipsis: s }) => {
  const n = typeof e == "string" && z(t) && t < e.length, i = n && rs(s, e.substr(0, t));
  return { flag: n, truthyValue: i };
}, zl = (e, t, s = "{0}...") => {
  const { flag: n, truthyValue: i } = Wi({ string: e, length: t, ellipsis: s });
  return n ? i : e;
}, is = (e, t, ...s) => {
  const n = e.apply(null, s);
  return isNaN(n) ? t : n;
}, Ki = (e) => z(e) ? Number(e.toFixed(0)) : typeof e == "string" ? parseInt(e, 10) : NaN, ql = (e, t) => is(Ki, t, e), Cn = (e) => z(e) ? e : typeof e == "string" ? parseFloat(e) : NaN, Hl = (e, t) => is(Cn, t, e), Xe = (e, t = 2, s = !1) => {
  let n = NaN;
  if (z(e) && (n = e), typeof e == "string") {
    const i = parseFloat(e);
    isNaN(i) || (n = i);
  }
  return z(n) && (s ? n = Ts(
    e.toString().split(".").slice(0, 2).map((i, r) => r ? i.slice(0, t) : i).join("."),
    t
  ) : n = Ts(n, t)), n;
}, jl = (e, t, s, n) => is(Xe, n, e, t, s), Yi = (e, t, s, n) => {
  if (Te(e)) {
    let i = Xe(Number(e), t, n);
    return i = String(i).replace(/(^|[^\w.])(\d{4,})/g, (r, o, a) => o + a.replace(/\d(?=(?:\d\d\d)+(?!\d))/g, "$&,")), s ? rs(s, i) : i;
  }
  return NaN;
}, Bl = (e, t, s, n) => isNaN(Cn(e)) ? n : Yi(e, t, s), Wl = (e) => z(e) ? e ? 1 : 0 : V(e) || e === "false" ? !1 : e === "true" ? !0 : typeof e == "boolean" ? e : !!e, Kl = (e, t = 1, s = 2) => z(e) && z(t) ? Xe(O(e).mul(100).div(t).toNumber(), s) + "%" : e, Yl = (e, t, s) => {
  if (Te(e)) {
    if (e = Number(e), e === 0)
      return `0${s || t || "B"}`;
    const n = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    let i = n.indexOf(s);
    if (i > -1)
      for (let o = 0; o < i; o++)
        e *= 1024;
    i = n.indexOf(t), i < 0 && (i = n.length - 1);
    let r = 0;
    for (let o = 0; o < i && (e <= -1024 || e >= 1024); o++)
      e /= 1024, r++;
    return Xe(e, 2) + n[r];
  }
  return e;
}, Ul = (e, t = "") => {
  if ([void 0, null].includes(e))
    return "";
  if (!z(e) || e <= 0)
    return e + t;
  const s = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  let n = Math.max(s.indexOf((t + "").toLocaleUpperCase()), 0);
  for (; e >= 1024 && n < s.length - 1; )
    e = e / 1024, n++;
  for (; e < 1 && n > 0; )
    e = e * 1024, n--;
  return parseFloat(Xe(e, 2, !0)) + " " + s[n];
}, Xl = (e) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(e), Gl = (e, t, s) => {
  let n;
  if (S) return { t: e, o: !1 };
  const r = document.createElement("canvas").getContext("2d");
  r.font = t;
  let o = r.measureText(e);
  if (o.width < s)
    return { t: e, o: !1 };
  for (let a = -1; ; a--)
    if (n = e.slice(0, a) + "...", o = r.measureText(n), o.width < s)
      return { t: n, o: !0 };
}, On = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ui = new RegExp(
  "^(\\d{4})(/|-)(((0)?[1-9])|(1[0-2]))((/|-)(((0)?[1-9])|([1-2][0-9])|(3[0-1])))?( ((0)?[0-9]|1[0-9]|20|21|22|23):([0-5]?[0-9])((:([0-5]?[0-9]))?(.([0-9]{1,6}))?)?)?$"
), Xi = new RegExp(
  "^(((0)?[1-9])|(1[0-2]))(/|-)(((0)?[1-9])|([1-2][0-9])|(3[0-1]))?(/|-)?(\\d{4})( ((0)?[0-9]|1[0-9]|20|21|22|23):([0-5]?[0-9])((:([0-5]?[0-9]))?(.([0-9]{1,6}))?)?)?$"
), Gi = new RegExp(
  "^(\\d{4})-(((0)?[1-9])|(1[0-2]))-(((0)?[1-9])|([1-2][0-9])|(3[0-1]))T(((0)?[0-9]|1[0-9]|20|21|22|23):([0-5]?[0-9])((:([0-5]?[0-9]))?(.([0-9]{1,6}))?)?)?(Z|([+-])((0)?[0-9]|1[0-9]|20|21|22|23):?([0-5]?[0-9]))$"
), Zi = {
  "y{1,4}": /y{1,4}/,
  "M{1,2}": /M{1,2}/,
  "d{1,2}": /d{1,2}/,
  "h{1,2}": /h{1,2}/,
  "H{1,2}": /H{1,2}/,
  "m{1,2}": /m{1,2}/,
  "s{1,2}": /s{1,2}/,
  "S{1,3}": /S{1,3}/,
  "Z{1,1}": /Z{1,1}/
}, ce = {
  YEAR: 9999,
  MONTH: 11,
  DATE: 31,
  HOUR: 23,
  MINUTE: 59,
  SECOND: 59,
  MILLISECOND: 999
}, Vi = "-12:00,-11:00,-10:00,-09:30,-08:00,-07:00,-06:00,-05:00,-04:30,-04:00,-03:30,-02:00,-01:00", Ji = "-00:00,+00:00,+01:00,+02:00,+03:00,+03:30,+04:00,+04:30,+05:00,+05:30,+05:45,+06:00", Qi = "+06:30,+07:00,+08:00,+09:00,+10:00,+10:30,+11:00,+11:30,+12:00,+12:45,+13:00,+14:00", eo = [...Vi.split(","), ...Ji.split(","), ...Qi.split(",")], to = (e) => {
  const t = 0 - e.getTimezoneOffset() / 60;
  let s;
  return t === 0 ? s = "Z" : t > 0 ? s = "+" + (t > 10 ? t : "0" + t) + "00" : s = (t < -10 ? t : "-0" + -t) + "00", s;
}, Ge = (e) => e % 400 === 0 || e % 4 === 0 && e % 100 !== 0, Fn = (e) => e > ce.MILLISECOND ? Number(String(e).substring(0, 3)) : e, os = ({ year: e, month: t, date: s, hours: n, minutes: i, seconds: r, milliseconds: o }) => {
  let a = On[t];
  if (Ge(e) && t === 1 && (a += 1), s <= a)
    return new Date(e, t, s, n, i, r, Fn(o));
}, so = (e) => {
  if (e.length === 23) {
    const t = Number(e[1]), s = e[3] - 1, n = Number(e[9] || 1), i = e[15] || 0, r = e[17] || 0, o = e[20] || 0, a = e[22] || 0;
    return os({
      date: n,
      year: t,
      hours: i,
      month: s,
      seconds: o,
      minutes: r,
      milliseconds: a
    });
  }
}, no = (e) => {
  if (e.length === 22) {
    const t = Number(e[12]), s = e[1] - 1, n = Number(e[6] || 1), i = e[14] || 0, r = e[16] || 0, o = e[19] || 0, a = e[21] || 0;
    return os({
      year: t,
      month: s,
      date: n,
      hours: i,
      minutes: r,
      seconds: o,
      milliseconds: a
    });
  }
}, ro = (e) => {
  if (e.length !== 25)
    return;
  const t = Number(e[1]), s = e[2] - 1, n = Number(e[6]), i = new Date(t, s, n).getTimezoneOffset(), r = e[12] || 0, o = e[14] || 0, a = e[17] || 0, l = e[19] || 0;
  let f = e[20];
  const u = e[21], c = e[22] || 0, h = e[24] || 0;
  let d = On[s], y, b;
  if (Ge(t) && s === 1 && (d += 1), n <= d) {
    if (f === "Z")
      y = r - i / 60, b = o;
    else {
      if (f.includes(":") || (f = f.substr(0, 3) + ":" + f.substr(3)), !eo.includes(f))
        return;
      y = u === "+" ? r - c - i / 60 : Number(r) + Number(c) - i / 60, b = u === "+" ? o - h : Number(o) + Number(h);
    }
    return new Date(t, s, n, y, b, a, Fn(l));
  }
}, Tt = [
  [Ui, so],
  [Xi, no],
  [Gi, ro]
], io = (e) => {
  for (let t = 0, s = Tt.length; t < s; t++) {
    const n = Tt[t][0].exec(e);
    if (n && n.length > 0)
      return Tt[t][1](n);
  }
}, oo = (e, t, s) => {
  if (s)
    switch (s) {
      case "yyyy":
      case "yy":
        e[0] = t;
        break;
      case "M":
      case "MM":
        e[1] = t - 1;
        break;
      case "d":
      case "dd":
        e[2] = t;
        break;
      case "h":
      case "hh":
        e[3] = t;
        break;
      case "m":
      case "mm":
        e[4] = t;
        break;
      case "s":
      case "ss":
        e[5] = t;
        break;
      case "S":
      case "SS":
      case "SSS":
        e[6] = t;
        break;
    }
}, ao = (e, t) => {
  const s = [0, -1, 0, 0, 0, 0];
  if (e.length !== t.length)
    return s;
  let n = 0, i = 0;
  for (let r = 0, o = e.length; r < o; r++) {
    const a = e.substr(r, 1), l = isNaN(Number(a)) || a.trim() === "";
    if (l && a === t.substr(r, 1) || r === o - 1) {
      let f, u;
      if (l) {
        f = e.substring(n, r), n = r + 1;
        const c = t.indexOf(a, i);
        u = t.substring(i, c === -1 ? t.length : c), i = c + 1;
      } else
        f = e.substring(n, o), u = t.substring(i, o);
      (f.length === u.length || f) && oo(s, f, u);
    }
  }
  return s;
}, be = (e, t, s) => isNaN(e) || e < t || e > s, lo = ({ year: e, month: t, date: s, hours: n, minutes: i, seconds: r, milliseconds: o }) => be(e, 0, ce.YEAR) || be(t, 0, ce.MONTH) || be(s, 0, ce.DATE) || be(n, 0, ce.HOUR) || be(i, 0, ce.MINUTE) || be(r, 0, ce.SECOND) || be(o, 0, ce.MILLISECOND), co = (e, t) => {
  if (typeof t == "string") {
    const s = ao(e, t), n = Number(s[0]), i = Number(s[1]), r = Number(s[2] || 1), o = Number(s[3] || 0), a = Number(s[4] || 0), l = Number(s[5] || 0), f = Number(s[6] || 0);
    return lo({
      year: n,
      month: i,
      date: r,
      hours: o,
      minutes: a,
      seconds: l,
      milliseconds: f
    }) ? void 0 : os({
      year: n,
      date: r,
      month: i,
      minutes: a,
      hours: o,
      milliseconds: f,
      seconds: l
    });
  } else
    return io(e);
}, as = (e, t, s) => {
  let n;
  if (z(e) ? n = new Date(e) : typeof e == "string" && (n = co(e, t)), s) {
    const i = s && as(s) || new Date(1, 1, 1, 0, 0, 0);
    return n && n < i ? i : n;
  }
  return n;
}, Ae = function(e, t = "yyyy/MM/dd hh:mm:ss") {
  if (Le(e)) {
    if (typeof t == "string") {
      const s = {
        "y{1,4}": e.getFullYear(),
        "M{1,2}": e.getMonth() + 1,
        "d{1,2}": e.getDate(),
        "h{1,2}": e.getHours(),
        "H{1,2}": e.getHours(),
        "m{1,2}": e.getMinutes(),
        "s{1,2}": e.getSeconds(),
        "S{1,3}": e.getMilliseconds(),
        "Z{1,1}": to(e)
      };
      return Object.keys(s).forEach((n) => {
        const i = t.match(Zi[n]);
        n && i && i.length && (t = t.replace(i[0], n === "Z{1,1}" ? s[n] : Ut(s[n].toString(), i[0].length)));
      }), t;
    }
  } else if (typeof e == "string" && arguments.length >= 2) {
    let s = t;
    arguments.length === 2 ? t = void 0 : s = arguments[2];
    const n = as(e, t);
    return n ? Ae(n, s) : "";
  }
}, fo = (e, t, s, n = 0) => {
  if (!Le(e) || !Te(t) || !Te(s) || !Te(n))
    return;
  const i = -t * 60, r = -s * 60, o = n * 60, a = e.getTime() + i * 6e4;
  return new Date(a - (r - o) * 6e4);
}, Zl = (e, t, s) => {
  if (e && Te(s)) {
    const n = parseFloat(s.toString());
    s = parseFloat(n.toFixed(2));
    const i = Le(e) ? e : new Date(as(e));
    e = fo(i, 0, s);
  }
  return Ae(e, t);
}, Vl = (e, t) => {
  typeof e == "boolean" && (t = e), Le(e) || (e = /* @__PURE__ */ new Date());
  const s = e.getDay();
  let n = e.getDate();
  return s === 0 ? !t && (n -= 6) : n = n - s + (!t && 1), new Date(e.getFullYear(), e.getMonth(), n);
}, uo = /(-|\+)(\d{2}):?(\d{2})$/, ho = () => 0 - (/* @__PURE__ */ new Date()).getTimezoneOffset() / 60, Jl = (e) => {
  const t = ho(), s = typeof e == "string" && e.match(uo);
  return s && (e = (Number(s[2]) + Number(s[3]) / 60) * `${s[1]}1`), z(e) && e >= -12 && e <= 12 ? e : t;
}, Cs = (e, t) => [31, Ge(e) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1], Os = (e, t, s) => (/* @__PURE__ */ new Date(`${e}/${t}/${s}`)).getDay(), po = (e, t) => (e = +e, t = +t, t === 1 ? (e--, t = 12) : t--, { year: e, month: t }), go = (e, t) => (e = +e, t = +t, t === 12 ? (e++, t = 1) : t++, { year: e, month: t }), Ql = (e, t) => {
  if (e && t && t <= 12) {
    const s = Cs(e, t), n = Os(e, t, 1), i = Os(e, t, s), r = po(e, t), o = go(e, t), a = Cs(r.year, r.month);
    let l = 0;
    const f = s + n + 7 - i - 1;
    return f / 7 < 6 && f / 7 >= 5 && (l = 6 * 7 - f), {
      last: {
        year: r.year,
        month: r.month,
        start: a - (n - 1),
        end: a
      },
      current: {
        year: e,
        month: t,
        start: 1,
        end: s
      },
      next: {
        year: o.year,
        month: o.month,
        start: 1,
        end: 7 - i - 1 + l
      }
    };
  }
}, ec = (e) => {
  const t = [];
  let s = 0;
  if (e && e.length) {
    const n = e.length / 7;
    for (let i = 0; i < n; i++) {
      t[i] = [];
      for (let r = 0; r < 7; r++)
        t[i][r] = e[s++];
    }
  }
  return t;
}, tc = (e) => {
  const t = new Date(e && typeof e == "number" ? e : 0);
  return {
    year: t.getFullYear(),
    month: t.getMonth() + 1,
    day: t.getDate(),
    hours: t.getHours(),
    minutes: t.getMinutes(),
    seconds: t.getSeconds()
  };
}, mo = {
  Backspace: 8,
  Tab: 9,
  Clear: 12,
  Enter: 13,
  Shift: 16,
  Control: 17,
  Alt: 18,
  CapsLock: 20,
  Escape: 27,
  Space: 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  ArrowLeft: 37,
  ArrowUp: 38,
  ArrowRight: 39,
  ArrowDown: 40,
  Insert: 45,
  Delete: 46,
  Colon: 58,
  Semicolon: 59,
  LessThan: 60,
  Equals: 61,
  GreaterThan: 62,
  QuestionMark: 63,
  AtMark: 64,
  KeyA: 65,
  KeyB: 66,
  KeyC: 67,
  KeyD: 68,
  KeyE: 69,
  KeyF: 70,
  KeyG: 71,
  KeyH: 72,
  KeyI: 73,
  KeyJ: 74,
  KeyK: 75,
  KeyL: 76,
  KeyM: 77,
  KeyN: 78,
  KeyO: 79,
  KeyP: 80,
  KeyQ: 81,
  KeyR: 82,
  KeyS: 83,
  KeyT: 84,
  KeyU: 85,
  KeyV: 86,
  KeyW: 87,
  KeyX: 88,
  KeyY: 89,
  KeyZ: 90,
  Digit0: 48,
  Digit1: 49,
  Digit2: 50,
  Digit3: 51,
  Digit4: 52,
  Digit5: 53,
  Digit6: 54,
  Digit7: 55,
  Digit8: 56,
  Digit9: 57,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NumLock: 144,
  Numpad0: 96,
  Numpad1: 97,
  Numpad2: 98,
  Numpad3: 99,
  Numpad4: 100,
  Numpad5: 101,
  Numpad6: 102,
  Numpad7: 103,
  Numpad8: 104,
  Numpad9: 105,
  NumpadMultiply: 106,
  NumpadAdd: 107,
  NumpadEnter: 13,
  NumpadSubtract: 109,
  NumpadDecimal: 110,
  NumpadDivide: 111,
  NumpadComma: 190
}, sc = { Left: "left", Right: "right", Top: "top", Bottom: "bottom" }, Dt = { Asc: "asc", Desc: "desc" }, nc = 100, rc = { Min: 0, Max: 255, NonNumeric: 25 }, ic = {
  FullDatetime: "yyyy-MM-dd hh:mm:ss.SSS",
  LongDatetime: "yyyy-MM-dd hh:mm:ss",
  Datetime: "yyyy-MM-dd hh:mm",
  Date: "yyyy-MM-dd",
  FullTime: "hh:mm:ss.SSS",
  LongTime: "hh:mm:ss",
  Time: "hh:mm",
  YearMonth: "yyyy-MM"
}, yo = "date,datetime,time,time-select,week,month,year,years,yearrange,daterange,monthrange,timerange,datetimerange,dates,quarter", Pe = {
  Day: "day",
  Date: "date",
  Dates: "dates",
  Year: "year",
  Years: "years",
  YearRange: "yearrange",
  PanelYearNum: 12,
  Month: "month",
  Week: "week",
  Normal: "normal",
  Today: "today",
  PreMonth: "pre-month",
  NextMonth: "next-month",
  YearI18n: "ui.datepicker.year",
  List: [38, 40, 37, 39],
  YearObj: { 38: -4, 40: 4, 37: -1, 39: 1 },
  WeekObj: { 38: -1, 40: 1, 37: -1, 39: 1 },
  DayObj: { 38: -7, 40: 7, 37: -1, 39: 1 },
  Aviailable: "available",
  Default: "default",
  Current: "current",
  InRange: "in-range",
  StartDate: "start-date",
  EndDate: "end-date",
  Selected: "selected",
  Disabled: "disabled",
  Range: "range",
  fullMonths: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
  fullWeeks: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  MonhtList: ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"],
  Weeks: ["sun", "mon", "tue", "wed", "thu", "fri", "sat"],
  PlacementMap: {
    left: "bottom-start",
    center: "bottom",
    right: "bottom-end"
  },
  QuarterMap: {
    0: 0,
    1: 3,
    2: 6,
    3: 9
  },
  MonthQuarterMap: {
    0: 1,
    3: 2,
    6: 3,
    9: 4
  },
  TriggerTypes: yo.split(","),
  DateFormats: {
    year: "yyyy",
    years: "yyyy",
    yearrange: "yyyy",
    month: "yyyy-MM",
    time: "HH:mm:ss",
    week: "yyyywWW",
    date: "yyyy-MM-dd",
    timerange: "HH:mm:ss",
    monthrange: "yyyy-MM",
    daterange: "yyyy-MM-dd",
    datetime: "yyyy-MM-dd HH:mm:ss",
    datetimerange: "yyyy-MM-dd HH:mm:ss"
  },
  Time: "time",
  TimeRange: "timerange",
  Quarter: "quarter",
  IconTime: "icon-time",
  IconDate: "icon-Calendar",
  DateRange: "daterange",
  DateTimeRange: "datetimerange",
  MonthRange: "monthrange",
  TimeSelect: "time-select",
  TimesTamp: "timestamp",
  DateTime: "datetime",
  SelectbaleRange: "selectableRange",
  Start: "09:00",
  End: "18:00",
  Step: "00:30",
  CompareOne: "-1:-1",
  CompareHundred: "100:100",
  selClass: ".selected",
  queryClass: ".tiny-picker-panel__content",
  disableClass: ".time-select-item:not(.disabled)",
  defaultClass: ".default",
  Qurtyli: '[data-tag="li"]',
  MappingKeyCode: { 40: 1, 38: -1 },
  DatePicker: "DatePicker",
  TimePicker: "TimePicker"
}, oc = {
  IE: "ie",
  Edge: "edge",
  Chrome: "chrome",
  Firefox: "firefox"
}, ac = 120, lc = {
  Validating: "validating",
  Success: "success",
  Error: "error"
}, cc = {
  SvgStr: '<path style="pointer-events: auto;" fill="transparent" d="M',
  CascaderNodeExpand: '.tiny-cascader-node[aria-expanded="true"]',
  CascaderNodeTab: '.tiny-cascader-node[tabindex="-1"]',
  ScrollWrap: ".tiny-scrollbar__wrap",
  CascaderActice: ".tiny-cascader-node.is-active",
  ActivePath: ".tiny-cascader-node.in-active-path",
  PropsObject: {
    "expand-trigger": "expand-trigger is removed, use `props.expandTrigger` instead.",
    "change-on-select": "change-on-select is removed, use `props.checkStrictly` instead.",
    "hover-threshold": "hover-threshold is removed, use `props.hoverThreshold` instead"
  },
  EventObject: {
    "active-item-change": "active-item-change is renamed to expand-change"
  },
  SugItem: ".tiny-cascader__suggestion-item",
  CascaderMenu: ".tiny-cascader-menu",
  InputClass: ".tiny-input__inner",
  TagClass: ".tiny-cascader__tags",
  ListClass: ".tiny-cascader__suggestion-list",
  PropsExpandTri: "expandTrigger",
  PropsCheckStric: "checkStrictly",
  PropsHover: "hoverThreshold",
  MenuConnector: "cascader-menu-"
}, j = {}, ls = ["\\d\\d?", "\\d{3}", "\\d{4}"], le = ls[0], bo = ls[1], wo = ls[2], qe = "[^\\s]+", kn = /\[([^]*?)\]/gm, Fs = () => {
}, vo = {
  shortDate: "M/D/yy",
  mediumDate: "MMM d, yyyy",
  longDate: "MMMM d, yyyy",
  fullDate: "dddd, MMMM d, yyyy",
  default: "ddd MMM dd yyyy HH:mm:ss",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
}, Rn = (e, t) => {
  let s = [];
  for (let n = 0, i = e.length; n < i; n++)
    s.push(e[n].substr(0, t));
  return s;
}, ks = (e) => (t, s, n) => {
  const i = n[e].indexOf(s.charAt(0).toUpperCase() + s.substr(1).toLowerCase());
  ~i && (t.month = i);
}, Y = (e, t) => {
  for (e = String(e), t = t || 2; e.length < t; )
    e = "0" + e;
  return e;
}, So = (e) => e.replace(/[|\\{()[^$+*?.-]/g, "\\$&"), In = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, Ln = Pe.fullWeeks, Pn = Pe.fullMonths, xo = Rn(Pn, 3), No = Rn(Ln, 3), Eo = ["th", "st", "nd", "rd"];
j.i18n = {
  dayNames: Ln,
  monthNames: Pn,
  dayNamesShort: No,
  monthNamesShort: xo,
  amPm: ["am", "pm"],
  doFn: (e) => e + Eo[e % 10 > 3 ? 0 : (e - e % 10 !== 10) * e % 10]
};
const Rs = {
  D: (e) => e.getDay(),
  DD: (e) => Y(e.getDay()),
  Do: (e, t) => t.doFn(e.getDate()),
  d: (e) => e.getDate(),
  dd: (e) => Y(e.getDate()),
  ddd: (e, t) => t.dayNamesShort[e.getDay()],
  dddd: (e, t) => t.dayNames[e.getDay()],
  M: (e) => e.getMonth() + 1,
  MM: (e) => Y(e.getMonth() + 1),
  MMM: (e, t) => t.monthNamesShort[e.getMonth()],
  MMMM: (e, t) => t.monthNames[e.getMonth()],
  yy: (e) => Y(String(e.getFullYear()), 4).substr(2),
  yyyy: (e) => Y(e.getFullYear(), 4),
  h: (e) => e.getHours() % 12 || 12,
  hh: (e) => Y(e.getHours() % 12 || 12),
  H: (e) => e.getHours(),
  HH: (e) => Y(e.getHours()),
  m: (e) => e.getMinutes(),
  mm: (e) => Y(e.getMinutes()),
  s: (e) => e.getSeconds(),
  ss: (e) => Y(e.getSeconds()),
  S: (e) => Math.round(e.getMilliseconds() / 100),
  SS: (e) => Y(Math.round(e.getMilliseconds() / 10), 2),
  SSS: (e) => Y(e.getMilliseconds(), 3),
  a: (e, t) => e.getHours() < 12 ? t.amPm[0] : t.amPm[1],
  A: (e, t) => e.getHours() < 12 ? t.amPm[0].toUpperCase() : t.amPm[1].toUpperCase(),
  ZZ: (e) => {
    const t = e.getTimezoneOffset();
    return (t > 0 ? "-" : "+") + Y(Math.floor(Math.abs(t) / 60) * 100 + Math.abs(t) % 60, 4);
  }
}, de = {
  d: [
    le,
    (e, t) => {
      e.day = t;
    }
  ],
  Do: [
    le + qe,
    (e, t) => {
      e.day = parseInt(t, 10);
    }
  ],
  M: [
    le,
    (e, t) => {
      e.month = t - 1;
    }
  ],
  yy: [
    le,
    (e, t) => {
      const n = Number(String((/* @__PURE__ */ new Date()).getFullYear()).substr(0, 2));
      e.year = String(t > 68 ? n - 1 : n) + t;
    }
  ],
  h: [
    le,
    (e, t) => {
      e.hour = t;
    }
  ],
  m: [
    le,
    (e, t) => {
      e.minute = t;
    }
  ],
  s: [
    le,
    (e, t) => {
      e.second = t;
    }
  ],
  yyyy: [
    wo,
    (e, t) => {
      e.year = t;
    }
  ],
  S: [
    "\\d",
    (e, t) => {
      e.millisecond = t * 100;
    }
  ],
  SS: [
    "\\d{2}",
    (e, t) => {
      e.millisecond = t * 10;
    }
  ],
  SSS: [
    bo,
    (e, t) => {
      e.millisecond = t;
    }
  ],
  D: [le, Fs],
  ddd: [qe, Fs],
  MMM: [qe, ks("monthNamesShort")],
  MMMM: [qe, ks("monthNames")],
  a: [
    qe,
    (e, t, s) => {
      const n = t.toLowerCase();
      n === s.amPm[0] ? e.isPm = !1 : n === s.amPm[1] && (e.isPm = !0);
    }
  ],
  ZZ: [
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z",
    (e, t) => {
      let s = String(t).match(/([+-]|\d\d)/gi), n;
      s && (n = Number(s[1] * 60) + parseInt(s[2], 10), e.timezoneOffset = s[0] === "+" ? n : -n);
    }
  ]
}, _o = ["A", "DD", "dd", "mm", "hh", "MM", "ss", "hh", "H", "HH"];
j.masks = vo;
de.dddd = de.ddd;
_o.forEach((e) => {
  e === "MM" ? de[e] = de[e.substr(0, 1)] : de[e] = de[e.substr(0, 1).toLowerCase()];
});
j.format = (e, t, s) => {
  const n = s || j.i18n;
  if (typeof e == "number" && (e = new Date(e)), !Le(e) || isNaN(e.getTime()))
    throw new Error("Invalid Date in fecha.format");
  t = j.masks[t] || t || j.masks.default;
  let i = [];
  return t = t.replace(kn, (r, o) => (i.push(o), "@@@")), t = t.replace(
    In,
    (r) => r in Rs ? Rs[r](e, n) : r.slice(1, r.length - 1)
  ), t.replace(/@@@/g, () => i.shift());
};
const Ao = (e, t) => {
  let s = [], n = So(e).replace(In, (i) => {
    if (de[i]) {
      const r = de[i];
      return t.push(r[1]), "(" + r[0] + ")";
    }
    return i;
  });
  return n = n.replace(/@@@/g, () => s.shift()), n;
}, Mo = (e) => {
  let t;
  const s = /* @__PURE__ */ new Date();
  if (V(e.timezoneOffset)) {
    const { year: n, month: i, day: r, hour: o, minute: a, second: l, millisecond: f } = e;
    t = new Date(
      n || s.getFullYear(),
      i || 0,
      r || 1,
      o || 0,
      a || 0,
      l || 0,
      f || 0
    );
  } else {
    e.minute = Number(e.minute || 0) - Number(e.timezoneOffset);
    const { year: n, month: i, day: r, hour: o, minute: a, second: l, millisecond: f } = e;
    t = new Date(
      Date.UTC(n || s.getFullYear(), i || 0, r || 1, o || 0, a || 0, l || 0, f || 0)
    );
  }
  return t;
};
j.parse = (e, t, s) => {
  const n = s || j.i18n;
  if (typeof t != "string")
    throw new TypeError("Invalid format in fecha.parse");
  if (t = j.masks[t] || t, e.length > 1e3)
    return null;
  let i = {}, r = [];
  t = t.replace(kn, (l, f) => "@@@");
  const o = Ao(t, r), a = e.match(new RegExp(o, "i"));
  if (!a)
    return null;
  for (let l = 1, f = a.length; l < f; l++)
    r[l - 1](i, a[l], n);
  return i.isPm === !0 && !V(i.hour) && Number(i.hour) !== 12 ? i.hour = Number(i.hour) + 12 : i.isPm === !1 && Number(i.hour) === 12 && (i.hour = 0), Mo(i);
};
const Is = Pe.Weeks, Ls = Pe.MonhtList, $n = Pe.DateFormats.date, zn = Pe.DateFormats.time, To = (e, t) => {
  let s = [];
  for (let n = e; n <= t; n++)
    s.push(n);
  return s;
}, qn = (e) => ({
  dayNamesShort: Is.map((t) => e(`ui.datepicker.weeks.${t}`)),
  dayNames: Is.map((t) => e(`ui.datepicker.weeks.${t}`)),
  monthNamesShort: Ls.map((t, s) => e(`ui.datepicker.month${s + 1}`).replace(" ", "")),
  monthNames: Ls.map((t) => e(`ui.datepicker.months.${t}`)),
  amPm: ["am", "pm"]
}), Hn = function(e) {
  return !(V(e) || isNaN(new Date(e).getTime()) || Array.isArray(e));
}, cs = (e) => Hn(e) ? new Date(e) : null, fc = (e) => e instanceof Date, uc = (e, t, s) => (e = cs(e), e ? j.format(e, t || $n, qn(s)) : ""), Do = (e, t, s) => j.parse(e, t || $n, qn(s)), Co = (e, t) => ~[3, 5, 8, 10].indexOf(t) ? 30 : t === 1 ? Ge(e) ? 29 : 28 : 31, dc = (e) => Ge(e) ? 366 : 365, hc = (e) => {
  const t = new Date(e.getTime());
  return t.setDate(1), t.getDay();
}, Oo = (e, t = 1) => new Date(e.getFullYear(), e.getMonth(), e.getDate() - t), pc = (e, t = 1) => new Date(e.getFullYear(), e.getMonth(), e.getDate() + t), gc = (e, t, s = 0) => {
  const n = new Date(e, t, 1), i = n.getDay(), r = i === 0 ? 7 : i, o = r + s <= 0 ? 7 + r : r;
  return Oo(n, o);
}, mc = (e) => {
  if (!Hn(e))
    return null;
  const t = new Date(e.getTime());
  t.setHours(0, 0, 0, 0), t.setDate(t.getDate() + 3 - (t.getDay() + 6) % 7);
  const s = new Date(t.getFullYear(), 0, 4);
  return 1 + Math.round(((t.getTime() - s.getTime()) / 864e5 - 3 + (s.getDay() + 6) % 7) / 7);
}, yc = (e = []) => {
  const t = [];
  let s = [];
  e.forEach((i) => {
    const r = i.map((o) => o.getHours());
    s = s.concat(To(r[0], r[1]));
  });
  let n;
  s.length ? n = (i) => !~s.indexOf(i) : n = () => !1;
  for (let i = 0; i < 24; i++)
    t[i] = n(i);
  return t;
}, He = (e, t, s, n) => {
  for (let i = t; i < s; i++)
    e[i] = n;
}, jn = (e) => Array.apply(null, { length: e }).map((t, s) => s), bc = (e) => {
  const s = new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate();
  return jn(s).map((n, i) => i + 1);
}, wc = (e, t) => {
  if (t <= 0)
    return [];
  const s = new Date(e.getTime());
  s.setDate(0);
  const n = s.getDate();
  return jn(t).map((i, r) => n - (t - r - 1));
}, vc = (e, t) => {
  const n = new Array(60);
  return e.length > 0 ? e.forEach((i) => {
    const [r, o] = i, a = r.getHours(), l = r.getMinutes(), f = o.getHours(), u = o.getMinutes(), c = a === t;
    c && f !== t ? He(n, l, 60, !0) : c && f === t ? He(n, l, u + 1, !0) : !c && f === t ? He(n, 0, u + 1, !0) : a < t && f > t && He(n, 0, 60, !0);
  }) : He(n, 0, 60, !0), n;
}, Bn = (e, t, s, n) => (e = cs(e), new Date(t, s, n, e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())), Fo = (e, t, s, n) => (e = cs(e), new Date(e.getFullYear(), e.getMonth(), e.getDate(), t, s, n, e.getMilliseconds())), Sc = (e, t, s) => V(e) || !t ? e : (t = Do(t, zn, s), Fo(e, t.getHours(), t.getMinutes(), t.getSeconds())), xc = (e) => new Date(e.getFullYear(), e.getMonth(), e.getDate()), Nc = (e) => new Date(
  e.getFullYear(),
  e.getMonth(),
  e.getDate(),
  e.getHours(),
  e.getMinutes(),
  e.getSeconds(),
  0
), ko = (e, t, s = zn) => {
  if (t.length === 0)
    return e;
  const n = (f) => j.parse(j.format(f, s), s), i = n(e), r = t.map((f) => f.map(n));
  if (r.some((f) => i >= f[0] && i <= f[1]))
    return e;
  let o = r[0][0], a = o;
  r.forEach((f) => {
    let u = o = new Date(Math.min(f[0], o));
    a = new Date(Math.max(f[1], u));
  });
  const l = i < o ? o : a;
  return Bn(l, e.getFullYear(), e.getMonth(), e.getDate());
}, Ec = (e, t, s) => ko(e, t, s).getTime() === e.getTime(), Re = (e, t, s) => {
  const n = Math.min(e.getDate(), Co(t, s));
  return Bn(e, t, s, n);
}, _c = (e) => {
  const t = e.getFullYear(), s = e.getMonth();
  return s === 11 ? Re(e, t + 1, 0) : Re(e, t, s + 1);
}, Ac = (e) => {
  const t = e.getFullYear(), s = e.getMonth();
  return s === 0 ? Re(e, t - 1, 11) : Re(e, t, s - 1);
}, Mc = (e, t = 1) => {
  const s = e.getFullYear(), n = e.getMonth();
  return Re(e, s + t, n);
}, Tc = (e, t = 1) => {
  const s = e.getFullYear(), n = e.getMonth();
  return Re(e, s - t, n);
}, Dc = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?y{2,4}/g, "").trim(), Cc = (e) => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), Oc = (e, t) => e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear(), wt = (e, t, s = pn) => {
  if (Array.isArray(e) && typeof s == "function") {
    for (let n = 0, i = e.length; n < i; n++)
      if (s(e[n], t))
        return n;
  }
  return -1;
}, Ro = (e, t) => {
  const s = wt(e, void 0, t);
  return s !== -1 ? e[s] : void 0;
}, Fc = (e, t, s = 1) => {
  if (Array.isArray(e) && e.length) {
    const n = wt(e, t);
    n > -1 && e.splice(n, s);
  }
  return e;
}, kc = (e, t, s = Dt.Asc) => (Array.isArray(e) && e.length > 1 && e.sort((n, i) => {
  const r = s === Dt.Asc ? [1, -1] : [-1, 1], o = De(n, t), a = De(i, t);
  return isNaN(o) ? s === Dt.Asc ? 1 : -1 : isNaN(a) ? -1 : o > a ? r[0] : r[1];
}), e), Rc = (e, t) => (Array.isArray(e) && !e.some((s) => pn(s, t)) && e.push(t), e), Ic = (e) => {
  if (Array.isArray(e)) {
    const t = [];
    for (let s = 0, n = e.length; s < n; s++) {
      const i = e[s];
      wt(t, i) === -1 && t.push(i);
    }
    return t;
  }
  return e;
}, Io = (e, t) => (Object.keys(t).forEach((s) => e[s] = t[s]), e), Lc = (e) => {
  const t = {};
  for (let s = 0; s < e.length; s++)
    e[s] && Io(t, e[s]);
  return t;
}, Lo = (e, t = "pId", s = "children", n = "id") => {
  const i = [];
  return Array.isArray(e) && e.forEach((r) => {
    if (!r[t] || r[t] === "0")
      i.push(r);
    else {
      const o = Ro(e, (a) => a[n] === r[t]);
      if (!o)
        return;
      o[s] || (o[s] = []), o[s].push(r);
    }
    delete r[t];
  }), i;
}, Po = (e, t = "id", s = "pId") => {
  let n;
  return Array.isArray(e) ? n = e : n = [e], n = n.map((r) => ({ ...r })), Lo(n, s, "children", t);
}, $o = (e) => {
  const t = {};
  return Object.keys(e).forEach((s) => {
    const { type: n, value: i } = e[s];
    if (n === "enum" && (t[s] = { type: i.map(() => 0), value: i }, i.length > 1 && (e[s].relation = "or")), n === "input") {
      const { relation: r, text: o } = i;
      t[s] = {
        type: [r === "startwith" ? 8 : r === "equals" ? 0 : 6],
        value: o
      };
    }
  }), JSON.stringify(t);
}, Wn = (e, t) => {
  const s = Array.isArray(t) ? t : t.split("."), n = s.shift();
  if (n === void 0) return;
  const i = e[n];
  return xe(i) && s.length ? Wn(i, s) : i;
}, zo = (e, t) => {
  if (t) {
    const { page: s, sort: n, filters: i } = t, { currentPage: r, pageSize: o } = s || {}, a = $o(i || {}), l = n && n.property ? n.property + " " + n.order : "";
    e.url = rs(e.url, {
      curPage: r,
      pageSize: o,
      filterStr: a,
      orderBy: l
    });
  }
}, st = (e, t) => {
  const { result: s, pageVO: n } = e, { key: i = "id", parentKey: r } = t || {};
  let o = s || e;
  return r && (o = Po(o, i, r)), n ? { result: o, page: { total: n.totalRows } } : o;
}, Pc = ({ dataset: e, service: t, tree: s }, n) => new Promise((i, r) => {
  if (Array.isArray(e))
    return i(st(e, s));
  const o = e, { source: a, value: l, api: f } = o || {}, u = t || o && o.service;
  if (Array.isArray(l))
    return i(st({ result: l }, s));
  if (!u)
    return i([]);
  if (xe(a) && (a != null && a.url)) {
    const {
      type: c = "GET",
      data: h,
      beforeRequest: d,
      afterRequest: y,
      success: b,
      hideErr: p,
      url: L,
      method: v,
      ...w
    } = a;
    w.url = L, w.method = v || c.toLocaleLowerCase();
    const P = w.method === "get" ? "params" : "data";
    w[P] = h || {};
    const M = y || b, N = { ...w };
    zo(N, n), d && d(N, n), u.network.request(N).then((F) => {
      M && M(F.data), i(st(F.data, s));
    }).catch((F) => {
      p || r(F);
    });
  } else if (f) {
    const c = Wn(u, f.name);
    c && c({ ...f.data, ...n }).then((h) => {
      i(st(h, s));
    }).catch((h) => {
      r(h);
    });
  }
}), $c = "FormItem", zc = {
  change: "form.change",
  blur: "form.blur"
}, qo = /%[sdj%]/g, Kn = () => {
};
function mt(e) {
  if (!e || !e.length)
    return null;
  const t = {};
  return e.forEach((s) => {
    const n = s.field;
    t[n] = t[n] || [], t[n].push(s);
  }), t;
}
function te(e, ...t) {
  if (typeof e == "function")
    return e(...t);
  if (typeof e == "string") {
    let s = 0;
    const n = t.length;
    return String(e).replace(qo, (r) => {
      if (r === "%%")
        return "%";
      if (s >= n)
        return r;
      switch (r) {
        case "%j":
          try {
            return JSON.stringify(t[s++]);
          } catch {
            return "[Circular]";
          }
        case "%d":
          return Number(t[s++]).toString();
        case "%s":
          return String(t[s++]);
        default:
          return r;
      }
    });
  }
  return String(e);
}
function Ho(e) {
  return e ? [
    "string",
    "url",
    "hex",
    "email",
    "pattern",
    "digits",
    "time",
    "dateYMD",
    "longDateTime",
    "dateTime",
    "dateYM",
    "version",
    "speczh",
    "specialch",
    "specialch2",
    "acceptImg",
    "acceptFile",
    "fileSize"
  ].includes(e) : !1;
}
function q(e, t) {
  return !!(V(e) || t === "array" && Array.isArray(e) && !e.length || Ho(t) && typeof e == "string" && !e);
}
function jo(e) {
  return Object.keys(e).length === 0;
}
function Bo(e, t, s) {
  let n = 0;
  const i = [], r = e.length;
  function o(a) {
    i.push(...a), n++, n === r && s(i);
  }
  e.forEach((a) => {
    t(a, o);
  });
}
function Ps(e, t, s) {
  let n = 0;
  const i = e.length;
  function r(o) {
    if (o && o.length) {
      s(o);
      return;
    }
    const a = n;
    n = n + 1, a < i ? t(e[a], r) : s([]);
  }
  r([]);
}
function Wo(e) {
  const t = [];
  return Object.keys(e).forEach((s) => {
    t.push(...e[s]);
  }), t;
}
function Yn(e, t, s, n) {
  if (t.first) {
    const u = new Promise((c, h) => {
      const d = h, y = (p) => (n(p), p.length ? d({ errors: p, fields: mt(p) }) : c()), b = Wo(e);
      Ps(b, s, y);
    });
    return u.catch((c) => c.errors && c.fields || $t.error(c)), u;
  }
  let i = Array.isArray(t.firstFields) ? t.firstFields : [];
  t.firstFields === !0 && (i = Object.keys(e));
  let r = 0;
  const o = Object.keys(e), a = o.length, l = [], f = new Promise((u, c) => {
    const h = c, d = (y) => {
      if (l.push(...y), r++, r === a)
        return n(l), l.length ? h({ errors: l, fields: mt(l) }) : u();
    };
    o.forEach((y) => {
      const b = e[y];
      i.includes(y) ? Ps(b, s, d) : Bo(b, s, d);
    });
  });
  return f.catch((u) => u.errors && u.fields || $t.error(u)), f;
}
function fs(e) {
  return (t) => t && t.message ? (t.field = t.field || e.fullField, t) : {
    message: typeof t == "function" ? t() : String(t),
    field: (t == null ? void 0 : t.field) || e.fullField
  };
}
function Xt(e, t) {
  if (!t)
    return e;
  for (const s in t)
    if (A.call(t, s)) {
      const n = t[s];
      typeof n == "object" && typeof e[s] == "object" ? e[s] = {
        ...e[s],
        ...n
      } : e[s] = n;
    }
  return e;
}
const Ko = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asyncMap: Yn,
  complementError: fs,
  convertFieldsError: mt,
  deepMerge: Xt,
  format: te,
  isEmptyObject: jo,
  isEmptyValue: q,
  warning: Kn
}, Symbol.toStringTag, { value: "Module" }));
function D(e, t) {
  D.getSystemMessage = () => D.getDefaultMessage(t), D.messages = D.getSystemMessage(t), D.systemMessages = D.messages, this.rules = null, this._messages = D.systemMessages, this.define(e);
}
const Yo = (e) => (t) => {
  let s, n = [], i = {};
  function r(o) {
    Array.isArray(o) ? n = n.concat(...o) : n.push(o);
  }
  for (s = 0; s < t.length; s++)
    r(t[s]);
  n.length ? i = mt(n) : (n = null, i = null), e(n, i);
}, Uo = (e, t) => {
  let s = (e.type === "object" || e.type === "array") && (typeof e.fields == "object" || typeof e.defaultField == "object");
  return s = s && (e.required || !e.required && t.value), s;
}, Xo = (e, t) => {
  let s = {};
  function n(i, r) {
    return {
      ...r,
      fullField: `${e.fullField}.${i}`
    };
  }
  if (e.defaultField)
    for (const i in t.value)
      A.call(t.value, i) && (s[i] = e.defaultField);
  s = {
    ...s,
    ...t.rule.fields
  };
  for (const i in s)
    if (A.call(s, i)) {
      const r = Array.isArray(s[i]) ? s[i] : [s[i]];
      s[i] = r.map(n.bind(null, i));
    }
  return s;
}, Go = (e) => (Array.isArray(e) || (e = [e]), e), Zo = ({ rule: e, failds: t, options: s }) => (e.message ? t = [].concat(e.message).map(fs(e)) : s.error ? t = [s.error(e, te(s.messages.required, e.field))] : t = [], t), Vo = ({ data: e, options: t }) => {
  if (e.rule.options) {
    let { messages: s, error: n } = t;
    Object.assign(e.rule.options, { messages: s, error: n });
  }
}, Jo = ({ failds: e, doIt: t }) => (s) => {
  const n = [];
  e && e.length && n.push(...e), s && s.length && n.push(...s), t(n.length ? n : null);
}, Qo = (e, t, s, n, i) => (r = []) => {
  let o = r;
  const a = Uo(t, i);
  if (o = Go(o), !e.suppressWarning && o.length && D.warning(), o.length && t.message && (o = [].concat(t.message)), o = o.map(fs(t)), e.first && o.length)
    return s[t.field] = 1, n(o);
  if (a) {
    if (t.required && !i.value)
      return o = Zo({ rule: t, failds: o, options: e }), n(o);
    const l = new D(Xo(t, i));
    l.messages(e.messages), Vo({ data: i, options: e }), l.validate(i.value, i.rule.options || e, Jo({ failds: o, doIt: n }));
  } else
    n(o);
};
D.prototype = {
  messages(e) {
    return e && (this._messages = Xt(D.getSystemMessage(), e)), this._messages;
  },
  /** 格式化检验规则并添加到实例上。
   *  rules格式化后的数据结构: { key: [ { type: 'xx', ...others } ] }
   */
  define(e) {
    if (!e)
      throw new Error("Cannot configure a schema with no rules");
    if (Array.isArray(e) || typeof e != "object")
      throw new TypeError("Rules must be an object");
    this.rules = {};
    let t;
    Object.keys(e).forEach((s) => {
      A.call(e, s) && (t = e[s], this.rules[s] = Array.isArray(t) ? t : [t]);
    });
  },
  /** 将检验规则和源数据合并转化成新数据
   *  rules: { key: [rule1, rule2] }, source: { key: sourceData, key2: sourceData2 }
   *  series { key: [{ rule: rule1, value: sourceData, source, field: key }, ...] }
   */
  getSeries(e, t, s) {
    let n, i;
    const r = {};
    return (e.keys || Object.keys(this.rules)).forEach((a) => {
      n = this.rules[a], i = t[a], n.forEach((l) => {
        let f = l;
        typeof f.transform == "function" && (t === s && (t = { ...t }), t[a] = f.transform(i), i = t[a]), typeof f == "function" ? f = { validator: f } : f = { ...f }, f.validator = this.getValidationMethod(f), f.field = a, f.fullField = f.fullField || a, f.type = this.getType(f), e.custom && Object.assign(f, e.custom), f.validator && (r[a] = r[a] || [], r[a].push({ rule: f, value: i, source: t, field: a }));
      });
    }), r;
  },
  mergeMessage(e) {
    if (e.messages) {
      let t = this.messages();
      t === D.systemMessages && (t = D.getSystemMessage()), Xt(t, e.messages), e.messages = t;
    } else
      e.messages = this.messages();
  },
  validate(e, t = {}, s = () => {
  }) {
    let n = e, i = t, r = s;
    if (typeof i == "function" && (r = i, i = {}), !this.rules || Object.keys(this.rules).length === 0)
      return r && r(), Promise.resolve();
    const o = Yo(r);
    this.mergeMessage(i);
    const a = this.getSeries(i, n, e), l = {};
    return Yn(
      a,
      i,
      (f, u) => {
        const c = f.rule, h = Qo(i, c, l, u, f);
        let d;
        c.asyncValidator ? d = c.asyncValidator(c, f.value, h, f.source, i) : c.validator && (d = c.validator(c, f.value, h, f.source, i), d === !0 ? h() : d === !1 ? h(c.message || `${c.field} fails`) : Array.isArray(d) ? h(d) : d instanceof Error && h(d.message)), d && d.then && d.then(
          () => h(),
          (y) => h(y)
        );
      },
      (f) => {
        o(f);
      }
    );
  },
  getValidationMethod(e) {
    var n;
    if (zt(e.validator))
      return e.validator;
    const t = Object.keys(e), s = t.indexOf("message");
    return s > -1 && t.splice(s, 1), t.length === 1 && t[0] === "required" ? (n = D.validators) == null ? void 0 : n.required : D.validators[this.getType(e)] || !1;
  },
  getType(e) {
    if (e.type === void 0 && e.pattern instanceof RegExp && (e.type = "pattern"), typeof e.validator != "function" && e.type && !A.call(D.validators, e.type))
      throw new Error(te("Unknown rule type %s", e.type));
    return e.type || "string";
  }
};
D.register = (e, t) => {
  if (typeof t != "function")
    throw new TypeError("Cannot register a validator by type, validator is not a function");
  D.validators[e] = t;
};
D.validators = {};
D.warning = Kn;
D.messages = {};
D.systemMessages = {};
D.getDefaultMessage = () => {
};
D.getSystemMessage = () => {
};
function Un({ rule: e, checkValue: t, source: s, errors: n, options: i, type: r }) {
  e.required && (!A.call(s, e.field) || q(t, r || e.type)) && n.push(te(i.messages.required));
}
const ea = '^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|(".+"))', ta = new RegExp(
  ea + "@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,6}))$"
), se = {
  acceptImg: /\.(png|jpe?g|gif)$/,
  acceptFile: /\.(doc?x|xls?x|ppt?x|txt)$/,
  email: ta,
  fileSize: /^\d+(\.\d+)?[KMGTPEZY]?B$/i,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
  speczh: /^[0-9a-zA-Z_\u4E00-\u9FA5]+$/,
  specialch: /^[0-9a-zA-Z_\-.]+$/,
  specialch2: /^[0-9a-zA-Z_-]+$/,
  url: /^(([a-zA-Z]{3,}):)?\/\/([\w-]+\.)+[\w]+(\/[a-zA-Z- ./?%&=]*)?/i,
  version: /^\d+\.\d+(\.\d+)*$/
}, We = {
  integer: (e) => We.number(e) && /^[-]?[\d]+$/.test(e),
  float: (e) => We.number(e) && !We.integer(e),
  array: Array.isArray,
  regexp(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e);
    } catch {
      return !1;
    }
  },
  date: Le,
  number: (e) => z(Number(e)),
  object: (e) => xe(e) && !We.array(e),
  method: (e) => B(e) === "function",
  email: (e) => R(e) || !!e.match(se.email) && e.length < 255,
  url: (e) => R(e) || !!e.match(se.url),
  hex: (e) => R(e) || !!e.match(se.hex),
  digits: (e) => R(e) || /^\d+$/.test(e),
  time: (e) => R(e) || /^((0)[0-9]|1[0-9]|20|21|22|23):([0-5][0-9])$/.test(e),
  dateYM: (e) => R(e) || Ae(e, "yyyy-MM") === e,
  dateYMD: (e) => R(e) || Ae(e, "yyyy-MM-dd") === e,
  dateTime: (e) => R(e) || Ae(e, "yyyy-MM-dd hh:mm") === e,
  longDateTime: (e) => R(e) || Ae(e, "yyyy-MM-dd hh:mm:ss") === e,
  version: (e) => R(e) || !!e.match(se.version),
  speczh: (e) => R(e) || !!e.match(se.speczh),
  specialch: (e) => R(e) || !!e.match(se.specialch),
  specialch2: (e) => R(e) || !!e.match(se.specialch2),
  acceptImg: (e) => R(e) || !!e.match(se.acceptImg),
  acceptFile: (e) => R(e) || !!e.match(se.acceptFile),
  fileSize: (e) => R(e) || !!e.match(se.fileSize)
};
function sa(e, t, s, n, i) {
  if (e.required && t === void 0) {
    Un({ rule: e, checkValue: t, source: s, errors: n, options: i });
    return;
  }
  const r = [
    "array",
    "acceptImg",
    "acceptFile",
    "date",
    "digits",
    "dateTime",
    "dateYM",
    "dateYMD",
    "email",
    "float",
    "fileSize",
    "hex",
    "integer",
    "longDateTime",
    "method",
    "number",
    "object",
    "regexp",
    "speczh",
    "specialch",
    "specialch2",
    "time",
    "version",
    "url"
  ], o = e.type;
  r.includes(o) ? We[o](t) || n.push(te(i.messages.types[o], e.type)) : o && typeof t !== e.type && n.push(te(i.messages.types[o], e.type));
}
function na({ min: e, max: t, val: s, key: n, rule: i, errors: r, util: o, options: a }) {
  e && !t && s < i.min ? r.push(o.format(a.messages[n].min, i.min)) : t && !e && s > i.max ? r.push(o.format(a.messages[n].max, i.max)) : e && t && (s < i.min || s > i.max) && r.push(o.format(a.messages[n].range, i.min, i.max));
}
function ra(e, t, s, n, i) {
  const r = z(e.len), o = z(e.min), a = z(e.max);
  let l = t, f = e.type;
  const u = z(t), c = typeof t == "string", h = Array.isArray(t);
  if (u ? f ?? (f = "number") : c ? f ?? (f = "string") : h && (f ?? (f = "array")), !f)
    return !1;
  h && (l = t.length), c && (l = Li(t, "string")), e.type === "number" && (l = t), r ? l !== e.len && n.push(te(i.messages[f].len, e.len)) : na({ min: o, max: a, val: l, key: f, rule: e, errors: n, util: Ko, options: i });
}
const _e = "enum";
function ia(e, t, s, n, i) {
  e[_e] = Array.isArray(e[_e]) ? e[_e] : [], e[_e].includes(t) || n.push(te(i.messages[_e], e[_e].join(", ")));
}
function oa(e, t, s, n, i) {
  e.pattern && (e.pattern instanceof RegExp ? (e.pattern.lastIndex = 0, e.pattern.test(t) || n.push(te(i.messages.pattern.mismatch, t, e.pattern))) : typeof e.pattern == "string" && (new RegExp(e.pattern).test(t) || n.push(te(i.messages.pattern.mismatch, t, e.pattern))));
}
function aa(e, t, s, n, i) {
  (/^\s+$/.test(t) || t === "") && n.push(te(i.messages.whitespace));
}
const _ = {
  type: sa,
  range: ra,
  pattern: oa,
  required: Un,
  whitespace: aa,
  enum: ia
};
function la(e, t, s, n, i) {
  const r = [], o = e.required || !e.required && A.call(n, e.field), a = (l) => l && typeof l == "string" && new Date(l).toString() !== "Invalid Date";
  if (o) {
    if (q(t) && !e.required)
      return s();
    if (_.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), !q(t)) {
      let l;
      typeof t == "number" || a(t) ? l = new Date(t) : l = t, _.type(e, l, n, r, i), l && typeof l.getTime == "function" && _.range(e, l.getTime(), n, r, i);
    }
  }
  s(r);
}
function H(e, t, s, n, i) {
  const r = e.type, o = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t, r) && !e.required)
      return s();
    _.required({
      rule: e,
      checkValue: t,
      source: n,
      errors: o,
      options: i,
      type: r
    }), q(t, r) || _.type(e, t, n, o, i);
  }
  s(o);
}
function ca(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t) && !e.required)
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), t !== void 0 && (_.type(e, t, n, r, i), _.range(e, t, n, r, i));
  }
  s(r);
}
function fa(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t, "array") && !e.required)
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i, type: "array" }), q(t, "array") || (_.type(e, t, n, r, i), _.range(e, t, n, r, i));
  }
  s(r);
}
function ua(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t, "string") && !e.required)
      return s();
    _.required({
      rule: e,
      checkValue: t,
      source: n,
      errors: r,
      options: i,
      type: "string"
    }), q(t, "string") || (_.type(e, t, n, r, i), _.range(e, t, n, r, i), _.pattern(e, t, n, r, i), e.whitespace === !0 && _.whitespace(e, t, n, r, i));
  }
  s(r);
}
function nt(e, t, s, n, i) {
  const r = e.required || !e.required && A.call(n, e.field), o = [];
  if (r) {
    if (!e.required && q(t))
      return s([]);
    _.required({ rule: e, checkValue: t, source: n, errors: o, options: i }), t !== void 0 && _.type(e, t, n, o, i);
  }
  s(o);
}
function da(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (t === "" && (t = void 0), !e.required && q(t))
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), t !== void 0 && (_.type(e, t, n, r, i), _.range(e, t, n, r, i));
  }
  s(r);
}
function ha(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t) && !e.required)
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), t !== void 0 && t !== "" && (_.type(e, t, n, r, i), _.range(e, t, n, r, i));
  }
  s(r);
}
function pa(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t, "string") && !e.required)
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), q(t, "string") || _.pattern(e, t, n, r, i);
  }
  s(r);
}
function ga(e, t, s, n, i) {
  const r = [], o = Array.isArray(t) ? "array" : typeof t;
  _.required({ rule: e, checkValue: t, source: n, errors: r, options: i, type: o }), s(r);
}
const ma = "enum";
function ya(e, t, s, n, i) {
  const r = [];
  if (e.required || !e.required && A.call(n, e.field)) {
    if (q(t) && !e.required)
      return s();
    _.required({ rule: e, checkValue: t, source: n, errors: r, options: i }), t !== void 0 && _[ma](e, t, n, r, i);
  }
  s(r);
}
const ba = {
  date: la,
  float: ca,
  array: fa,
  string: ua,
  method: nt,
  number: da,
  integer: ha,
  pattern: pa,
  required: ga,
  hex: H,
  url: H,
  time: H,
  email: H,
  digits: H,
  dateYM: H,
  speczh: H,
  dateYMD: H,
  version: H,
  fileSize: H,
  regexp: nt,
  object: nt,
  dateTime: H,
  specialch: H,
  boolean: nt,
  acceptImg: H,
  specialch2: H,
  acceptFile: H,
  longDateTime: H,
  enum: ya
}, wa = (e) => ({
  string: e("validation.types.string"),
  method: e("validation.types.method"),
  array: e("validation.types.array"),
  object: e("validation.types.object"),
  number: e("validation.types.number"),
  date: e("validation.types.date"),
  boolean: e("validation.types.boolean"),
  integer: e("validation.types.integer"),
  float: e("validation.types.float"),
  regexp: e("validation.types.regexp"),
  email: e("validation.types.email"),
  url: e("validation.types.url"),
  hex: e("validation.types.hex"),
  digits: e("validation.types.digits"),
  time: e("validation.types.time"),
  dateYM: e("validation.types.dateYM"),
  dateYMD: e("validation.types.dateYMD"),
  dateTime: e("validation.types.dateTime"),
  longDateTime: e("validation.types.longDateTime"),
  version: e("validation.types.version"),
  speczh: e("validation.types.speczh"),
  specialch: e("validation.types.specialch"),
  specialch2: e("validation.types.hex"),
  acceptImg: e("validation.types.acceptImg"),
  acceptFile: e("validation.types.acceptFile"),
  fileSize: e("validation.types.fileSize")
}), va = (e = (t) => t) => ({
  default: e("validation.default"),
  required: e("validation.required"),
  enum: e("validation.enum"),
  whitespace: e("validation.whitespace"),
  date: {
    format: e("validation.date.format"),
    parse: e("validation.date.parse"),
    invalid: e("validation.date.invalid")
  },
  types: wa(e),
  string: {
    len: e("validation.string.len"),
    min: e("validation.string.min"),
    max: e("validation.string.max"),
    range: e("validation.string.range")
  },
  number: {
    len: e("validation.number.len"),
    min: e("validation.number.min"),
    max: e("validation.number.max"),
    range: e("validation.number.range")
  },
  array: {
    len: e("validation.array.len"),
    min: e("validation.array.min"),
    max: e("validation.array.max"),
    range: e("validation.array.range")
  },
  pattern: {
    mismatch: e("validation.pattern.mismatch")
  }
});
D.validators = ba;
D.getDefaultMessage = va;
const qc = D, Hc = (e, t, ...s) => {
  let n = !1;
  if (typeof e == "function" && typeof t == "string") {
    const i = document.createEvent("HTMLEvents");
    i.initEvent(t, !1, !0), i.preventDefault = () => {
      n = !0;
    }, s.unshift(i), s.unshift(t), e.apply(null, s);
  }
  return !n;
}, jc = (e) => !e || !e.target ? null : e.target.shadowRoot && e.composed && e.composedPath()[0] || e.target, Bc = (e, t) => {
  let s;
  if (e.target === null && t)
    s = t;
  else {
    const n = e.composedPath();
    e.target !== n[0] && (s = n[0]);
  }
  s && Object.defineProperty(e, "target", {
    get() {
      return s;
    },
    enumerable: !0,
    configurable: !0
  });
}, Sa = () => {
}, Wc = (e, { args: t = [], done: s, canceled: n, error: i }) => {
  if (e) {
    const r = e(...t);
    Or(r) ? r.then((o) => {
      o ? s() : n && n();
    }).catch(i || Sa) : r ? s() : n && n();
  } else
    s();
}, xa = function() {
  return S ? function(e) {
    setTimeout(() => e(Date.now()), 1e3 / 60);
  } : window.requestAnimationFrame.bind(window);
}(), Gt = (e) => {
  e.scheduled || (e.scheduled = !0, e.raf(Na.bind(null, e)));
}, Na = (e) => {
  const { reads: t, writes: s } = e;
  let n;
  try {
    e.runTasks(t), e.runTasks(s);
  } catch (i) {
    n = i;
  }
  if (e.scheduled = !1, (t.length || s.length) && Gt(e), n)
    if (e.catch)
      e.catch(n);
    else
      throw n;
}, $s = (e, t) => {
  const s = e.indexOf(t);
  return !!~s && !!e.splice(s, 1);
}, Ea = (e, t) => {
  for (let s in t)
    Object.hasOwnProperty.call(t, s) && (e[s] = t[s]);
};
class _a {
  constructor() {
    this.reads = [], this.writes = [], this.raf = xa.bind(window);
  }
  runTasks(t) {
    let s;
    for (; s = t.shift(); ) s();
  }
  measure(t, s) {
    const n = s ? t.bind(s) : t;
    return this.reads.push(n), Gt(this), n;
  }
  mutate(t, s) {
    const n = s ? t.bind(s) : t;
    return this.writes.push(n), Gt(this), n;
  }
  clear(t) {
    return $s(this.reads, t) || $s(this.writes, t);
  }
  extend(t) {
    if (!t || typeof t != "object") throw new Error("[TINY][FastDom] expected object");
    const s = Object.create(this);
    return Ea(s, t), s.fastdom = this, s.initialize && s.initialize(), s;
  }
}
const Xn = new _a(), zs = (e, t, s, n) => {
  const i = e._tasks, r = e.fastdom;
  let o;
  const a = new Promise(function(l, f) {
    o = r[t](function() {
      i.delete(a);
      try {
        l(n ? s.call(n) : s());
      } catch (u) {
        f(u);
      }
    }, n);
  });
  return i.set(a, o), a;
}, Aa = {
  initialize() {
    this._tasks = /* @__PURE__ */ new Map();
  },
  mutate(e, t) {
    return zs(this, "mutate", e, t);
  },
  measure(e, t) {
    return zs(this, "measure", e, t);
  },
  clear(e) {
    const t = this._tasks, s = t.get(e);
    this.fastdom.clear(s), t.delete(e);
  }
}, Kc = Xn.extend(Aa), Ma = (e, t) => {
  let s = t.length;
  for (; s--; )
    e.clear(t[s]), t.splice(s, 1);
}, Ta = (e, t) => {
  const s = e.indexOf(t);
  return !!~s && !!e.splice(s, 1);
};
class Da {
  constructor(t) {
    this.fastdom = t, this.tasks = [];
  }
  measure(t, s) {
    const n = this.tasks, i = this.fastdom.measure(function() {
      return n.splice(n.indexOf(i)), t.call(s);
    });
    return n.push(i), i;
  }
  mutate(t, s) {
    const n = this.tasks, i = this.fastdom.mutate(function() {
      return n.splice(n.indexOf(i)), t.call(s);
    });
    return this.tasks.push(i), i;
  }
  clear(t) {
    return arguments.length || Ma(this.fastdom, this.tasks), Ta(this.tasks, t), this.fastdom.clear(t);
  }
}
const Ca = {
  sandbox() {
    return new Da(this.fastdom);
  }
}, Yc = Xn.extend(Ca), Oa = [
  "fullscreenElement",
  "fullscreenEnabled",
  "requestFullscreen",
  "exitFullscreen",
  "fullscreenchange",
  "fullscreenerror"
], Fa = [
  "mozFullScreenElement",
  "mozFullScreenEnabled",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror"
], ka = [
  "webkitFullscreenElement",
  "webkitFullscreenEnabled",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror"
], Ra = [
  "msFullscreenElement",
  "msFullscreenEnabled",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError"
], Ct = [Oa, ka, Fa, Ra], oe = typeof window < "u" && typeof window.document < "u" ? window.document : {};
let I = null;
const Ia = () => {
  if (!S)
    for (let e = 0, t = Ct.length; e < t; e++) {
      let s = Ct[e];
      if (s && s[1] in oe) {
        for (I = {}, e = 0; e < s.length; e++)
          I[Ct[0][e]] = s[e];
        return;
      }
    }
};
Ia();
const qs = {
  change: I && I.fullscreenchange,
  error: I && I.fullscreenerror
}, U = {
  request(e, t) {
    return new Promise((s, n) => {
      const i = () => {
        this.off("change", i), s();
      };
      if (this.on("change", i), e = e || (S ? null : oe.documentElement), e && I && e[I.requestFullscreen]) {
        const r = e[I.requestFullscreen](t);
        r instanceof Promise && r.then(i).catch(n);
      } else
        n(new Error("Fullscreen API not supported or element is null."));
    });
  },
  exit() {
    return new Promise((e, t) => {
      if (!this.isFullscreen) {
        e();
        return;
      }
      const s = () => {
        this.off("change", s), e();
      };
      if (this.on("change", s), !S && I && oe[I.exitFullscreen]) {
        const n = oe[I.exitFullscreen]();
        n instanceof Promise && n.then(s).catch(t);
      } else
        t(new Error("Fullscreen API not supported."));
    });
  },
  toggle(e, t) {
    return this.isFullscreen ? this.exit() : this.request(e, t);
  },
  onchange(e) {
    this.on("change", e);
  },
  onerror(e) {
    this.on("error", e);
  },
  on(e, t) {
    const s = qs[e];
    s && !S && Z(oe, s, t);
  },
  off(e, t) {
    const s = qs[e];
    s && !S && ne(oe, s, t);
  },
  raw: I || {}
};
S ? Object.defineProperties(U, {
  isFullscreen: {
    get() {
      return !1;
    }
  },
  element: {
    enumerable: !0,
    get() {
      return null;
    }
  },
  isEnabled: {
    enumerable: !0,
    get() {
      return !1;
    }
  }
}) : Object.defineProperties(U, {
  isFullscreen: {
    get() {
      return !!oe[I && I.fullscreenElement];
    }
  },
  element: {
    enumerable: !0,
    get() {
      return oe[I && I.fullscreenElement];
    }
  },
  isEnabled: {
    enumerable: !0,
    get() {
      return !!oe[I && I.fullscreenEnabled];
    }
  }
});
const La = {
  callback: () => {
  },
  fullscreenClass: "fullscreen",
  pageOnly: !1,
  teleport: !1
};
let yt, Ce;
const Gn = (e, t) => {
  e.style.position = t.position, e.style.left = t.left, e.style.top = t.top, e.style.width = t.width, e.style.height = t.height, e.style.zIndex = t.zIndex;
}, Hs = (e) => {
  const t = e.targetElement;
  t && (t.classList.remove(e.opts.fullscreenClass), (e.opts.teleport || e.opts.pageOnly) && (e.opts.teleport && Ce && (Ce.insertBefore(t, yt), Ce.removeChild(yt)), t.__styleCache && Gn(t, t.__styleCache)));
}, Pa = (e, t) => {
  const { position: s, left: n, top: i, width: r, height: o, zIndex: a } = e.style;
  if (e.classList.add(t.fullscreenClass), t.teleport || t.pageOnly) {
    const l = {
      position: "fixed",
      left: "0",
      top: "0",
      width: "100%",
      height: "100%"
    };
    e.__styleCache = { position: s, left: n, top: i, width: r, height: o, zIndex: a }, t.zIndex && (l.zIndex = t.zIndex), Gn(e, l);
  }
}, $a = (e, t, s) => (t = ke({}, La, t), s === document.body && (t.teleport = !1), e.isEnabled || (t.pageOnly = !0), t), Ie = {
  targetElement: null,
  opts: null,
  isEnabled: U.isEnabled,
  isFullscreen: !1,
  toggle(e, t, s) {
    return s === void 0 ? this.isFullscreen ? this.exit() : this.request(e, t) : s ? this.request(e, t) : this.exit();
  },
  request(e, t) {
    if (this.isFullscreen)
      return Promise.resolve();
    if (e || (e = document.body), this.opts = $a(U, t, e), Pa(e, this.opts), this.opts.teleport && (Ce = e.parentNode, Ce && (yt = document.createComment("fullscreen-token"), Ce.insertBefore(yt, e), document.body.appendChild(e))), this.opts.pageOnly) {
      const s = (n) => {
        n.key === "Escape" && (ne(document, "keyup", s), this.exit());
      };
      return this.isFullscreen = !0, this.targetElement = e, ne(document, "keyup", s), Z(document, "keyup", s), this.opts.callback && this.opts.callback(this.isFullscreen), Promise.resolve();
    } else {
      const s = () => {
        U.isFullscreen || (U.off("change", s), Hs(this)), this.isFullscreen = U.isFullscreen, this.targetElement = this.opts.teleport ? e || null : U.targetElement, this.opts.callback && this.opts.callback(U.isFullscreen);
      };
      return U.on("change", s), U.request(this.opts.teleport ? document.body : e);
    }
  },
  exit() {
    return this.isFullscreen ? this.opts.pageOnly ? (Hs(this), this.isFullscreen = !1, this.targetElement = null, this.opts.callback && this.opts.callback(this.isFullscreen), Promise.resolve()) : U.exit() : Promise.resolve();
  }
};
Ie.support = Ie.isEnabled;
Ie.getState = () => Ie.isFullscreen;
Ie.enter = Ie.request;
const Oe = "$treeNodeId", za = function(e, t) {
  return e ? t[e] : t[Oe];
}, js = function(e, t) {
  !t || t[Oe] || Object.defineProperty(t, Oe, {
    value: e.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, Ot = "children", Bs = "isLeaf", rt = (e, t) => {
  const s = e.store.props, n = e.data || {}, i = s[t];
  if (B(i) === "string")
    return n[i];
  if (B(i) === "function")
    return i(n, e);
  if (typeof i > "u") {
    const r = n[t];
    return r === void 0 ? "" : r;
  }
}, Zt = (e) => {
  let t = !0, s = !0, n = !0;
  for (let r = 0, o = e.length; r < o; r++) {
    const { checked: a, disabled: l, indeterminate: f } = e[r];
    (a !== !0 || f) && (t = !1, l || (n = !1)), (a !== !1 || f) && (s = !1);
  }
  return { all: t, none: s, allWithoutDisable: n, half: !t && !s };
}, lt = (e) => {
  const t = e.childNodes;
  if (t.length === 0)
    return;
  const { all: s, none: n, half: i } = Zt(t);
  s ? Object.assign(e, { checked: !0, indeterminate: !1 }) : i ? Object.assign(e, { checked: !1, indeterminate: !0 }) : n && Object.assign(e, { checked: !1, indeterminate: !1 });
  const r = e.parent;
  !r || r.level === 0 || !e.store.checkStrictly && lt(r);
};
let qa = 0;
class Ue {
  constructor(t) {
    this.init(t);
    const s = this.store;
    if (!s)
      throw new Error("[TINY-Tree][Node]store is required!");
    s.registerNode(this);
    const n = s.props;
    if (n && typeof n.isLeaf < "u") {
      const a = rt(this, Bs);
      typeof a == "boolean" && (this.isLeafByUser = a);
    }
    if (this.initExpandState(), Array.isArray(this.data) || js(this, this.data), !this.data)
      return;
    this.expandByDefaultKeys();
    const { key: i, lazy: r, currentNodeKey: o } = s;
    i && o !== void 0 && this.key === o && (s.currentNode = this, s.currentNode.isCurrent = !0), r && s._initDefaultCheckedNode(this), this.updateLeafState();
  }
  initExpandState() {
    const { store: t, data: s, level: n } = this;
    t.lazy !== !0 && s ? (this.setData(s), t.defaultExpandAll && (this.expanded = !0, this.updateMethod(this, "expanded"))) : n > 0 && t.lazy && t.defaultExpandAll && this.expand();
  }
  init(t) {
    var n, i;
    this.id = qa++, this.checked = !1, this.indeterminate = !1, this.expanded = !1, this.visible = !0, this.isCurrent = !1, this.text = null, this.data = null, this.parent = null, this.updateMethod = () => {
    }, Object.keys(t).forEach((r) => {
      A.call(t, r) && (this[r] = t[r]);
    });
    const s = ((i = (n = this.store) == null ? void 0 : n.props) == null ? void 0 : i.isLeaf) || Bs;
    this.isLeaf = !!(this.data && this.data[s]), this.loaded = this.isLeaf, this.loading = !1, this.childNodes = [], this.level = this.parent ? this.parent.level + 1 : 0;
  }
  expandByDefaultKeys() {
    const { defaultExpandedKeys: t, key: s, autoExpandParent: n } = this.store;
    s && t && ~t.indexOf(this.key) && this.expand(null, n);
  }
  setData(t) {
    Array.isArray(t) || js(this, t), this.data = t, this.childNodes = [];
    let s;
    this.level === 0 && Array.isArray(this.data) ? s = this.data : s = rt(this, Ot) || [];
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      this.insertChild({ data: r });
    }
  }
  get key() {
    const { store: t, data: s } = this, n = t.key;
    return s ? s[n] : null;
  }
  get label() {
    return rt(this, "label");
  }
  get disabled() {
    return rt(this, "disabled");
  }
  get nextSibling() {
    const t = this.parent;
    if (t) {
      const s = t.childNodes, n = s.indexOf(this);
      if (~n)
        return s[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const t = this.parent;
    if (t) {
      const s = t.childNodes, n = s.indexOf(this);
      if (~n)
        return n > 0 ? s[n - 1] : null;
    }
    return null;
  }
  remove() {
    const t = this.parent;
    t && t.removeChild(this);
  }
  contains(t, s = !0) {
    const n = (i) => {
      const r = i.childNodes || [];
      let o = !1;
      for (let a = 0, l = r.length; a < l; a++) {
        const f = r[a];
        if (f === t || s && n(f)) {
          o = !0;
          break;
        }
      }
      return o;
    };
    return n(this);
  }
  insertChild(t, s, n) {
    if (!t)
      throw new Error("[TINY-Tree] insertChild error: child is required.");
    const i = ({ arr: r, index: o, item: a }) => {
      typeof o > "u" || o < 0 ? r.push(a) : r.splice(o, 0, a);
    };
    if (!(t instanceof Ue)) {
      if (!n) {
        const r = this.getChildren(!0) || [];
        ~r.indexOf(t.data) || i({ arr: r, index: s, item: t.data });
      }
      Ms(t, { parent: this, store: this.store }), t = new Ue(t);
    }
    return t.level = this.level + 1, i({ arr: this.childNodes, index: s, item: t }), this.updateLeafState(), t;
  }
  insertBefore(t, s) {
    let n;
    s && (n = this.childNodes.indexOf(s)), this.insertChild(t, n);
  }
  insertAfter(t, s) {
    let n;
    s && (n = this.childNodes.indexOf(s), ~n && (n += 1)), this.insertChild(t, n);
  }
  removeChild(t) {
    const s = this.getChildren() || [];
    let n = s.indexOf(t.data);
    ~n && s.splice(n, 1), n = this.childNodes.indexOf(t), ~n && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(n, 1)), this.updateLeafState();
  }
  removeChildByData(t) {
    let s = null;
    for (let n = 0, i = this.childNodes.length; n < i; n++) {
      const r = this.childNodes[n];
      if (r.data === t) {
        s = r;
        break;
      }
    }
    s && this.removeChild(s);
  }
  expand(t, s) {
    const n = () => {
      if (s) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i.updateMethod(i, "expanded"), i = i.parent;
      }
      this.expanded = !0, this.updateMethod(this, "expanded"), t && t();
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || lt(this), n());
    }) : n();
  }
  doCreateChildren(t, s = {}) {
    t.forEach((n) => {
      this.insertChild(Ms({ data: n }, s), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.updateMethod(this, "expanded");
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    const { store: t, loaded: s, isLeafByUser: n } = this, i = t.lazy;
    if (i === !0 && s !== !0 && typeof n < "u") {
      this.isLeaf = n;
      return;
    }
    const r = this.childNodes;
    if (!i || i === !0 && s === !0) {
      this.isLeaf = !r || r.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  getChildren(t = !1) {
    const { level: s, data: n } = this;
    if (s === 0)
      return n;
    if (!n)
      return null;
    const i = this.store.props;
    let r = Ot;
    return i && (r = i.children || Ot), n[r] === void 0 && (n[r] = null), t && !n[r] && (n[r] = []), n[r];
  }
  setChecked(t, s, n, i, r) {
    this.checked = t === !0, this.indeterminate = t === "half";
    const { checkStrictly: o, checkDescendants: a } = this.store;
    if (o && !r)
      return;
    let l = this.setCheckedInner({
      checkDescendants: a,
      value: t,
      isDeepChecked: s,
      passValue: i,
      checkEasily: r
    }), f = l.returnFlag;
    if (i = l.passValue, t = l.value, f || o && r)
      return;
    const u = this.parent;
    !u || u.level === 0 || n || lt(u);
  }
  setCheckedInner({ checkDescendants: t, value: s, isDeepChecked: n, passValue: i, checkEasily: r }) {
    let o = !1;
    if (this.shouldLoadData() && !t)
      return { value: s, passValue: i, returnFlag: o };
    const { all: a, allWithoutDisable: l } = Zt(this.childNodes);
    !this.isLeaf && !a && l && !r && (this.checked = !1, s = !1);
    const f = () => {
      if (n) {
        const u = this.childNodes;
        for (let d = 0, y = u.length; d < y; d++) {
          const b = u[d];
          i = i || s !== !1;
          const p = b.disabled ? b.checked : i;
          b.setChecked(p, n, !0, i, r);
        }
        const { half: c, all: h } = Zt(u);
        !h && !r && (this.checked = h, this.indeterminate = c);
      }
    };
    if (this.shouldLoadData()) {
      const u = () => {
        f(), lt(this);
      };
      this.loadData(u, { checked: s !== !1 }), o = !0;
    } else
      f();
    return { value: s, passValue: i, returnFlag: o };
  }
  updateChildren() {
    const t = this.getChildren() || [], s = this.childNodes.map((r) => r.data), n = {}, i = [];
    t.forEach((r, o) => {
      const a = r[Oe];
      !!a && wt(s, a, (f, u) => f[Oe] === u) >= 0 ? n[a] = { index: o, data: r } : i.push({ index: o, data: r });
    }), this.store.lazy || s.forEach((r) => {
      n[r[Oe]] || this.removeChildByData(r);
    }), i.forEach(({ data: r, index: o }) => {
      this.insertChild({ data: r }, o);
    }), this.updateLeafState();
  }
  loadData(t, s = {}) {
    const { lazy: n, load: i } = this.store;
    n === !0 && i && !this.loaded && (!this.loading || Object.keys(s).length) ? (this.loading = !0, this.store.load(this, (r) => {
      this.loading = !1, this.loaded = !0, this.childNodes = [], this.doCreateChildren(r, s), this.updateLeafState(), t && t.call(this, r), typeof this.store.afterLoad == "function" && this.store.afterLoad({ data: r });
    })) : t && t.call(this);
  }
  getPathData(t) {
    const s = [t ? this.data[t] : this.data];
    let n = this.parent;
    for (; n && n.parent; )
      s.unshift(t ? n.data[t] : n.data), n = n.parent;
    return s;
  }
  getPathText(t, s = ",") {
    return (this.getPathData(t) || []).join(s);
  }
}
class Uc {
  constructor(t) {
    x(this, "currentNode", null);
    x(this, "currentNodeKey", null);
    x(this, "nodesMap", {});
    x(this, "root");
    x(this, "data");
    x(this, "lazy", !1);
    x(this, "load");
    x(this, "afterLoad");
    x(this, "props", {});
    x(this, "filterNodeMethod");
    x(this, "key", "");
    x(this, "defaultCheckedKeys", []);
    x(this, "checkStrictly", !1);
    x(this, "defaultExpandedKeys", []);
    x(this, "autoExpandParent", !0);
    this.currentNode = null, this.currentNodeKey = null;
    for (let s in t)
      A.call(t, s) && (this[s] = t[s]);
    this.nodesMap = {}, this.root = new Ue({ data: this.data, store: this }), this.lazy && this.load ? this.load(this.root, (s) => {
      this.root.doCreateChildren(s), this._initDefaultCheckedNodes(), typeof this.afterLoad == "function" && this.afterLoad({ data: s, init: !0 });
    }) : this._initDefaultCheckedNodes();
  }
  getMappingData(t) {
    const s = this.props || {}, n = {};
    for (let i in s)
      A.call(s, i) && (n[i] = t[s[i]]);
    return { ...t, ...n };
  }
  filter(t) {
    const { lazy: s, filterNodeMethod: n, getMappingData: i } = this, r = (o) => {
      const a = o.root ? o.root.childNodes : o.childNodes;
      if (a.forEach((l) => {
        const f = i.call(this, l.data);
        n && (l.visible = n.call(l, t, f, l)), r(l);
      }), !o.visible && a.length) {
        let l = !a.some(({ visible: f }) => f);
        o.root ? o.root.visible = l === !1 : o.visible = l === !1;
      }
      t && o.visible && !o.isLeaf && !s && o.expand(null, this.autoExpandParent);
    };
    r(this);
  }
  setData(t) {
    t !== this.root.data ? (this.root.setData(t), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(t) {
    if (t instanceof Ue)
      return t;
    const s = typeof t != "object" ? t : za(this.key, t);
    return this.nodesMap[s] || null;
  }
  insertBefore(t, s) {
    const n = this.getNode(s);
    n && n.parent && n.parent.insertBefore({ data: t }, n);
  }
  insertAfter(t, s) {
    const n = this.getNode(s);
    n && n.parent && n.parent.insertAfter({ data: t }, n);
  }
  remove(t, s, n) {
    const i = n ? t : this.getNode(t);
    i && i.parent && (i === this.currentNode && (this.currentNode = null), s && i.childNodes && i.childNodes.forEach((r) => {
      i.parent.insertChild({ data: r.data });
    }), i.parent.removeChild(i));
  }
  append(t, s, n) {
    const i = s ? this.getNode(s) : this.root;
    if (i) {
      const r = i.insertChild({ data: t }, n);
      t._isNewNode && this.registerNode(r);
    }
  }
  setDefaultCheckedKey(t) {
    t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
  }
  _initDefaultCheckedNodes() {
    const t = this.defaultCheckedKeys || [], s = this.nodesMap;
    t.forEach((n) => {
      const i = s[n];
      i && i.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(t) {
    ~(this.defaultCheckedKeys || []).indexOf(t.key) && t.setChecked(!0, !this.checkStrictly);
  }
  getCheckedKeys(t = !1) {
    return this.getCheckedNodes(t).map((s) => (s || {})[this.key]);
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
  }
  deregisterNode(t) {
    !this.key || !t || !t.data || (t.childNodes.forEach((n) => {
      this.deregisterNode(n);
    }), delete this.nodesMap[t.key]);
  }
  registerNode(t) {
    if (!this.key || !t || !t.data)
      return;
    const n = t.key;
    n !== void 0 && (this.nodesMap[n] = t);
  }
  getCheckedNodes(t = !1, s = !1, n = !1) {
    const i = [], r = (o) => {
      (o.root ? o.root.childNodes : o.childNodes).forEach((l) => {
        const { checked: f, indeterminate: u, isLeaf: c, data: h } = l;
        (f || s && u) && (!t || t && c) && i.push(n ? l : h), r(l);
      });
    };
    return r(this), i;
  }
  getHalfCheckedNodes() {
    const t = [], s = (n) => {
      (n.root ? n.root.childNodes : n.childNodes).forEach((r) => {
        const { indeterminate: o, data: a } = r;
        o && t.push(a), s(r);
      });
    };
    return s(this), t;
  }
  _getAllNodes() {
    const t = [], s = this.nodesMap;
    return Object.keys(s).forEach((n) => {
      A.call(s, n) && t.push(s[n]);
    }), t;
  }
  updateChildren(t, s) {
    const n = this.nodesMap[t];
    if (!n)
      return;
    const i = n.childNodes;
    for (let r = i.length - 1; r >= 0; r--)
      this.remove(i[r].data, !1, !1);
    for (let r = 0, o = s.length; r < o; r++) {
      const a = s[r];
      this.append(a, n.data);
    }
  }
  _setCheckedKeys(t, s = !1, n = {}) {
    const i = this._getAllNodes().sort((a, l) => l.level - a.level), r = /* @__PURE__ */ Object.create(null), o = Object.keys(n);
    i.forEach((a) => {
      a.setChecked(!1, !1);
    });
    for (let a = 0, l = i.length; a < l; a++) {
      const f = i[a], u = f.data[t].toString();
      if (!~o.indexOf(u))
        f.checked && !r[u] && f.setChecked(!1, !1);
      else {
        let h = f.parent;
        for (; h && h.level > 0; )
          r[h.data[t]] = !0, h = h.parent;
        if (f.isLeaf || this.checkStrictly)
          f.setChecked(!0, !1);
        else if (s) {
          f.setChecked(!1, !1);
          const d = (y) => {
            y.childNodes.forEach((p) => {
              !p.isLeaf && p.setChecked(!1, !1), d(p);
            });
          };
          d(f);
        } else
          f.setChecked(!0, !0);
      }
    }
  }
  setDefaultExpandedKeys(t) {
    t = t || [], this.defaultExpandedKeys = t, t.forEach((s) => {
      const n = this.getNode(s);
      n && n.expand(null, this.autoExpandParent);
    });
  }
  setCheckedKeys(t, s = !1) {
    this.defaultCheckedKeys = t;
    const n = {};
    t.forEach((i) => {
      n[i] = !0;
    }), this._setCheckedKeys(this.key, s, n);
  }
  setCheckedNodes(t, s = !1) {
    const n = this.key, i = {};
    t.forEach((r) => {
      i[(r || {})[n]] = !0;
    }), this._setCheckedKeys(n, s, i);
  }
  setChecked(t, s, n) {
    const i = this.getNode(t);
    i && i.setChecked(!!s, n);
  }
  setCurrentNode(t) {
    const s = this.currentNode;
    s && (s.isCurrent = !1), this.currentNode = t, t && (this.currentNode.isCurrent = !0);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNodeKey(t) {
    if (V(t)) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const s = this.getNode(t);
    s && this.setCurrentNode(s);
  }
  setUserCurrentNode(t) {
    const s = t[this.key], n = this.nodesMap[s];
    this.setCurrentNode(n);
  }
  getData(t) {
    return (this.getNode(t) || {}).data;
  }
  getAllData() {
    const t = this.props.children, s = (n) => n.map((i) => ({ ...i.data, [t]: s(i.childNodes) }));
    return s(this.root.childNodes);
  }
}
const Ws = "after-leave", Ha = 300;
function Xc(e, t, s = Ha, n = !1) {
  if (!e || !t)
    throw new Error("instance & callback is required");
  let i = !1;
  const r = function() {
    i || (i = !0, typeof t == "function" && t.apply(null, arguments));
  };
  n ? e.$once(Ws, r) : e.$on(Ws, r), setTimeout(r, s + 100);
}
function Ks(e, t, s, n) {
  let i, r = 0;
  typeof t != "boolean" && (n = s, s = t, t = void 0);
  function o() {
    const l = this, f = (/* @__PURE__ */ new Date()).valueOf() - r, u = arguments;
    function c() {
      r = (/* @__PURE__ */ new Date()).valueOf(), s.apply(l, u);
    }
    function h() {
      i = void 0;
    }
    n && !i && c(), i && clearTimeout(i);
    const d = n === void 0;
    d && f > e ? c() : t !== !0 && (i = setTimeout(n ? h : c, d ? e - f : e));
  }
  function a() {
    i && (clearTimeout(i), i = null);
  }
  return o._cancel = a, o;
}
function Gc(e, t, s) {
  return s === void 0 ? Ks(e, t, !1) : Ks(e, s, t !== !1);
}
let ve = null;
const ja = "ws://localhost", Ys = [27197, 27198, 27199];
let Ft = 0, Se, Zn = 1e3, Vn = 3e4, Ba = 0, us = {}, Jn;
const Wa = 20 * 1e3;
let Us = null, Qn = null, Vt = {}, er = {}, k = {}, tr = () => {
}, sr = () => {
};
const nr = function(e) {
  clearTimeout(Vt[e]), delete us[e], delete Vt[e];
}, Ka = function() {
  Qn = setTimeout(() => {
    ve.close();
  }, 5e3);
}, ae = function(e, t) {
  let s = Ba++;
  if (s = String(s), e.cid = s, !Se) {
    t && setTimeout(t, 0, { ok: !1, message: "eSpace is not logged in." });
    return;
  }
  typeof t == "function" && (us[s] = t, Vt[s] = setTimeout(() => {
    t({ ok: !1, message: "time out" }), nr(s);
  }, Vn)), ve.send(JSON.stringify(e));
}, rr = function() {
  Us = setTimeout(() => {
    Se ? ae(
      {
        type: "heartbeat"
      },
      () => {
        rr();
      }
    ) : clearTimeout(Us);
  }, Wa);
}, Ya = function(e) {
  Se = !0, rr(), clearTimeout(Jn), clearTimeout(Qn), sr(e);
}, Ua = function(e) {
  let t = e.data;
  if (typeof t == "string" && (t = t.replace(/^\d+/, ""), !!t)) {
    try {
      t = JSON.parse(t);
    } catch (s) {
      return !s;
    }
    if (Se) {
      let s = er[t.type];
      if (s)
        return s(t.data);
      let n = t.cid, i = us[n];
      i && (t.ok ? i(null, t.data) : i({ ok: t.ok }), nr(n));
    } else
      t.type === "eSpace-ctrl-connection-success" ? Ya(t.data) : ve.close();
  }
}, Xa = function() {
  ve.onopen = Ka, ve.onclose = Ga, ve.onmessage = Ua;
}, ir = function(e) {
  Jn = setTimeout(() => {
    Ft >= Ys.length && (Ft = 0), ve = new WebSocket(ja + ":" + Ys[Ft++]), Xa();
  }, e || 0);
}, Ga = function() {
  (Se || typeof Se > "u") && (Se = !1, tr()), ir(Zn);
};
k.init = function(e) {
  e && (Vn = e.timeout || 3e4, Zn = e.pollingInterval || 0), ir();
};
k.ready = function(e) {
  sr = e;
};
k.error = function(e) {
  tr = e;
};
const Xs = function(e, t, s) {
  let n = [];
  for (let i = 0; i < t; i++) {
    let r = e;
    i && (r += i);
    let o = s[r];
    o && n.push(o);
  }
  return n;
};
k.on = function(e, t) {
  er[e] = t;
};
k.getUserInfo = function(e, t) {
  ae(
    {
      type: "get-user-info",
      param: e
    },
    function(n, i) {
      if (n)
        return t(n);
      const r = function(o) {
        return {
          account: o.account,
          name: o.name,
          mobile: Xs("mobile", 6, o),
          office_phone: Xs("office_phone", 6, o),
          home_phone: o.home_phone,
          ip_phone: o.ip_phone,
          other_phone: o.other_phone
        };
      };
      if (i.account)
        t(null, r(i));
      else {
        let o = {};
        for (let a in i)
          if (Object.prototype.hasOwnProperty.call(i, a)) {
            let l = i[a];
            o[a] = l && r(l);
          }
        t(null, o);
      }
    }
  );
};
k.subscribeUserStatus = function(e, t) {
  Array.isArray(e) && e.forEach((s) => {
  }), ae(
    {
      type: "subscribe-user-status",
      param: e
    },
    t
  );
};
k.eSpaceCall = function(e, t, s) {
  ae(
    {
      type: "espace-call",
      param: {
        account: e,
        number: t
      }
    },
    s
  );
};
k.eSpaceCallByAccount = function(e, t) {
  ae(
    {
      type: "espace-call",
      param: {
        account: e
      }
    },
    t
  );
};
k.eSpaceCallByNumber = function(e, t) {
  ae(
    {
      type: "espace-call",
      param: {
        number: e
      }
    },
    t
  );
};
k.showImDialog = function(e, t) {
  ae(
    {
      type: "show-espace-im-dialog",
      param: e
    },
    t
  );
};
k.showGroupDialog = function(e, t) {
  ae(
    {
      type: "show-espace-im-group-dialog",
      param: e
    },
    t
  );
};
k.addContactList = function(e, t) {
  ae(
    {
      type: "add-contact-list",
      param: e
    },
    t
  );
};
if (S || !window.WebSocket) {
  const e = function() {
  };
  for (let t in k)
    Object.prototype.hasOwnProperty.call(k, t) && typeof k[t] == "function" && (k[t] = e);
}
let Gs = !1;
function Zc() {
  return !Gs && !S && (localStorage.setItem("eSpaceCtrl_initialized", 0), k.init({ timeout: 3e3, pollingInterval: 1e3 }), k.ready(() => {
    localStorage.setItem("eSpaceCtrl_initialized", 1);
  }), k.error(() => {
    localStorage.setItem("eSpaceCtrl_initialized", 0);
  }), Gs = !0), k;
}
const Vc = k;
class Jc {
  constructor(t, s = {}) {
    if (t && typeof t == "object" ? s = t : t = [], typeof s.key != "string" || !s.key)
      throw new Error("Memorize Initialization error.");
    this._prefix = "tiny_memorize_", this._customField1 = "frequency", this._customField2 = "time", this._sortBy = (s.sortBy || "frequency").toUpperCase(), this._sort = (s.sort || "desc").toUpperCase(), this._dataKey = s.dataKey || "value", this._highlightClass = s.highlightClass || "memorize-highlight", this._highlightNum = s.highlightNum || 1 / 0, this._cacheNum = s.cacheNum || 1 / 0, this._serialize = s.serialize || JSON.stringify, this._deserialize = s.deserialize || JSON.parse, this.setKey(s.key), this.assemble(t);
  }
  setKey(t) {
    this._storeKey = this._prefix + (t || Number(/* @__PURE__ */ new Date()));
  }
  getValue(t = !0) {
    const s = window.localStorage[this._storeKey] || "";
    if (s)
      try {
        const n = this._deserialize(s);
        return t ? this.sort(n) : n;
      } catch {
        return [];
      }
    return [];
  }
  setValue(t) {
    try {
      window.localStorage.setItem(this._storeKey, this._serialize(t));
    } catch {
      throw new Error("Memorize set localStorage error.");
    }
  }
  clear() {
    window.localStorage.removeItem(this._storeKey);
  }
  add(t) {
    const s = this.getValue(!1), n = {
      key: t
    };
    n[this._customField1] = 1, n[this._customField2] = Number(/* @__PURE__ */ new Date()), s.length < this._cacheNum && (s.push(n), this.setValue(s));
  }
  updateByKey(t) {
    let s = !1;
    const n = this.getValue(!1);
    n.some((i) => i.key === t ? (i[this._customField1] = (i[this._customField1] || 0) + 1, i[this._customField2] = Number(/* @__PURE__ */ new Date()), s = !0, !0) : !1), s ? this.setValue(n) : this.add(t);
  }
  sort(t) {
    return Array.isArray(t) ? t.sort((s, n) => {
      const i = this._sort === "DESC", r = i ? [-1, 1] : [1, -1], o = this._sortBy === "FREQUENCY" ? this._customField1 : this._customField2, a = s[o], l = n[o];
      return isNaN(a) ? i ? -1 : 1 : isNaN(l) ? -1 : a > l ? r[0] : r[1];
    }) : t;
  }
  assemble(t) {
    const s = this.getValue(!0);
    if (!(Array.isArray(t) && t.length) || !s.length)
      return t;
    let n = 0;
    const i = (r) => (o, a) => o[this._dataKey] === r.key ? (n++, t.splice(a, 1), n <= this._highlightNum && (o._highlightClass = this._highlightClass), t.unshift(o), !0) : !1;
    for (let r = s.length - 1; r > -1; r--) {
      const o = s[r];
      t.some(i(o));
    }
    return t;
  }
}
const it = {}, je = {
  leave: "v-modal-leave",
  enter: "v-modal-enter",
  modal: "v-modal"
}, Za = (e, t) => {
  for (let s = e.length - 1; s >= 0; s--)
    if (e[s].id === t) {
      e.splice(s, 1);
      break;
    }
};
let Jt;
const $ = {
  step: 2,
  zIndex: 2e3,
  globalScroll: !1,
  // 是否打开全局滚动监听
  modalFade: !0,
  modalStack: [],
  modalDom: null,
  // 当前model挂载的div.
  hasModal: !1,
  // 当前是否有Modal
  popLockClass: "popup-parent--hidden",
  oldBodyBorder: "",
  viewportWindow: null,
  fixBodyBorder() {
    const e = window.innerWidth - document.documentElement.clientWidth;
    e && (this.oldBodyBorder = document.documentElement.style.borderRight, document.body.style.borderRight = `${e}px solid transparent`);
  },
  resetBodyBorder() {
    document.body.style.borderRight = this.oldBodyBorder, this.oldBodyBorder = "";
  },
  /** 全局反注册 */
  deregister: (e) => {
    e && (it[e] = null, delete it[e]);
  },
  /** 返回全局实例 */
  getInstance: (e) => it[e],
  /** 全局注册   仅vue-popup.ts中使用，instance就是vm, 把vm注册到 vm._popupId 这个键值上 */
  register: (e, t) => {
    e && t && (it[e] = t);
  },
  nextZIndex: () => {
    const e = $.zIndex;
    return $.zIndex += $.step, e;
  },
  /** 打开遮罩层， 仅vue-popup.ts中使用。 dom = vm.$el 或者 undefined (appendtoBody时)  */
  openModal(e, t, s, n, i) {
    if (S || !e || t === void 0)
      return;
    this.modalFade = i;
    for (let a = 0, l = this.modalStack.length; a < l; a++)
      if (this.modalStack[a].id === e)
        return;
    const r = Jt();
    et(r, je.modal), this.modalFade && !$.hasModal && et(r, je.enter), n && n.trim().split(/\s+/).forEach((l) => et(r, l)), setTimeout(() => {
      tt(r, je.enter);
    }, 200), t && (r.style.zIndex = t.toString()), r.style.display = "", r.tabIndex = 0;
    let o;
    s && s.parentNode && s.parentNode.nodeType !== 11 ? o = s.parentNode : o = document.body, o.appendChild(r), this.modalStack.push({ id: e, zIndex: t, modalClass: n });
  },
  /** 点击背景遮罩层时，调用栈顶的popup，调用它的close() */
  doOnModalClick: () => {
    const e = $.modalStack, t = e[e.length - 1];
    if (!t)
      return;
    const s = $.getInstance(t.id);
    s && s.closeOnClickModal && typeof s.close == "function" && s.close();
  },
  closeModal(e) {
    const t = this.modalStack, s = Jt();
    if (t.length > 0) {
      const n = t[t.length - 1];
      if (n.id === e) {
        n.modalClass && n.modalClass.trim().split(/\s+/).forEach((o) => tt(s, o)), t.pop();
        const i = t.length;
        i > 0 && (s.style.zIndex = t[i - 1].zIndex.toString());
      } else
        Za(t, e);
    }
    t.length === 0 && (this.modalFade && et(s, je.leave), tt(document.body, this.popLockClass), this.resetBodyBorder(), setTimeout(() => {
      t.length === 0 && (s.parentNode && s.parentNode.removeChild(s), s.style.display = "none", $.modalDom = null), tt(s, je.leave);
    }, 200));
  }
};
Jt = () => {
  if (S)
    return null;
  let e = $.modalDom;
  return e ? $.hasModal = !0 : ($.hasModal = !1, e = document.createElement("div"), $.modalDom = e, e.addEventListener(
    "touchmove",
    (t) => {
      t.preventDefault(), t.stopPropagation();
    },
    { passive: !0 }
  ), Z(e, "click", () => {
    $.doOnModalClick();
  })), e;
};
S || Z(window, "keydown", (e) => {
  if (e.keyCode === mo.Escape) {
    const t = $.modalStack;
    if (t.length > 0) {
      const s = t[t.length - 1];
      if (!s)
        return;
      const n = $.getInstance(s.id);
      n && n.closeOnPressEscape && (n.handleClose ? n.handleClose("esc") : n.handleAction ? n.handleAction("cancel") : n.close());
    }
  }
});
const Va = ["left", "right", "top", "bottom"], or = ["shift", "offset", "preventOverflow", "keepTogether", "arrow", "flip", "applyStyle"], Ja = {
  arrowOffset: 0,
  arrowElement: "[x-arrow]",
  boundariesElement: "viewport",
  boundariesPadding: 5,
  flipBehavior: "flip",
  // 全局没有修改过它，所以它一直是flip
  forceAbsolute: !1,
  gpuAcceleration: !0,
  offset: 0,
  placement: "bottom",
  preventOverflowOrder: Va,
  modifiers: or,
  // 此处是string数组， 构造函数调用之后转为函数数组
  updateHiddenPopperOnScroll: !1
  // 滚动过程中是否更新隐藏的弹出层位置
}, ct = (e, t) => {
  const s = (n) => n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
  Object.keys(t).forEach((n) => {
    let i = "";
    ~["width", "height", "top", "right", "bottom", "left"].indexOf(n) && s(t[n]) && (i = "px"), e.style[n] = t[n] + i;
  });
}, kt = (e) => {
  let t = e.offsetParent;
  return t === window.document.body || !t ? window.document.documentElement : t;
}, ar = (e, t) => !e || e.nodeType !== 1 ? void 0 : window.getComputedStyle(e, null)[t], lr = (e) => e === window.document.body ? !1 : ar(e, "position") === "fixed" ? !0 : (e.host && (e = e.host), e.parentNode ? lr(e.parentNode) : !1), Qt = (e) => {
  let t = e.getBoundingClientRect();
  return {
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom,
    width: t.right - t.left,
    height: t.bottom - t.top
  };
}, cr = (e) => {
  if (!e || e.nodeType !== 1)
    return !1;
  const t = window.getComputedStyle(e, null), s = t.overflow, n = t.overflowX, i = t.overflowY, r = /(auto|scroll|overlay|clip)/;
  return (e.scrollHeight > e.clientHeight || e.scrollWidth > e.clientWidth) && r.test(s + i + n);
}, Qa = (e) => {
  const t = document.createElement("div");
  ct(t, {
    opacity: 0,
    position: "fixed",
    width: 1,
    height: 1,
    top: 0,
    left: 0,
    "z-index": "-99"
  }), e.appendChild(t);
  const s = Qt(t);
  return e.removeChild(t), s;
}, ft = (e) => {
  let t = e.parentNode;
  return t ? t === window.document ? window.document.body.scrollTop || window.document.body.scrollLeft ? window.document.body : window.document.documentElement : cr(t) ? t : ft(t) : e;
}, el = (e, t, s, n) => {
  let { top: i, left: r, width: o, height: a } = Qt(e);
  if (s) {
    if (n.parentElement) {
      const { top: u, left: c } = Qa(n.parentElement);
      i -= u, r -= c;
    }
    return {
      top: i,
      left: r,
      bottom: i + a,
      right: r + o,
      width: o,
      height: a
    };
  }
  let l = Qt(t);
  return {
    top: i - l.top,
    left: r - l.left,
    bottom: i - l.top + a,
    right: r - l.left + o,
    width: o,
    height: a
  };
}, tl = (e) => e === document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : e.scrollTop || 0, sl = (e) => e === document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : e.scrollLeft || 0, nl = (e, t) => {
  const s = Math.max(e.scrollHeight, e.offsetHeight, t.clientHeight, t.scrollHeight, t.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth, t.clientWidth, t.scrollWidth, t.offsetWidth), height: s };
}, Rt = (e) => {
  let t = e.style.display, s = e.style.visibility;
  e.style.display = "block", e.style.visibility = "hidden";
  let n = window.getComputedStyle(e), i = parseFloat(n.marginTop) + parseFloat(n.marginBottom), r = parseFloat(n.marginLeft) + parseFloat(n.marginRight), o = { width: e.offsetWidth + r, height: e.offsetHeight + i };
  return e.style.display = t, e.style.visibility = s, o;
}, Zs = (e) => {
  let t = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return e.replace(/left|right|bottom|top/g, (s) => t[s]);
}, Be = (e) => {
  let t = { ...e };
  return t.right = t.left + t.width, t.bottom = t.top + t.height, t;
}, fr = (e, t = []) => {
  const s = e.parentNode;
  return s ? (cr(s) && t.push(s), ar(s, "position") === "fixed" ? t : fr(s, t)) : t;
}, Vs = (e) => {
  const t = {
    width: e.offsetWidth,
    height: e.offsetHeight,
    left: e.offsetLeft,
    top: e.offsetTop,
    right: 0,
    bottom: 0
  };
  return t.right = t.left + t.width, t.bottom = t.top + t.height, t;
}, Js = (e) => {
  e.stopPropagation();
}, Qs = !S && typeof ResizeObserver == "function" ? new ResizeObserver((e) => {
  e.forEach((t) => {
    t.target.popperVm && t.contentRect.height > 50 && t.target.popperVm.update();
  });
}) : null;
class Qc {
  constructor(t, s, n) {
    x(this, "_reference");
    x(this, "_popper");
    x(this, "state");
    x(this, "_options");
    x(this, "modifiers", {});
    /** 每次update, 计算popper的大小并缓存 */
    x(this, "popperOuterSize", null);
    this._reference = t, this._popper = s, this.state = {}, this._options = { ...Ja, ...n }, this._options.modifierFns = or.map((i) => this[i]), S || (this._popper.setAttribute("x-placement", this._options.placement), this.state.position = this._getPopperPositionByRefernce(this._reference), ct(this._popper, { position: this.state.position, top: 0 }), this._popper && (this._popper.popperVm = this, Qs && Qs.observe(this._popper)), this.update(), this._setupEventListeners());
  }
  destroy() {
    return this._popper.removeAttribute("x-placement"), this._popper.style.display = "none", this._removeEventListeners(), this._options.removeOnDestroy && this._popper.remove(), this;
  }
  onUpdate(t) {
    return this.state.updateCallback = t, this;
  }
  update() {
    let t = { instance: this, styles: {} };
    this.stopEventBubble(), this.popperOuterSize = null, t.placement = t._originalPlacement = this._options.placement, t.offsets = this._getRefPopOffsets(this._popper, this._reference, t.placement), t.boundaries = this._getBoundaries(t, this._options.boundariesPadding, this._options.boundariesElement), t = this.runModifiers(t, this._options.modifierFns), typeof this.state.updateCallback == "function" && this.state.updateCallback(t);
  }
  // 阻止popper的mousewheel等事件冒泡。 通过 onxxx 绑定，是为了避免重复绑定事件
  stopEventBubble() {
    this._popper && (this._popper.onmousewheel || (this._popper.onmousewheel = Js), this._popper.onwheel || (this._popper.onwheel = Js));
  }
  /** 按顺序执行Modifiers， 如果传入终点modifier,则执行到指定位置 */
  runModifiers(t, s, n) {
    let i = s.slice();
    const r = this._options;
    return n !== void 0 && (i = this._options.modifierFns.slice(
      0,
      r.modifierFns.findIndex((o) => o === n)
    )), i.forEach((o) => {
      B(o) === "function" && (t = o.call(this, t));
    }), t;
  }
  // 此时才把offsets.popper 赋值给popper dom,  offsets.array赋值给array dom
  applyStyle(t) {
    let s = { position: t.offsets.popper.position }, n = Math.round(t.offsets.popper.left), i = Math.round(t.offsets.popper.top);
    return this._options.gpuAcceleration ? (s.transform = `translate3d(${n}px, ${i}px, 0)`, Object.assign(s, { top: 0, left: 0 })) : Object.assign(s, { top: i, left: n }), Object.assign(s, t.styles), ct(this._popper, s), this._popper.setAttribute("x-placement", t.placement), t.offsets.arrow && ct(t.arrowElement, t.offsets.arrow), t;
  }
  // 判断 placement是不是2段式的，是则处理一下偏移。 修改data.offsets.popper的值
  shift(t) {
    let s = t.placement, n = s.split("-")[0], i = s.split("-")[1];
    if (i) {
      let { top: r, left: o, height: a, width: l } = t.offsets.reference, f = Be(t.offsets.popper), u = {
        y: {
          start: { top: r },
          end: { top: r + a - f.height }
        },
        x: {
          start: { left: o },
          end: { left: o + l - f.width }
        }
      }, c = ~["bottom", "top"].indexOf(n) ? "x" : "y";
      t.offsets.popper = Object.assign(f, u[c][i]);
    }
    return t;
  }
  // 校正popper的位置在boundaries 的内部
  preventOverflow(t) {
    if (this._options.ignoreBoundaries)
      return t;
    let s = this._options.preventOverflowOrder, n = Be(t.offsets.popper), i = {
      top: () => {
        let { top: r } = n;
        return r < t.boundaries.top && (r = Math.max(r, t.boundaries.top)), { top: r };
      },
      right: () => {
        let { left: r } = n;
        return n.right > t.boundaries.right && (r = Math.min(r, t.boundaries.right - n.width)), { left: r };
      },
      bottom: () => {
        let { top: r } = n;
        return n.bottom > t.boundaries.bottom && (r = Math.min(r, t.boundaries.bottom - n.height)), { top: r };
      },
      left: () => {
        let { left: r } = n;
        return n.left < t.boundaries.left && (r = Math.max(r, t.boundaries.left)), { left: r };
      }
    };
    return s.forEach((r) => {
      t.offsets.popper = Object.assign(n, i[r]());
    }), t;
  }
  // 校正popper的位置在reference的边上。 如果2个分离了，重新调整popper的位置。 可能是担心 modifiers.offset 带来的副作用吧
  keepTogether(t) {
    let s = Be(t.offsets.popper), n = t.offsets.reference;
    return s.right < Math.floor(n.left) && (t.offsets.popper.left = Math.floor(n.left) - s.width), s.left > Math.floor(n.right) && (t.offsets.popper.left = Math.floor(n.right)), s.bottom < Math.floor(n.top) && (t.offsets.popper.top = Math.floor(n.top) - s.height), s.top > Math.floor(n.bottom) && (t.offsets.popper.top = Math.floor(n.bottom)), t;
  }
  // 根据flip的策略，计算当前应该显示的位置。 空间不够要计算出flip的位置。 可能是担心preventOverflow 时，造成pop, reference会重叠。 重叠了就要flip一下
  flip(t) {
    if (t.flipped && t.placement === t._originalPlacement)
      return t;
    const s = t.placement.split("-");
    let n = s[0], i = Zs(n), r = s[1] || "", o = [n, i];
    return o.forEach((a, l) => {
      if (n !== a || o.length === l + 1)
        return;
      n = t.placement.split("-")[0], i = Zs(n);
      let f = Be(t.offsets.popper), u = ["right", "bottom"].includes(n), c = Math.floor(t.offsets.reference[n]), h = Math.floor(f[i]);
      (u && c > h || !u && c < h) && (t.flipped = !0, t.placement = o[l + 1], r && (t.placement += `-${r}`), t.offsets.popper = this._getRefPopOffsets(this._popper, this._reference, t.placement).popper, t = this.runModifiers(t, this._options.modifierFns, this.flip));
    }), t;
  }
  // 根据入参option上的offset, 给data.offset.popper进行校正
  offset(t) {
    let s = this._options.offset, n = t.offsets.popper;
    return ~t.placement.indexOf("left") ? n.top -= s : ~t.placement.indexOf("right") ? n.top += s : ~t.placement.indexOf("top") ? n.left -= s : ~t.placement.indexOf("bottom") && (n.left += s), t;
  }
  // 计算arrow的位置,保存在data.offsets.arrow ={top,left}
  arrow(t) {
    let s = this._options.arrowElement, n = this._options.arrowOffset;
    if (typeof s == "string" && (s = this._popper.querySelector(s)), !s || !this._popper.contains(s))
      return t;
    let i = {}, r = t.placement.split("-")[0], o = Be(t.offsets.popper), a = t.offsets.reference, l = ~["left", "right"].indexOf(r), f = l ? "height" : "width", u = l ? "bottom" : "right", c = l ? "left" : "top", h = l ? "top" : "left", d = this.popperOuterSize ? this.popperOuterSize : this.popperOuterSize = Rt(this._popper), y = Rt(s), b = y[f];
    a[u] - b < o[h] && (t.offsets.popper[h] -= o[h] - (a[u] - b)), a[h] + b > o[u] && (t.offsets.popper[h] += a[h] + b - o[u]);
    let L = a[h] + (n || a[f] / 2 - b / 2) - o[h];
    const v = 4;
    L = Math.max(Math.min(o[f] - b - v, L), v), i[h] = L, i[c] = "";
    const w = this._options.placement.split("-");
    return this._options.adjustArrow && ~["top", "bottom"].indexOf(w[0]) && h === "left" && (w[1] === "start" ? i.left = v : w[1] || (i.left = (d.width - y.width) / 2)), t.offsets.arrow = i, t.arrowElement = s, t;
  }
  /** 判断 reference 的 offsetParent 元素是fix还是abs, 这个值会赋值给popper 的dom */
  _getPopperPositionByRefernce(t) {
    return this._options.forceAbsolute ? "absolute" : lr(t) ? "fixed" : "absolute";
  }
  /** 实时计算一下popper, reference的 位置信息， 用于 */
  _getRefPopOffsets(t, s, n) {
    n = n.split("-")[0];
    let i = { position: this.state.position }, r = i.position === "fixed", o = el(
      s,
      kt(t),
      r,
      t
    );
    const { width: a, height: l } = this.popperOuterSize ? this.popperOuterSize : this.popperOuterSize = Rt(t);
    return ~["right", "left"].indexOf(n) ? (i.top = o.top + o.height / 2 - l / 2, n === "left" ? i.left = o.left - a : i.left = o.right) : (i.left = o.left + o.width / 2 - a / 2, n === "top" ? i.top = o.top - l : i.top = o.bottom), i.width = a, i.height = l, {
      popper: i,
      reference: o
    };
  }
  _setupEventListeners() {
    var t, s;
    if (this.state.updateBoundFn = this.update.bind(this), this.state.scrollUpdate = () => {
      if (this._options.updateHiddenPopperOnScroll)
        this.state.updateBoundFn();
      else {
        if (yn(this._reference)) return;
        this.state.updateBoundFn();
      }
    }, Z(window, "resize", this.state.updateBoundFn), this._options.boundariesElement !== "window") {
      let n = this._options.scrollParent || ft(this._reference);
      const i = [];
      if ((s = (t = n == null ? void 0 : n.dataset) == null ? void 0 : t.tag) != null && s.includes("-form")) {
        i.push(n);
        let r = ft(n);
        (r === window.document.body || r === window.document.documentElement) && (r = window), i.push(r);
      }
      if ((n === window.document.body || n === window.document.documentElement) && (n = window), this.state.scrollTarget = n, this._options.bubbling || $.globalScroll) {
        let r = fr(this._reference);
        this.state.scrollTargets = r || [], r.forEach((o) => {
          Z(o, "scroll", this.state.scrollUpdate);
        });
      } else
        i.length ? (this.state.scrollTargets = i, i.forEach((r) => {
          Z(r, "scroll", this.state.scrollUpdate);
        })) : Z(n, "scroll", this.state.scrollUpdate);
    }
  }
  _removeEventListeners() {
    ne(window, "resize", this.state.updateBoundFn), this._options.boundariesElement !== "window" && this.state.scrollTarget && (ne(this.state.scrollTarget, "scroll", this.state.scrollUpdate), this.state.scrollTarget = null, (this._options.bubbling || $.globalScroll) && ((this.state.scrollTargets || []).forEach((s) => {
      ne(s, "scroll", this.state.scrollUpdate);
    }), this.state.scrollTargets = null)), this.state.updateBoundFn = null, this.state.scrollUpdate = null;
  }
  /** 实时计算一下Boundary的位置 */
  _getBoundaries(t, s, n) {
    let i = { right: 0, left: 0, top: 0, bottom: 0 };
    if (n === "window" || n === "body") {
      let r = window.document.body, o = window.document.documentElement, { width: a, height: l } = nl(r, o);
      i = { top: 0, right: a, bottom: l, left: 0 };
    } else if (n === "viewport") {
      let r = kt(this._popper), o = ft(this._popper), a = Vs(r);
      const f = t.offsets.popper.position === "fixed" || !this._options.appendToBody && ["right", "left"].includes(this._options.placement);
      let u = f ? 0 : tl(o), c = f ? 0 : sl(o);
      const h = ts.viewportWindow || $.viewportWindow || window;
      i = {
        top: 0 - (a.top - u),
        right: h.document.documentElement.clientWidth - (a.left - c),
        bottom: h.document.documentElement.clientHeight - (a.top - u),
        left: 0 - (a.left - c)
      };
    } else if (kt(this._popper) === n) {
      const { clientWidth: r, clientHeight: o } = n;
      i = {
        right: r,
        bottom: o,
        top: 0,
        left: 0
      };
    } else
      i = Vs(n);
    return i.right -= s, i.left += s, i.bottom = i.bottom - s, i.top = i.top + s, i;
  }
  // https://popper.js.org/docs/v2/lifecycle/#set-new-options
  setOptions(t) {
    Object.assign(this._options, t);
  }
}
const he = "__resizeListeners__", rl = (e) => {
  e.forEach((t) => {
    const s = t.target[he] || [];
    s.length && s.forEach((n) => {
      n();
    });
  });
}, ef = (e, t) => {
  S || (e[he] || (e[he] = [], e.__ro__ = new oi(rl), e.__ro__.observe(e)), e[he].push(t));
}, tf = (e, t) => {
  !e || !e[he] || (e[he].splice(e[he].indexOf(t), 1), e[he].length || (e.__ro__.disconnect(), delete e.__ro__));
};
let ot;
function sf() {
  if (S)
    return 0;
  if (ot !== void 0)
    return ot;
  const e = document.createElement("div");
  e.className = "tiny-scrollbar", e.style.visibility = "hidden", e.style.position = "absolute", e.style.top = "-9999px";
  const t = document.createElement("div");
  t.className = "tiny-scrollbar__wrap", t.style.width = "100px", e.appendChild(t), document.body.appendChild(e);
  const s = t.offsetWidth;
  t.style.overflow = "scroll";
  const n = document.createElement("div");
  n.style.width = "100%", t.appendChild(n);
  const i = n.offsetWidth;
  return t.parentNode.removeChild(t), ot = s - i, ot;
}
const nf = (e, t) => {
  if (S)
    return;
  if (!t) {
    e.scrollTop = 0;
    return;
  }
  const s = [];
  let { offsetParent: n, offsetTop: i, offsetHeight: r } = t;
  for (; n && e !== n && e.contains(n); )
    s.push(n), n = n.offsetParent;
  const o = i + s.reduce((u, c) => u + c.offsetTop, 0), a = o + r, l = e.scrollTop, f = l + e.clientHeight;
  o < l ? e.scrollTop = o : a > f && (e.scrollTop = a - e.clientHeight);
}, en = 10, il = (e, t) => e > t && e > en ? "horizontal" : t > e && t > en ? "vertical" : "", rf = (e) => (t) => {
  ol(e), e.startX = t.touches[0].clientX, e.startY = t.touches[0].clientY;
}, of = (e) => (t) => {
  const s = t.touches[0];
  e.deltaX = s.clientX - e.startX, e.deltaY = s.clientY - e.startY, e.offsetX = Math.abs(e.deltaX), e.offsetY = Math.abs(e.deltaY), e.direction = e.direction || il(e.offsetX, e.offsetY);
}, ol = (e) => {
  e.direction = "", e.deltaX = 0, e.deltaY = 0, e.offsetX = 0, e.offsetY = 0;
};
let tn = !1, It = !1, Me = null, at = null;
const al = S ? null : Element.prototype.matches, ll = (e, t) => {
  if (!S)
    do {
      if (al.call(e, t)) return e;
      e = e.parentElement || e.parentNode;
    } while (e !== null && e.nodeType === 1);
  return null;
};
class cl {
  constructor(t, s, n, i, r) {
    this.target = t, this.identifier = s, i = i || 0, r = r || 0, this.pageX = n.pageX + i, this.pageY = n.pageY + r, this.screenX = n.screenX + i, this.screenY = n.screenY + r, this.clientX = n.clientX + i, this.clientY = n.clientY + r, this.offsetX = n.offsetX + i, this.offsetY = n.offsetY + r;
  }
}
const ur = () => {
  const e = [];
  return e.item = (t) => e[t] || null, e.identifiedTouch = (t) => e[t + 1] || null, e;
}, dr = (e) => {
  const t = ur();
  return t.push(new cl(Me, 1, e, 0, 0)), t;
}, sn = (e) => e.type === "mouseup" ? ur() : dr(e), fl = (e, t) => {
  const s = document.createEvent("Event");
  s.initEvent(e, !0, !0), s.altKey = t.altKey, s.metaKey = t.metaKey, s.ctrlKey = t.ctrlKey, s.shiftKey = t.shiftKey, s.changedTouches = dr(t), s.targetTouches = sn(t), s.touches = sn(t), s.isTinySimulate = !0, Me.dispatchEvent(s);
}, Lt = (e) => (t) => {
  t.type === "mousedown" && (It = !0), t.type === "mouseup" && (It = !1), !(t.type === "mousemove" && !It) && ((t.type === "mousedown" || !at) && (at = t.target), Me = ll(at, "[data-tiny-touch-simulate-container]"), Me && Me.dispatchEvent && fl(e, t), t.type === "mouseup" && (Me = null, at = null));
}, ul = () => {
  window.addEventListener("mousedown", Lt("touchstart"), !0), window.addEventListener("mousemove", Lt("touchmove"), !0), window.addEventListener("mouseup", Lt("touchend"), !0);
}, af = () => {
  if (!S) {
    const e = "ontouchstart" in window;
    !tn && !e && (tn = !0, ul());
  }
}, dl = (e) => {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}, hl = (e, t, s) => {
  let n;
  s.response ? n = s.response.error || s.response : s.responseText ? n = s.responseText : n = `fail to post ${e} ${s.status}`;
  const i = new Error(n);
  return i.status = s.status, i.method = "post", i.url = e, i;
}, lf = (e) => {
  if (typeof XMLHttpRequest > "u")
    return;
  const t = new XMLHttpRequest(), s = Ar.filterUrl(e.action);
  t.upload && (t.upload.onprogress = (r) => {
    r.total > 0 && (r.percent = r.loaded / r.total * 100), e.onProgress(r);
  });
  const n = new FormData();
  e.data && Object.keys(e.data).forEach((r) => {
    n.append(r, e.data[r]);
  }), Array.isArray(e.file) ? e.file.forEach((r) => {
    n.append(e.filename, r, r.name);
  }) : n.append(e.filename, e.file, e.file.name), t.onerror = (r) => {
    e.onError(r);
  }, t.onload = () => {
    if (t.status < 200 || t.status >= 300)
      return e.onError(hl(s, e, t));
    e.onSuccess(dl(t));
  }, t.open("post", s, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const i = e.headers || {};
  for (let r in i)
    A.call(i, r) && i[r] !== null && t.setRequestHeader(r, i[r]);
  return t.send(n), t;
}, cf = { logger: $t };
export {
  oc as BROWSER_NAME,
  Ye as BigIntDecimal,
  cc as CASCADER,
  ic as DATE,
  Pe as DATEPICKER,
  O as Decimal,
  zc as FORM_EVENT,
  $c as FORM_ITEM,
  Ie as FullscreenApi,
  rc as IPTHRESHOLD,
  mo as KEY_CODE,
  ac as MOUSEDELTA,
  Jc as Memorize,
  Oe as NODE_KEY,
  Ue as Node,
  we as NumberDecimal,
  sc as POSITION,
  Qc as PopperJS,
  $ as PopupManager,
  nc as REFRESH_INTERVAL,
  oi as ResizeObserver,
  Dt as SORT,
  Uc as TreeStore,
  lc as VALIDATE_STATE,
  qc as Validator,
  et as addClass,
  ef as addResizeListener,
  Xc as afterLeave,
  bl as browserInfo,
  sf as calcScrollWidth,
  Wc as callInterceptor,
  kl as camelize,
  Rl as capitalize,
  Re as changeYearMonthAndClampDate,
  Nc as clearMilliseconds,
  xc as clearTime,
  Si as copyArray,
  Ht as copyField,
  Bc as correctTarget,
  Gc as debounce,
  _s as each,
  Hc as emitEvent,
  af as emulate,
  Cl as equalsDecimal,
  $l as escape,
  Yt as escapeChars,
  gt as escapeHtml,
  Vc as espaceCtrl,
  ke as extend,
  Cc as extractDateFormat,
  Dc as extractTimeFormat,
  Xn as fastdom,
  Kc as fastdomAsync,
  Yc as fastdomSandbox,
  zi as fieldFormat,
  Ut as fillChar,
  Ro as find,
  uc as formatDate,
  Ae as formatDateByPattern,
  Ul as formatFileSize,
  Ol as formatNumber,
  rs as formatString,
  G as formatTypes,
  jc as getActualTarget,
  Ql as getCalendar,
  Zt as getChildState,
  Pc as getDataset,
  fo as getDateWithNewTimezone,
  Co as getDayCountOfMonth,
  dc as getDayCountOfYear,
  Cs as getDays,
  il as getDirection,
  Nl as getDomNode,
  hc as getFirstDayOfMonth,
  qn as getI18nSettings,
  Li as getLength,
  ho as getLocalTimezone,
  Ne as getMiniDecimal,
  bc as getMonthDays,
  za as getNodeKey,
  Bt as getNumberPrecision,
  De as getObj,
  wc as getPrevMonthLastDays,
  yc as getRangeHours,
  vc as getRangeMinutes,
  Sl as getScrollContainer,
  Hr as getScrollParent,
  ft as getScrollParent1,
  El as getScrollTop,
  gc as getStartDateOfMonth,
  Jl as getStrTimezone,
  At as getStyle,
  yl as getViewportWindow,
  Os as getWeek,
  mc as getWeekNumber,
  Vl as getWeekOfFirstDay,
  ts as globalConfig,
  Pl as guid,
  vl as hasClass,
  A as hasOwn,
  Il as hyphenate,
  wt as indexOf,
  Zc as initEspace,
  Le as isDate,
  Hn as isDate1,
  fc as isDateObject,
  yn as isDisplayNone,
  ss as isE,
  pt as isEachEqual,
  gl as isEmptyObject,
  _n as isEqual,
  zt as isFunction,
  xl as isInContainer,
  Xl as isKorean,
  Ge as isLeapYear,
  V as isNull,
  R as isNullOrEmpty,
  z as isNumber,
  Te as isNumeric,
  xe as isObject,
  ee as isPlainObject,
  Or as isPromise,
  ml as isRegExp,
  pn as isSame,
  Pr as isScroll,
  S as isServer,
  po as lastMonth,
  Dl as lessEquals,
  ko as limitTimeRange,
  cf as log,
  $t as logger,
  js as markNodeData,
  Ms as merge,
  Bn as modifyDate,
  Fo as modifyTime,
  Sc as modifyWithTimeString,
  Ml as nanoid,
  pc as nextDate,
  go as nextMonth,
  _c as nextMonth1,
  Mc as nextYear,
  Sa as noop,
  Mn as num2str,
  ne as off,
  Gl as omitText,
  Z as on,
  wl as once,
  tc as parseDate,
  Do as parseDate1,
  Oo as prevDate,
  Ac as prevMonth,
  Tc as prevYear,
  _l as preventDefault,
  Rc as push,
  Pi as random,
  jn as range,
  Fl as recoverNumber,
  Fc as remove,
  tt as removeClass,
  tf as removeResizeListener,
  ol as resetTouchStatus,
  Tn as roundFixed,
  nf as scrollIntoView,
  _i as setDecimalClass,
  As as setObj,
  Lr as setStyle,
  U as sf,
  Tl as sha256,
  kc as sort,
  $r as stopPropagation,
  jt as supportBigInt,
  Ks as throttle,
  Ec as timeWithinRange,
  Wl as toBoolValue,
  Yi as toCurrency,
  as as toDate,
  cs as toDate1,
  Zl as toDateStr,
  Xe as toDecimal,
  Yl as toFileSize,
  Tn as toFixedBigInt,
  Ts as toFixedDecimal,
  Ki as toInt,
  Ll as toJson,
  Ni as toJsonStr,
  Cn as toNumber,
  Lc as toObject,
  Kl as toRate,
  dn as toString,
  of as touchMove,
  rf as touchStart,
  ec as transformArray,
  Lo as transformPidToChildren,
  Po as transformTreeData,
  Ke as trimNumber,
  zl as truncate,
  is as tryToConvert,
  Bl as tryToCurrency,
  jl as tryToDecimal,
  ql as tryToInt,
  Hl as tryToNumber,
  B as typeOf,
  Ic as unique,
  lf as uploadAjax,
  Al as useScrollParent,
  An as validateNumber,
  Oc as validateRangeInOneMonth,
  Ar as xss
};
