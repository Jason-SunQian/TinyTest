import {
  isRef,
  reactive,
  readonly
} from "./chunk-TYA5SUDX.js";
import {
  init_buffer,
  init_process
} from "./chunk-USER6M25.js";

// ../node_modules/.pnpm/@opentiny+tiny-engine-meta-register@2.7.2_@opentiny+vue-renderless@3.20.0_typescript@5.4.5/node_modules/@opentiny/tiny-engine-meta-register/dist/index.js
init_process();
init_buffer();
var Ja = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
var Ad = typeof self == "object" && self && self.Object === Object && self;
var ms = Ja || Ad || Function("return this")();
var kr = ms.Symbol;
var Ya = Object.prototype;
var xd = Ya.hasOwnProperty;
var Id = Ya.toString;
var Ts = kr ? kr.toStringTag : void 0;
function Pd(e) {
  var t = xd.call(e, Ts), n = e[Ts];
  try {
    e[Ts] = void 0;
    var s = true;
  } catch {
  }
  var r = Id.call(e);
  return s && (t ? e[Ts] = n : delete e[Ts]), r;
}
var Rd = Object.prototype;
var Md = Rd.toString;
function $d(e) {
  return Md.call(e);
}
var kd = "[object Null]";
var Ld = "[object Undefined]";
var hl = kr ? kr.toStringTag : void 0;
function mi(e) {
  return e == null ? e === void 0 ? Ld : kd : hl && hl in Object(e) ? Pd(e) : $d(e);
}
function cr(e) {
  return e != null && typeof e == "object";
}
var Eo = Array.isArray;
function Hn(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function Xa(e) {
  return e;
}
var Fd = "[object AsyncFunction]";
var Hd = "[object Function]";
var jd = "[object GeneratorFunction]";
var Ud = "[object Proxy]";
function oc(e) {
  if (!Hn(e))
    return false;
  var t = mi(e);
  return t == Hd || t == jd || t == Fd || t == Ud;
}
var Zi = ms["__core-js_shared__"];
var gl = function() {
  var e = /[^.]+$/.exec(Zi && Zi.keys && Zi.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Bd(e) {
  return !!gl && gl in e;
}
var Kd = Function.prototype;
var Wd = Kd.toString;
function qd(e) {
  if (e != null) {
    try {
      return Wd.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Gd = /[\\^$.*+?()[\]{}|]/g;
var zd = /^\[object .+?Constructor\]$/;
var Jd = Function.prototype;
var Yd = Object.prototype;
var Xd = Jd.toString;
var Zd = Yd.hasOwnProperty;
var Qd = RegExp(
  "^" + Xd.call(Zd).replace(Gd, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function eh(e) {
  if (!Hn(e) || Bd(e))
    return false;
  var t = oc(e) ? Qd : zd;
  return t.test(qd(e));
}
function th(e, t) {
  return e == null ? void 0 : e[t];
}
function cc(e, t) {
  var n = th(e, t);
  return eh(n) ? n : void 0;
}
var ml = Object.create;
var nh = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Hn(t))
      return {};
    if (ml)
      return ml(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function sh(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function rh(e, t) {
  var n = -1, s = e.length;
  for (t || (t = Array(s)); ++n < s; )
    t[n] = e[n];
  return t;
}
var ih = 800;
var oh = 16;
var ch = Date.now;
function lh(e) {
  var t = 0, n = 0;
  return function() {
    var s = ch(), r = oh - (s - n);
    if (n = s, r > 0) {
      if (++t >= ih)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function ah(e) {
  return function() {
    return e;
  };
}
var Lr = function() {
  try {
    var e = cc(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
var fh = Lr ? function(e, t) {
  return Lr(e, "toString", {
    configurable: true,
    enumerable: false,
    value: ah(t),
    writable: true
  });
} : Xa;
var uh = lh(fh);
var ph = 9007199254740991;
var dh = /^(?:0|[1-9]\d*)$/;
function Za(e, t) {
  var n = typeof e;
  return t = t ?? ph, !!t && (n == "number" || n != "symbol" && dh.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function lc(e, t, n) {
  t == "__proto__" && Lr ? Lr(e, t, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e[t] = n;
}
function _i(e, t) {
  return e === t || e !== e && t !== t;
}
var hh = Object.prototype;
var gh = hh.hasOwnProperty;
function mh(e, t, n) {
  var s = e[t];
  (!(gh.call(e, t) && _i(s, n)) || n === void 0 && !(t in e)) && lc(e, t, n);
}
function _h(e, t, n, s) {
  var r = !n;
  n || (n = {});
  for (var i = -1, o = t.length; ++i < o; ) {
    var c = t[i], l = void 0;
    l === void 0 && (l = e[c]), r ? lc(n, c, l) : mh(n, c, l);
  }
  return n;
}
var _l = Math.max;
function Eh(e, t, n) {
  return t = _l(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var s = arguments, r = -1, i = _l(s.length - t, 0), o = Array(i); ++r < i; )
      o[r] = s[t + r];
    r = -1;
    for (var c = Array(t + 1); ++r < t; )
      c[r] = s[r];
    return c[t] = n(o), sh(e, this, c);
  };
}
function yh(e, t) {
  return uh(Eh(e, t, Xa), e + "");
}
var vh = 9007199254740991;
function Qa(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= vh;
}
function ac(e) {
  return e != null && Qa(e.length) && !oc(e);
}
function Nh(e, t, n) {
  if (!Hn(n))
    return false;
  var s = typeof t;
  return (s == "number" ? ac(n) && Za(t, n.length) : s == "string" && t in n) ? _i(n[t], e) : false;
}
function bh(e) {
  return yh(function(t, n) {
    var s = -1, r = n.length, i = r > 1 ? n[r - 1] : void 0, o = r > 2 ? n[2] : void 0;
    for (i = e.length > 3 && typeof i == "function" ? (r--, i) : void 0, o && Nh(n[0], n[1], o) && (i = r < 3 ? void 0 : i, r = 1), t = Object(t); ++s < r; ) {
      var c = n[s];
      c && e(t, c, s, i);
    }
    return t;
  });
}
var Oh = Object.prototype;
function ef(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || Oh;
  return e === n;
}
function Sh(e, t) {
  for (var n = -1, s = Array(e); ++n < e; )
    s[n] = t(n);
  return s;
}
var Th = "[object Arguments]";
function El(e) {
  return cr(e) && mi(e) == Th;
}
var tf = Object.prototype;
var Dh = tf.hasOwnProperty;
var wh = tf.propertyIsEnumerable;
var yo = El(/* @__PURE__ */ function() {
  return arguments;
}()) ? El : function(e) {
  return cr(e) && Dh.call(e, "callee") && !wh.call(e, "callee");
};
function Ch() {
  return false;
}
var nf = typeof exports == "object" && exports && !exports.nodeType && exports;
var yl = nf && typeof module == "object" && module && !module.nodeType && module;
var Vh = yl && yl.exports === nf;
var vl = Vh ? ms.Buffer : void 0;
var Ah = vl ? vl.isBuffer : void 0;
var sf = Ah || Ch;
var xh = "[object Arguments]";
var Ih = "[object Array]";
var Ph = "[object Boolean]";
var Rh = "[object Date]";
var Mh = "[object Error]";
var $h = "[object Function]";
var kh = "[object Map]";
var Lh = "[object Number]";
var Fh = "[object Object]";
var Hh = "[object RegExp]";
var jh = "[object Set]";
var Uh = "[object String]";
var Bh = "[object WeakMap]";
var Kh = "[object ArrayBuffer]";
var Wh = "[object DataView]";
var qh = "[object Float32Array]";
var Gh = "[object Float64Array]";
var zh = "[object Int8Array]";
var Jh = "[object Int16Array]";
var Yh = "[object Int32Array]";
var Xh = "[object Uint8Array]";
var Zh = "[object Uint8ClampedArray]";
var Qh = "[object Uint16Array]";
var eg = "[object Uint32Array]";
var _e = {};
_e[qh] = _e[Gh] = _e[zh] = _e[Jh] = _e[Yh] = _e[Xh] = _e[Zh] = _e[Qh] = _e[eg] = true;
_e[xh] = _e[Ih] = _e[Kh] = _e[Ph] = _e[Wh] = _e[Rh] = _e[Mh] = _e[$h] = _e[kh] = _e[Lh] = _e[Fh] = _e[Hh] = _e[jh] = _e[Uh] = _e[Bh] = false;
function tg(e) {
  return cr(e) && Qa(e.length) && !!_e[mi(e)];
}
function ng(e) {
  return function(t) {
    return e(t);
  };
}
var rf = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ms = rf && typeof module == "object" && module && !module.nodeType && module;
var sg = Ms && Ms.exports === rf;
var Qi = sg && Ja.process;
var Nl = function() {
  try {
    var e = Ms && Ms.require && Ms.require("util").types;
    return e || Qi && Qi.binding && Qi.binding("util");
  } catch {
  }
}();
var bl = Nl && Nl.isTypedArray;
var of = bl ? ng(bl) : tg;
function rg(e, t) {
  var n = Eo(e), s = !n && yo(e), r = !n && !s && sf(e), i = !n && !s && !r && of(e), o = n || s || r || i, c = o ? Sh(e.length, String) : [], l = c.length;
  for (var f in e)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (f == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (f == "offset" || f == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (f == "buffer" || f == "byteLength" || f == "byteOffset") || // Skip index properties.
    Za(f, l)) || c.push(f);
  return c;
}
function ig(e, t) {
  return function(n) {
    return e(t(n));
  };
}
function og(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var cg = Object.prototype;
var lg = cg.hasOwnProperty;
function ag(e) {
  if (!Hn(e))
    return og(e);
  var t = ef(e), n = [];
  for (var s in e)
    s == "constructor" && (t || !lg.call(e, s)) || n.push(s);
  return n;
}
function cf(e) {
  return ac(e) ? rg(e) : ag(e);
}
var qs = cc(Object, "create");
function fg() {
  this.__data__ = qs ? qs(null) : {}, this.size = 0;
}
function ug(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var pg = "__lodash_hash_undefined__";
var dg = Object.prototype;
var hg = dg.hasOwnProperty;
function gg(e) {
  var t = this.__data__;
  if (qs) {
    var n = t[e];
    return n === pg ? void 0 : n;
  }
  return hg.call(t, e) ? t[e] : void 0;
}
var mg = Object.prototype;
var _g = mg.hasOwnProperty;
function Eg(e) {
  var t = this.__data__;
  return qs ? t[e] !== void 0 : _g.call(t, e);
}
var yg = "__lodash_hash_undefined__";
function vg(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = qs && t === void 0 ? yg : t, this;
}
function Rn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var s = e[t];
    this.set(s[0], s[1]);
  }
}
Rn.prototype.clear = fg;
Rn.prototype.delete = ug;
Rn.prototype.get = gg;
Rn.prototype.has = Eg;
Rn.prototype.set = vg;
function Ng() {
  this.__data__ = [], this.size = 0;
}
function Ei(e, t) {
  for (var n = e.length; n--; )
    if (_i(e[n][0], t))
      return n;
  return -1;
}
var bg = Array.prototype;
var Og = bg.splice;
function Sg(e) {
  var t = this.__data__, n = Ei(t, e);
  if (n < 0)
    return false;
  var s = t.length - 1;
  return n == s ? t.pop() : Og.call(t, n, 1), --this.size, true;
}
function Tg(e) {
  var t = this.__data__, n = Ei(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function Dg(e) {
  return Ei(this.__data__, e) > -1;
}
function wg(e, t) {
  var n = this.__data__, s = Ei(n, e);
  return s < 0 ? (++this.size, n.push([e, t])) : n[s][1] = t, this;
}
function Gt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var s = e[t];
    this.set(s[0], s[1]);
  }
}
Gt.prototype.clear = Ng;
Gt.prototype.delete = Sg;
Gt.prototype.get = Tg;
Gt.prototype.has = Dg;
Gt.prototype.set = wg;
var lf = cc(ms, "Map");
function Cg() {
  this.size = 0, this.__data__ = {
    hash: new Rn(),
    map: new (lf || Gt)(),
    string: new Rn()
  };
}
function Vg(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function yi(e, t) {
  var n = e.__data__;
  return Vg(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function Ag(e) {
  var t = yi(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function xg(e) {
  return yi(this, e).get(e);
}
function Ig(e) {
  return yi(this, e).has(e);
}
function Pg(e, t) {
  var n = yi(this, e), s = n.size;
  return n.set(e, t), this.size += n.size == s ? 0 : 1, this;
}
function _s(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var s = e[t];
    this.set(s[0], s[1]);
  }
}
_s.prototype.clear = Cg;
_s.prototype.delete = Ag;
_s.prototype.get = xg;
_s.prototype.has = Ig;
_s.prototype.set = Pg;
var af = ig(Object.getPrototypeOf, Object);
var Rg = "[object Object]";
var Mg = Function.prototype;
var $g = Object.prototype;
var ff = Mg.toString;
var kg = $g.hasOwnProperty;
var Lg = ff.call(Object);
function Fg(e) {
  if (!cr(e) || mi(e) != Rg)
    return false;
  var t = af(e);
  if (t === null)
    return true;
  var n = kg.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && ff.call(n) == Lg;
}
function Hg() {
  this.__data__ = new Gt(), this.size = 0;
}
function jg(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function Ug(e) {
  return this.__data__.get(e);
}
function Bg(e) {
  return this.__data__.has(e);
}
var Kg = 200;
function Wg(e, t) {
  var n = this.__data__;
  if (n instanceof Gt) {
    var s = n.__data__;
    if (!lf || s.length < Kg - 1)
      return s.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new _s(s);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Es(e) {
  var t = this.__data__ = new Gt(e);
  this.size = t.size;
}
Es.prototype.clear = Hg;
Es.prototype.delete = jg;
Es.prototype.get = Ug;
Es.prototype.has = Bg;
Es.prototype.set = Wg;
var uf = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ol = uf && typeof module == "object" && module && !module.nodeType && module;
var qg = Ol && Ol.exports === uf;
var Sl = qg ? ms.Buffer : void 0;
Sl && Sl.allocUnsafe;
function Gg(e, t) {
  return e.slice();
}
var Tl = ms.Uint8Array;
function zg(e) {
  var t = new e.constructor(e.byteLength);
  return new Tl(t).set(new Tl(e)), t;
}
function Jg(e, t) {
  var n = zg(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
function Yg(e) {
  return typeof e.constructor == "function" && !ef(e) ? nh(af(e)) : {};
}
function Xg(e) {
  return function(t, n, s) {
    for (var r = -1, i = Object(t), o = s(t), c = o.length; c--; ) {
      var l = o[++r];
      if (n(i[l], l, i) === false)
        break;
    }
    return t;
  };
}
var Zg = Xg();
function vo(e, t, n) {
  (n !== void 0 && !_i(e[t], n) || n === void 0 && !(t in e)) && lc(e, t, n);
}
function Qg(e) {
  return cr(e) && ac(e);
}
function No(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function em(e) {
  return _h(e, cf(e));
}
function tm(e, t, n, s, r, i, o) {
  var c = No(e, n), l = No(t, n), f = o.get(l);
  if (f) {
    vo(e, n, f);
    return;
  }
  var u = i ? i(c, l, n + "", e, t, o) : void 0, a = u === void 0;
  if (a) {
    var p = Eo(l), h = !p && sf(l), _ = !p && !h && of(l);
    u = l, p || h || _ ? Eo(c) ? u = c : Qg(c) ? u = rh(c) : h ? (a = false, u = Gg(l)) : _ ? (a = false, u = Jg(l)) : u = [] : Fg(l) || yo(l) ? (u = c, yo(c) ? u = em(c) : (!Hn(c) || oc(c)) && (u = Yg(l))) : a = false;
  }
  a && (o.set(l, u), r(u, l, s, i, o), o.delete(l)), vo(e, n, u);
}
function pf(e, t, n, s, r) {
  e !== t && Zg(t, function(i, o) {
    if (r || (r = new Es()), Hn(i))
      tm(e, t, o, n, pf, s, r);
    else {
      var c = s ? s(No(e, o), i, o + "", e, t, r) : void 0;
      c === void 0 && (c = i), vo(e, o, c);
    }
  }, cf);
}
var df = bh(function(e, t, n) {
  pf(e, t, n);
});
var ne = {
  useLayout: "layout",
  useCanvas: "canvas",
  useResource: "resource",
  useHistory: "history",
  useProperties: "properties",
  useProperty: "property",
  useSaveLocal: "saveLocal",
  useBlock: "block",
  useTranslate: "translate",
  usePage: "page",
  useDataSource: "dataSource",
  useBreadcrumb: "breadcrumb",
  useHelp: "help",
  useHttp: "http",
  useEnv: "env",
  useModal: "modal",
  useNotify: "notify",
  useCustom: "custom",
  useMaterial: "material",
  useStyle: "style"
};
var bn = {
  [ne.useLayout]: {},
  [ne.useCanvas]: {},
  [ne.useResource]: {},
  [ne.useHistory]: {},
  [ne.useProperties]: {},
  [ne.useProperty]: {},
  [ne.useSaveLocal]: {},
  [ne.useBlock]: {},
  [ne.useTranslate]: {},
  [ne.usePage]: {},
  [ne.useDataSource]: {},
  [ne.useBreadcrumb]: {},
  [ne.useHelp]: {},
  [ne.useHttp]: {},
  [ne.useEnv]: {},
  [ne.useNotify]: {},
  [ne.useModal]: {},
  [ne.useMaterial]: {},
  [ne.useStyle]: {},
  [ne.useCustom]: {}
  // 自定义
};
var we = (e, t) => typeof bn[e] == "function" ? bn[e](...t) : bn[e];
var qb = (...e) => we(ne.useLayout, e);
var Gb = (...e) => we(ne.useCanvas, e);
var zb = (...e) => we(ne.useResource, e);
var Jb = (...e) => we(ne.useHistory, e);
var Yb = (...e) => we(ne.useProperties, e);
var Xb = (...e) => we(ne.useSaveLocal, e);
var Zb = (...e) => we(ne.useBlock, e);
var Qb = (...e) => we(ne.useTranslate, e);
var eO = (...e) => we(ne.usePage, e);
var tO = (...e) => we(ne.useDataSource, e);
var nO = (...e) => we(ne.useBreadcrumb, e);
var sO = (...e) => we(ne.useProperty, e);
var rO = (...e) => we(ne.useHelp, e);
var iO = (...e) => we(ne.useHttp, e);
var oO = (...e) => we(ne.useEnv, e);
var cO = (...e) => we(ne.useModal, e);
var lO = (...e) => we(ne.useNotify, e);
var aO = (...e) => we(ne.useMaterial, e);
var fO = (...e) => we(ne.useStyle, e);
var uO = (...e) => we(ne.useCustom, e);
function nm(e, t, { useDefaultExport: n } = {}) {
  if (!Object.keys(bn).includes(e))
    throw new Error("Invalid hook name provided: " + e);
  return n ? bn[e] = t : Object.assign(bn[e], t), bn[e];
}
var Ut = /* @__PURE__ */ new Map();
var wr = {};
var hf = {};
var pO = (e, t) => {
  if (wr[e])
    return t ? wr[e][t] : wr[e];
};
var dO = (e) => hf[e];
var hO = (e) => Ut.get(e);
var gO = (e) => {
  const t = [];
  for (const [n, s] of Ut)
    s.type === e && t.push(s);
  return t;
};
var mO = () => Array.from(Ut.values());
var bo = (e, t) => {
  const { apis: n, options: s, composable: r } = t || {};
  n && (wr[e] = n, r != null && r.name && nm(r.name, n)), s && (hf[e] = s);
};
var gf = (e) => {
  Object.entries(e).forEach(([t, n]) => {
    if (typeof n == "object" && n && !isRef(n)) {
      const { id: s } = n;
      s && t !== "metaData" && (bo(s, n), Ut.set(s, n)), gf(n);
    }
  });
};
var _O = (e, ...t) => {
  gf(e), t.forEach((n) => {
    !n || Object.prototype.toString.call(n) !== "[object Object]" || Object.entries(n).forEach(([s, r]) => {
      const i = Ut.get(s);
      if (i && !r) {
        Ut.delete(s);
        return;
      }
      if (!i && r) {
        Ut.set(s, r), bo(s, r);
        return;
      }
      if (i && r) {
        const o = df({}, i, r);
        Ut.set(s, o), bo(s, o);
      }
    });
  });
};
function Ie(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return (n) => n in t;
}
var se = true ? Object.freeze({}) : {};
var Yn = true ? Object.freeze([]) : [];
var me = () => {
};
var As = () => false;
var Wt = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97);
var Fr = (e) => e.startsWith("onUpdate:");
var te = Object.assign;
var fc = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
};
var sm = Object.prototype.hasOwnProperty;
var oe = (e, t) => sm.call(e, t);
var F = Array.isArray;
var Tn = (e) => ys(e) === "[object Map]";
var jn = (e) => ys(e) === "[object Set]";
var Dl = (e) => ys(e) === "[object Date]";
var rm = (e) => ys(e) === "[object RegExp]";
var J = (e) => typeof e == "function";
var X = (e) => typeof e == "string";
var nt = (e) => typeof e == "symbol";
var ie = (e) => e !== null && typeof e == "object";
var vi = (e) => (ie(e) || J(e)) && J(e.then) && J(e.catch);
var mf = Object.prototype.toString;
var ys = (e) => mf.call(e);
var uc = (e) => ys(e).slice(8, -1);
var Ni = (e) => ys(e) === "[object Object]";
var pc = (e) => X(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e;
var ln = Ie(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var _f = Ie(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
var bi = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
};
var im = /-(\w)/g;
var de = bi(
  (e) => e.replace(im, (t, n) => n ? n.toUpperCase() : "")
);
var om = /\B([A-Z])/g;
var Fe = bi(
  (e) => e.replace(om, "-$1").toLowerCase()
);
var Pt = bi((e) => e.charAt(0).toUpperCase() + e.slice(1));
var At = bi(
  (e) => e ? `on${Pt(e)}` : ""
);
var We = (e, t) => !Object.is(e, t);
var rn = (e, ...t) => {
  for (let n = 0; n < e.length; n++)
    e[n](...t);
};
var Mn = (e, t, n, s = false) => {
  Object.defineProperty(e, t, {
    configurable: true,
    enumerable: false,
    writable: s,
    value: n
  });
};
var Hr = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
};
var jr = (e) => {
  const t = X(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
var wl;
var an = () => wl || (wl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function cm(e, t) {
  return e + JSON.stringify(
    t,
    (n, s) => typeof s == "function" ? s.toString() : s
  );
}
var $s = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "NEED_HYDRATION",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "CACHED",
  [-2]: "BAIL"
};
var lm = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
};
var am = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
var fm = Ie(am);
var Cl = 2;
function um(e, t = 0, n = e.length) {
  if (t = Math.max(0, Math.min(t, e.length)), n = Math.max(0, Math.min(n, e.length)), t > n) return "";
  let s = e.split(/(\r?\n)/);
  const r = s.filter((c, l) => l % 2 === 1);
  s = s.filter((c, l) => l % 2 === 0);
  let i = 0;
  const o = [];
  for (let c = 0; c < s.length; c++)
    if (i += s[c].length + (r[c] && r[c].length || 0), i >= t) {
      for (let l = c - Cl; l <= c + Cl || n > i; l++) {
        if (l < 0 || l >= s.length) continue;
        const f = l + 1;
        o.push(
          `${f}${" ".repeat(Math.max(3 - String(f).length, 0))}|  ${s[l]}`
        );
        const u = s[l].length, a = r[l] && r[l].length || 0;
        if (l === c) {
          const p = t - (i - (u + a)), h = Math.max(
            1,
            n > i ? u - p : n - t
          );
          o.push("   |  " + " ".repeat(p) + "^".repeat(h));
        } else if (l > c) {
          if (n > i) {
            const p = Math.max(Math.min(n - i, u), 1);
            o.push("   |  " + "^".repeat(p));
          }
          i += u + a;
        }
      }
      break;
    }
  return o.join(`
`);
}
function vs(e) {
  if (F(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const s = e[n], r = X(s) ? Ef(s) : vs(s);
      if (r)
        for (const i in r)
          t[i] = r[i];
    }
    return t;
  } else if (X(e) || ie(e))
    return e;
}
var pm = /;(?![^(]*\))/g;
var dm = /:([^]+)/;
var hm = /\/\*[^]*?\*\//g;
function Ef(e) {
  const t = {};
  return e.replace(hm, "").split(pm).forEach((n) => {
    if (n) {
      const s = n.split(dm);
      s.length > 1 && (t[s[0].trim()] = s[1].trim());
    }
  }), t;
}
function gm(e) {
  if (!e) return "";
  if (X(e)) return e;
  let t = "";
  for (const n in e) {
    const s = e[n];
    if (X(s) || typeof s == "number") {
      const r = n.startsWith("--") ? n : Fe(n);
      t += `${r}:${s};`;
    }
  }
  return t;
}
function Ns(e) {
  let t = "";
  if (X(e))
    t = e;
  else if (F(e))
    for (let n = 0; n < e.length; n++) {
      const s = Ns(e[n]);
      s && (t += s + " ");
    }
  else if (ie(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
function mm(e) {
  if (!e) return null;
  let { class: t, style: n } = e;
  return t && !X(t) && (e.class = Ns(t)), n && (e.style = vs(n)), e;
}
var _m = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var Em = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var ym = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
var vm = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var yf = Ie(_m);
var vf = Ie(Em);
var Nf = Ie(ym);
var Nm = Ie(vm);
var bf = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
var bm = Ie(bf);
var Vl = Ie(
  bf + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
);
function dc(e) {
  return !!e || e === "";
}
var Om = Ie(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
);
var Sm = Ie(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
);
function Tm(e) {
  if (e == null)
    return false;
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean";
}
var Dm = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function wm(e, t) {
  return e.replace(
    Dm,
    (n) => `\\${n}`
  );
}
function Cm(e, t) {
  if (e.length !== t.length) return false;
  let n = true;
  for (let s = 0; n && s < e.length; s++)
    n = dn(e[s], t[s]);
  return n;
}
function dn(e, t) {
  if (e === t) return true;
  let n = Dl(e), s = Dl(t);
  if (n || s)
    return n && s ? e.getTime() === t.getTime() : false;
  if (n = nt(e), s = nt(t), n || s)
    return e === t;
  if (n = F(e), s = F(t), n || s)
    return n && s ? Cm(e, t) : false;
  if (n = ie(e), s = ie(t), n || s) {
    if (!n || !s)
      return false;
    const r = Object.keys(e).length, i = Object.keys(t).length;
    if (r !== i)
      return false;
    for (const o in e) {
      const c = e.hasOwnProperty(o), l = t.hasOwnProperty(o);
      if (c && !l || !c && l || !dn(e[o], t[o]))
        return false;
    }
  }
  return String(e) === String(t);
}
function Oi(e, t) {
  return e.findIndex((n) => dn(n, t));
}
var Of = (e) => !!(e && e.__v_isRef === true);
var Sf = (e) => X(e) ? e : e == null ? "" : F(e) || ie(e) && (e.toString === mf || !J(e.toString)) ? Of(e) ? Sf(e.value) : JSON.stringify(e, Tf, 2) : String(e);
var Tf = (e, t) => Of(t) ? Tf(e, t.value) : Tn(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (n, [s, r], i) => (n[eo(s, i) + " =>"] = r, n),
    {}
  )
} : jn(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((n) => eo(n))
} : nt(t) ? eo(t) : ie(t) && !F(t) && !Ni(t) ? String(t) : t;
var eo = (e, t = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    nt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  );
};
function Df(e) {
  return e == null ? "initial" : typeof e == "string" ? e === "" ? " " : e : ((typeof e != "number" || !Number.isFinite(e)) && true && console.warn(
    "[Vue warn] Invalid value used for CSS binding. Expected a string or a finite number but received:",
    e
  ), String(e));
}
function pt(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
var ke;
var hc = class {
  constructor(t = false) {
    this.detached = t, this._active = true, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = false, this.parent = ke, !t && ke && (this.index = (ke.scopes || (ke.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = false;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const n = ke;
      try {
        return ke = this, t();
      } finally {
        ke = n;
      }
    } else pt("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = ke, ke = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (ke = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = false;
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, s = this.scopes.length; n < s; n++)
          this.scopes[n].stop(true);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
};
function Vm(e) {
  return new hc(e);
}
function wf() {
  return ke;
}
function Am(e, t = false) {
  ke ? ke.cleanups.push(e) : !t && pt(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
var ae;
var to = /* @__PURE__ */ new WeakSet();
var Gs = class {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, ke && ke.active && ke.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, to.has(this) && (to.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Vf(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Al(this), Af(this);
    const t = ae, n = Nt;
    ae = this, Nt = true;
    try {
      return this.fn();
    } finally {
      ae !== this && pt(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), xf(this), ae = t, Nt = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        _c(t);
      this.deps = this.depsTail = void 0, Al(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? to.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Oo(this) && this.run();
  }
  get dirty() {
    return Oo(this);
  }
};
var Cf = 0;
var ks;
var Ls;
function Vf(e, t = false) {
  if (e.flags |= 8, t) {
    e.next = Ls, Ls = e;
    return;
  }
  e.next = ks, ks = e;
}
function gc() {
  Cf++;
}
function mc() {
  if (--Cf > 0)
    return;
  if (Ls) {
    let t = Ls;
    for (Ls = void 0; t; ) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n;
    }
  }
  let e;
  for (; ks; ) {
    let t = ks;
    for (ks = void 0; t; ) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (s) {
          e || (e = s);
        }
      t = n;
    }
  }
  if (e) throw e;
}
function Af(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function xf(e) {
  let t, n = e.depsTail, s = n;
  for (; s; ) {
    const r = s.prevDep;
    s.version === -1 ? (s === n && (n = r), _c(s), xm(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r;
  }
  e.deps = t, e.depsTail = n;
}
function Oo(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (If(t.dep.computed) || t.dep.version !== t.version))
      return true;
  return !!e._dirty;
}
function If(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === zs) || (e.globalVersion = zs, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Oo(e))))
    return;
  e.flags |= 2;
  const t = e.dep, n = ae, s = Nt;
  ae = e, Nt = true;
  try {
    Af(e);
    const r = e.fn(e._value);
    (t.version === 0 || We(r, e._value)) && (e.flags |= 128, e._value = r, t.version++);
  } catch (r) {
    throw t.version++, r;
  } finally {
    ae = n, Nt = s, xf(e), e.flags &= -3;
  }
}
function _c(e, t = false) {
  const { dep: n, prevSub: s, nextSub: r } = e;
  if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), n.subsHead === e && (n.subsHead = r), n.subs === e && (n.subs = s, !s && n.computed)) {
    n.computed.flags &= -5;
    for (let i = n.computed.deps; i; i = i.nextDep)
      _c(i, true);
  }
  !t && !--n.sc && n.map && n.map.delete(n.key);
}
function xm(e) {
  const { prevDep: t, nextDep: n } = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
}
function Im(e, t) {
  e.effect instanceof Gs && (e = e.effect.fn);
  const n = new Gs(e);
  t && te(n, t);
  try {
    n.run();
  } catch (r) {
    throw n.stop(), r;
  }
  const s = n.run.bind(n);
  return s.effect = n, s;
}
function Pm(e) {
  e.effect.stop();
}
var Nt = true;
var Pf = [];
function Ot() {
  Pf.push(Nt), Nt = false;
}
function St() {
  const e = Pf.pop();
  Nt = e === void 0 ? true : e;
}
function Al(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const n = ae;
    ae = void 0;
    try {
      t();
    } finally {
      ae = n;
    }
  }
}
var zs = 0;
var Rm = class {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
var Si = class {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = true, this.subsHead = void 0;
  }
  track(t) {
    if (!ae || !Nt || ae === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== ae)
      n = this.activeLink = new Rm(ae, this), ae.deps ? (n.prevDep = ae.depsTail, ae.depsTail.nextDep = n, ae.depsTail = n) : ae.deps = ae.depsTail = n, Rf(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const s = n.nextDep;
      s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = ae.depsTail, n.nextDep = void 0, ae.depsTail.nextDep = n, ae.depsTail = n, ae.deps === n && (ae.deps = s);
    }
    return ae.onTrack && ae.onTrack(
      te(
        {
          effect: ae
        },
        t
      )
    ), n;
  }
  trigger(t) {
    this.version++, zs++, this.notify(t);
  }
  notify(t) {
    gc();
    try {
      if (true)
        for (let n = this.subsHead; n; n = n.nextSub)
          n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
            te(
              {
                effect: n.sub
              },
              t
            )
          );
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      mc();
    }
  }
};
function Rf(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let s = t.deps; s; s = s.nextDep)
        Rf(s);
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subsHead === void 0 && (e.dep.subsHead = e), e.dep.subs = e;
  }
}
var Ur = /* @__PURE__ */ new WeakMap();
var Dn = Symbol(
  true ? "Object iterate" : ""
);
var So = Symbol(
  true ? "Map keys iterate" : ""
);
var Js = Symbol(
  true ? "Array iterate" : ""
);
function Ve(e, t, n) {
  if (Nt && ae) {
    let s = Ur.get(e);
    s || Ur.set(e, s = /* @__PURE__ */ new Map());
    let r = s.get(n);
    r || (s.set(n, r = new Si()), r.map = s, r.key = n), true ? r.track({
      target: e,
      type: t,
      key: n
    }) : r.track();
  }
}
function xt(e, t, n, s, r, i) {
  const o = Ur.get(e);
  if (!o) {
    zs++;
    return;
  }
  const c = (l) => {
    l && (true ? l.trigger({
      target: e,
      type: t,
      key: n,
      newValue: s,
      oldValue: r,
      oldTarget: i
    }) : l.trigger());
  };
  if (gc(), t === "clear")
    o.forEach(c);
  else {
    const l = F(e), f = l && pc(n);
    if (l && n === "length") {
      const u = Number(s);
      o.forEach((a, p) => {
        (p === "length" || p === Js || !nt(p) && p >= u) && c(a);
      });
    } else
      switch ((n !== void 0 || o.has(void 0)) && c(o.get(n)), f && c(o.get(Js)), t) {
        case "add":
          l ? f && c(o.get("length")) : (c(o.get(Dn)), Tn(e) && c(o.get(So)));
          break;
        case "delete":
          l || (c(o.get(Dn)), Tn(e) && c(o.get(So)));
          break;
        case "set":
          Tn(e) && c(o.get(Dn));
          break;
      }
  }
  mc();
}
function Mm(e, t) {
  const n = Ur.get(e);
  return n && n.get(t);
}
function Wn(e) {
  const t = Q(e);
  return t === e ? t : (Ve(t, "iterate", Js), je(e) ? t : t.map(Me));
}
function Ti(e) {
  return Ve(e = Q(e), "iterate", Js), e;
}
var $m = {
  __proto__: null,
  [Symbol.iterator]() {
    return no(this, Symbol.iterator, Me);
  },
  concat(...e) {
    return Wn(this).concat(
      ...e.map((t) => F(t) ? Wn(t) : t)
    );
  },
  entries() {
    return no(this, "entries", (e) => (e[1] = Me(e[1]), e));
  },
  every(e, t) {
    return Mt(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return Mt(this, "filter", e, t, (n) => n.map(Me), arguments);
  },
  find(e, t) {
    return Mt(this, "find", e, t, Me, arguments);
  },
  findIndex(e, t) {
    return Mt(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return Mt(this, "findLast", e, t, Me, arguments);
  },
  findLastIndex(e, t) {
    return Mt(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return Mt(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return so(this, "includes", e);
  },
  indexOf(...e) {
    return so(this, "indexOf", e);
  },
  join(e) {
    return Wn(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return so(this, "lastIndexOf", e);
  },
  map(e, t) {
    return Mt(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return Ds(this, "pop");
  },
  push(...e) {
    return Ds(this, "push", e);
  },
  reduce(e, ...t) {
    return xl(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return xl(this, "reduceRight", e, t);
  },
  shift() {
    return Ds(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return Mt(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return Ds(this, "splice", e);
  },
  toReversed() {
    return Wn(this).toReversed();
  },
  toSorted(e) {
    return Wn(this).toSorted(e);
  },
  toSpliced(...e) {
    return Wn(this).toSpliced(...e);
  },
  unshift(...e) {
    return Ds(this, "unshift", e);
  },
  values() {
    return no(this, "values", Me);
  }
};
function no(e, t, n) {
  const s = Ti(e), r = s[t]();
  return s !== e && !je(e) && (r._next = r.next, r.next = () => {
    const i = r._next();
    return i.value && (i.value = n(i.value)), i;
  }), r;
}
var km = Array.prototype;
function Mt(e, t, n, s, r, i) {
  const o = Ti(e), c = o !== e && !je(e), l = o[t];
  if (l !== km[t]) {
    const a = l.apply(e, i);
    return c ? Me(a) : a;
  }
  let f = n;
  o !== e && (c ? f = function(a, p) {
    return n.call(this, Me(a), p, e);
  } : n.length > 2 && (f = function(a, p) {
    return n.call(this, a, p, e);
  }));
  const u = l.call(o, f, s);
  return c && r ? r(u) : u;
}
function xl(e, t, n, s) {
  const r = Ti(e);
  let i = n;
  return r !== e && (je(e) ? n.length > 3 && (i = function(o, c, l) {
    return n.call(this, o, c, l, e);
  }) : i = function(o, c, l) {
    return n.call(this, o, Me(c), l, e);
  }), r[t](i, ...s);
}
function so(e, t, n) {
  const s = Q(e);
  Ve(s, "iterate", Js);
  const r = s[t](...n);
  return (r === -1 || r === false) && ss(n[0]) ? (n[0] = Q(n[0]), s[t](...n)) : r;
}
function Ds(e, t, n = []) {
  Ot(), gc();
  const s = Q(e)[t].apply(e, n);
  return mc(), St(), s;
}
var Lm = Ie("__proto__,__v_isRef,__isVue");
var Mf = new Set(
  Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(nt)
);
function Fm(e) {
  nt(e) || (e = String(e));
  const t = Q(this);
  return Ve(t, "has", e), t.hasOwnProperty(e);
}
var $f = class {
  constructor(t = false, n = false) {
    this._isReadonly = t, this._isShallow = n;
  }
  get(t, n, s) {
    if (n === "__v_skip") return t.__v_skip;
    const r = this._isReadonly, i = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return i;
    if (n === "__v_raw")
      return s === (r ? i ? Uf : jf : i ? Hf : Ff).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0;
    const o = F(t);
    if (!r) {
      let l;
      if (o && (l = $m[n]))
        return l;
      if (n === "hasOwnProperty")
        return Fm;
    }
    const c = Reflect.get(
      t,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      be(t) ? t : s
    );
    return (nt(n) ? Mf.has(n) : Lm(n)) || (r || Ve(t, "get", n), i) ? c : be(c) ? o && pc(n) ? c : c.value : ie(c) ? r ? Ci(c) : wi(c) : c;
  }
};
var kf = class extends $f {
  constructor(t = false) {
    super(false, t);
  }
  set(t, n, s, r) {
    let i = t[n];
    if (!this._isShallow) {
      const l = Tt(i);
      if (!je(s) && !Tt(s) && (i = Q(i), s = Q(s)), !F(t) && be(i) && !be(s))
        return l ? false : (i.value = s, true);
    }
    const o = F(t) && pc(n) ? Number(n) < t.length : oe(t, n), c = Reflect.set(
      t,
      n,
      s,
      be(t) ? t : r
    );
    return t === Q(r) && (o ? We(s, i) && xt(t, "set", n, s, i) : xt(t, "add", n, s)), c;
  }
  deleteProperty(t, n) {
    const s = oe(t, n), r = t[n], i = Reflect.deleteProperty(t, n);
    return i && s && xt(t, "delete", n, void 0, r), i;
  }
  has(t, n) {
    const s = Reflect.has(t, n);
    return (!nt(n) || !Mf.has(n)) && Ve(t, "has", n), s;
  }
  ownKeys(t) {
    return Ve(
      t,
      "iterate",
      F(t) ? "length" : Dn
    ), Reflect.ownKeys(t);
  }
};
var Lf = class extends $f {
  constructor(t = false) {
    super(true, t);
  }
  set(t, n) {
    return pt(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), true;
  }
  deleteProperty(t, n) {
    return pt(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), true;
  }
};
var Hm = new kf();
var jm = new Lf();
var Um = new kf(true);
var Bm = new Lf(true);
var To = (e) => e;
var mr = (e) => Reflect.getPrototypeOf(e);
function Km(e, t, n) {
  return function(...s) {
    const r = this.__v_raw, i = Q(r), o = Tn(i), c = e === "entries" || e === Symbol.iterator && o, l = e === "keys" && o, f = r[e](...s), u = n ? To : t ? Br : Me;
    return !t && Ve(
      i,
      "iterate",
      l ? So : Dn
    ), {
      // iterator protocol
      next() {
        const { value: a, done: p } = f.next();
        return p ? { value: a, done: p } : {
          value: c ? [u(a[0]), u(a[1])] : u(a),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function _r(e) {
  return function(...t) {
    if (true) {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      pt(
        `${Pt(e)} operation ${n}failed: target is readonly.`,
        Q(this)
      );
    }
    return e === "delete" ? false : e === "clear" ? void 0 : this;
  };
}
function Wm(e, t) {
  const n = {
    get(r) {
      const i = this.__v_raw, o = Q(i), c = Q(r);
      e || (We(r, c) && Ve(o, "get", r), Ve(o, "get", c));
      const { has: l } = mr(o), f = t ? To : e ? Br : Me;
      if (l.call(o, r))
        return f(i.get(r));
      if (l.call(o, c))
        return f(i.get(c));
      i !== o && i.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !e && Ve(Q(r), "iterate", Dn), Reflect.get(r, "size", r);
    },
    has(r) {
      const i = this.__v_raw, o = Q(i), c = Q(r);
      return e || (We(r, c) && Ve(o, "has", r), Ve(o, "has", c)), r === c ? i.has(r) : i.has(r) || i.has(c);
    },
    forEach(r, i) {
      const o = this, c = o.__v_raw, l = Q(c), f = t ? To : e ? Br : Me;
      return !e && Ve(l, "iterate", Dn), c.forEach((u, a) => r.call(i, f(u), f(a), o));
    }
  };
  return te(
    n,
    e ? {
      add: _r("add"),
      set: _r("set"),
      delete: _r("delete"),
      clear: _r("clear")
    } : {
      add(r) {
        !t && !je(r) && !Tt(r) && (r = Q(r));
        const i = Q(this);
        return mr(i).has.call(i, r) || (i.add(r), xt(i, "add", r, r)), this;
      },
      set(r, i) {
        !t && !je(i) && !Tt(i) && (i = Q(i));
        const o = Q(this), { has: c, get: l } = mr(o);
        let f = c.call(o, r);
        f ? Il(o, c, r) : (r = Q(r), f = c.call(o, r));
        const u = l.call(o, r);
        return o.set(r, i), f ? We(i, u) && xt(o, "set", r, i, u) : xt(o, "add", r, i), this;
      },
      delete(r) {
        const i = Q(this), { has: o, get: c } = mr(i);
        let l = o.call(i, r);
        l ? Il(i, o, r) : (r = Q(r), l = o.call(i, r));
        const f = c ? c.call(i, r) : void 0, u = i.delete(r);
        return l && xt(i, "delete", r, void 0, f), u;
      },
      clear() {
        const r = Q(this), i = r.size !== 0, o = true ? Tn(r) ? new Map(r) : new Set(r) : void 0, c = r.clear();
        return i && xt(
          r,
          "clear",
          void 0,
          void 0,
          o
        ), c;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = Km(r, e, t);
  }), n;
}
function Di(e, t) {
  const n = Wm(e, t);
  return (s, r, i) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(
    oe(n, r) && r in s ? n : s,
    r,
    i
  );
}
var qm = {
  get: Di(false, false)
};
var Gm = {
  get: Di(false, true)
};
var zm = {
  get: Di(true, false)
};
var Jm = {
  get: Di(true, true)
};
function Il(e, t, n) {
  const s = Q(n);
  if (s !== n && t.call(e, s)) {
    const r = uc(e);
    pt(
      `Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
var Ff = /* @__PURE__ */ new WeakMap();
var Hf = /* @__PURE__ */ new WeakMap();
var jf = /* @__PURE__ */ new WeakMap();
var Uf = /* @__PURE__ */ new WeakMap();
function Ym(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Xm(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Ym(uc(e));
}
function wi(e) {
  return Tt(e) ? e : Vi(
    e,
    false,
    Hm,
    qm,
    Ff
  );
}
function Bf(e) {
  return Vi(
    e,
    false,
    Um,
    Gm,
    Hf
  );
}
function Ci(e) {
  return Vi(
    e,
    true,
    jm,
    zm,
    jf
  );
}
function Et(e) {
  return Vi(
    e,
    true,
    Bm,
    Jm,
    Uf
  );
}
function Vi(e, t, n, s, r) {
  if (!ie(e))
    return pt(
      `value cannot be made ${t ? "readonly" : "reactive"}: ${String(
        e
      )}`
    ), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const i = Xm(e);
  if (i === 0)
    return e;
  const o = r.get(e);
  if (o)
    return o;
  const c = new Proxy(
    e,
    i === 2 ? s : n
  );
  return r.set(e, c), c;
}
function Bt(e) {
  return Tt(e) ? Bt(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Tt(e) {
  return !!(e && e.__v_isReadonly);
}
function je(e) {
  return !!(e && e.__v_isShallow);
}
function ss(e) {
  return e ? !!e.__v_raw : false;
}
function Q(e) {
  const t = e && e.__v_raw;
  return t ? Q(t) : e;
}
function Kf(e) {
  return !oe(e, "__v_skip") && Object.isExtensible(e) && Mn(e, "__v_skip", true), e;
}
var Me = (e) => ie(e) ? wi(e) : e;
var Br = (e) => ie(e) ? Ci(e) : e;
function be(e) {
  return e ? e.__v_isRef === true : false;
}
function wn(e) {
  return qf(e, false);
}
function Wf(e) {
  return qf(e, true);
}
function qf(e, t) {
  return be(e) ? e : new Zm(e, t);
}
var Zm = class {
  constructor(t, n) {
    this.dep = new Si(), this.__v_isRef = true, this.__v_isShallow = false, this._rawValue = n ? t : Q(t), this._value = n ? t : Me(t), this.__v_isShallow = n;
  }
  get value() {
    return true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(t) {
    const n = this._rawValue, s = this.__v_isShallow || je(t) || Tt(t);
    t = s ? t : Q(t), We(t, n) && (this._rawValue = t, this._value = s ? t : Me(t), true ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: n
    }) : this.dep.trigger());
  }
};
function Qm(e) {
  e.dep && (true ? e.dep.trigger({
    target: e,
    type: "set",
    key: "value",
    newValue: e._value
  }) : e.dep.trigger());
}
function Ai(e) {
  return be(e) ? e.value : e;
}
function e_(e) {
  return J(e) ? e() : Ai(e);
}
var t_ = {
  get: (e, t, n) => t === "__v_raw" ? e : Ai(Reflect.get(e, t, n)),
  set: (e, t, n, s) => {
    const r = e[t];
    return be(r) && !be(n) ? (r.value = n, true) : Reflect.set(e, t, n, s);
  }
};
function Ec(e) {
  return Bt(e) ? e : new Proxy(e, t_);
}
var n_ = class {
  constructor(t) {
    this.__v_isRef = true, this._value = void 0;
    const n = this.dep = new Si(), { get: s, set: r } = t(n.track.bind(n), n.trigger.bind(n));
    this._get = s, this._set = r;
  }
  get value() {
    return this._value = this._get();
  }
  set value(t) {
    this._set(t);
  }
};
function Gf(e) {
  return new n_(e);
}
function s_(e) {
  !ss(e) && pt("toRefs() expects a reactive object but received a plain one.");
  const t = F(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = zf(e, n);
  return t;
}
var r_ = class {
  constructor(t, n, s) {
    this._object = t, this._key = n, this._defaultValue = s, this.__v_isRef = true, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return Mm(Q(this._object), this._key);
  }
};
var i_ = class {
  constructor(t) {
    this._getter = t, this.__v_isRef = true, this.__v_isReadonly = true, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
};
function o_(e, t, n) {
  return be(e) ? e : J(e) ? new i_(e) : ie(e) && arguments.length > 1 ? zf(e, t, n) : wn(e);
}
function zf(e, t, n) {
  const s = e[t];
  return be(s) ? s : new r_(e, t, n);
}
var c_ = class {
  constructor(t, n, s) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new Si(this), this.__v_isRef = true, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = zs - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    ae !== this)
      return Vf(this, true), true;
  }
  get value() {
    const t = true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return If(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter ? this.setter(t) : pt("Write operation failed: computed value is readonly");
  }
};
function l_(e, t, n = false) {
  let s, r;
  J(e) ? s = e : (s = e.get, r = e.set);
  const i = new c_(s, r, n);
  return t && !n && (i.onTrack = t.onTrack, i.onTrigger = t.onTrigger), i;
}
var a_ = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
};
var f_ = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
};
var Er = {};
var Kr = /* @__PURE__ */ new WeakMap();
var Qt;
function u_() {
  return Qt;
}
function Jf(e, t = false, n = Qt) {
  if (n) {
    let s = Kr.get(n);
    s || Kr.set(n, s = []), s.push(e);
  } else !t && pt(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function p_(e, t, n = se) {
  const { immediate: s, deep: r, once: i, scheduler: o, augmentJob: c, call: l } = n, f = (y) => {
    (n.onWarn || pt)(
      "Invalid watch source: ",
      y,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = (y) => r ? y : je(y) || r === false || r === 0 ? Ht(y, 1) : Ht(y);
  let a, p, h, _, E = false, M = false;
  if (be(e) ? (p = () => e.value, E = je(e)) : Bt(e) ? (p = () => u(e), E = true) : F(e) ? (M = true, E = e.some((y) => Bt(y) || je(y)), p = () => e.map((y) => {
    if (be(y))
      return y.value;
    if (Bt(y))
      return u(y);
    if (J(y))
      return l ? l(y, 2) : y();
    f(y);
  })) : J(e) ? t ? p = l ? () => l(e, 2) : e : p = () => {
    if (h) {
      Ot();
      try {
        h();
      } finally {
        St();
      }
    }
    const y = Qt;
    Qt = a;
    try {
      return l ? l(e, 3, [_]) : e(_);
    } finally {
      Qt = y;
    }
  } : (p = me, f(e)), t && r) {
    const y = p, w = r === true ? 1 / 0 : r;
    p = () => Ht(y(), w);
  }
  const C = wf(), D = () => {
    a.stop(), C && C.active && fc(C.effects, a);
  };
  if (i && t) {
    const y = t;
    t = (...w) => {
      y(...w), D();
    };
  }
  let g = M ? new Array(e.length).fill(Er) : Er;
  const N = (y) => {
    if (!(!(a.flags & 1) || !a.dirty && !y))
      if (t) {
        const w = a.run();
        if (r || E || (M ? w.some((H, V) => We(H, g[V])) : We(w, g))) {
          h && h();
          const H = Qt;
          Qt = a;
          try {
            const V = [
              w,
              // pass undefined as the old value when it's changed for the first time
              g === Er ? void 0 : M && g[0] === Er ? [] : g,
              _
            ];
            g = w, l ? l(t, 3, V) : (
              // @ts-expect-error
              t(...V)
            );
          } finally {
            Qt = H;
          }
        }
      } else
        a.run();
  };
  return c && c(N), a = new Gs(p), a.scheduler = o ? () => o(N, false) : N, _ = (y) => Jf(y, false, a), h = a.onStop = () => {
    const y = Kr.get(a);
    if (y) {
      if (l)
        l(y, 4);
      else
        for (const w of y) w();
      Kr.delete(a);
    }
  }, a.onTrack = n.onTrack, a.onTrigger = n.onTrigger, t ? s ? N(true) : g = a.run() : o ? o(N.bind(null, true), true) : a.run(), D.pause = a.pause.bind(a), D.resume = a.resume.bind(a), D.stop = D, D;
}
function Ht(e, t = 1 / 0, n) {
  if (t <= 0 || !ie(e) || e.__v_skip || (n = n || /* @__PURE__ */ new Set(), n.has(e)))
    return e;
  if (n.add(e), t--, be(e))
    Ht(e.value, t, n);
  else if (F(e))
    for (let s = 0; s < e.length; s++)
      Ht(e[s], t, n);
  else if (jn(e) || Tn(e))
    e.forEach((s) => {
      Ht(s, t, n);
    });
  else if (Ni(e)) {
    for (const s in e)
      Ht(e[s], t, n);
    for (const s of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, s) && Ht(e[s], t, n);
  }
  return e;
}
var Cn = [];
function Xn(e) {
  Cn.push(e);
}
function Zn() {
  Cn.pop();
}
var ro = false;
function T(e, ...t) {
  if (ro) return;
  ro = true, Ot();
  const n = Cn.length ? Cn[Cn.length - 1].component : null, s = n && n.appContext.config.warnHandler, r = d_();
  if (s)
    Un(
      s,
      n,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        e + t.map((i) => {
          var o, c;
          return (c = (o = i.toString) == null ? void 0 : o.call(i)) != null ? c : JSON.stringify(i);
        }).join(""),
        n && n.proxy,
        r.map(
          ({ vnode: i }) => `at <${Bi(n, i.type)}>`
        ).join(`
`),
        r
      ]
    );
  else {
    const i = [`[Vue warn]: ${e}`, ...t];
    r.length && i.push(`
`, ...h_(r)), console.warn(...i);
  }
  St(), ro = false;
}
function d_() {
  let e = Cn[Cn.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const n = t[0];
    n && n.vnode === e ? n.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const s = e.component && e.component.parent;
    e = s && s.vnode;
  }
  return t;
}
function h_(e) {
  const t = [];
  return e.forEach((n, s) => {
    t.push(...s === 0 ? [] : [`
`], ...g_(n));
  }), t;
}
function g_({ vnode: e, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : "", s = e.component ? e.component.parent == null : false, r = ` at <${Bi(
    e.component,
    e.type,
    s
  )}`, i = ">" + n;
  return e.props ? [r, ...m_(e.props), i] : [r + i];
}
function m_(e) {
  const t = [], n = Object.keys(e);
  return n.slice(0, 3).forEach((s) => {
    t.push(...Yf(s, e[s]));
  }), n.length > 3 && t.push(" ..."), t;
}
function Yf(e, t, n) {
  return X(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : be(t) ? (t = Yf(e, Q(t.value), true), n ? t : [`${e}=Ref<`, t, ">"]) : J(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Q(t), n ? t : [`${e}=`, t]);
}
function yc(e, t) {
  e !== void 0 && (typeof e != "number" ? T(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && T(`${t} is NaN - the duration expression might be incorrect.`));
}
var __ = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE",
  APP_UNMOUNT_CLEANUP: 16,
  16: "APP_UNMOUNT_CLEANUP"
};
var xi = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Un(e, t, n, s) {
  try {
    return s ? e(...s) : e();
  } catch (r) {
    gn(r, t, n);
  }
}
function dt(e, t, n, s) {
  if (J(e)) {
    const r = Un(e, t, n, s);
    return r && vi(r) && r.catch((i) => {
      gn(i, t, n);
    }), r;
  }
  if (F(e)) {
    const r = [];
    for (let i = 0; i < e.length; i++)
      r.push(dt(e[i], t, n, s));
    return r;
  } else T(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`
  );
}
function gn(e, t, n, s = true) {
  const r = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: o } = t && t.appContext.config || se;
  if (t) {
    let c = t.parent;
    const l = t.proxy, f = true ? xi[n] : `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; c; ) {
      const u = c.ec;
      if (u) {
        for (let a = 0; a < u.length; a++)
          if (u[a](e, l, f) === false)
            return;
      }
      c = c.parent;
    }
    if (i) {
      Ot(), Un(i, null, 10, [
        e,
        l,
        f
      ]), St();
      return;
    }
  }
  E_(e, n, r, s, o);
}
function E_(e, t, n, s = true, r = false) {
  if (true) {
    const i = xi[t];
    if (n && Xn(n), T(`Unhandled error${i ? ` during execution of ${i}` : ""}`), n && Zn(), s)
      throw e;
    console.error(e);
  } else {
    if (r)
      throw e;
    console.error(e);
  }
}
var qe = [];
var Ct = -1;
var Qn = [];
var en = null;
var zn = 0;
var Xf = Promise.resolve();
var Wr = null;
var y_ = 100;
function Ii(e) {
  const t = Wr || Xf;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function v_(e) {
  let t = Ct + 1, n = qe.length;
  for (; t < n; ) {
    const s = t + n >>> 1, r = qe[s], i = Ys(r);
    i < e || i === e && r.flags & 2 ? t = s + 1 : n = s;
  }
  return t;
}
function Pi(e) {
  if (!(e.flags & 1)) {
    const t = Ys(e), n = qe[qe.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= Ys(n) ? qe.push(e) : qe.splice(v_(t), 0, e), e.flags |= 1, Zf();
  }
}
function Zf() {
  Wr || (Wr = Xf.then(Qf));
}
function rs(e) {
  F(e) ? Qn.push(...e) : en && e.id === -1 ? en.splice(zn + 1, 0, e) : e.flags & 1 || (Qn.push(e), e.flags |= 1), Zf();
}
function Pl(e, t, n = Ct + 1) {
  for (t = t || /* @__PURE__ */ new Map(); n < qe.length; n++) {
    const s = qe[n];
    if (s && s.flags & 2) {
      if (e && s.id !== e.uid || vc(t, s))
        continue;
      qe.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function qr(e) {
  if (Qn.length) {
    const t = [...new Set(Qn)].sort(
      (n, s) => Ys(n) - Ys(s)
    );
    if (Qn.length = 0, en) {
      en.push(...t);
      return;
    }
    for (en = t, e = e || /* @__PURE__ */ new Map(), zn = 0; zn < en.length; zn++) {
      const n = en[zn];
      vc(e, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
    }
    en = null, zn = 0;
  }
}
var Ys = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function Qf(e) {
  e = e || /* @__PURE__ */ new Map();
  const t = true ? (n) => vc(e, n) : me;
  try {
    for (Ct = 0; Ct < qe.length; Ct++) {
      const n = qe[Ct];
      if (n && !(n.flags & 8)) {
        if (t(n))
          continue;
        n.flags & 4 && (n.flags &= -2), Un(
          n,
          n.i,
          n.i ? 15 : 14
        ), n.flags & 4 || (n.flags &= -2);
      }
    }
  } finally {
    for (; Ct < qe.length; Ct++) {
      const n = qe[Ct];
      n && (n.flags &= -2);
    }
    Ct = -1, qe.length = 0, qr(e), Wr = null, (qe.length || Qn.length) && Qf(e);
  }
}
function vc(e, t) {
  const n = e.get(t) || 0;
  if (n > y_) {
    const s = t.i, r = s && cs(s.type);
    return gn(
      `Maximum recursive updates exceeded${r ? ` in component <${r}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), true;
  }
  return e.set(t, n + 1), false;
}
var yt = false;
var Cr = /* @__PURE__ */ new Map();
an().__VUE_HMR_RUNTIME__ = {
  createRecord: io(eu),
  rerender: io(O_),
  reload: io(S_)
};
var $n = /* @__PURE__ */ new Map();
function N_(e) {
  const t = e.type.__hmrId;
  let n = $n.get(t);
  n || (eu(t, e.type), n = $n.get(t)), n.instances.add(e);
}
function b_(e) {
  $n.get(e.type.__hmrId).instances.delete(e);
}
function eu(e, t) {
  return $n.has(e) ? false : ($n.set(e, {
    initialDef: Gr(t),
    instances: /* @__PURE__ */ new Set()
  }), true);
}
function Gr(e) {
  return lp(e) ? e.__vccOpts : e;
}
function O_(e, t) {
  const n = $n.get(e);
  n && (n.initialDef.render = t, [...n.instances].forEach((s) => {
    t && (s.render = t, Gr(s.type).render = t), s.renderCache = [], yt = true, s.update(), yt = false;
  }));
}
function S_(e, t) {
  const n = $n.get(e);
  if (!n) return;
  t = Gr(t), Rl(n.initialDef, t);
  const s = [...n.instances];
  for (let r = 0; r < s.length; r++) {
    const i = s[r], o = Gr(i.type);
    let c = Cr.get(o);
    c || (o !== n.initialDef && Rl(o, t), Cr.set(o, c = /* @__PURE__ */ new Set())), c.add(i), i.appContext.propsCache.delete(i.type), i.appContext.emitsCache.delete(i.type), i.appContext.optionsCache.delete(i.type), i.ceReload ? (c.add(i), i.ceReload(t.styles), c.delete(i)) : i.parent ? Pi(() => {
      yt = true, i.parent.update(), yt = false, c.delete(i);
    }) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), i.root.ce && i !== i.root && i.root.ce._removeChildStyle(o);
  }
  rs(() => {
    Cr.clear();
  });
}
function Rl(e, t) {
  te(e, t);
  for (const n in e)
    n !== "__file" && !(n in t) && delete e[n];
}
function io(e) {
  return (t, n) => {
    try {
      return e(t, n);
    } catch (s) {
      console.error(s), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
var mt;
var xs = [];
var Do = false;
function lr(e, ...t) {
  mt ? mt.emit(e, ...t) : Do || xs.push({ event: e, args: t });
}
function Nc(e, t) {
  var n, s;
  mt = e, mt ? (mt.enabled = true, xs.forEach(({ event: r, args: i }) => mt.emit(r, ...i)), xs = []) : (
    /* handle late devtools injection - only do this if we are in an actual */
    /* browser environment to avoid the timer handle stalling test runner exit */
    /* (#4815) */
    typeof window < "u" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((s = (n = window.navigator) == null ? void 0 : n.userAgent) != null && s.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((i) => {
      Nc(i, t);
    }), setTimeout(() => {
      mt || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Do = true, xs = []);
    }, 3e3)) : (Do = true, xs = [])
  );
}
function T_(e, t) {
  lr("app:init", e, t, {
    Fragment: De,
    Text: It,
    Comment: Ee,
    Static: un
  });
}
function D_(e) {
  lr("app:unmount", e);
}
var wo = bc(
  "component:added"
  /* COMPONENT_ADDED */
);
var tu = bc(
  "component:updated"
  /* COMPONENT_UPDATED */
);
var w_ = bc(
  "component:removed"
  /* COMPONENT_REMOVED */
);
var C_ = (e) => {
  mt && typeof mt.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !mt.cleanupBuffer(e) && w_(e);
};
function bc(e) {
  return (t) => {
    lr(
      e,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
var V_ = nu(
  "perf:start"
  /* PERFORMANCE_START */
);
var A_ = nu(
  "perf:end"
  /* PERFORMANCE_END */
);
function nu(e) {
  return (t, n, s) => {
    lr(e, t.appContext.app, t.uid, t, n, s);
  };
}
function x_(e, t, n) {
  lr(
    "component:emit",
    e.appContext.app,
    e,
    t,
    n
  );
}
var Te = null;
var Ri = null;
function Xs(e) {
  const t = Te;
  return Te = e, Ri = e && e.type.__scopeId || null, t;
}
function I_(e) {
  Ri = e;
}
function P_() {
  Ri = null;
}
var R_ = (e) => Oc;
function Oc(e, t = Te, n) {
  if (!t || e._n)
    return e;
  const s = (...r) => {
    s._d && $o(-1);
    const i = Xs(t);
    let o;
    try {
      o = e(...r);
    } finally {
      Xs(i), s._d && $o(1);
    }
    return tu(t), o;
  };
  return s._n = true, s._c = true, s._d = true, s;
}
function su(e) {
  _f(e) && T("Do not use built-in directive ids as custom directive id: " + e);
}
function M_(e, t) {
  if (Te === null)
    return T("withDirectives can only be used inside render functions."), e;
  const n = ur(Te), s = e.dirs || (e.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [i, o, c, l = se] = t[r];
    i && (J(i) && (i = {
      mounted: i,
      updated: i
    }), i.deep && Ht(o), s.push({
      dir: i,
      instance: n,
      value: o,
      oldValue: void 0,
      arg: c,
      modifiers: l
    }));
  }
  return e;
}
function Vt(e, t, n, s) {
  const r = e.dirs, i = t && t.dirs;
  for (let o = 0; o < r.length; o++) {
    const c = r[o];
    i && (c.oldValue = i[o].value);
    let l = c.dir[s];
    l && (Ot(), dt(l, n, 8, [
      e.el,
      c,
      e,
      t
    ]), St());
  }
}
var ru = Symbol("_vte");
var iu = (e) => e.__isTeleport;
var Vn = (e) => e && (e.disabled || e.disabled === "");
var Ml = (e) => e && (e.defer || e.defer === "");
var $l = (e) => typeof SVGElement < "u" && e instanceof SVGElement;
var kl = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement;
var Co = (e, t) => {
  const n = e && e.to;
  if (X(n))
    if (t) {
      const s = t(n);
      return !s && !Vn(e) && T(
        `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), s;
    } else
      return T(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return !n && !Vn(e) && T(`Invalid Teleport target: ${n}`), n;
};
var ou = {
  name: "Teleport",
  __isTeleport: true,
  process(e, t, n, s, r, i, o, c, l, f) {
    const {
      mc: u,
      pc: a,
      pbc: p,
      o: { insert: h, querySelector: _, createText: E, createComment: M }
    } = f, C = Vn(t.props);
    let { shapeFlag: D, children: g, dynamicChildren: N } = t;
    if (yt && (l = false, N = null), e == null) {
      const y = t.el = true ? M("teleport start") : E(""), w = t.anchor = true ? M("teleport end") : E("");
      h(y, n, s), h(w, n, s);
      const H = (v, S) => {
        D & 16 && (r && r.isCE && (r.ce._teleportTarget = v), u(
          g,
          v,
          S,
          r,
          i,
          o,
          c,
          l
        ));
      }, V = () => {
        const v = t.target = Co(t.props, _), S = cu(v, t, E, h);
        v ? (o !== "svg" && $l(v) ? o = "svg" : o !== "mathml" && kl(v) && (o = "mathml"), C || (H(v, S), Vr(t, false))) : !C && T(
          "Invalid Teleport target on mount:",
          v,
          `(${typeof v})`
        );
      };
      C && (H(n, w), Vr(t, true)), Ml(t.props) ? (t.el.__isMounted = false, Ce(() => {
        V(), delete t.el.__isMounted;
      }, i)) : V();
    } else {
      if (Ml(t.props) && e.el.__isMounted === false) {
        Ce(() => {
          ou.process(
            e,
            t,
            n,
            s,
            r,
            i,
            o,
            c,
            l,
            f
          );
        }, i);
        return;
      }
      t.el = e.el, t.targetStart = e.targetStart;
      const y = t.anchor = e.anchor, w = t.target = e.target, H = t.targetAnchor = e.targetAnchor, V = Vn(e.props), v = V ? n : w, S = V ? y : H;
      if (o === "svg" || $l(w) ? o = "svg" : (o === "mathml" || kl(w)) && (o = "mathml"), N ? (p(
        e.dynamicChildren,
        N,
        v,
        r,
        i,
        o,
        c
      ), js(e, t, false)) : l || a(
        e,
        t,
        v,
        S,
        r,
        i,
        o,
        c,
        false
      ), C)
        V ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : yr(
          t,
          n,
          y,
          f,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const R = t.target = Co(
          t.props,
          _
        );
        R ? yr(
          t,
          R,
          null,
          f,
          0
        ) : T(
          "Invalid Teleport target on update:",
          w,
          `(${typeof w})`
        );
      } else V && yr(
        t,
        w,
        H,
        f,
        1
      );
      Vr(t, C);
    }
  },
  remove(e, t, n, { um: s, o: { remove: r } }, i) {
    const {
      shapeFlag: o,
      children: c,
      anchor: l,
      targetStart: f,
      targetAnchor: u,
      target: a,
      props: p
    } = e;
    if (a && (r(f), r(u)), i && r(l), o & 16) {
      const h = i || !Vn(p);
      for (let _ = 0; _ < c.length; _++) {
        const E = c[_];
        s(
          E,
          t,
          n,
          h,
          !!E.dynamicChildren
        );
      }
    }
  },
  move: yr,
  hydrate: $_
};
function yr(e, t, n, { o: { insert: s }, m: r }, i = 2) {
  i === 0 && s(e.targetAnchor, t, n);
  const { el: o, anchor: c, shapeFlag: l, children: f, props: u } = e, a = i === 2;
  if (a && s(o, t, n), (!a || Vn(u)) && l & 16)
    for (let p = 0; p < f.length; p++)
      r(
        f[p],
        t,
        n,
        2
      );
  a && s(c, t, n);
}
function $_(e, t, n, s, r, i, {
  o: { nextSibling: o, parentNode: c, querySelector: l, insert: f, createText: u }
}, a) {
  const p = t.target = Co(
    t.props,
    l
  );
  if (p) {
    const h = Vn(t.props), _ = p._lpa || p.firstChild;
    if (t.shapeFlag & 16)
      if (h)
        t.anchor = a(
          o(e),
          t,
          c(e),
          n,
          s,
          r,
          i
        ), t.targetStart = _, t.targetAnchor = _ && o(_);
      else {
        t.anchor = o(e);
        let E = _;
        for (; E; ) {
          if (E && E.nodeType === 8) {
            if (E.data === "teleport start anchor")
              t.targetStart = E;
            else if (E.data === "teleport anchor") {
              t.targetAnchor = E, p._lpa = t.targetAnchor && o(t.targetAnchor);
              break;
            }
          }
          E = o(E);
        }
        t.targetAnchor || cu(p, t, u, f), a(
          _ && o(_),
          t,
          p,
          n,
          s,
          r,
          i
        );
      }
    Vr(t, h);
  }
  return t.anchor && o(t.anchor);
}
var k_ = ou;
function Vr(e, t) {
  const n = e.ctx;
  if (n && n.ut) {
    let s, r;
    for (t ? (s = e.el, r = e.anchor) : (s = e.targetStart, r = e.targetAnchor); s && s !== r; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", n.uid), s = s.nextSibling;
    n.ut();
  }
}
function cu(e, t, n, s) {
  const r = t.targetStart = n(""), i = t.targetAnchor = n("");
  return r[ru] = i, e && (s(r, e), s(i, e)), i;
}
var tn = Symbol("_leaveCb");
var vr = Symbol("_enterCb");
function Sc() {
  const e = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return ar(() => {
    e.isMounted = true;
  }), Li(() => {
    e.isUnmounting = true;
  }), e;
}
var at = [Function, Array];
var Tc = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: at,
  onEnter: at,
  onAfterEnter: at,
  onEnterCancelled: at,
  // leave
  onBeforeLeave: at,
  onLeave: at,
  onAfterLeave: at,
  onLeaveCancelled: at,
  // appear
  onBeforeAppear: at,
  onAppear: at,
  onAfterAppear: at,
  onAppearCancelled: at
};
var lu = (e) => {
  const t = e.subTree;
  return t.component ? lu(t.component) : t;
};
var L_ = {
  name: "BaseTransition",
  props: Tc,
  setup(e, { slots: t }) {
    const n = ze(), s = Sc();
    return () => {
      const r = t.default && Mi(t.default(), true);
      if (!r || !r.length)
        return;
      const i = au(r), o = Q(e), { mode: c } = o;
      if (c && c !== "in-out" && c !== "out-in" && c !== "default" && T(`invalid <transition> mode: ${c}`), s.isLeaving)
        return oo(i);
      const l = Ll(i);
      if (!l)
        return oo(i);
      let f = is(
        l,
        o,
        s,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (a) => f = a
      );
      l.type !== Ee && qt(l, f);
      let u = n.subTree && Ll(n.subTree);
      if (u && u.type !== Ee && !_t(l, u) && lu(n).type !== Ee) {
        let a = is(
          u,
          o,
          s,
          n
        );
        if (qt(u, a), c === "out-in" && l.type !== Ee)
          return s.isLeaving = true, a.afterLeave = () => {
            s.isLeaving = false, n.job.flags & 8 || n.update(), delete a.afterLeave, u = void 0;
          }, oo(i);
        c === "in-out" && l.type !== Ee ? a.delayLeave = (p, h, _) => {
          const E = uu(
            s,
            u
          );
          E[String(u.key)] = u, p[tn] = () => {
            h(), p[tn] = void 0, delete f.delayedLeave, u = void 0;
          }, f.delayedLeave = () => {
            _(), delete f.delayedLeave, u = void 0;
          };
        } : u = void 0;
      } else u && (u = void 0);
      return i;
    };
  }
};
function au(e) {
  let t = e[0];
  if (e.length > 1) {
    let n = false;
    for (const s of e)
      if (s.type !== Ee) {
        if (n) {
          T(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (t = s, n = true, false) break;
      }
  }
  return t;
}
var fu = L_;
function uu(e, t) {
  const { leavingVNodes: n } = e;
  let s = n.get(t.type);
  return s || (s = /* @__PURE__ */ Object.create(null), n.set(t.type, s)), s;
}
function is(e, t, n, s, r) {
  const {
    appear: i,
    mode: o,
    persisted: c = false,
    onBeforeEnter: l,
    onEnter: f,
    onAfterEnter: u,
    onEnterCancelled: a,
    onBeforeLeave: p,
    onLeave: h,
    onAfterLeave: _,
    onLeaveCancelled: E,
    onBeforeAppear: M,
    onAppear: C,
    onAfterAppear: D,
    onAppearCancelled: g
  } = t, N = String(e.key), y = uu(n, e), w = (v, S) => {
    v && dt(
      v,
      s,
      9,
      S
    );
  }, H = (v, S) => {
    const R = S[1];
    w(v, S), F(v) ? v.every((b) => b.length <= 1) && R() : v.length <= 1 && R();
  }, V = {
    mode: o,
    persisted: c,
    beforeEnter(v) {
      let S = l;
      if (!n.isMounted)
        if (i)
          S = M || l;
        else
          return;
      v[tn] && v[tn](
        true
        /* cancelled */
      );
      const R = y[N];
      R && _t(e, R) && R.el[tn] && R.el[tn](), w(S, [v]);
    },
    enter(v) {
      let S = f, R = u, b = a;
      if (!n.isMounted)
        if (i)
          S = C || f, R = D || u, b = g || a;
        else
          return;
      let L = false;
      const W = v[vr] = (q) => {
        L || (L = true, q ? w(b, [v]) : w(R, [v]), V.delayedLeave && V.delayedLeave(), v[vr] = void 0);
      };
      S ? H(S, [v, W]) : W();
    },
    leave(v, S) {
      const R = String(e.key);
      if (v[vr] && v[vr](
        true
        /* cancelled */
      ), n.isUnmounting)
        return S();
      w(p, [v]);
      let b = false;
      const L = v[tn] = (W) => {
        b || (b = true, S(), W ? w(E, [v]) : w(_, [v]), v[tn] = void 0, y[R] === e && delete y[R]);
      };
      y[R] = e, h ? H(h, [v, L]) : L();
    },
    clone(v) {
      const S = is(
        v,
        t,
        n,
        s,
        r
      );
      return r && r(S), S;
    }
  };
  return V;
}
function oo(e) {
  if (bs(e))
    return e = ht(e), e.children = null, e;
}
function Ll(e) {
  if (!bs(e))
    return iu(e.type) && e.children ? au(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: t, children: n } = e;
  if (n) {
    if (t & 16)
      return n[0];
    if (t & 32 && J(n.default))
      return n.default();
  }
}
function qt(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, qt(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function Mi(e, t = false, n) {
  let s = [], r = 0;
  for (let i = 0; i < e.length; i++) {
    let o = e[i];
    const c = n == null ? o.key : String(n) + String(o.key != null ? o.key : i);
    o.type === De ? (o.patchFlag & 128 && r++, s = s.concat(
      Mi(o.children, t, c)
    )) : (t || o.type !== Ee) && s.push(c != null ? ht(o, { key: c }) : o);
  }
  if (r > 1)
    for (let i = 0; i < s.length; i++)
      s[i].patchFlag = -2;
  return s;
}
function Dc(e, t) {
  return J(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    te({ name: e.name }, t, { setup: e })
  ) : e;
}
function F_() {
  const e = ze();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : (T(
    "useId() is called when there is no active component instance to be associated with."
  ), "");
}
function wc(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
var pu = /* @__PURE__ */ new WeakSet();
function H_(e) {
  const t = ze(), n = Wf(null);
  if (t) {
    const r = t.refs === se ? t.refs = {} : t.refs;
    let i;
    (i = Object.getOwnPropertyDescriptor(r, e)) && !i.configurable ? T(`useTemplateRef('${e}') already exists.`) : Object.defineProperty(r, e, {
      enumerable: true,
      get: () => n.value,
      set: (o) => n.value = o
    });
  } else T(
    "useTemplateRef() is called when there is no active component instance to be associated with."
  );
  const s = true ? Ci(n) : n;
  return pu.add(s), s;
}
function es(e, t, n, s, r = false) {
  if (F(e)) {
    e.forEach(
      (_, E) => es(
        _,
        t && (F(t) ? t[E] : t),
        n,
        s,
        r
      )
    );
    return;
  }
  if (fn(s) && !r) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && es(e, t, n, s.component.subTree);
    return;
  }
  const i = s.shapeFlag & 4 ? ur(s.component) : s.el, o = r ? null : i, { i: c, r: l } = e;
  if (!c) {
    T(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const f = t && t.r, u = c.refs === se ? c.refs = {} : c.refs, a = c.setupState, p = Q(a), h = a === se ? () => false : (_) => (oe(p, _) && !be(p[_]) && T(
    `Template ref "${_}" used on a non-ref value. It will not work in the production build.`
  ), pu.has(p[_])) ? false : oe(p, _);
  if (f != null && f !== l && (X(f) ? (u[f] = null, h(f) && (a[f] = null)) : be(f) && (f.value = null)), J(l))
    Un(l, c, 12, [o, u]);
  else {
    const _ = X(l), E = be(l);
    if (_ || E) {
      const M = () => {
        if (e.f) {
          const C = _ ? h(l) ? a[l] : u[l] : l.value;
          r ? F(C) && fc(C, i) : F(C) ? C.includes(i) || C.push(i) : _ ? (u[l] = [i], h(l) && (a[l] = u[l])) : (l.value = [i], e.k && (u[e.k] = l.value));
        } else _ ? (u[l] = o, h(l) && (a[l] = o)) : E ? (l.value = o, e.k && (u[e.k] = o)) : T("Invalid template ref type:", l, `(${typeof l})`);
      };
      o ? (M.id = -1, Ce(M, n)) : M();
    } else T("Invalid template ref type:", l, `(${typeof l})`);
  }
}
var Fl = false;
var mn = () => {
  Fl || (console.error("Hydration completed but contains mismatches."), Fl = true);
};
var j_ = (e) => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject";
var U_ = (e) => e.namespaceURI.includes("MathML");
var Nr = (e) => {
  if (e.nodeType === 1) {
    if (j_(e)) return "svg";
    if (U_(e)) return "mathml";
  }
};
var Nn = (e) => e.nodeType === 8;
function B_(e) {
  const {
    mt: t,
    p: n,
    o: {
      patchProp: s,
      createText: r,
      nextSibling: i,
      parentNode: o,
      remove: c,
      insert: l,
      createComment: f
    }
  } = e, u = (g, N) => {
    if (!N.hasChildNodes()) {
      T(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), n(null, g, N), qr(), N._vnode = g;
      return;
    }
    a(N.firstChild, g, null, null, null), qr(), N._vnode = g;
  }, a = (g, N, y, w, H, V = false) => {
    V = V || !!N.dynamicChildren;
    const v = Nn(g) && g.data === "[", S = () => E(
      g,
      N,
      y,
      w,
      H,
      v
    ), { type: R, ref: b, shapeFlag: L, patchFlag: W } = N;
    let q = g.nodeType;
    N.el = g, Mn(g, "__vnode", N, true), Mn(g, "__vueParentComponent", y, true), W === -2 && (V = false, N.dynamicChildren = null);
    let K = null;
    switch (R) {
      case It:
        q !== 3 ? N.children === "" ? (l(N.el = r(""), o(g), g), K = g) : K = S() : (g.data !== N.children && (T(
          "Hydration text mismatch in",
          g.parentNode,
          `
  - rendered on server: ${JSON.stringify(
            g.data
          )}
  - expected on client: ${JSON.stringify(N.children)}`
        ), mn(), g.data = N.children), K = i(g));
        break;
      case Ee:
        D(g) ? (K = i(g), C(
          N.el = g.content.firstChild,
          g,
          y
        )) : q !== 8 || v ? K = S() : K = i(g);
        break;
      case un:
        if (v && (g = i(g), q = g.nodeType), q === 1 || q === 3) {
          K = g;
          const z = !N.children.length;
          for (let B = 0; B < N.staticCount; B++)
            z && (N.children += K.nodeType === 1 ? K.outerHTML : K.data), B === N.staticCount - 1 && (N.anchor = K), K = i(K);
          return v ? i(K) : K;
        } else
          S();
        break;
      case De:
        v ? K = _(
          g,
          N,
          y,
          w,
          H,
          V
        ) : K = S();
        break;
      default:
        if (L & 1)
          (q !== 1 || N.type.toLowerCase() !== g.tagName.toLowerCase()) && !D(g) ? K = S() : K = p(
            g,
            N,
            y,
            w,
            H,
            V
          );
        else if (L & 6) {
          N.slotScopeIds = H;
          const z = o(g);
          if (v ? K = M(g) : Nn(g) && g.data === "teleport start" ? K = M(g, g.data, "teleport end") : K = i(g), t(
            N,
            z,
            null,
            y,
            w,
            Nr(z),
            V
          ), fn(N) && !N.type.__asyncResolved) {
            let B;
            v ? (B = ye(De), B.anchor = K ? K.previousSibling : z.lastChild) : B = g.nodeType === 3 ? kc("") : ye("div"), B.el = g, N.component.subTree = B;
          }
        } else L & 64 ? q !== 8 ? K = S() : K = N.type.hydrate(
          g,
          N,
          y,
          w,
          H,
          V,
          e,
          h
        ) : L & 128 ? K = N.type.hydrate(
          g,
          N,
          y,
          w,
          Nr(o(g)),
          H,
          V,
          e,
          a
        ) : T("Invalid HostVNode type:", R, `(${typeof R})`);
    }
    return b != null && es(b, null, w, N), K;
  }, p = (g, N, y, w, H, V) => {
    V = V || !!N.dynamicChildren;
    const { type: v, props: S, patchFlag: R, shapeFlag: b, dirs: L, transition: W } = N, q = v === "input" || v === "option";
    if (true) {
      L && Vt(N, null, y, "created");
      let K = false;
      if (D(g)) {
        K = Lu(
          null,
          // no need check parentSuspense in hydration
          W
        ) && y && y.vnode.props && y.vnode.props.appear;
        const B = g.content.firstChild;
        if (K) {
          const fe = B.getAttribute("class");
          fe && (B.$cls = fe), W.beforeEnter(B);
        }
        C(B, g, y), N.el = g = B;
      }
      if (b & 16 && // skip if element has innerHTML / textContent
      !(S && (S.innerHTML || S.textContent))) {
        let B = h(
          g.firstChild,
          N,
          g,
          y,
          w,
          H,
          V
        ), fe = false;
        for (; B; ) {
          Is(
            g,
            1
            /* CHILDREN */
          ) || (!fe && (T(
            "Hydration children mismatch on",
            g,
            `
Server rendered element contains more child nodes than client vdom.`
          ), fe = true), mn());
          const Je = B;
          B = B.nextSibling, c(Je);
        }
      } else if (b & 8) {
        let B = N.children;
        B[0] === `
` && (g.tagName === "PRE" || g.tagName === "TEXTAREA") && (B = B.slice(1)), g.textContent !== B && (Is(
          g,
          0
          /* TEXT */
        ) || (T(
          "Hydration text content mismatch on",
          g,
          `
  - rendered on server: ${g.textContent}
  - expected on client: ${N.children}`
        ), mn()), g.textContent = N.children);
      }
      if (S) {
        if (true) {
          const B = g.tagName.includes("-");
          for (const fe in S)
            // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !(L && L.some((Je) => Je.dir.created)) && K_(g, fe, S[fe], N, y) && mn(), (q && (fe.endsWith("value") || fe === "indeterminate") || Wt(fe) && !ln(fe) || // force hydrate v-bind with .prop modifiers
            fe[0] === "." || B) && s(g, fe, null, S[fe], void 0, y);
        } else if (S.onClick)
          s(
            g,
            "onClick",
            null,
            S.onClick,
            void 0,
            y
          );
        else if (R & 4 && Bt(S.style))
          for (const B in S.style) S.style[B];
      }
      let z;
      (z = S && S.onVnodeBeforeMount) && Qe(z, y, N), L && Vt(N, null, y, "beforeMount"), ((z = S && S.onVnodeMounted) || L || K) && zu(() => {
        z && Qe(z, y, N), K && W.enter(g), L && Vt(N, null, y, "mounted");
      }, w);
    }
    return g.nextSibling;
  }, h = (g, N, y, w, H, V, v) => {
    v = v || !!N.dynamicChildren;
    const S = N.children, R = S.length;
    let b = false;
    for (let L = 0; L < R; L++) {
      const W = v ? S[L] : S[L] = Ge(S[L]), q = W.type === It;
      g ? (q && !v && L + 1 < R && Ge(S[L + 1]).type === It && (l(
        r(
          g.data.slice(W.children.length)
        ),
        y,
        i(g)
      ), g.data = W.children), g = a(
        g,
        W,
        w,
        H,
        V,
        v
      )) : q && !W.children ? l(W.el = r(""), y) : (Is(
        y,
        1
        /* CHILDREN */
      ) || (!b && (T(
        "Hydration children mismatch on",
        y,
        `
Server rendered element contains fewer child nodes than client vdom.`
      ), b = true), mn()), n(
        null,
        W,
        y,
        null,
        w,
        H,
        Nr(y),
        V
      ));
    }
    return g;
  }, _ = (g, N, y, w, H, V) => {
    const { slotScopeIds: v } = N;
    v && (H = H ? H.concat(v) : v);
    const S = o(g), R = h(
      i(g),
      N,
      S,
      y,
      w,
      H,
      V
    );
    return R && Nn(R) && R.data === "]" ? i(N.anchor = R) : (mn(), l(N.anchor = f("]"), S, R), R);
  }, E = (g, N, y, w, H, V) => {
    if (Is(
      g.parentElement,
      1
      /* CHILDREN */
    ) || (T(
      `Hydration node mismatch:
- rendered on server:`,
      g,
      g.nodeType === 3 ? "(text)" : Nn(g) && g.data === "[" ? "(start of fragment)" : "",
      `
- expected on client:`,
      N.type
    ), mn()), N.el = null, V) {
      const R = M(g);
      for (; ; ) {
        const b = i(g);
        if (b && b !== R)
          c(b);
        else
          break;
      }
    }
    const v = i(g), S = o(g);
    return c(g), n(
      null,
      N,
      S,
      v,
      y,
      w,
      Nr(S),
      H
    ), y && (y.vnode.el = N.el, Ui(y, N.el)), v;
  }, M = (g, N = "[", y = "]") => {
    let w = 0;
    for (; g; )
      if (g = i(g), g && Nn(g) && (g.data === N && w++, g.data === y)) {
        if (w === 0)
          return i(g);
        w--;
      }
    return g;
  }, C = (g, N, y) => {
    const w = N.parentNode;
    w && w.replaceChild(g, N);
    let H = y;
    for (; H; )
      H.vnode.el === N && (H.vnode.el = H.subTree.el = g), H = H.parent;
  }, D = (g) => g.nodeType === 1 && g.tagName === "TEMPLATE";
  return [u, a];
}
function K_(e, t, n, s, r) {
  let i, o, c, l;
  if (t === "class")
    e.$cls ? (c = e.$cls, delete e.$cls) : c = e.getAttribute("class"), l = Ns(n), W_(Hl(c || ""), Hl(l)) || (i = 2, o = "class");
  else if (t === "style") {
    c = e.getAttribute("style") || "", l = X(n) ? n : gm(vs(n));
    const f = jl(c), u = jl(l);
    if (s.dirs)
      for (const { dir: a, value: p } of s.dirs)
        a.name === "show" && !p && u.set("display", "none");
    r && du(r, s, u), q_(f, u) || (i = 3, o = "style");
  } else (e instanceof SVGElement && Sm(t) || e instanceof HTMLElement && (Vl(t) || Om(t))) && (Vl(t) ? (c = e.hasAttribute(t), l = dc(n)) : n == null ? (c = e.hasAttribute(t), l = false) : (e.hasAttribute(t) ? c = e.getAttribute(t) : t === "value" && e.tagName === "TEXTAREA" ? c = e.value : c = false, l = Tm(n) ? String(n) : false), c !== l && (i = 4, o = t));
  if (i != null && !Is(e, i)) {
    const f = (p) => p === false ? "(not rendered)" : `${o}="${p}"`, u = `Hydration ${hu[i]} mismatch on`, a = `
  - rendered on server: ${f(c)}
  - expected on client: ${f(l)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    return T(u, e, a), true;
  }
  return false;
}
function Hl(e) {
  return new Set(e.trim().split(/\s+/));
}
function W_(e, t) {
  if (e.size !== t.size)
    return false;
  for (const n of e)
    if (!t.has(n))
      return false;
  return true;
}
function jl(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e.split(";")) {
    let [s, r] = n.split(":");
    s = s.trim(), r = r && r.trim(), s && r && t.set(s, r);
  }
  return t;
}
function q_(e, t) {
  if (e.size !== t.size)
    return false;
  for (const [n, s] of e)
    if (s !== t.get(n))
      return false;
  return true;
}
function du(e, t, n) {
  const s = e.subTree;
  if (e.getCssVars && (t === s || s && s.type === De && s.children.includes(t))) {
    const r = e.getCssVars();
    for (const i in r) {
      const o = Df(r[i]);
      n.set(`--${wm(i)}`, o);
    }
  }
  t === s && e.parent && du(e.parent, e.vnode, n);
}
var Ul = "data-allow-mismatch";
var hu = {
  0: "text",
  1: "children",
  2: "class",
  3: "style",
  4: "attribute"
};
function Is(e, t) {
  if (t === 0 || t === 1)
    for (; e && !e.hasAttribute(Ul); )
      e = e.parentElement;
  const n = e && e.getAttribute(Ul);
  if (n == null)
    return false;
  if (n === "")
    return true;
  {
    const s = n.split(",");
    return t === 0 && s.includes("children") ? true : s.includes(hu[t]);
  }
}
var G_ = an().requestIdleCallback || ((e) => setTimeout(e, 1));
var z_ = an().cancelIdleCallback || ((e) => clearTimeout(e));
var J_ = (e = 1e4) => (t) => {
  const n = G_(t, { timeout: e });
  return () => z_(n);
};
function Y_(e) {
  const { top: t, left: n, bottom: s, right: r } = e.getBoundingClientRect(), { innerHeight: i, innerWidth: o } = window;
  return (t > 0 && t < i || s > 0 && s < i) && (n > 0 && n < o || r > 0 && r < o);
}
var X_ = (e) => (t, n) => {
  const s = new IntersectionObserver((r) => {
    for (const i of r)
      if (i.isIntersecting) {
        s.disconnect(), t();
        break;
      }
  }, e);
  return n((r) => {
    if (r instanceof Element) {
      if (Y_(r))
        return t(), s.disconnect(), false;
      s.observe(r);
    }
  }), () => s.disconnect();
};
var Z_ = (e) => (t) => {
  if (e) {
    const n = matchMedia(e);
    if (n.matches)
      t();
    else
      return n.addEventListener("change", t, { once: true }), () => n.removeEventListener("change", t);
  }
};
var Q_ = (e = []) => (t, n) => {
  X(e) && (e = [e]);
  let s = false;
  const r = (o) => {
    s || (s = true, i(), t(), o.target.dispatchEvent(new o.constructor(o.type, o)));
  }, i = () => {
    n((o) => {
      for (const c of e)
        o.removeEventListener(c, r);
    });
  };
  return n((o) => {
    for (const c of e)
      o.addEventListener(c, r, { once: true });
  }), i;
};
function eE(e, t) {
  if (Nn(e) && e.data === "[") {
    let n = 1, s = e.nextSibling;
    for (; s; ) {
      if (s.nodeType === 1) {
        if (t(s) === false)
          break;
      } else if (Nn(s))
        if (s.data === "]") {
          if (--n === 0) break;
        } else s.data === "[" && n++;
      s = s.nextSibling;
    }
  } else
    t(e);
}
var fn = (e) => !!e.type.__asyncLoader;
function tE(e) {
  J(e) && (e = { loader: e });
  const {
    loader: t,
    loadingComponent: n,
    errorComponent: s,
    delay: r = 200,
    hydrate: i,
    timeout: o,
    // undefined = never times out
    suspensible: c = true,
    onError: l
  } = e;
  let f = null, u, a = 0;
  const p = () => (a++, f = null, h()), h = () => {
    let _;
    return f || (_ = f = t().catch((E) => {
      if (E = E instanceof Error ? E : new Error(String(E)), l)
        return new Promise((M, C) => {
          l(E, () => M(p()), () => C(E), a + 1);
        });
      throw E;
    }).then((E) => {
      if (_ !== f && f)
        return f;
      if (!E && T(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), E && (E.__esModule || E[Symbol.toStringTag] === "Module") && (E = E.default), E && !ie(E) && !J(E))
        throw new Error(`Invalid async component load result: ${E}`);
      return u = E, E;
    }));
  };
  return Dc({
    name: "AsyncComponentWrapper",
    __asyncLoader: h,
    __asyncHydrate(_, E, M) {
      let C = false;
      (E.bu || (E.bu = [])).push(() => C = true);
      const D = () => {
        if (C) {
          T(
            `Skipping lazy hydration for component '${cs(u) || u.__file}': it was updated before lazy hydration performed.`
          );
          return;
        }
        M();
      }, g = i ? () => {
        const N = i(
          D,
          (y) => eE(_, y)
        );
        N && (E.bum || (E.bum = [])).push(N);
      } : D;
      u ? g() : h().then(() => !E.isUnmounted && g());
    },
    get __asyncResolved() {
      return u;
    },
    setup() {
      const _ = xe;
      if (wc(_), u)
        return () => co(u, _);
      const E = (g) => {
        f = null, gn(
          g,
          _,
          13,
          !s
        );
      };
      if (c && _.suspense || os)
        return h().then((g) => () => co(g, _)).catch((g) => (E(g), () => s ? ye(s, {
          error: g
        }) : null));
      const M = wn(false), C = wn(), D = wn(!!r);
      return r && setTimeout(() => {
        D.value = false;
      }, r), o != null && setTimeout(() => {
        if (!M.value && !C.value) {
          const g = new Error(
            `Async component timed out after ${o}ms.`
          );
          E(g), C.value = g;
        }
      }, o), h().then(() => {
        M.value = true, _.parent && bs(_.parent.vnode) && _.parent.update();
      }).catch((g) => {
        E(g), C.value = g;
      }), () => {
        if (M.value && u)
          return co(u, _);
        if (C.value && s)
          return ye(s, {
            error: C.value
          });
        if (n && !D.value)
          return ye(n);
      };
    }
  });
}
function co(e, t) {
  const { ref: n, props: s, children: r, ce: i } = t.vnode, o = ye(e, s, r);
  return o.ref = n, o.ce = i, delete t.vnode.ce, o;
}
var bs = (e) => e.type.__isKeepAlive;
var nE = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(e, { slots: t }) {
    const n = ze(), s = n.ctx;
    if (!s.renderer)
      return () => {
        const D = t.default && t.default();
        return D && D.length === 1 ? D[0] : D;
      };
    const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
    let o = null;
    n.__v_cache = r;
    const c = n.suspense, {
      renderer: {
        p: l,
        m: f,
        um: u,
        o: { createElement: a }
      }
    } = s, p = a("div");
    s.activate = (D, g, N, y, w) => {
      const H = D.component;
      f(D, g, N, 0, c), l(
        H.vnode,
        D,
        g,
        N,
        H,
        c,
        y,
        D.slotScopeIds,
        w
      ), Ce(() => {
        H.isDeactivated = false, H.a && rn(H.a);
        const V = D.props && D.props.onVnodeMounted;
        V && Qe(V, H.parent, D);
      }, c), wo(H);
    }, s.deactivate = (D) => {
      const g = D.component;
      Xr(g.m), Xr(g.a), f(D, p, null, 1, c), Ce(() => {
        g.da && rn(g.da);
        const N = D.props && D.props.onVnodeUnmounted;
        N && Qe(N, g.parent, D), g.isDeactivated = true;
      }, c), wo(g), g.__keepAliveStorageContainer = p;
    };
    function h(D) {
      lo(D), u(D, n, c, true);
    }
    function _(D) {
      r.forEach((g, N) => {
        const y = cs(g.type);
        y && !D(y) && E(N);
      });
    }
    function E(D) {
      const g = r.get(D);
      g && (!o || !_t(g, o)) ? h(g) : o && lo(o), r.delete(D), i.delete(D);
    }
    ts(
      () => [e.include, e.exclude],
      ([D, g]) => {
        D && _((N) => Ps(D, N)), g && _((N) => !Ps(g, N));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let M = null;
    const C = () => {
      M != null && (Qr(n.subTree.type) ? Ce(() => {
        r.set(M, br(n.subTree));
      }, n.subTree.suspense) : r.set(M, br(n.subTree)));
    };
    return ar(C), ki(C), Li(() => {
      r.forEach((D) => {
        const { subTree: g, suspense: N } = n, y = br(g);
        if (D.type === y.type && D.key === y.key) {
          lo(y);
          const w = y.component.da;
          w && Ce(w, N);
          return;
        }
        h(D);
      });
    }), () => {
      if (M = null, !t.default)
        return o = null;
      const D = t.default(), g = D[0];
      if (D.length > 1)
        return T("KeepAlive should contain exactly one component child."), o = null, D;
      if (!Rt(g) || !(g.shapeFlag & 4) && !(g.shapeFlag & 128))
        return o = null, g;
      let N = br(g);
      if (N.type === Ee)
        return o = null, N;
      const y = N.type, w = cs(
        fn(N) ? N.type.__asyncResolved || {} : y
      ), { include: H, exclude: V, max: v } = e;
      if (H && (!w || !Ps(H, w)) || V && w && Ps(V, w))
        return N.shapeFlag &= -257, o = N, g;
      const S = N.key == null ? y : N.key, R = r.get(S);
      return N.el && (N = ht(N), g.shapeFlag & 128 && (g.ssContent = N)), M = S, R ? (N.el = R.el, N.component = R.component, N.transition && qt(N, N.transition), N.shapeFlag |= 512, i.delete(S), i.add(S)) : (i.add(S), v && i.size > parseInt(v, 10) && E(i.values().next().value)), N.shapeFlag |= 256, o = N, Qr(g.type) ? g : N;
    };
  }
};
var sE = nE;
function Ps(e, t) {
  return F(e) ? e.some((n) => Ps(n, t)) : X(e) ? e.split(",").includes(t) : rm(e) ? (e.lastIndex = 0, e.test(t)) : false;
}
function gu(e, t) {
  _u(e, "a", t);
}
function mu(e, t) {
  _u(e, "da", t);
}
function _u(e, t, n = xe) {
  const s = e.__wdc || (e.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return e();
  });
  if ($i(t, s, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      bs(r.parent.vnode) && rE(s, t, n, r), r = r.parent;
  }
}
function rE(e, t, n, s) {
  const r = $i(
    t,
    e,
    s,
    true
    /* prepend */
  );
  Fi(() => {
    fc(s[t], r);
  }, n);
}
function lo(e) {
  e.shapeFlag &= -257, e.shapeFlag &= -513;
}
function br(e) {
  return e.shapeFlag & 128 ? e.ssContent : e;
}
function $i(e, t, n = xe, s = false) {
  if (n) {
    const r = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...o) => {
      Ot();
      const c = Ln(n), l = dt(t, n, e, o);
      return c(), St(), l;
    });
    return s ? r.unshift(i) : r.push(i), i;
  } else if (true) {
    const r = At(xi[e].replace(/ hook$/, ""));
    T(
      `${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
var zt = (e) => (t, n = xe) => {
  (!os || e === "sp") && $i(e, (...s) => t(...s), n);
};
var Eu = zt("bm");
var ar = zt("m");
var Cc = zt(
  "bu"
);
var ki = zt("u");
var Li = zt(
  "bum"
);
var Fi = zt("um");
var yu = zt(
  "sp"
);
var vu = zt("rtg");
var Nu = zt("rtc");
function bu(e, t = xe) {
  $i("ec", e, t);
}
var zr = "components";
var iE = "directives";
function oE(e, t) {
  return Ac(zr, e, true, t) || e;
}
var Vc = Symbol.for("v-ndc");
function cE(e) {
  return X(e) ? Ac(zr, e, false) || e : e || Vc;
}
function lE(e) {
  return Ac(iE, e);
}
function Ac(e, t, n = true, s = false) {
  const r = Te || xe;
  if (r) {
    const i = r.type;
    if (e === zr) {
      const c = cs(
        i,
        false
      );
      if (c && (c === t || c === de(t) || c === Pt(de(t))))
        return i;
    }
    const o = (
      // local registration
      // check instance[type] first which is resolved for options API
      Bl(r[e] || i[e], t) || // global registration
      Bl(r.appContext[e], t)
    );
    if (!o && s)
      return i;
    if (n && !o) {
      const c = e === zr ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      T(`Failed to resolve ${e.slice(0, -1)}: ${t}${c}`);
    }
    return o;
  } else T(
    `resolve${Pt(e.slice(0, -1))} can only be used in render() or setup().`
  );
}
function Bl(e, t) {
  return e && (e[t] || e[de(t)] || e[Pt(de(t))]);
}
function aE(e, t, n, s) {
  let r;
  const i = n && n[s], o = F(e);
  if (o || X(e)) {
    const c = o && Bt(e);
    let l = false, f = false;
    c && (l = !je(e), f = Tt(e), e = Ti(e)), r = new Array(e.length);
    for (let u = 0, a = e.length; u < a; u++)
      r[u] = t(
        l ? f ? Br(Me(e[u])) : Me(e[u]) : e[u],
        u,
        void 0,
        i && i[u]
      );
  } else if (typeof e == "number") {
    !Number.isInteger(e) && T(`The v-for range expect an integer value but got ${e}.`), r = new Array(e);
    for (let c = 0; c < e; c++)
      r[c] = t(c + 1, c, void 0, i && i[c]);
  } else if (ie(e))
    if (e[Symbol.iterator])
      r = Array.from(
        e,
        (c, l) => t(c, l, void 0, i && i[l])
      );
    else {
      const c = Object.keys(e);
      r = new Array(c.length);
      for (let l = 0, f = c.length; l < f; l++) {
        const u = c[l];
        r[l] = t(e[u], u, l, i && i[l]);
      }
    }
  else
    r = [];
  return n && (n[s] = r), r;
}
function fE(e, t) {
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    if (F(s))
      for (let r = 0; r < s.length; r++)
        e[s[r].name] = s[r].fn;
    else s && (e[s.name] = s.key ? (...r) => {
      const i = s.fn(...r);
      return i && (i.key = s.key), i;
    } : s.fn);
  }
  return e;
}
function uE(e, t, n = {}, s, r) {
  if (Te.ce || Te.parent && fn(Te.parent) && Te.parent.ce)
    return t !== "default" && (n.name = t), er(), ei(
      De,
      null,
      [ye("slot", n, s && s())],
      64
    );
  let i = e[t];
  i && i.length > 1 && (T(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), i = () => []), i && i._c && (i._d = false), er();
  const o = i && xc(i(n)), c = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  o && o.key, l = ei(
    De,
    {
      key: (c && !nt(c) ? c : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!o && s ? "_fb" : "")
    },
    o || (s ? s() : []),
    o && e._ === 1 ? 64 : -2
  );
  return !r && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), i && i._c && (i._d = true), l;
}
function xc(e) {
  return e.some((t) => Rt(t) ? !(t.type === Ee || t.type === De && !xc(t.children)) : true) ? e : null;
}
function pE(e, t) {
  const n = {};
  if (!ie(e))
    return T("v-on with no argument expects an object value."), n;
  for (const s in e)
    n[t && /[A-Z]/.test(s) ? `on:${s}` : At(s)] = e[s];
  return n;
}
var Vo = (e) => e ? sp(e) ? ur(e) : Vo(e.parent) : null;
var An = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  te(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => true ? Et(e.props) : e.props,
    $attrs: (e) => true ? Et(e.attrs) : e.attrs,
    $slots: (e) => true ? Et(e.slots) : e.slots,
    $refs: (e) => true ? Et(e.refs) : e.refs,
    $parent: (e) => Vo(e.parent),
    $root: (e) => Vo(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => __VUE_OPTIONS_API__ ? Pc(e) : e.type,
    $forceUpdate: (e) => e.f || (e.f = () => {
      Pi(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = Ii.bind(e.proxy)),
    $watch: (e) => __VUE_OPTIONS_API__ ? ny.bind(e) : me
  })
);
var Ic = (e) => e === "_" || e === "$";
var ao = (e, t) => e !== se && !e.__isScriptSetup && oe(e, t);
var Fs = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return true;
    const { ctx: n, setupState: s, data: r, props: i, accessCache: o, type: c, appContext: l } = e;
    if (t === "__isVue")
      return true;
    let f;
    if (t[0] !== "$") {
      const h = o[t];
      if (h !== void 0)
        switch (h) {
          case 1:
            return s[t];
          case 2:
            return r[t];
          case 4:
            return n[t];
          case 3:
            return i[t];
        }
      else {
        if (ao(s, t))
          return o[t] = 1, s[t];
        if (r !== se && oe(r, t))
          return o[t] = 2, r[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (f = e.propsOptions[0]) && oe(f, t)
        )
          return o[t] = 3, i[t];
        if (n !== se && oe(n, t))
          return o[t] = 4, n[t];
        (!__VUE_OPTIONS_API__ || Ao) && (o[t] = 0);
      }
    }
    const u = An[t];
    let a, p;
    if (u)
      return t === "$attrs" ? (Ve(e.attrs, "get", ""), Zr()) : t === "$slots" && Ve(e, "get", t), u(e);
    if (
      // css module (injected by vue-loader)
      (a = c.__cssModules) && (a = a[t])
    )
      return a;
    if (n !== se && oe(n, t))
      return o[t] = 4, n[t];
    if (
      // global properties
      p = l.config.globalProperties, oe(p, t)
    )
      return p[t];
    Te && (!X(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (r !== se && Ic(t[0]) && oe(r, t) ? T(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e === Te && T(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e }, t, n) {
    const { data: s, setupState: r, ctx: i } = e;
    return ao(r, t) ? (r[t] = n, true) : r.__isScriptSetup && oe(r, t) ? (T(`Cannot mutate <script setup> binding "${t}" from Options API.`), false) : s !== se && oe(s, t) ? (s[t] = n, true) : oe(e.props, t) ? (T(`Attempting to mutate prop "${t}". Props are readonly.`), false) : t[0] === "$" && t.slice(1) in e ? (T(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), false) : (t in e.appContext.config.globalProperties ? Object.defineProperty(i, t, {
      enumerable: true,
      configurable: true,
      value: n
    }) : i[t] = n, true);
  },
  has({
    _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, propsOptions: i }
  }, o) {
    let c;
    return !!n[o] || e !== se && oe(e, o) || ao(t, o) || (c = i[0]) && oe(c, o) || oe(s, o) || oe(An, o) || oe(r.config.globalProperties, o);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : oe(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
Fs.ownKeys = (e) => (T(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e));
var dE = te({}, Fs, {
  get(e, t) {
    if (t !== Symbol.unscopables)
      return Fs.get(e, t, e);
  },
  has(e, t) {
    const n = t[0] !== "_" && !fm(t);
    return !n && Fs.has(e, t) && T(
      `Property ${JSON.stringify(
        t
      )} should not start with _ which is a reserved prefix for Vue internals.`
    ), n;
  }
});
function hE(e) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: true,
    enumerable: false,
    get: () => e
  }), Object.keys(An).forEach((n) => {
    Object.defineProperty(t, n, {
      configurable: true,
      enumerable: false,
      get: () => An[n](e),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: me
    });
  }), t;
}
function gE(e) {
  const {
    ctx: t,
    propsOptions: [n]
  } = e;
  n && Object.keys(n).forEach((s) => {
    Object.defineProperty(t, s, {
      enumerable: true,
      configurable: true,
      get: () => e.props[s],
      set: me
    });
  });
}
function mE(e) {
  const { ctx: t, setupState: n } = e;
  Object.keys(Q(n)).forEach((s) => {
    if (!n.__isScriptSetup) {
      if (Ic(s[0])) {
        T(
          `setup() return property ${JSON.stringify(
            s
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, s, {
        enumerable: true,
        configurable: true,
        get: () => n[s],
        set: me
      });
    }
  });
}
var Bn = (e) => T(
  `${e}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function _E() {
  return Bn("defineProps"), null;
}
function EE() {
  return Bn("defineEmits"), null;
}
function yE(e) {
  Bn("defineExpose");
}
function vE(e) {
  Bn("defineOptions");
}
function NE() {
  return Bn("defineSlots"), null;
}
function bE() {
  Bn("defineModel");
}
function OE(e, t) {
  return Bn("withDefaults"), null;
}
function SE() {
  return Ou("useSlots").slots;
}
function TE() {
  return Ou("useAttrs").attrs;
}
function Ou(e) {
  const t = ze();
  return !t && T(`${e}() called without active instance.`), t.setupContext || (t.setupContext = cp(t));
}
function Zs(e) {
  return F(e) ? e.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e;
}
function DE(e, t) {
  const n = Zs(e);
  for (const s in t) {
    if (s.startsWith("__skip")) continue;
    let r = n[s];
    r ? F(r) || J(r) ? r = n[s] = { type: r, default: t[s] } : r.default = t[s] : r === null ? r = n[s] = { default: t[s] } : T(`props default key "${s}" has no corresponding declaration.`), r && t[`__skip_${s}`] && (r.skipFactory = true);
  }
  return n;
}
function wE(e, t) {
  return !e || !t ? e || t : F(e) && F(t) ? e.concat(t) : te({}, Zs(e), Zs(t));
}
function CE(e, t) {
  const n = {};
  for (const s in e)
    t.includes(s) || Object.defineProperty(n, s, {
      enumerable: true,
      get: () => e[s]
    });
  return n;
}
function VE(e) {
  const t = ze();
  !t && T(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let n = e();
  return Fo(), vi(n) && (n = n.catch((s) => {
    throw Ln(t), s;
  })), [n, () => Ln(t)];
}
function AE() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n) => {
    e[n] ? T(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t;
  };
}
var Ao = true;
function xE(e) {
  const t = Pc(e), n = e.proxy, s = e.ctx;
  Ao = false, t.beforeCreate && Kl(t.beforeCreate, e, "bc");
  const {
    // state
    data: r,
    computed: i,
    methods: o,
    watch: c,
    provide: l,
    inject: f,
    // lifecycle
    created: u,
    beforeMount: a,
    mounted: p,
    beforeUpdate: h,
    updated: _,
    activated: E,
    deactivated: M,
    beforeDestroy: C,
    beforeUnmount: D,
    destroyed: g,
    unmounted: N,
    render: y,
    renderTracked: w,
    renderTriggered: H,
    errorCaptured: V,
    serverPrefetch: v,
    // public API
    expose: S,
    inheritAttrs: R,
    // assets
    components: b,
    directives: L,
    filters: W
  } = t, q = true ? AE() : null;
  if (true) {
    const [z] = e.propsOptions;
    if (z)
      for (const B in z)
        q("Props", B);
  }
  if (f && IE(f, s, q), o)
    for (const z in o) {
      const B = o[z];
      J(B) ? (true ? Object.defineProperty(s, z, {
        value: B.bind(n),
        configurable: true,
        enumerable: true,
        writable: true
      }) : s[z] = B.bind(n), q("Methods", z)) : T(
        `Method "${z}" has type "${typeof B}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (r) {
    !J(r) && T(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const z = r.call(n, n);
    if (vi(z) && T(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !ie(z))
      T("data() should return an object.");
    else if (e.data = wi(z), true)
      for (const B in z)
        q("Data", B), Ic(B[0]) || Object.defineProperty(s, B, {
          configurable: true,
          enumerable: true,
          get: () => z[B],
          set: me
        });
  }
  if (Ao = true, i)
    for (const z in i) {
      const B = i[z], fe = J(B) ? B.bind(n, n) : J(B.get) ? B.get.bind(n, n) : me;
      fe === me && T(`Computed property "${z}" has no getter.`);
      const Je = !J(B) && J(B.set) ? B.set.bind(n) : true ? () => {
        T(
          `Write operation failed: computed property "${z}" is readonly.`
        );
      } : me, ct = ap({
        get: fe,
        set: Je
      });
      Object.defineProperty(s, z, {
        enumerable: true,
        configurable: true,
        get: () => ct.value,
        set: (lt) => ct.value = lt
      }), q("Computed", z);
    }
  if (c)
    for (const z in c)
      Su(c[z], s, n, z);
  if (l) {
    const z = J(l) ? l.call(n) : l;
    Reflect.ownKeys(z).forEach((B) => {
      Du(B, z[B]);
    });
  }
  u && Kl(u, e, "c");
  function K(z, B) {
    F(B) ? B.forEach((fe) => z(fe.bind(n))) : B && z(B.bind(n));
  }
  if (K(Eu, a), K(ar, p), K(Cc, h), K(ki, _), K(gu, E), K(mu, M), K(bu, V), K(Nu, w), K(vu, H), K(Li, D), K(Fi, N), K(yu, v), F(S))
    if (S.length) {
      const z = e.exposed || (e.exposed = {});
      S.forEach((B) => {
        Object.defineProperty(z, B, {
          get: () => n[B],
          set: (fe) => n[B] = fe,
          enumerable: true
        });
      });
    } else e.exposed || (e.exposed = {});
  y && e.render === me && (e.render = y), R != null && (e.inheritAttrs = R), b && (e.components = b), L && (e.directives = L), v && wc(e);
}
function IE(e, t, n = me) {
  F(e) && (e = xo(e));
  for (const s in e) {
    const r = e[s];
    let i;
    ie(r) ? "default" in r ? i = Hs(
      r.from || s,
      r.default,
      true
    ) : i = Hs(r.from || s) : i = Hs(r), be(i) ? Object.defineProperty(t, s, {
      enumerable: true,
      configurable: true,
      get: () => i.value,
      set: (o) => i.value = o
    }) : t[s] = i, n("Inject", s);
  }
}
function Kl(e, t, n) {
  dt(
    F(e) ? e.map((s) => s.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  );
}
function Su(e, t, n, s) {
  let r = s.includes(".") ? Bu(n, s) : () => n[s];
  if (X(e)) {
    const i = t[e];
    J(i) ? ts(r, i) : T(`Invalid watch handler specified by key "${e}"`, i);
  } else if (J(e))
    ts(r, e.bind(n));
  else if (ie(e))
    if (F(e))
      e.forEach((i) => Su(i, t, n, s));
    else {
      const i = J(e.handler) ? e.handler.bind(n) : t[e.handler];
      J(i) ? ts(r, i, e) : T(`Invalid watch handler specified by key "${e.handler}"`, i);
    }
  else T(`Invalid watch option: "${s}"`, e);
}
function Pc(e) {
  const t = e.type, { mixins: n, extends: s } = t, {
    mixins: r,
    optionsCache: i,
    config: { optionMergeStrategies: o }
  } = e.appContext, c = i.get(t);
  let l;
  return c ? l = c : !r.length && !n && !s ? l = t : (l = {}, r.length && r.forEach(
    (f) => Jr(l, f, o, true)
  ), Jr(l, t, o)), ie(t) && i.set(t, l), l;
}
function Jr(e, t, n, s = false) {
  const { mixins: r, extends: i } = t;
  i && Jr(e, i, n, true), r && r.forEach(
    (o) => Jr(e, o, n, true)
  );
  for (const o in t)
    if (s && o === "expose")
      T(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const c = PE[o] || n && n[o];
      e[o] = c ? c(e[o], t[o]) : t[o];
    }
  return e;
}
var PE = {
  data: Wl,
  props: ql,
  emits: ql,
  // objects
  methods: Rs,
  computed: Rs,
  // lifecycle
  beforeCreate: Ke,
  created: Ke,
  beforeMount: Ke,
  mounted: Ke,
  beforeUpdate: Ke,
  updated: Ke,
  beforeDestroy: Ke,
  beforeUnmount: Ke,
  destroyed: Ke,
  unmounted: Ke,
  activated: Ke,
  deactivated: Ke,
  errorCaptured: Ke,
  serverPrefetch: Ke,
  // assets
  components: Rs,
  directives: Rs,
  // watch
  watch: ME,
  // provide / inject
  provide: Wl,
  inject: RE
};
function Wl(e, t) {
  return t ? e ? function() {
    return te(
      J(e) ? e.call(this, this) : e,
      J(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function RE(e, t) {
  return Rs(xo(e), xo(t));
}
function xo(e) {
  if (F(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function Ke(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Rs(e, t) {
  return e ? te(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function ql(e, t) {
  return e ? F(e) && F(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : te(
    /* @__PURE__ */ Object.create(null),
    Zs(e),
    Zs(t ?? {})
  ) : t;
}
function ME(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = te(/* @__PURE__ */ Object.create(null), e);
  for (const s in t)
    n[s] = Ke(e[s], t[s]);
  return n;
}
function Tu() {
  return {
    app: null,
    config: {
      isNativeTag: As,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
var $E = 0;
function kE(e, t) {
  return function(s, r = null) {
    J(s) || (s = te({}, s)), r != null && !ie(r) && (T("root props passed to app.mount() must be an object."), r = null);
    const i = Tu(), o = /* @__PURE__ */ new WeakSet(), c = [];
    let l = false;
    const f = i.app = {
      _uid: $E++,
      _component: s,
      _props: r,
      _container: null,
      _context: i,
      _instance: null,
      version: Bo,
      get config() {
        return i.config;
      },
      set config(u) {
        T(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...a) {
        return o.has(u) ? T("Plugin has already been applied to target app.") : u && J(u.install) ? (o.add(u), u.install(f, ...a)) : J(u) ? (o.add(u), u(f, ...a)) : T(
          'A plugin must either be a function or an object with an "install" function.'
        ), f;
      },
      mixin(u) {
        return __VUE_OPTIONS_API__ ? i.mixins.includes(u) ? T(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : i.mixins.push(u) : T("Mixins are only available in builds supporting Options API"), f;
      },
      component(u, a) {
        return Ho(u, i.config), a ? (i.components[u] && T(`Component "${u}" has already been registered in target app.`), i.components[u] = a, f) : i.components[u];
      },
      directive(u, a) {
        return su(u), a ? (i.directives[u] && T(`Directive "${u}" has already been registered in target app.`), i.directives[u] = a, f) : i.directives[u];
      },
      mount(u, a, p) {
        if (l)
          T(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          u.__vue_app__ && T(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = f._ceVNode || ye(s, r);
          return h.appContext = i, p === true ? p = "svg" : p === false && (p = void 0), i.reload = () => {
            const _ = ht(h);
            _.el = null, e(_, u, p);
          }, a && t ? t(h, u) : e(h, u, p), l = true, f._container = u, u.__vue_app__ = f, f._instance = h.component, T_(f, Bo), ur(h.component);
        }
      },
      onUnmount(u) {
        typeof u != "function" && T(
          `Expected function as first argument to app.onUnmount(), but got ${typeof u}`
        ), c.push(u);
      },
      unmount() {
        l ? (dt(
          c,
          f._instance,
          16
        ), e(null, f._container), f._instance = null, D_(f), delete f._container.__vue_app__) : T("Cannot unmount an app that is not mounted.");
      },
      provide(u, a) {
        return u in i.provides && (oe(i.provides, u) ? T(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ) : T(
          `App already provides property with key "${String(u)}" inherited from its parent element. It will be overwritten with the new value.`
        )), i.provides[u] = a, f;
      },
      runWithContext(u) {
        const a = xn;
        xn = f;
        try {
          return u();
        } finally {
          xn = a;
        }
      }
    };
    return f;
  };
}
var xn = null;
function Du(e, t) {
  if (!xe)
    T("provide() can only be used inside setup().");
  else {
    let n = xe.provides;
    const s = xe.parent && xe.parent.provides;
    s === n && (n = xe.provides = Object.create(s)), n[e] = t;
  }
}
function Hs(e, t, n = false) {
  const s = ze();
  if (s || xn) {
    let r = xn ? xn._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (r && e in r)
      return r[e];
    if (arguments.length > 1)
      return n && J(t) ? t.call(s && s.proxy) : t;
    T(`injection "${String(e)}" not found.`);
  } else T("inject() can only be used inside setup() or functional components.");
}
function LE() {
  return !!(ze() || xn);
}
var wu = {};
var Cu = () => Object.create(wu);
var Vu = (e) => Object.getPrototypeOf(e) === wu;
function FE(e, t, n, s = false) {
  const r = {}, i = Cu();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), Au(e, t, r, i);
  for (const o in e.propsOptions[0])
    o in r || (r[o] = void 0);
  Iu(t || {}, r, e), n ? e.props = s ? r : Bf(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i;
}
function HE(e) {
  for (; e; ) {
    if (e.type.__hmrId) return true;
    e = e.parent;
  }
}
function jE(e, t, n, s) {
  const {
    props: r,
    attrs: i,
    vnode: { patchFlag: o }
  } = e, c = Q(r), [l] = e.propsOptions;
  let f = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !HE(e) && (s || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const u = e.vnode.dynamicProps;
      for (let a = 0; a < u.length; a++) {
        let p = u[a];
        if (Hi(e.emitsOptions, p))
          continue;
        const h = t[p];
        if (l)
          if (oe(i, p))
            h !== i[p] && (i[p] = h, f = true);
          else {
            const _ = de(p);
            r[_] = Io(
              l,
              c,
              _,
              h,
              e,
              false
            );
          }
        else
          h !== i[p] && (i[p] = h, f = true);
      }
    }
  } else {
    Au(e, t, r, i) && (f = true);
    let u;
    for (const a in c)
      (!t || // for camelCase
      !oe(t, a) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Fe(a)) === a || !oe(t, u))) && (l ? n && // for camelCase
      (n[a] !== void 0 || // for kebab-case
      n[u] !== void 0) && (r[a] = Io(
        l,
        c,
        a,
        void 0,
        e,
        true
      )) : delete r[a]);
    if (i !== c)
      for (const a in i)
        (!t || !oe(t, a)) && (delete i[a], f = true);
  }
  f && xt(e.attrs, "set", ""), Iu(t || {}, r, e);
}
function Au(e, t, n, s) {
  const [r, i] = e.propsOptions;
  let o = false, c;
  if (t)
    for (let l in t) {
      if (ln(l))
        continue;
      const f = t[l];
      let u;
      r && oe(r, u = de(l)) ? !i || !i.includes(u) ? n[u] = f : (c || (c = {}))[u] = f : Hi(e.emitsOptions, l) || (!(l in s) || f !== s[l]) && (s[l] = f, o = true);
    }
  if (i) {
    const l = Q(n), f = c || se;
    for (let u = 0; u < i.length; u++) {
      const a = i[u];
      n[a] = Io(
        r,
        l,
        a,
        f[a],
        e,
        !oe(f, a)
      );
    }
  }
  return o;
}
function Io(e, t, n, s, r, i) {
  const o = e[n];
  if (o != null) {
    const c = oe(o, "default");
    if (c && s === void 0) {
      const l = o.default;
      if (o.type !== Function && !o.skipFactory && J(l)) {
        const { propsDefaults: f } = r;
        if (n in f)
          s = f[n];
        else {
          const u = Ln(r);
          s = f[n] = l.call(
            null,
            t
          ), u();
        }
      } else
        s = l;
      r.ce && r.ce._setProp(n, s);
    }
    o[
      0
      /* shouldCast */
    ] && (i && !c ? s = false : o[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Fe(n)) && (s = true));
  }
  return s;
}
var UE = /* @__PURE__ */ new WeakMap();
function xu(e, t, n = false) {
  const s = __VUE_OPTIONS_API__ && n ? UE : t.propsCache, r = s.get(e);
  if (r)
    return r;
  const i = e.props, o = {}, c = [];
  let l = false;
  if (__VUE_OPTIONS_API__ && !J(e)) {
    const u = (a) => {
      l = true;
      const [p, h] = xu(a, t, true);
      te(o, p), h && c.push(...h);
    };
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  if (!i && !l)
    return ie(e) && s.set(e, Yn), Yn;
  if (F(i))
    for (let u = 0; u < i.length; u++) {
      !X(i[u]) && T("props must be strings when using array syntax.", i[u]);
      const a = de(i[u]);
      Gl(a) && (o[a] = se);
    }
  else if (i) {
    !ie(i) && T("invalid props options", i);
    for (const u in i) {
      const a = de(u);
      if (Gl(a)) {
        const p = i[u], h = o[a] = F(p) || J(p) ? { type: p } : te({}, p), _ = h.type;
        let E = false, M = true;
        if (F(_))
          for (let C = 0; C < _.length; ++C) {
            const D = _[C], g = J(D) && D.name;
            if (g === "Boolean") {
              E = true;
              break;
            } else g === "String" && (M = false);
          }
        else
          E = J(_) && _.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = E, h[
          1
          /* shouldCastTrue */
        ] = M, (E || oe(h, "default")) && c.push(a);
      }
    }
  }
  const f = [o, c];
  return ie(e) && s.set(e, f), f;
}
function Gl(e) {
  return e[0] !== "$" && !ln(e) ? true : (T(`Invalid prop name: "${e}" is a reserved property.`), false);
}
function BE(e) {
  return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "";
}
function Iu(e, t, n) {
  const s = Q(t), r = n.propsOptions[0], i = Object.keys(e).map((o) => de(o));
  for (const o in r) {
    let c = r[o];
    c != null && KE(
      o,
      s[o],
      c,
      true ? Et(s) : s,
      !i.includes(o)
    );
  }
}
function KE(e, t, n, s, r) {
  const { type: i, required: o, validator: c, skipCheck: l } = n;
  if (o && r) {
    T('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !o)) {
    if (i != null && i !== true && !l) {
      let f = false;
      const u = F(i) ? i : [i], a = [];
      for (let p = 0; p < u.length && !f; p++) {
        const { valid: h, expectedType: _ } = qE(t, u[p]);
        a.push(_ || ""), f = h;
      }
      if (!f) {
        T(GE(e, t, a));
        return;
      }
    }
    c && !c(t, s) && T('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
var WE = Ie(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function qE(e, t) {
  let n;
  const s = BE(t);
  if (s === "null")
    n = e === null;
  else if (WE(s)) {
    const r = typeof e;
    n = r === s.toLowerCase(), !n && r === "object" && (n = e instanceof t);
  } else s === "Object" ? n = ie(e) : s === "Array" ? n = F(e) : n = e instanceof t;
  return {
    valid: n,
    expectedType: s
  };
}
function GE(e, t, n) {
  if (n.length === 0)
    return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;
  let s = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(Pt).join(" | ")}`;
  const r = n[0], i = uc(t), o = zl(t, r), c = zl(t, i);
  return n.length === 1 && Jl(r) && !zE(r, i) && (s += ` with value ${o}`), s += `, got ${i} `, Jl(i) && (s += `with value ${c}.`), s;
}
function zl(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function Jl(e) {
  return ["string", "number", "boolean"].some((n) => e.toLowerCase() === n);
}
function zE(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
var Rc = (e) => e === "_" || e === "__" || e === "_ctx" || e === "$stable";
var Mc = (e) => F(e) ? e.map(Ge) : [Ge(e)];
var JE = (e, t, n) => {
  if (t._n)
    return t;
  const s = Oc((...r) => (xe && !(n === null && Te) && !(n && n.root !== xe.root) && T(
    `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Mc(t(...r))), n);
  return s._c = false, s;
};
var Pu = (e, t, n) => {
  const s = e._ctx;
  for (const r in e) {
    if (Rc(r)) continue;
    const i = e[r];
    if (J(i))
      t[r] = JE(r, i, s);
    else if (i != null) {
      T(
        `Non-function value encountered for slot "${r}". Prefer function slots for better performance.`
      );
      const o = Mc(i);
      t[r] = () => o;
    }
  }
};
var Ru = (e, t) => {
  !bs(e.vnode) && T(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const n = Mc(t);
  e.slots.default = () => n;
};
var Po = (e, t, n) => {
  for (const s in t)
    (n || !Rc(s)) && (e[s] = t[s]);
};
var YE = (e, t, n) => {
  const s = e.slots = Cu();
  if (e.vnode.shapeFlag & 32) {
    const r = t.__;
    r && Mn(s, "__", r, true);
    const i = t._;
    i ? (Po(s, t, n), n && Mn(s, "_", i, true)) : Pu(t, s);
  } else t && Ru(e, t);
};
var XE = (e, t, n) => {
  const { vnode: s, slots: r } = e;
  let i = true, o = se;
  if (s.shapeFlag & 32) {
    const c = t._;
    c ? yt ? (Po(r, t, n), xt(e, "set", "$slots")) : n && c === 1 ? i = false : Po(r, t, n) : (i = !t.$stable, Pu(t, r)), o = t;
  } else t && (Ru(e, t), o = { default: 1 });
  if (i)
    for (const c in r)
      !Rc(c) && o[c] == null && delete r[c];
};
var ws;
var on;
function $t(e, t) {
  e.appContext.config.performance && Yr() && on.mark(`vue-${t}-${e.uid}`), V_(e, t, Yr() ? on.now() : Date.now());
}
function kt(e, t) {
  if (e.appContext.config.performance && Yr()) {
    const n = `vue-${t}-${e.uid}`, s = n + ":end";
    on.mark(s), on.measure(
      `<${Bi(e, e.type)}> ${t}`,
      n,
      s
    ), on.clearMarks(n), on.clearMarks(s);
  }
  A_(e, t, Yr() ? on.now() : Date.now());
}
function Yr() {
  return ws !== void 0 || (typeof window < "u" && window.performance ? (ws = true, on = window.performance) : ws = false), ws;
}
function ZE() {
  const e = [];
  if (typeof __VUE_OPTIONS_API__ != "boolean" && (e.push("__VUE_OPTIONS_API__"), an().__VUE_OPTIONS_API__ = true), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (e.push("__VUE_PROD_DEVTOOLS__"), an().__VUE_PROD_DEVTOOLS__ = false), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (e.push("__VUE_PROD_HYDRATION_MISMATCH_DETAILS__"), an().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false), e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
var Ce = zu;
function Mu(e) {
  return ku(e);
}
function $u(e) {
  return ku(e, B_);
}
function ku(e, t) {
  ZE();
  const n = an();
  n.__VUE__ = true, Nc(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const {
    insert: s,
    remove: r,
    patchProp: i,
    createElement: o,
    createText: c,
    createComment: l,
    setText: f,
    setElementText: u,
    parentNode: a,
    nextSibling: p,
    setScopeId: h = me,
    insertStaticContent: _
  } = e, E = (d, m, O, I = null, A = null, x = null, j = void 0, k = null, $ = yt ? false : !!m.dynamicChildren) => {
    if (d === m)
      return;
    d && !_t(d, m) && (I = gr(d), Jt(d, A, x, true), d = null), m.patchFlag === -2 && ($ = false, m.dynamicChildren = null);
    const { type: P, ref: Y, shapeFlag: U } = m;
    switch (P) {
      case It:
        M(d, m, O, I);
        break;
      case Ee:
        C(d, m, O, I);
        break;
      case un:
        d == null ? D(m, O, I, j) : g(d, m, O, j);
        break;
      case De:
        L(
          d,
          m,
          O,
          I,
          A,
          x,
          j,
          k,
          $
        );
        break;
      default:
        U & 1 ? w(
          d,
          m,
          O,
          I,
          A,
          x,
          j,
          k,
          $
        ) : U & 6 ? W(
          d,
          m,
          O,
          I,
          A,
          x,
          j,
          k,
          $
        ) : U & 64 || U & 128 ? P.process(
          d,
          m,
          O,
          I,
          A,
          x,
          j,
          k,
          $,
          Kn
        ) : T("Invalid VNode type:", P, `(${typeof P})`);
    }
    Y != null && A ? es(Y, d && d.ref, x, m || d, !m) : Y == null && d && d.ref != null && es(d.ref, null, x, d, true);
  }, M = (d, m, O, I) => {
    if (d == null)
      s(
        m.el = c(m.children),
        O,
        I
      );
    else {
      const A = m.el = d.el;
      m.children !== d.children && f(A, m.children);
    }
  }, C = (d, m, O, I) => {
    d == null ? s(
      m.el = l(m.children || ""),
      O,
      I
    ) : m.el = d.el;
  }, D = (d, m, O, I) => {
    [d.el, d.anchor] = _(
      d.children,
      m,
      O,
      I,
      d.el,
      d.anchor
    );
  }, g = (d, m, O, I) => {
    if (m.children !== d.children) {
      const A = p(d.anchor);
      y(d), [m.el, m.anchor] = _(
        m.children,
        O,
        A,
        I
      );
    } else
      m.el = d.el, m.anchor = d.anchor;
  }, N = ({ el: d, anchor: m }, O, I) => {
    let A;
    for (; d && d !== m; )
      A = p(d), s(d, O, I), d = A;
    s(m, O, I);
  }, y = ({ el: d, anchor: m }) => {
    let O;
    for (; d && d !== m; )
      O = p(d), r(d), d = O;
    r(m);
  }, w = (d, m, O, I, A, x, j, k, $) => {
    m.type === "svg" ? j = "svg" : m.type === "math" && (j = "mathml"), d == null ? H(
      m,
      O,
      I,
      A,
      x,
      j,
      k,
      $
    ) : S(
      d,
      m,
      A,
      x,
      j,
      k,
      $
    );
  }, H = (d, m, O, I, A, x, j, k) => {
    let $, P;
    const { props: Y, shapeFlag: U, transition: G, dirs: Z } = d;
    if ($ = d.el = o(
      d.type,
      x,
      Y && Y.is,
      Y
    ), U & 8 ? u($, d.children) : U & 16 && v(
      d.children,
      $,
      null,
      I,
      A,
      fo(d, x),
      j,
      k
    ), Z && Vt(d, null, I, "created"), V($, d, d.scopeId, j, I), Y) {
      for (const he in Y)
        he !== "value" && !ln(he) && i($, he, null, Y[he], x, I);
      "value" in Y && i($, "value", null, Y.value, x), (P = Y.onVnodeBeforeMount) && Qe(P, I, d);
    }
    Mn($, "__vnode", d, true), Mn($, "__vueParentComponent", I, true), Z && Vt(d, null, I, "beforeMount");
    const le = Lu(A, G);
    le && G.beforeEnter($), s($, m, O), ((P = Y && Y.onVnodeMounted) || le || Z) && Ce(() => {
      P && Qe(P, I, d), le && G.enter($), Z && Vt(d, null, I, "mounted");
    }, A);
  }, V = (d, m, O, I, A) => {
    if (O && h(d, O), I)
      for (let x = 0; x < I.length; x++)
        h(d, I[x]);
    if (A) {
      let x = A.subTree;
      if (x.patchFlag > 0 && x.patchFlag & 2048 && (x = ji(x.children) || x), m === x || Qr(x.type) && (x.ssContent === m || x.ssFallback === m)) {
        const j = A.vnode;
        V(
          d,
          j,
          j.scopeId,
          j.slotScopeIds,
          A.parent
        );
      }
    }
  }, v = (d, m, O, I, A, x, j, k, $ = 0) => {
    for (let P = $; P < d.length; P++) {
      const Y = d[P] = k ? nn(d[P]) : Ge(d[P]);
      E(
        null,
        Y,
        m,
        O,
        I,
        A,
        x,
        j,
        k
      );
    }
  }, S = (d, m, O, I, A, x, j) => {
    const k = m.el = d.el;
    k.__vnode = m;
    let { patchFlag: $, dynamicChildren: P, dirs: Y } = m;
    $ |= d.patchFlag & 16;
    const U = d.props || se, G = m.props || se;
    let Z;
    if (O && _n(O, false), (Z = G.onVnodeBeforeUpdate) && Qe(Z, O, m, d), Y && Vt(m, d, O, "beforeUpdate"), O && _n(O, true), yt && ($ = 0, j = false, P = null), (U.innerHTML && G.innerHTML == null || U.textContent && G.textContent == null) && u(k, ""), P ? (R(
      d.dynamicChildren,
      P,
      k,
      O,
      I,
      fo(m, A),
      x
    ), js(d, m)) : j || fe(
      d,
      m,
      k,
      null,
      O,
      I,
      fo(m, A),
      x,
      false
    ), $ > 0) {
      if ($ & 16)
        b(k, U, G, O, A);
      else if ($ & 2 && U.class !== G.class && i(k, "class", null, G.class, A), $ & 4 && i(k, "style", U.style, G.style, A), $ & 8) {
        const le = m.dynamicProps;
        for (let he = 0; he < le.length; he++) {
          const ue = le[he], Ye = U[ue], $e = G[ue];
          ($e !== Ye || ue === "value") && i(k, ue, Ye, $e, A, O);
        }
      }
      $ & 1 && d.children !== m.children && u(k, m.children);
    } else !j && P == null && b(k, U, G, O, A);
    ((Z = G.onVnodeUpdated) || Y) && Ce(() => {
      Z && Qe(Z, O, m, d), Y && Vt(m, d, O, "updated");
    }, I);
  }, R = (d, m, O, I, A, x, j) => {
    for (let k = 0; k < m.length; k++) {
      const $ = d[k], P = m[k], Y = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        $.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        ($.type === De || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !_t($, P) || // - In the case of a component, it could contain anything.
        $.shapeFlag & 198) ? a($.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          O
        )
      );
      E(
        $,
        P,
        Y,
        null,
        I,
        A,
        x,
        j,
        true
      );
    }
  }, b = (d, m, O, I, A) => {
    if (m !== O) {
      if (m !== se)
        for (const x in m)
          !ln(x) && !(x in O) && i(
            d,
            x,
            m[x],
            null,
            A,
            I
          );
      for (const x in O) {
        if (ln(x)) continue;
        const j = O[x], k = m[x];
        j !== k && x !== "value" && i(d, x, k, j, A, I);
      }
      "value" in O && i(d, "value", m.value, O.value, A);
    }
  }, L = (d, m, O, I, A, x, j, k, $) => {
    const P = m.el = d ? d.el : c(""), Y = m.anchor = d ? d.anchor : c("");
    let { patchFlag: U, dynamicChildren: G, slotScopeIds: Z } = m;
    // #5523 dev root fragment may inherit directives
    (yt || U & 2048) && (U = 0, $ = false, G = null), Z && (k = k ? k.concat(Z) : Z), d == null ? (s(P, O, I), s(Y, O, I), v(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      m.children || [],
      O,
      Y,
      A,
      x,
      j,
      k,
      $
    )) : U > 0 && U & 64 && G && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    d.dynamicChildren ? (R(
      d.dynamicChildren,
      G,
      O,
      A,
      x,
      j,
      k
    ), true ? js(d, m) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (m.key != null || A && m === A.subTree) && js(
        d,
        m,
        true
        /* shallow */
      )
    )) : fe(
      d,
      m,
      O,
      Y,
      A,
      x,
      j,
      k,
      $
    );
  }, W = (d, m, O, I, A, x, j, k, $) => {
    m.slotScopeIds = k, d == null ? m.shapeFlag & 512 ? A.ctx.activate(
      m,
      O,
      I,
      j,
      $
    ) : q(
      m,
      O,
      I,
      A,
      x,
      j,
      $
    ) : K(d, m, $);
  }, q = (d, m, O, I, A, x, j) => {
    const k = d.component = np(
      d,
      I,
      A
    );
    if (k.type.__hmrId && N_(k), Xn(d), $t(k, "mount"), bs(d) && (k.ctx.renderer = Kn), $t(k, "init"), rp(k, false, j), kt(k, "init"), yt && (d.el = null), k.asyncDep) {
      if (A && A.registerDep(k, z, j), !d.el) {
        const $ = k.subTree = ye(Ee);
        C(null, $, m, O), d.placeholder = $.el;
      }
    } else
      z(
        k,
        d,
        m,
        O,
        A,
        x,
        j
      );
    Zn(), kt(k, "mount");
  }, K = (d, m, O) => {
    const I = m.component = d.component;
    if (cy(d, m, O))
      if (I.asyncDep && !I.asyncResolved) {
        Xn(m), B(I, m, O), Zn();
        return;
      } else
        I.next = m, I.update();
    else
      m.el = d.el, I.vnode = m;
  }, z = (d, m, O, I, A, x, j) => {
    const k = () => {
      if (d.isMounted) {
        let { next: U, bu: G, u: Z, parent: le, vnode: he } = d;
        {
          const st = Fu(d);
          if (st) {
            U && (U.el = he.el, B(d, U, j)), st.asyncDep.then(() => {
              d.isUnmounted || k();
            });
            return;
          }
        }
        let ue = U, Ye;
        Xn(U || d.vnode), _n(d, false), U ? (U.el = he.el, B(d, U, j)) : U = he, G && rn(G), (Ye = U.props && U.props.onVnodeBeforeUpdate) && Qe(Ye, le, U, he), _n(d, true), $t(d, "render");
        const $e = Ar(d);
        kt(d, "render");
        const gt = d.subTree;
        d.subTree = $e, $t(d, "patch"), E(
          gt,
          $e,
          // parent may have changed if it's in a teleport
          a(gt.el),
          // anchor may have changed if it's in a fragment
          gr(gt),
          d,
          A,
          x
        ), kt(d, "patch"), U.el = $e.el, ue === null && Ui(d, $e.el), Z && Ce(Z, A), (Ye = U.props && U.props.onVnodeUpdated) && Ce(
          () => Qe(Ye, le, U, he),
          A
        ), tu(d), Zn();
      } else {
        let U;
        const { el: G, props: Z } = m, { bm: le, m: he, parent: ue, root: Ye, type: $e } = d, gt = fn(m);
        if (_n(d, false), le && rn(le), !gt && (U = Z && Z.onVnodeBeforeMount) && Qe(U, ue, m), _n(d, true), G && Xi) {
          const st = () => {
            $t(d, "render"), d.subTree = Ar(d), kt(d, "render"), $t(d, "hydrate"), Xi(
              G,
              d.subTree,
              d,
              A,
              null
            ), kt(d, "hydrate");
          };
          gt && $e.__asyncHydrate ? $e.__asyncHydrate(
            G,
            d,
            st
          ) : st();
        } else {
          Ye.ce && // @ts-expect-error _def is private
          Ye.ce._def.shadowRoot !== false && Ye.ce._injectChildStyle($e), $t(d, "render");
          const st = d.subTree = Ar(d);
          kt(d, "render"), $t(d, "patch"), E(
            null,
            st,
            O,
            I,
            d,
            A,
            x
          ), kt(d, "patch"), m.el = st.el;
        }
        if (he && Ce(he, A), !gt && (U = Z && Z.onVnodeMounted)) {
          const st = m;
          Ce(
            () => Qe(U, ue, st),
            A
          );
        }
        (m.shapeFlag & 256 || ue && fn(ue.vnode) && ue.vnode.shapeFlag & 256) && d.a && Ce(d.a, A), d.isMounted = true, wo(d), m = O = I = null;
      }
    };
    d.scope.on();
    const $ = d.effect = new Gs(k);
    d.scope.off();
    const P = d.update = $.run.bind($), Y = d.job = $.runIfDirty.bind($);
    Y.i = d, Y.id = d.uid, $.scheduler = () => Pi(Y), _n(d, true), $.onTrack = d.rtc ? (U) => rn(d.rtc, U) : void 0, $.onTrigger = d.rtg ? (U) => rn(d.rtg, U) : void 0, P();
  }, B = (d, m, O) => {
    m.component = d;
    const I = d.vnode.props;
    d.vnode = m, d.next = null, jE(d, m.props, I, O), XE(d, m.children, O), Ot(), Pl(d), St();
  }, fe = (d, m, O, I, A, x, j, k, $ = false) => {
    const P = d && d.children, Y = d ? d.shapeFlag : 0, U = m.children, { patchFlag: G, shapeFlag: Z } = m;
    if (G > 0) {
      if (G & 128) {
        ct(
          P,
          U,
          O,
          I,
          A,
          x,
          j,
          k,
          $
        );
        return;
      } else if (G & 256) {
        Je(
          P,
          U,
          O,
          I,
          A,
          x,
          j,
          k,
          $
        );
        return;
      }
    }
    Z & 8 ? (Y & 16 && Os(P, A, x), U !== P && u(O, U)) : Y & 16 ? Z & 16 ? ct(
      P,
      U,
      O,
      I,
      A,
      x,
      j,
      k,
      $
    ) : Os(P, A, x, true) : (Y & 8 && u(O, ""), Z & 16 && v(
      U,
      O,
      I,
      A,
      x,
      j,
      k,
      $
    ));
  }, Je = (d, m, O, I, A, x, j, k, $) => {
    d = d || Yn, m = m || Yn;
    const P = d.length, Y = m.length, U = Math.min(P, Y);
    let G;
    for (G = 0; G < U; G++) {
      const Z = m[G] = $ ? nn(m[G]) : Ge(m[G]);
      E(
        d[G],
        Z,
        O,
        null,
        A,
        x,
        j,
        k,
        $
      );
    }
    P > Y ? Os(
      d,
      A,
      x,
      true,
      false,
      U
    ) : v(
      m,
      O,
      I,
      A,
      x,
      j,
      k,
      $,
      U
    );
  }, ct = (d, m, O, I, A, x, j, k, $) => {
    let P = 0;
    const Y = m.length;
    let U = d.length - 1, G = Y - 1;
    for (; P <= U && P <= G; ) {
      const Z = d[P], le = m[P] = $ ? nn(m[P]) : Ge(m[P]);
      if (_t(Z, le))
        E(
          Z,
          le,
          O,
          null,
          A,
          x,
          j,
          k,
          $
        );
      else
        break;
      P++;
    }
    for (; P <= U && P <= G; ) {
      const Z = d[U], le = m[G] = $ ? nn(m[G]) : Ge(m[G]);
      if (_t(Z, le))
        E(
          Z,
          le,
          O,
          null,
          A,
          x,
          j,
          k,
          $
        );
      else
        break;
      U--, G--;
    }
    if (P > U) {
      if (P <= G) {
        const Z = G + 1, le = Z < Y ? m[Z].el : I;
        for (; P <= G; )
          E(
            null,
            m[P] = $ ? nn(m[P]) : Ge(m[P]),
            O,
            le,
            A,
            x,
            j,
            k,
            $
          ), P++;
      }
    } else if (P > G)
      for (; P <= U; )
        Jt(d[P], A, x, true), P++;
    else {
      const Z = P, le = P, he = /* @__PURE__ */ new Map();
      for (P = le; P <= G; P++) {
        const Be = m[P] = $ ? nn(m[P]) : Ge(m[P]);
        Be.key != null && (he.has(Be.key) && T(
          "Duplicate keys found during update:",
          JSON.stringify(Be.key),
          "Make sure keys are unique."
        ), he.set(Be.key, P));
      }
      let ue, Ye = 0;
      const $e = G - le + 1;
      let gt = false, st = 0;
      const Ss = new Array($e);
      for (P = 0; P < $e; P++) Ss[P] = 0;
      for (P = Z; P <= U; P++) {
        const Be = d[P];
        if (Ye >= $e) {
          Jt(Be, A, x, true);
          continue;
        }
        let Dt;
        if (Be.key != null)
          Dt = he.get(Be.key);
        else
          for (ue = le; ue <= G; ue++)
            if (Ss[ue - le] === 0 && _t(Be, m[ue])) {
              Dt = ue;
              break;
            }
        Dt === void 0 ? Jt(Be, A, x, true) : (Ss[Dt - le] = P + 1, Dt >= st ? st = Dt : gt = true, E(
          Be,
          m[Dt],
          O,
          null,
          A,
          x,
          j,
          k,
          $
        ), Ye++);
      }
      const ul = gt ? QE(Ss) : Yn;
      for (ue = ul.length - 1, P = $e - 1; P >= 0; P--) {
        const Be = le + P, Dt = m[Be], pl = m[Be + 1], dl = Be + 1 < Y ? (
          // #13559, fallback to el placeholder for unresolved async component
          pl.el || pl.placeholder
        ) : I;
        Ss[P] === 0 ? E(
          null,
          Dt,
          O,
          dl,
          A,
          x,
          j,
          k,
          $
        ) : gt && (ue < 0 || P !== ul[ue] ? lt(Dt, O, dl, 2) : ue--);
      }
    }
  }, lt = (d, m, O, I, A = null) => {
    const { el: x, type: j, transition: k, children: $, shapeFlag: P } = d;
    if (P & 6) {
      lt(d.component.subTree, m, O, I);
      return;
    }
    if (P & 128) {
      d.suspense.move(m, O, I);
      return;
    }
    if (P & 64) {
      j.move(d, m, O, Kn);
      return;
    }
    if (j === De) {
      s(x, m, O);
      for (let U = 0; U < $.length; U++)
        lt($[U], m, O, I);
      s(d.anchor, m, O);
      return;
    }
    if (j === un) {
      N(d, m, O);
      return;
    }
    if (I !== 2 && P & 1 && k)
      if (I === 0)
        k.beforeEnter(x), s(x, m, O), Ce(() => k.enter(x), A);
      else {
        const { leave: U, delayLeave: G, afterLeave: Z } = k, le = () => {
          d.ctx.isUnmounted ? r(x) : s(x, m, O);
        }, he = () => {
          U(x, () => {
            le(), Z && Z();
          });
        };
        G ? G(x, le, he) : he();
      }
    else
      s(x, m, O);
  }, Jt = (d, m, O, I = false, A = false) => {
    const {
      type: x,
      props: j,
      ref: k,
      children: $,
      dynamicChildren: P,
      shapeFlag: Y,
      patchFlag: U,
      dirs: G,
      cacheIndex: Z
    } = d;
    if (U === -2 && (A = false), k != null && (Ot(), es(k, null, O, d, true), St()), Z != null && (m.renderCache[Z] = void 0), Y & 256) {
      m.ctx.deactivate(d);
      return;
    }
    const le = Y & 1 && G, he = !fn(d);
    let ue;
    if (he && (ue = j && j.onVnodeBeforeUnmount) && Qe(ue, m, d), Y & 6)
      wd(d.component, O, I);
    else {
      if (Y & 128) {
        d.suspense.unmount(O, I);
        return;
      }
      le && Vt(d, null, m, "beforeUnmount"), Y & 64 ? d.type.remove(
        d,
        m,
        O,
        Kn,
        I
      ) : P && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !P.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (x !== De || U > 0 && U & 64) ? Os(
        P,
        m,
        O,
        false,
        true
      ) : (x === De && U & 384 || !A && Y & 16) && Os($, m, O), I && zi(d);
    }
    (he && (ue = j && j.onVnodeUnmounted) || le) && Ce(() => {
      ue && Qe(ue, m, d), le && Vt(d, null, m, "unmounted");
    }, O);
  }, zi = (d) => {
    const { type: m, el: O, anchor: I, transition: A } = d;
    if (m === De) {
      d.patchFlag > 0 && d.patchFlag & 2048 && A && !A.persisted ? d.children.forEach((j) => {
        j.type === Ee ? r(j.el) : zi(j);
      }) : Dd(O, I);
      return;
    }
    if (m === un) {
      y(d);
      return;
    }
    const x = () => {
      r(O), A && !A.persisted && A.afterLeave && A.afterLeave();
    };
    if (d.shapeFlag & 1 && A && !A.persisted) {
      const { leave: j, delayLeave: k } = A, $ = () => j(O, x);
      k ? k(d.el, x, $) : $();
    } else
      x();
  }, Dd = (d, m) => {
    let O;
    for (; d !== m; )
      O = p(d), r(d), d = O;
    r(m);
  }, wd = (d, m, O) => {
    d.type.__hmrId && b_(d);
    const {
      bum: I,
      scope: A,
      job: x,
      subTree: j,
      um: k,
      m: $,
      a: P,
      parent: Y,
      slots: { __: U }
    } = d;
    Xr($), Xr(P), I && rn(I), Y && F(U) && U.forEach((G) => {
      Y.renderCache[G] = void 0;
    }), A.stop(), x && (x.flags |= 8, Jt(j, d, m, O)), k && Ce(k, m), Ce(() => {
      d.isUnmounted = true;
    }, m), m && m.pendingBranch && !m.isUnmounted && d.asyncDep && !d.asyncResolved && d.suspenseId === m.pendingId && (m.deps--, m.deps === 0 && m.resolve()), C_(d);
  }, Os = (d, m, O, I = false, A = false, x = 0) => {
    for (let j = x; j < d.length; j++)
      Jt(d[j], m, O, I, A);
  }, gr = (d) => {
    if (d.shapeFlag & 6)
      return gr(d.component.subTree);
    if (d.shapeFlag & 128)
      return d.suspense.next();
    const m = p(d.anchor || d.el), O = m && m[ru];
    return O ? p(O) : m;
  };
  let Ji = false;
  const fl = (d, m, O) => {
    d == null ? m._vnode && Jt(m._vnode, null, null, true) : E(
      m._vnode || null,
      d,
      m,
      null,
      null,
      null,
      O
    ), m._vnode = d, Ji || (Ji = true, Pl(), qr(), Ji = false);
  }, Kn = {
    p: E,
    um: Jt,
    m: lt,
    r: zi,
    mt: q,
    mc: v,
    pc: fe,
    pbc: R,
    n: gr,
    o: e
  };
  let Yi, Xi;
  return t && ([Yi, Xi] = t(
    Kn
  )), {
    render: fl,
    hydrate: Yi,
    createApp: kE(fl, Yi)
  };
}
function fo({ type: e, props: t }, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function _n({ effect: e, job: t }, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function Lu(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function js(e, t, n = false) {
  const s = e.children, r = t.children;
  if (F(s) && F(r))
    for (let i = 0; i < s.length; i++) {
      const o = s[i];
      let c = r[i];
      c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = r[i] = nn(r[i]), c.el = o.el), !n && c.patchFlag !== -2 && js(o, c)), c.type === It && (c.el = o.el), c.type === Ee && !c.el && (c.el = o.el), c.el && (c.el.__vnode = c);
    }
}
function QE(e) {
  const t = e.slice(), n = [0];
  let s, r, i, o, c;
  const l = e.length;
  for (s = 0; s < l; s++) {
    const f = e[s];
    if (f !== 0) {
      if (r = n[n.length - 1], e[r] < f) {
        t[s] = r, n.push(s);
        continue;
      }
      for (i = 0, o = n.length - 1; i < o; )
        c = i + o >> 1, e[n[c]] < f ? i = c + 1 : o = c;
      f < e[n[i]] && (i > 0 && (t[s] = n[i - 1]), n[i] = s);
    }
  }
  for (i = n.length, o = n[i - 1]; i-- > 0; )
    n[i] = o, o = t[o];
  return n;
}
function Fu(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : Fu(t);
}
function Xr(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
var Hu = Symbol.for("v-scx");
var ju = () => {
  {
    const e = Hs(Hu);
    return e || T(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e;
  }
};
function ey(e, t) {
  return fr(e, null, t);
}
function ty(e, t) {
  return fr(
    e,
    null,
    true ? te({}, t, { flush: "post" }) : { flush: "post" }
  );
}
function Uu(e, t) {
  return fr(
    e,
    null,
    true ? te({}, t, { flush: "sync" }) : { flush: "sync" }
  );
}
function ts(e, t, n) {
  return !J(t) && T(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), fr(e, t, n);
}
function fr(e, t, n = se) {
  const { immediate: s, deep: r, flush: i, once: o } = n;
  !t && (s !== void 0 && T(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && T(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), o !== void 0 && T(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const c = te({}, n);
  c.onWarn = T;
  const l = t && s || !t && i !== "post";
  let f;
  if (os) {
    if (i === "sync") {
      const h = ju();
      f = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!l) {
      const h = () => {
      };
      return h.stop = me, h.resume = me, h.pause = me, h;
    }
  }
  const u = xe;
  c.call = (h, _, E) => dt(h, u, _, E);
  let a = false;
  i === "post" ? c.scheduler = (h) => {
    Ce(h, u && u.suspense);
  } : i !== "sync" && (a = true, c.scheduler = (h, _) => {
    _ ? h() : Pi(h);
  }), c.augmentJob = (h) => {
    t && (h.flags |= 4), a && (h.flags |= 2, u && (h.id = u.uid, h.i = u));
  };
  const p = p_(e, t, c);
  return os && (f ? f.push(p) : l && p()), p;
}
function ny(e, t, n) {
  const s = this.proxy, r = X(e) ? e.includes(".") ? Bu(s, e) : () => s[e] : e.bind(s, s);
  let i;
  J(t) ? i = t : (i = t.handler, n = t);
  const o = Ln(this), c = fr(r, i.bind(s), n);
  return o(), c;
}
function Bu(e, t) {
  const n = t.split(".");
  return () => {
    let s = e;
    for (let r = 0; r < n.length && s; r++)
      s = s[n[r]];
    return s;
  };
}
function sy(e, t, n = se) {
  const s = ze();
  if (!s)
    return T("useModel() called without active instance."), wn();
  const r = de(t);
  if (!s.propsOptions[0][r])
    return T(`useModel() called with prop "${t}" which is not declared.`), wn();
  const i = Fe(t), o = Ku(e, r), c = Gf((l, f) => {
    let u, a = se, p;
    return Uu(() => {
      const h = e[r];
      We(u, h) && (u = h, f());
    }), {
      get() {
        return l(), n.get ? n.get(u) : u;
      },
      set(h) {
        const _ = n.set ? n.set(h) : h;
        if (!We(_, u) && !(a !== se && We(h, a)))
          return;
        const E = s.vnode.props;
        E && // check if parent has passed v-model
        (t in E || r in E || i in E) && (`onUpdate:${t}` in E || `onUpdate:${r}` in E || `onUpdate:${i}` in E) || (u = h, f()), s.emit(`update:${t}`, _), We(h, _) && We(h, a) && !We(_, p) && f(), a = h, p = _;
      }
    };
  });
  return c[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? { value: l++ ? o || se : c, done: false } : { done: true };
      }
    };
  }, c;
}
var Ku = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${de(t)}Modifiers`] || e[`${Fe(t)}Modifiers`];
function ry(e, t, ...n) {
  if (e.isUnmounted) return;
  const s = e.vnode.props || se;
  if (true) {
    const {
      emitsOptions: u,
      propsOptions: [a]
    } = e;
    if (u)
      if (!(t in u))
        (!a || !(At(de(t)) in a)) && T(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${At(de(t))}" prop.`
        );
      else {
        const p = u[t];
        J(p) && (p(...n) || T(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let r = n;
  const i = t.startsWith("update:"), o = i && Ku(s, t.slice(7));
  if (o && (o.trim && (r = n.map((u) => X(u) ? u.trim() : u)), o.number && (r = n.map(Hr))), x_(e, t, r), true) {
    const u = t.toLowerCase();
    u !== t && s[At(u)] && T(
      `Event "${u}" is emitted in component ${Bi(
        e,
        e.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Fe(
        t
      )}" instead of "${t}".`
    );
  }
  let c, l = s[c = At(t)] || // also try camelCase event handler (#2249)
  s[c = At(de(t))];
  !l && i && (l = s[c = At(Fe(t))]), l && dt(
    l,
    e,
    6,
    r
  );
  const f = s[c + "Once"];
  if (f) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[c])
      return;
    e.emitted[c] = true, dt(
      f,
      e,
      6,
      r
    );
  }
}
function Wu(e, t, n = false) {
  const s = t.emitsCache, r = s.get(e);
  if (r !== void 0)
    return r;
  const i = e.emits;
  let o = {}, c = false;
  if (__VUE_OPTIONS_API__ && !J(e)) {
    const l = (f) => {
      const u = Wu(f, t, true);
      u && (c = true, te(o, u));
    };
    !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l);
  }
  return !i && !c ? (ie(e) && s.set(e, null), null) : (F(i) ? i.forEach((l) => o[l] = null) : te(o, i), ie(e) && s.set(e, o), o);
}
function Hi(e, t) {
  return !e || !Wt(t) ? false : (t = t.slice(2).replace(/Once$/, ""), oe(e, t[0].toLowerCase() + t.slice(1)) || oe(e, Fe(t)) || oe(e, t));
}
var Ro = false;
function Zr() {
  Ro = true;
}
function Ar(e) {
  const {
    type: t,
    vnode: n,
    proxy: s,
    withProxy: r,
    propsOptions: [i],
    slots: o,
    attrs: c,
    emit: l,
    render: f,
    renderCache: u,
    props: a,
    data: p,
    setupState: h,
    ctx: _,
    inheritAttrs: E
  } = e, M = Xs(e);
  let C, D;
  Ro = false;
  try {
    if (n.shapeFlag & 4) {
      const y = r || s, w = h.__isScriptSetup ? new Proxy(y, {
        get(H, V, v) {
          return T(
            `Property '${String(
              V
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(H, V, v);
        }
      }) : y;
      C = Ge(
        f.call(
          w,
          y,
          u,
          true ? Et(a) : a,
          h,
          p,
          _
        )
      ), D = c;
    } else {
      const y = t;
      c === a && Zr(), C = Ge(
        y.length > 1 ? y(
          true ? Et(a) : a,
          true ? {
            get attrs() {
              return Zr(), Et(c);
            },
            slots: o,
            emit: l
          } : { attrs: c, slots: o, emit: l }
        ) : y(
          true ? Et(a) : a,
          null
        )
      ), D = t.props ? c : iy(c);
    }
  } catch (y) {
    Us.length = 0, gn(y, e, 1), C = ye(Ee);
  }
  let g = C, N;
  if (C.patchFlag > 0 && C.patchFlag & 2048 && ([g, N] = qu(C)), D && E !== false) {
    const y = Object.keys(D), { shapeFlag: w } = g;
    if (y.length) {
      if (w & 7)
        i && y.some(Fr) && (D = oy(
          D,
          i
        )), g = ht(g, D, false, true);
      else if (!Ro && g.type !== Ee) {
        const H = Object.keys(c), V = [], v = [];
        for (let S = 0, R = H.length; S < R; S++) {
          const b = H[S];
          Wt(b) ? Fr(b) || V.push(b[2].toLowerCase() + b.slice(3)) : v.push(b);
        }
        v.length && T(
          `Extraneous non-props attributes (${v.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), V.length && T(
          `Extraneous non-emits event listeners (${V.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return n.dirs && (!Yl(g) && T(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), g = ht(g, null, false, true), g.dirs = g.dirs ? g.dirs.concat(n.dirs) : n.dirs), n.transition && (!Yl(g) && T(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), qt(g, n.transition)), N ? N(g) : C = g, Xs(M), C;
}
var qu = (e) => {
  const t = e.children, n = e.dynamicChildren, s = ji(t, false);
  if (s) {
    if (s.patchFlag > 0 && s.patchFlag & 2048)
      return qu(s);
  } else return [e, void 0];
  const r = t.indexOf(s), i = n ? n.indexOf(s) : -1, o = (c) => {
    t[r] = c, n && (i > -1 ? n[i] = c : c.patchFlag > 0 && (e.dynamicChildren = [...n, c]));
  };
  return [Ge(s), o];
};
function ji(e, t = true) {
  let n;
  for (let s = 0; s < e.length; s++) {
    const r = e[s];
    if (Rt(r)) {
      if (r.type !== Ee || r.children === "v-if") {
        if (n)
          return;
        if (n = r, t && n.patchFlag > 0 && n.patchFlag & 2048)
          return ji(n.children);
      }
    } else
      return;
  }
  return n;
}
var iy = (e) => {
  let t;
  for (const n in e)
    (n === "class" || n === "style" || Wt(n)) && ((t || (t = {}))[n] = e[n]);
  return t;
};
var oy = (e, t) => {
  const n = {};
  for (const s in e)
    (!Fr(s) || !(s.slice(9) in t)) && (n[s] = e[s]);
  return n;
};
var Yl = (e) => e.shapeFlag & 7 || e.type === Ee;
function cy(e, t, n) {
  const { props: s, children: r, component: i } = e, { props: o, children: c, patchFlag: l } = t, f = i.emitsOptions;
  if ((r || c) && yt || t.dirs || t.transition)
    return true;
  if (n && l >= 0) {
    if (l & 1024)
      return true;
    if (l & 16)
      return s ? Xl(s, o, f) : !!o;
    if (l & 8) {
      const u = t.dynamicProps;
      for (let a = 0; a < u.length; a++) {
        const p = u[a];
        if (o[p] !== s[p] && !Hi(f, p))
          return true;
      }
    }
  } else
    return (r || c) && (!c || !c.$stable) ? true : s === o ? false : s ? o ? Xl(s, o, f) : true : !!o;
  return false;
}
function Xl(e, t, n) {
  const s = Object.keys(t);
  if (s.length !== Object.keys(e).length)
    return true;
  for (let r = 0; r < s.length; r++) {
    const i = s[r];
    if (t[i] !== e[i] && !Hi(n, i))
      return true;
  }
  return false;
}
function Ui({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const s = t.subTree;
    if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e)
      (e = t.vnode).el = n, t = t.parent;
    else
      break;
  }
}
var Qr = (e) => e.__isSuspense;
var Mo = 0;
var ly = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(e, t, n, s, r, i, o, c, l, f) {
    if (e == null)
      fy(
        t,
        n,
        s,
        r,
        i,
        o,
        c,
        l,
        f
      );
    else {
      if (i && i.deps > 0 && !e.suspense.isInFallback) {
        t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el;
        return;
      }
      uy(
        e,
        t,
        n,
        s,
        r,
        o,
        c,
        l,
        f
      );
    }
  },
  hydrate: py,
  normalize: dy
};
var ay = ly;
function Qs(e, t) {
  const n = e.props && e.props[t];
  J(n) && n();
}
function fy(e, t, n, s, r, i, o, c, l) {
  const {
    p: f,
    o: { createElement: u }
  } = l, a = u("div"), p = e.suspense = Gu(
    e,
    r,
    s,
    t,
    a,
    n,
    i,
    o,
    c,
    l
  );
  f(
    null,
    p.pendingBranch = e.ssContent,
    a,
    null,
    s,
    p,
    i,
    o
  ), p.deps > 0 ? (Qs(e, "onPending"), Qs(e, "onFallback"), f(
    null,
    e.ssFallback,
    t,
    n,
    s,
    null,
    // fallback tree will not have suspense context
    i,
    o
  ), ns(p, e.ssFallback)) : p.resolve(false, true);
}
function uy(e, t, n, s, r, i, o, c, { p: l, um: f, o: { createElement: u } }) {
  const a = t.suspense = e.suspense;
  a.vnode = t, t.el = e.el;
  const p = t.ssContent, h = t.ssFallback, { activeBranch: _, pendingBranch: E, isInFallback: M, isHydrating: C } = a;
  if (E)
    a.pendingBranch = p, _t(p, E) ? (l(
      E,
      p,
      a.hiddenContainer,
      null,
      r,
      a,
      i,
      o,
      c
    ), a.deps <= 0 ? a.resolve() : M && (C || (l(
      _,
      h,
      n,
      s,
      r,
      null,
      // fallback tree will not have suspense context
      i,
      o,
      c
    ), ns(a, h)))) : (a.pendingId = Mo++, C ? (a.isHydrating = false, a.activeBranch = E) : f(E, r, a), a.deps = 0, a.effects.length = 0, a.hiddenContainer = u("div"), M ? (l(
      null,
      p,
      a.hiddenContainer,
      null,
      r,
      a,
      i,
      o,
      c
    ), a.deps <= 0 ? a.resolve() : (l(
      _,
      h,
      n,
      s,
      r,
      null,
      // fallback tree will not have suspense context
      i,
      o,
      c
    ), ns(a, h))) : _ && _t(p, _) ? (l(
      _,
      p,
      n,
      s,
      r,
      a,
      i,
      o,
      c
    ), a.resolve(true)) : (l(
      null,
      p,
      a.hiddenContainer,
      null,
      r,
      a,
      i,
      o,
      c
    ), a.deps <= 0 && a.resolve()));
  else if (_ && _t(p, _))
    l(
      _,
      p,
      n,
      s,
      r,
      a,
      i,
      o,
      c
    ), ns(a, p);
  else if (Qs(t, "onPending"), a.pendingBranch = p, p.shapeFlag & 512 ? a.pendingId = p.component.suspenseId : a.pendingId = Mo++, l(
    null,
    p,
    a.hiddenContainer,
    null,
    r,
    a,
    i,
    o,
    c
  ), a.deps <= 0)
    a.resolve();
  else {
    const { timeout: D, pendingId: g } = a;
    D > 0 ? setTimeout(() => {
      a.pendingId === g && a.fallback(h);
    }, D) : D === 0 && a.fallback(h);
  }
}
var Zl = false;
function Gu(e, t, n, s, r, i, o, c, l, f, u = false) {
  !Zl && (Zl = true, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: a,
    m: p,
    um: h,
    n: _,
    o: { parentNode: E, remove: M }
  } = f;
  let C;
  const D = hy(e);
  D && t && t.pendingBranch && (C = t.pendingId, t.deps++);
  const g = e.props ? jr(e.props.timeout) : void 0;
  yc(g, "Suspense timeout");
  const N = i, y = {
    vnode: e,
    parent: t,
    parentComponent: n,
    namespace: o,
    container: s,
    hiddenContainer: r,
    deps: 0,
    pendingId: Mo++,
    timeout: typeof g == "number" ? g : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !u,
    isHydrating: u,
    isUnmounted: false,
    effects: [],
    resolve(w = false, H = false) {
      if (true) {
        if (!w && !y.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (y.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: V,
        activeBranch: v,
        pendingBranch: S,
        pendingId: R,
        effects: b,
        parentComponent: L,
        container: W
      } = y;
      let q = false;
      y.isHydrating ? y.isHydrating = false : w || (q = v && S.transition && S.transition.mode === "out-in", q && (v.transition.afterLeave = () => {
        R === y.pendingId && (p(
          S,
          W,
          i === N ? _(v) : i,
          0
        ), rs(b));
      }), v && (E(v.el) === W && (i = _(v)), h(v, L, y, true)), q || p(S, W, i, 0)), ns(y, S), y.pendingBranch = null, y.isInFallback = false;
      let K = y.parent, z = false;
      for (; K; ) {
        if (K.pendingBranch) {
          K.effects.push(...b), z = true;
          break;
        }
        K = K.parent;
      }
      !z && !q && rs(b), y.effects = [], D && t && t.pendingBranch && C === t.pendingId && (t.deps--, t.deps === 0 && !H && t.resolve()), Qs(V, "onResolve");
    },
    fallback(w) {
      if (!y.pendingBranch)
        return;
      const { vnode: H, activeBranch: V, parentComponent: v, container: S, namespace: R } = y;
      Qs(H, "onFallback");
      const b = _(V), L = () => {
        y.isInFallback && (a(
          null,
          w,
          S,
          b,
          v,
          null,
          // fallback tree will not have suspense context
          R,
          c,
          l
        ), ns(y, w));
      }, W = w.transition && w.transition.mode === "out-in";
      W && (V.transition.afterLeave = L), y.isInFallback = true, h(
        V,
        v,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      ), W || L();
    },
    move(w, H, V) {
      y.activeBranch && p(y.activeBranch, w, H, V), y.container = w;
    },
    next() {
      return y.activeBranch && _(y.activeBranch);
    },
    registerDep(w, H, V) {
      const v = !!y.pendingBranch;
      v && y.deps++;
      const S = w.vnode.el;
      w.asyncDep.catch((R) => {
        gn(R, w, 0);
      }).then((R) => {
        if (w.isUnmounted || y.isUnmounted || y.pendingId !== w.suspenseId)
          return;
        w.asyncResolved = true;
        const { vnode: b } = w;
        Xn(b), jo(w, R, false), S && (b.el = S);
        const L = !S && w.subTree.el;
        H(
          w,
          b,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          E(S || w.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          S ? null : _(w.subTree),
          y,
          o,
          V
        ), L && M(L), Ui(w, b.el), Zn(), v && --y.deps === 0 && y.resolve();
      });
    },
    unmount(w, H) {
      y.isUnmounted = true, y.activeBranch && h(
        y.activeBranch,
        n,
        w,
        H
      ), y.pendingBranch && h(
        y.pendingBranch,
        n,
        w,
        H
      );
    }
  };
  return y;
}
function py(e, t, n, s, r, i, o, c, l) {
  const f = t.suspense = Gu(
    t,
    s,
    n,
    e.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    r,
    i,
    o,
    c,
    true
  ), u = l(
    e,
    f.pendingBranch = t.ssContent,
    n,
    f,
    i,
    o
  );
  return f.deps === 0 && f.resolve(false, true), u;
}
function dy(e) {
  const { shapeFlag: t, children: n } = e, s = t & 32;
  e.ssContent = Ql(
    s ? n.default : n
  ), e.ssFallback = s ? Ql(n.fallback) : ye(Ee);
}
function Ql(e) {
  let t;
  if (J(e)) {
    const n = kn && e._c;
    n && (e._d = false, er()), e = e(), n && (e._d = true, t = He, Ju());
  }
  if (F(e)) {
    const n = ji(e);
    !n && e.filter((s) => s !== Vc).length > 0 && T("<Suspense> slots expect a single root node."), e = n;
  }
  return e = Ge(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter((n) => n !== e)), e;
}
function zu(e, t) {
  t && t.pendingBranch ? F(e) ? t.effects.push(...e) : t.effects.push(e) : rs(e);
}
function ns(e, t) {
  e.activeBranch = t;
  const { vnode: n, parentComponent: s } = e;
  let r = t.el;
  for (; !r && t.component; )
    t = t.component.subTree, r = t.el;
  n.el = r, s && s.subTree === n && (s.vnode.el = r, Ui(s, r));
}
function hy(e) {
  const t = e.props && e.props.suspensible;
  return t != null && t !== false;
}
var De = Symbol.for("v-fgt");
var It = Symbol.for("v-txt");
var Ee = Symbol.for("v-cmt");
var un = Symbol.for("v-stc");
var Us = [];
var He = null;
function er(e = false) {
  Us.push(He = e ? null : []);
}
function Ju() {
  Us.pop(), He = Us[Us.length - 1] || null;
}
var kn = 1;
function $o(e, t = false) {
  kn += e, e < 0 && He && t && (He.hasOnce = true);
}
function Yu(e) {
  return e.dynamicChildren = kn > 0 ? He || Yn : null, Ju(), kn > 0 && He && He.push(e), e;
}
function gy(e, t, n, s, r, i) {
  return Yu(
    $c(
      e,
      t,
      n,
      s,
      r,
      i,
      true
    )
  );
}
function ei(e, t, n, s, r) {
  return Yu(
    ye(
      e,
      t,
      n,
      s,
      r,
      true
    )
  );
}
function Rt(e) {
  return e ? e.__v_isVNode === true : false;
}
function _t(e, t) {
  if (t.shapeFlag & 6 && e.component) {
    const n = Cr.get(t.type);
    if (n && n.has(e.component))
      return e.shapeFlag &= -257, t.shapeFlag &= -513, false;
  }
  return e.type === t.type && e.key === t.key;
}
var ko;
function my(e) {
  ko = e;
}
var _y = (...e) => Zu(
  ...ko ? ko(e, Te) : e
);
var Xu = ({ key: e }) => e ?? null;
var xr = ({
  ref: e,
  ref_key: t,
  ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? X(e) || be(e) || J(e) ? { i: Te, r: e, k: t, f: !!n } : e : null);
function $c(e, t = null, n = null, s = 0, r = null, i = e === De ? 0 : 1, o = false, c = false) {
  const l = {
    __v_isVNode: true,
    __v_skip: true,
    type: e,
    props: t,
    key: t && Xu(t),
    ref: t && xr(t),
    scopeId: Ri,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: s,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Te
  };
  return c ? (Lc(l, n), i & 128 && e.normalize(l)) : n && (l.shapeFlag |= X(n) ? 8 : 16), l.key !== l.key && T("VNode created with invalid key (NaN). VNode type:", l.type), kn > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  He && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || i & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && He.push(l), l;
}
var ye = true ? _y : Zu;
function Zu(e, t = null, n = null, s = 0, r = null, i = false) {
  if ((!e || e === Vc) && (!e && T(`Invalid vnode type when creating vnode: ${e}.`), e = Ee), Rt(e)) {
    const c = ht(
      e,
      t,
      true
      /* mergeRef: true */
    );
    return n && Lc(c, n), kn > 0 && !i && He && (c.shapeFlag & 6 ? He[He.indexOf(e)] = c : He.push(c)), c.patchFlag = -2, c;
  }
  if (lp(e) && (e = e.__vccOpts), t) {
    t = Qu(t);
    let { class: c, style: l } = t;
    c && !X(c) && (t.class = Ns(c)), ie(l) && (ss(l) && !F(l) && (l = te({}, l)), t.style = vs(l));
  }
  const o = X(e) ? 1 : Qr(e) ? 128 : iu(e) ? 64 : ie(e) ? 4 : J(e) ? 2 : 0;
  return o & 4 && ss(e) && (e = Q(e), T(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e
  )), $c(
    e,
    t,
    n,
    s,
    r,
    o,
    i,
    true
  );
}
function Qu(e) {
  return e ? ss(e) || Vu(e) ? te({}, e) : e : null;
}
function ht(e, t, n = false, s = false) {
  const { props: r, ref: i, patchFlag: o, children: c, transition: l } = e, f = t ? tp(r || {}, t) : r, u = {
    __v_isVNode: true,
    __v_skip: true,
    type: e.type,
    props: f,
    key: f && Xu(f),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && i ? F(i) ? i.concat(xr(t)) : [i, xr(t)] : xr(t)
    ) : i,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: o === -1 && F(c) ? c.map(ep) : c,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== De ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && ht(e.ssContent),
    ssFallback: e.ssFallback && ht(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return l && s && qt(
    u,
    l.clone(u)
  ), u;
}
function ep(e) {
  const t = ht(e);
  return F(e.children) && (t.children = e.children.map(ep)), t;
}
function kc(e = " ", t = 0) {
  return ye(It, null, e, t);
}
function Ey(e, t) {
  const n = ye(un, null, e);
  return n.staticCount = t, n;
}
function yy(e = "", t = false) {
  return t ? (er(), ei(Ee, null, e)) : ye(Ee, null, e);
}
function Ge(e) {
  return e == null || typeof e == "boolean" ? ye(Ee) : F(e) ? ye(
    De,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : Rt(e) ? nn(e) : ye(It, null, String(e));
}
function nn(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : ht(e);
}
function Lc(e, t) {
  let n = 0;
  const { shapeFlag: s } = e;
  if (t == null)
    t = null;
  else if (F(t))
    n = 16;
  else if (typeof t == "object")
    if (s & 65) {
      const r = t.default;
      r && (r._c && (r._d = false), Lc(e, r()), r._c && (r._d = true));
      return;
    } else {
      n = 32;
      const r = t._;
      !r && !Vu(t) ? t._ctx = Te : r === 3 && Te && (Te.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else J(t) ? (t = { default: t, _ctx: Te }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [kc(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function tp(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    for (const r in s)
      if (r === "class")
        t.class !== s.class && (t.class = Ns([t.class, s.class]));
      else if (r === "style")
        t.style = vs([t.style, s.style]);
      else if (Wt(r)) {
        const i = t[r], o = s[r];
        o && i !== o && !(F(i) && i.includes(o)) && (t[r] = i ? [].concat(i, o) : o);
      } else r !== "" && (t[r] = s[r]);
  }
  return t;
}
function Qe(e, t, n, s = null) {
  dt(e, t, 7, [
    n,
    s
  ]);
}
var vy = Tu();
var Ny = 0;
function np(e, t, n) {
  const s = e.type, r = (t ? t.appContext : e.appContext) || vy, i = {
    uid: Ny++,
    vnode: e,
    type: s,
    parent: t,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new hc(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(r.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: xu(s, r),
    emitsOptions: Wu(s, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: se,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: se,
    data: se,
    props: se,
    attrs: se,
    slots: se,
    refs: se,
    setupState: se,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return true ? i.ctx = hE(i) : i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = ry.bind(null, i), e.ce && e.ce(i), i;
}
var xe = null;
var ze = () => xe || Te;
var ti;
var Lo;
{
  const e = an(), t = (n, s) => {
    let r;
    return (r = e[n]) || (r = e[n] = []), r.push(s), (i) => {
      r.length > 1 ? r.forEach((o) => o(i)) : r[0](i);
    };
  };
  ti = t(
    "__VUE_INSTANCE_SETTERS__",
    (n) => xe = n
  ), Lo = t(
    "__VUE_SSR_SETTERS__",
    (n) => os = n
  );
}
var Ln = (e) => {
  const t = xe;
  return ti(e), e.scope.on(), () => {
    e.scope.off(), ti(t);
  };
};
var Fo = () => {
  xe && xe.scope.off(), ti(null);
};
var by = Ie("slot,component");
function Ho(e, { isNativeTag: t }) {
  (by(e) || t(e)) && T(
    "Do not use built-in or reserved HTML elements as component id: " + e
  );
}
function sp(e) {
  return e.vnode.shapeFlag & 4;
}
var os = false;
function rp(e, t = false, n = false) {
  t && Lo(t);
  const { props: s, children: r } = e.vnode, i = sp(e);
  FE(e, s, i, t), YE(e, r, n || t);
  const o = i ? Oy(e, t) : void 0;
  return t && Lo(false), o;
}
function Oy(e, t) {
  var n;
  const s = e.type;
  if (true) {
    if (s.name && Ho(s.name, e.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        Ho(i[o], e.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        su(i[o]);
    }
    s.compilerOptions && Fc() && T(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, Fs), gE(e);
  const { setup: r } = s;
  if (r) {
    Ot();
    const i = e.setupContext = r.length > 1 ? cp(e) : null, o = Ln(e), c = Un(
      r,
      e,
      0,
      [
        true ? Et(e.props) : e.props,
        i
      ]
    ), l = vi(c);
    if (St(), o(), (l || e.sp) && !fn(e) && wc(e), l) {
      if (c.then(Fo, Fo), t)
        return c.then((f) => {
          jo(e, f, t);
        }).catch((f) => {
          gn(f, e, 0);
        });
      if (e.asyncDep = c, !e.suspense) {
        const f = (n = s.name) != null ? n : "Anonymous";
        T(
          `Component <${f}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      jo(e, c, t);
  } else
    op(e, t);
}
function jo(e, t, n) {
  J(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ie(t) ? (Rt(t) && T(
    "setup() should not return VNodes directly - return a render function instead."
  ), e.devtoolsRawSetupState = t, e.setupState = Ec(t), mE(e)) : t !== void 0 && T(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), op(e, n);
}
var Bs;
var Uo;
function ip(e) {
  Bs = e, Uo = (t) => {
    t.render._rc && (t.withProxy = new Proxy(t.ctx, dE));
  };
}
var Fc = () => !Bs;
function op(e, t, n) {
  const s = e.type;
  if (!e.render) {
    if (!t && Bs && !s.render) {
      const r = s.template || __VUE_OPTIONS_API__ && Pc(e).template;
      if (r) {
        $t(e, "compile");
        const { isCustomElement: i, compilerOptions: o } = e.appContext.config, { delimiters: c, compilerOptions: l } = s, f = te(
          te(
            {
              isCustomElement: i,
              delimiters: c
            },
            o
          ),
          l
        );
        s.render = Bs(r, f), kt(e, "compile");
      }
    }
    e.render = s.render || me, Uo && Uo(e);
  }
  if (__VUE_OPTIONS_API__) {
    const r = Ln(e);
    Ot();
    try {
      xE(e);
    } finally {
      St(), r();
    }
  }
  !s.render && e.render === me && !t && (!Bs && s.template ? T(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : T("Component is missing template or render function: ", s));
}
var ea = true ? {
  get(e, t) {
    return Zr(), Ve(e, "get", ""), e[t];
  },
  set() {
    return T("setupContext.attrs is readonly."), false;
  },
  deleteProperty() {
    return T("setupContext.attrs is readonly."), false;
  }
} : {
  get(e, t) {
    return Ve(e, "get", ""), e[t];
  }
};
function Sy(e) {
  return new Proxy(e.slots, {
    get(t, n) {
      return Ve(e, "get", "$slots"), t[n];
    }
  });
}
function cp(e) {
  const t = (n) => {
    if (e.exposed && T("expose() should be called only once per setup()."), n != null) {
      let s = typeof n;
      s === "object" && (F(n) ? s = "array" : be(n) && (s = "ref")), s !== "object" && T(
        `expose() should be passed a plain object, received ${s}.`
      );
    }
    e.exposed = n || {};
  };
  if (true) {
    let n, s;
    return Object.freeze({
      get attrs() {
        return n || (n = new Proxy(e.attrs, ea));
      },
      get slots() {
        return s || (s = Sy(e));
      },
      get emit() {
        return (r, ...i) => e.emit(r, ...i);
      },
      expose: t
    });
  } else
    return {
      attrs: new Proxy(e.attrs, ea),
      slots: e.slots,
      emit: e.emit,
      expose: t
    };
}
function ur(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Ec(Kf(e.exposed)), {
    get(t, n) {
      if (n in t)
        return t[n];
      if (n in An)
        return An[n](e);
    },
    has(t, n) {
      return n in t || n in An;
    }
  })) : e.proxy;
}
var Ty = /(?:^|[-_])(\w)/g;
var Dy = (e) => e.replace(Ty, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function cs(e, t = true) {
  return J(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function Bi(e, t, n = false) {
  let s = cs(t);
  if (!s && t.__file) {
    const r = t.__file.match(/([^/\\]+)\.\w+$/);
    r && (s = r[1]);
  }
  if (!s && e && e.parent) {
    const r = (i) => {
      for (const o in i)
        if (i[o] === t)
          return o;
    };
    s = r(
      e.components || e.parent.type.components
    ) || r(e.appContext.components);
  }
  return s ? Dy(s) : n ? "App" : "Anonymous";
}
function lp(e) {
  return J(e) && "__vccOpts" in e;
}
var ap = (e, t) => {
  const n = l_(e, t, os);
  if (true) {
    const s = ze();
    s && s.appContext.config.warnRecursiveComputed && (n._warnRecursive = true);
  }
  return n;
};
function fp(e, t, n) {
  const s = arguments.length;
  return s === 2 ? ie(t) && !F(t) ? Rt(t) ? ye(e, null, [t]) : ye(e, t) : ye(e, null, t) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && Rt(n) && (n = [n]), ye(e, t, n));
}
function up() {
  if (typeof window > "u")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, s = { style: "color:#eb2f96" }, r = {
    __vue_custom_formatter: true,
    header(a) {
      if (!ie(a))
        return null;
      if (a.__isVue)
        return ["div", e, "VueInstance"];
      if (be(a)) {
        Ot();
        const p = a.value;
        return St(), [
          "div",
          {},
          ["span", e, u(a)],
          "<",
          c(p),
          ">"
        ];
      } else {
        if (Bt(a))
          return [
            "div",
            {},
            ["span", e, je(a) ? "ShallowReactive" : "Reactive"],
            "<",
            c(a),
            `>${Tt(a) ? " (readonly)" : ""}`
          ];
        if (Tt(a))
          return [
            "div",
            {},
            ["span", e, je(a) ? "ShallowReadonly" : "Readonly"],
            "<",
            c(a),
            ">"
          ];
      }
      return null;
    },
    hasBody(a) {
      return a && a.__isVue;
    },
    body(a) {
      if (a && a.__isVue)
        return [
          "div",
          {},
          ...i(a.$)
        ];
    }
  };
  function i(a) {
    const p = [];
    a.type.props && a.props && p.push(o("props", Q(a.props))), a.setupState !== se && p.push(o("setup", a.setupState)), a.data !== se && p.push(o("data", Q(a.data)));
    const h = l(a, "computed");
    h && p.push(o("computed", h));
    const _ = l(a, "inject");
    return _ && p.push(o("injected", _)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: s.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: a }]
    ]), p;
  }
  function o(a, p) {
    return p = te({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        a
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((h) => [
          "div",
          {},
          ["span", s, h + ": "],
          c(p[h], false)
        ])
      ]
    ] : ["span", {}];
  }
  function c(a, p = true) {
    return typeof a == "number" ? ["span", t, a] : typeof a == "string" ? ["span", n, JSON.stringify(a)] : typeof a == "boolean" ? ["span", s, a] : ie(a) ? ["object", { object: p ? Q(a) : a }] : ["span", n, String(a)];
  }
  function l(a, p) {
    const h = a.type;
    if (J(h))
      return;
    const _ = {};
    for (const E in a.ctx)
      f(h, E, p) && (_[E] = a.ctx[E]);
    return _;
  }
  function f(a, p, h) {
    const _ = a[h];
    if (F(_) && _.includes(p) || ie(_) && p in _ || a.extends && f(a.extends, p, h) || a.mixins && a.mixins.some((E) => f(E, p, h)))
      return true;
  }
  function u(a) {
    return je(a) ? "ShallowRef" : a.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(r) : window.devtoolsFormatters = [r];
}
function wy(e, t, n, s) {
  const r = n[s];
  if (r && pp(r, e))
    return r;
  const i = t();
  return i.memo = e.slice(), i.cacheIndex = s, n[s] = i;
}
function pp(e, t) {
  const n = e.memo;
  if (n.length != t.length)
    return false;
  for (let s = 0; s < n.length; s++)
    if (We(n[s], t[s]))
      return false;
  return kn > 0 && He && He.push(e), true;
}
var Bo = "3.5.18";
var Ne = true ? T : me;
var Cy = xi;
var Vy = ("development", mt);
var Ay = ("development", Nc);
var xy = {
  createComponentInstance: np,
  setupComponent: rp,
  renderComponentRoot: Ar,
  setCurrentRenderingInstance: Xs,
  isVNode: Rt,
  normalizeVNode: Ge,
  getComponentPublicInstance: ur,
  ensureValidVNode: xc,
  pushWarningContext: Xn,
  popWarningContext: Zn
};
var Iy = xy;
var Py = null;
var Ry = null;
var My = null;
var Ko;
var ta = typeof window < "u" && window.trustedTypes;
if (ta)
  try {
    Ko = ta.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch (e) {
    Ne(`Error creating trusted types policy: ${e}`);
  }
var dp = Ko ? (e) => Ko.createHTML(e) : (e) => e;
var $y = "http://www.w3.org/2000/svg";
var ky = "http://www.w3.org/1998/Math/MathML";
var Ft = typeof document < "u" ? document : null;
var na = Ft && Ft.createElement("template");
var Ly = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, n, s) => {
    const r = t === "svg" ? Ft.createElementNS($y, e) : t === "mathml" ? Ft.createElementNS(ky, e) : n ? Ft.createElement(e, { is: n }) : Ft.createElement(e);
    return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r;
  },
  createText: (e) => Ft.createTextNode(e),
  createComment: (e) => Ft.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Ft.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, n, s, r, i) {
    const o = n ? n.previousSibling : t.lastChild;
    if (r && (r === i || r.nextSibling))
      for (; t.insertBefore(r.cloneNode(true), n), !(r === i || !(r = r.nextSibling)); )
        ;
    else {
      na.innerHTML = dp(
        s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e
      );
      const c = na.content;
      if (s === "svg" || s === "mathml") {
        const l = c.firstChild;
        for (; l.firstChild; )
          c.appendChild(l.firstChild);
        c.removeChild(l);
      }
      t.insertBefore(c, n);
    }
    return [
      // first
      o ? o.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
};
var Yt = "transition";
var Cs = "animation";
var ls = Symbol("_vtc");
var hp = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var gp = te(
  {},
  Tc,
  hp
);
var Fy = (e) => (e.displayName = "Transition", e.props = gp, e);
var Hy = Fy(
  (e, { slots: t }) => fp(fu, mp(e), t)
);
var En = (e, t = []) => {
  F(e) ? e.forEach((n) => n(...t)) : e && e(...t);
};
var sa = (e) => e ? F(e) ? e.some((t) => t.length > 1) : e.length > 1 : false;
function mp(e) {
  const t = {};
  for (const b in e)
    b in hp || (t[b] = e[b]);
  if (e.css === false)
    return t;
  const {
    name: n = "v",
    type: s,
    duration: r,
    enterFromClass: i = `${n}-enter-from`,
    enterActiveClass: o = `${n}-enter-active`,
    enterToClass: c = `${n}-enter-to`,
    appearFromClass: l = i,
    appearActiveClass: f = o,
    appearToClass: u = c,
    leaveFromClass: a = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: h = `${n}-leave-to`
  } = e, _ = jy(r), E = _ && _[0], M = _ && _[1], {
    onBeforeEnter: C,
    onEnter: D,
    onEnterCancelled: g,
    onLeave: N,
    onLeaveCancelled: y,
    onBeforeAppear: w = C,
    onAppear: H = D,
    onAppearCancelled: V = g
  } = t, v = (b, L, W, q) => {
    b._enterCancelled = q, Zt(b, L ? u : c), Zt(b, L ? f : o), W && W();
  }, S = (b, L) => {
    b._isLeaving = false, Zt(b, a), Zt(b, h), Zt(b, p), L && L();
  }, R = (b) => (L, W) => {
    const q = b ? H : D, K = () => v(L, b, W);
    En(q, [L, K]), ra(() => {
      Zt(L, b ? l : i), wt(L, b ? u : c), sa(q) || ia(L, s, E, K);
    });
  };
  return te(t, {
    onBeforeEnter(b) {
      En(C, [b]), wt(b, i), wt(b, o);
    },
    onBeforeAppear(b) {
      En(w, [b]), wt(b, l), wt(b, f);
    },
    onEnter: R(false),
    onAppear: R(true),
    onLeave(b, L) {
      b._isLeaving = true;
      const W = () => S(b, L);
      wt(b, a), b._enterCancelled ? (wt(b, p), Wo()) : (Wo(), wt(b, p)), ra(() => {
        b._isLeaving && (Zt(b, a), wt(b, h), sa(N) || ia(b, s, M, W));
      }), En(N, [b, W]);
    },
    onEnterCancelled(b) {
      v(b, false, void 0, true), En(g, [b]);
    },
    onAppearCancelled(b) {
      v(b, true, void 0, true), En(V, [b]);
    },
    onLeaveCancelled(b) {
      S(b), En(y, [b]);
    }
  });
}
function jy(e) {
  if (e == null)
    return null;
  if (ie(e))
    return [uo(e.enter), uo(e.leave)];
  {
    const t = uo(e);
    return [t, t];
  }
}
function uo(e) {
  const t = jr(e);
  return yc(t, "<transition> explicit duration"), t;
}
function wt(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[ls] || (e[ls] = /* @__PURE__ */ new Set())).add(t);
}
function Zt(e, t) {
  t.split(/\s+/).forEach((s) => s && e.classList.remove(s));
  const n = e[ls];
  n && (n.delete(t), n.size || (e[ls] = void 0));
}
function ra(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
var Uy = 0;
function ia(e, t, n, s) {
  const r = e._endId = ++Uy, i = () => {
    r === e._endId && s();
  };
  if (n != null)
    return setTimeout(i, n);
  const { type: o, timeout: c, propCount: l } = _p(e, t);
  if (!o)
    return s();
  const f = o + "end";
  let u = 0;
  const a = () => {
    e.removeEventListener(f, p), i();
  }, p = (h) => {
    h.target === e && ++u >= l && a();
  };
  setTimeout(() => {
    u < l && a();
  }, c + 1), e.addEventListener(f, p);
}
function _p(e, t) {
  const n = window.getComputedStyle(e), s = (_) => (n[_] || "").split(", "), r = s(`${Yt}Delay`), i = s(`${Yt}Duration`), o = oa(r, i), c = s(`${Cs}Delay`), l = s(`${Cs}Duration`), f = oa(c, l);
  let u = null, a = 0, p = 0;
  t === Yt ? o > 0 && (u = Yt, a = o, p = i.length) : t === Cs ? f > 0 && (u = Cs, a = f, p = l.length) : (a = Math.max(o, f), u = a > 0 ? o > f ? Yt : Cs : null, p = u ? u === Yt ? i.length : l.length : 0);
  const h = u === Yt && /\b(transform|all)(,|$)/.test(
    s(`${Yt}Property`).toString()
  );
  return {
    type: u,
    timeout: a,
    propCount: p,
    hasTransform: h
  };
}
function oa(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, s) => ca(n) + ca(e[s])));
}
function ca(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function Wo() {
  return document.body.offsetHeight;
}
function By(e, t, n) {
  const s = e[ls];
  s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
}
var ni = Symbol("_vod");
var Ep = Symbol("_vsh");
var Hc = {
  beforeMount(e, { value: t }, { transition: n }) {
    e[ni] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Vs(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: s }) {
    !t != !n && (s ? t ? (s.beforeEnter(e), Vs(e, true), s.enter(e)) : s.leave(e, () => {
      Vs(e, false);
    }) : Vs(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Vs(e, t);
  }
};
Hc.name = "show";
function Vs(e, t) {
  e.style.display = t ? e[ni] : "none", e[Ep] = !t;
}
function Ky() {
  Hc.getSSRProps = ({ value: e }) => {
    if (!e)
      return { style: { display: "none" } };
  };
}
var yp = Symbol(true ? "CSS_VAR_TEXT" : "");
function Wy(e) {
  const t = ze();
  if (!t) {
    Ne("useCssVars is called without current active component instance.");
    return;
  }
  const n = t.ut = (r = e(t.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${t.uid}"]`)
    ).forEach((i) => si(i, r));
  };
  t.getCssVars = () => e(t.proxy);
  const s = () => {
    const r = e(t.proxy);
    t.ce ? si(t.ce, r) : qo(t.subTree, r), n(r);
  };
  Cc(() => {
    rs(s);
  }), ar(() => {
    ts(s, me, { flush: "post" });
    const r = new MutationObserver(s);
    r.observe(t.subTree.el.parentNode, { childList: true }), Fi(() => r.disconnect());
  });
}
function qo(e, t) {
  if (e.shapeFlag & 128) {
    const n = e.suspense;
    e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
      qo(n.activeBranch, t);
    });
  }
  for (; e.component; )
    e = e.component.subTree;
  if (e.shapeFlag & 1 && e.el)
    si(e.el, t);
  else if (e.type === De)
    e.children.forEach((n) => qo(n, t));
  else if (e.type === un) {
    let { el: n, anchor: s } = e;
    for (; n && (si(n, t), n !== s); )
      n = n.nextSibling;
  }
}
function si(e, t) {
  if (e.nodeType === 1) {
    const n = e.style;
    let s = "";
    for (const r in t) {
      const i = Df(t[r]);
      n.setProperty(`--${r}`, i), s += `--${r}: ${i};`;
    }
    n[yp] = s;
  }
}
var qy = /(^|;)\s*display\s*:/;
function Gy(e, t, n) {
  const s = e.style, r = X(n);
  let i = false;
  if (n && !r) {
    if (t)
      if (X(t))
        for (const o of t.split(";")) {
          const c = o.slice(0, o.indexOf(":")).trim();
          n[c] == null && Ir(s, c, "");
        }
      else
        for (const o in t)
          n[o] == null && Ir(s, o, "");
    for (const o in n)
      o === "display" && (i = true), Ir(s, o, n[o]);
  } else if (r) {
    if (t !== n) {
      const o = s[yp];
      o && (n += ";" + o), s.cssText = n, i = qy.test(n);
    }
  } else t && e.removeAttribute("style");
  ni in e && (e[ni] = i ? s.display : "", e[Ep] && (s.display = "none"));
}
var zy = /[^\\];\s*$/;
var la = /\s*!important$/;
function Ir(e, t, n) {
  if (F(n))
    n.forEach((s) => Ir(e, t, s));
  else if (n == null && (n = ""), zy.test(n) && Ne(
    `Unexpected semicolon at the end of '${t}' style value: '${n}'`
  ), t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const s = Jy(e, t);
    la.test(n) ? e.setProperty(
      Fe(s),
      n.replace(la, ""),
      "important"
    ) : e[s] = n;
  }
}
var aa = ["Webkit", "Moz", "ms"];
var po = {};
function Jy(e, t) {
  const n = po[t];
  if (n)
    return n;
  let s = de(t);
  if (s !== "filter" && s in e)
    return po[t] = s;
  s = Pt(s);
  for (let r = 0; r < aa.length; r++) {
    const i = aa[r] + s;
    if (i in e)
      return po[t] = i;
  }
  return t;
}
var fa = "http://www.w3.org/1999/xlink";
function ua(e, t, n, s, r, i = bm(t)) {
  s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(fa, t.slice(6, t.length)) : e.setAttributeNS(fa, t, n) : n == null || i && !dc(n) ? e.removeAttribute(t) : e.setAttribute(
    t,
    i ? "" : nt(n) ? String(n) : n
  );
}
function pa(e, t, n, s, r) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? dp(n) : n);
    return;
  }
  const i = e.tagName;
  if (t === "value" && i !== "PROGRESS" && // custom elements may use _value internally
  !i.includes("-")) {
    const c = i === "OPTION" ? e.getAttribute("value") || "" : e.value, l = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(n);
    (c !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n;
    return;
  }
  let o = false;
  if (n === "" || n == null) {
    const c = typeof e[t];
    c === "boolean" ? n = dc(n) : n == null && c === "string" ? (n = "", o = true) : c === "number" && (n = 0, o = true);
  }
  try {
    e[t] = n;
  } catch (c) {
    !o && Ne(
      `Failed setting prop "${t}" on <${i.toLowerCase()}>: value ${n} is invalid.`,
      c
    );
  }
  o && e.removeAttribute(r || t);
}
function jt(e, t, n, s) {
  e.addEventListener(t, n, s);
}
function Yy(e, t, n, s) {
  e.removeEventListener(t, n, s);
}
var da = Symbol("_vei");
function Xy(e, t, n, s, r = null) {
  const i = e[da] || (e[da] = {}), o = i[t];
  if (s && o)
    o.value = true ? ga(s, t) : s;
  else {
    const [c, l] = Zy(t);
    if (s) {
      const f = i[t] = tv(
        true ? ga(s, t) : s,
        r
      );
      jt(e, c, f, l);
    } else o && (Yy(e, c, o, l), i[t] = void 0);
  }
}
var ha = /(?:Once|Passive|Capture)$/;
function Zy(e) {
  let t;
  if (ha.test(e)) {
    t = {};
    let s;
    for (; s = e.match(ha); )
      e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = true;
  }
  return [e[2] === ":" ? e.slice(3) : Fe(e.slice(2)), t];
}
var ho = 0;
var Qy = Promise.resolve();
var ev = () => ho || (Qy.then(() => ho = 0), ho = Date.now());
function tv(e, t) {
  const n = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= n.attached)
      return;
    dt(
      nv(s, n.value),
      t,
      5,
      [s]
    );
  };
  return n.value = e, n.attached = ev(), n;
}
function ga(e, t) {
  return J(e) || F(e) ? e : (Ne(
    `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`
  ), me);
}
function nv(e, t) {
  if (F(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = true;
    }, t.map(
      (s) => (r) => !r._stopped && s && s(r)
    );
  } else
    return t;
}
var ma = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123;
var sv = (e, t, n, s, r, i) => {
  const o = r === "svg";
  t === "class" ? By(e, s, o) : t === "style" ? Gy(e, n, s) : Wt(t) ? Fr(t) || Xy(e, t, n, s, i) : (t[0] === "." ? (t = t.slice(1), true) : t[0] === "^" ? (t = t.slice(1), false) : rv(e, t, s, o)) ? (pa(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && ua(e, t, s, o, i, t !== "value")) : (
    /* #11081 force set props for possible async custom element */
    e._isVueCE && (/[A-Z]/.test(t) || !X(s)) ? pa(e, de(t), s, i, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), ua(e, t, s, o))
  );
};
function rv(e, t, n, s) {
  if (s)
    return !!(t === "innerHTML" || t === "textContent" || t in e && ma(t) && J(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return false;
  if (t === "width" || t === "height") {
    const r = e.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return false;
  }
  return ma(t) && X(n) ? false : t in e;
}
var _a = {};
function vp(e, t, n) {
  const s = Dc(e, t);
  Ni(s) && te(s, t);
  class r extends Ki {
    constructor(o) {
      super(s, o, n);
    }
  }
  return r.def = s, r;
}
var iv = (e, t) => vp(e, t, xp);
var ov = typeof HTMLElement < "u" ? HTMLElement : class {
};
var Ki = class _Ki extends ov {
  constructor(t, n = {}, s = zo) {
    super(), this._def = t, this._props = n, this._createApp = s, this._isVueCE = true, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = false, this._resolved = false, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && s !== zo ? this._root = this.shadowRoot : (this.shadowRoot && Ne(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), t.shadowRoot !== false ? (this.attachShadow({ mode: "open" }), this._root = this.shadowRoot) : this._root = this);
  }
  connectedCallback() {
    if (!this.isConnected) return;
    !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = true;
    let t = this;
    for (; t = t && (t.parentNode || t.host); )
      if (t instanceof _Ki) {
        this._parent = t;
        break;
      }
    this._instance || (this._resolved ? this._mount(this._def) : t && t._pendingResolve ? this._pendingResolve = t._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(t = this._parent) {
    t && (this._instance.parent = t._instance, this._inheritParentContext(t));
  }
  _inheritParentContext(t = this._parent) {
    t && this._app && Object.setPrototypeOf(
      this._app._context.provides,
      t._instance.provides
    );
  }
  disconnectedCallback() {
    this._connected = false, Ii(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve)
      return;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    this._ob = new MutationObserver((s) => {
      for (const r of s)
        this._setAttr(r.attributeName);
    }), this._ob.observe(this, { attributes: true });
    const t = (s, r = false) => {
      this._resolved = true, this._pendingResolve = void 0;
      const { props: i, styles: o } = s;
      let c;
      if (i && !F(i))
        for (const l in i) {
          const f = i[l];
          (f === Number || f && f.type === Number) && (l in this._props && (this._props[l] = jr(this._props[l])), (c || (c = /* @__PURE__ */ Object.create(null)))[de(l)] = true);
        }
      this._numberProps = c, this._resolveProps(s), this.shadowRoot ? this._applyStyles(o) : o && Ne(
        "Custom element style injection is not supported when using shadowRoot: false"
      ), this._mount(s);
    }, n = this._def.__asyncLoader;
    n ? this._pendingResolve = n().then((s) => {
      s.configureApp = this._def.configureApp, t(this._def = s, true);
    }) : t(this._def);
  }
  _mount(t) {
    !t.name && (t.name = "VueElement"), this._app = this._createApp(t), this._inheritParentContext(), t.configureApp && t.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    const n = this._instance && this._instance.exposed;
    if (n)
      for (const s in n)
        oe(this, s) ? Ne(`Exposed property "${s}" already exists on custom element.`) : Object.defineProperty(this, s, {
          // unwrap ref to be consistent with public instance behavior
          get: () => Ai(n[s])
        });
  }
  _resolveProps(t) {
    const { props: n } = t, s = F(n) ? n : Object.keys(n || {});
    for (const r of Object.keys(this))
      r[0] !== "_" && s.includes(r) && this._setProp(r, this[r]);
    for (const r of s.map(de))
      Object.defineProperty(this, r, {
        get() {
          return this._getProp(r);
        },
        set(i) {
          this._setProp(r, i, true, true);
        }
      });
  }
  _setAttr(t) {
    if (t.startsWith("data-v-")) return;
    const n = this.hasAttribute(t);
    let s = n ? this.getAttribute(t) : _a;
    const r = de(t);
    n && this._numberProps && this._numberProps[r] && (s = jr(s)), this._setProp(r, s, false, true);
  }
  /**
   * @internal
   */
  _getProp(t) {
    return this._props[t];
  }
  /**
   * @internal
   */
  _setProp(t, n, s = true, r = false) {
    if (n !== this._props[t] && (n === _a ? delete this._props[t] : (this._props[t] = n, t === "key" && this._app && (this._app._ceVNode.key = n)), r && this._instance && this._update(), s)) {
      const i = this._ob;
      i && i.disconnect(), n === true ? this.setAttribute(Fe(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Fe(t), n + "") : n || this.removeAttribute(Fe(t)), i && i.observe(this, { attributes: true });
    }
  }
  _update() {
    const t = this._createVNode();
    this._app && (t.appContext = this._app._context), Ap(t, this._root);
  }
  _createVNode() {
    const t = {};
    this.shadowRoot || (t.onVnodeMounted = t.onVnodeUpdated = this._renderSlots.bind(this));
    const n = ye(this._def, te(t, this._props));
    return this._instance || (n.ce = (s) => {
      this._instance = s, s.ce = this, s.isCE = true, s.ceReload = (i) => {
        this._styles && (this._styles.forEach((o) => this._root.removeChild(o)), this._styles.length = 0), this._applyStyles(i), this._instance = null, this._update();
      };
      const r = (i, o) => {
        this.dispatchEvent(
          new CustomEvent(
            i,
            Ni(o[0]) ? te({ detail: o }, o[0]) : { detail: o }
          )
        );
      };
      s.emit = (i, ...o) => {
        r(i, o), Fe(i) !== i && r(Fe(i), o);
      }, this._setParent();
    }), n;
  }
  _applyStyles(t, n) {
    if (!t) return;
    if (n) {
      if (n === this._def || this._styleChildren.has(n))
        return;
      this._styleChildren.add(n);
    }
    const s = this._nonce;
    for (let r = t.length - 1; r >= 0; r--) {
      const i = document.createElement("style");
      if (s && i.setAttribute("nonce", s), i.textContent = t[r], this.shadowRoot.prepend(i), true)
        if (n) {
          if (n.__hmrId) {
            this._childStyles || (this._childStyles = /* @__PURE__ */ new Map());
            let o = this._childStyles.get(n.__hmrId);
            o || this._childStyles.set(n.__hmrId, o = []), o.push(i);
          }
        } else
          (this._styles || (this._styles = [])).push(i);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const t = this._slots = {};
    let n;
    for (; n = this.firstChild; ) {
      const s = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (t[s] || (t[s] = [])).push(n), this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const t = (this._teleportTarget || this).querySelectorAll("slot"), n = this._instance.type.__scopeId;
    for (let s = 0; s < t.length; s++) {
      const r = t[s], i = r.getAttribute("name") || "default", o = this._slots[i], c = r.parentNode;
      if (o)
        for (const l of o) {
          if (n && l.nodeType === 1) {
            const f = n + "-s", u = document.createTreeWalker(l, 1);
            l.setAttribute(f, "");
            let a;
            for (; a = u.nextNode(); )
              a.setAttribute(f, "");
          }
          c.insertBefore(l, r);
        }
      else
        for (; r.firstChild; ) c.insertBefore(r.firstChild, r);
      c.removeChild(r);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(t) {
    this._applyStyles(t.styles, t);
  }
  /**
   * @internal
   */
  _removeChildStyle(t) {
    if (this._styleChildren.delete(t), this._childStyles && t.__hmrId) {
      const n = this._childStyles.get(t.__hmrId);
      n && (n.forEach((s) => this._root.removeChild(s)), n.length = 0);
    }
  }
};
function Go(e) {
  const t = ze(), n = t && t.ce;
  return n || (Ne(
    t ? `${e || "useHost"} can only be used in components defined via defineCustomElement.` : `${e || "useHost"} called without an active component instance.`
  ), null);
}
function cv() {
  const e = true ? Go("useShadowRoot") : Go();
  return e && e.shadowRoot;
}
function lv(e = "$style") {
  {
    const t = ze();
    if (!t)
      return Ne("useCssModule must be called inside setup()"), se;
    const n = t.type.__cssModules;
    if (!n)
      return Ne("Current instance does not have CSS modules injected."), se;
    const s = n[e];
    return s || (Ne(`Current instance does not have CSS module named "${e}".`), se);
  }
}
var Np = /* @__PURE__ */ new WeakMap();
var bp = /* @__PURE__ */ new WeakMap();
var ri = Symbol("_moveCb");
var Ea = Symbol("_enterCb");
var av = (e) => (delete e.props.mode, e);
var fv = av({
  name: "TransitionGroup",
  props: te({}, gp, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: t }) {
    const n = ze(), s = Sc();
    let r, i;
    return ki(() => {
      if (!r.length)
        return;
      const o = e.moveClass || `${e.name || "v"}-move`;
      if (!gv(
        r[0].el,
        n.vnode.el,
        o
      )) {
        r = [];
        return;
      }
      r.forEach(pv), r.forEach(dv);
      const c = r.filter(hv);
      Wo(), c.forEach((l) => {
        const f = l.el, u = f.style;
        wt(f, o), u.transform = u.webkitTransform = u.transitionDuration = "";
        const a = f[ri] = (p) => {
          p && p.target !== f || (!p || /transform$/.test(p.propertyName)) && (f.removeEventListener("transitionend", a), f[ri] = null, Zt(f, o));
        };
        f.addEventListener("transitionend", a);
      }), r = [];
    }), () => {
      const o = Q(e), c = mp(o);
      let l = o.tag || De;
      if (r = [], i)
        for (let f = 0; f < i.length; f++) {
          const u = i[f];
          u.el && u.el instanceof Element && (r.push(u), qt(
            u,
            is(
              u,
              c,
              s,
              n
            )
          ), Np.set(
            u,
            u.el.getBoundingClientRect()
          ));
        }
      i = t.default ? Mi(t.default()) : [];
      for (let f = 0; f < i.length; f++) {
        const u = i[f];
        u.key != null ? qt(
          u,
          is(u, c, s, n)
        ) : u.type !== It && Ne("<TransitionGroup> children must be keyed.");
      }
      return ye(l, null, i);
    };
  }
});
var uv = fv;
function pv(e) {
  const t = e.el;
  t[ri] && t[ri](), t[Ea] && t[Ea]();
}
function dv(e) {
  bp.set(e, e.el.getBoundingClientRect());
}
function hv(e) {
  const t = Np.get(e), n = bp.get(e), s = t.left - n.left, r = t.top - n.top;
  if (s || r) {
    const i = e.el.style;
    return i.transform = i.webkitTransform = `translate(${s}px,${r}px)`, i.transitionDuration = "0s", e;
  }
}
function gv(e, t, n) {
  const s = e.cloneNode(), r = e[ls];
  r && r.forEach((c) => {
    c.split(/\s+/).forEach((l) => l && s.classList.remove(l));
  }), n.split(/\s+/).forEach((c) => c && s.classList.add(c)), s.style.display = "none";
  const i = t.nodeType === 1 ? t : t.parentNode;
  i.appendChild(s);
  const { hasTransform: o } = _p(s);
  return i.removeChild(s), o;
}
var hn = (e) => {
  const t = e.props["onUpdate:modelValue"] || false;
  return F(t) ? (n) => rn(t, n) : t;
};
function mv(e) {
  e.target.composing = true;
}
function ya(e) {
  const t = e.target;
  t.composing && (t.composing = false, t.dispatchEvent(new Event("input")));
}
var ut = Symbol("_assign");
var ii = {
  created(e, { modifiers: { lazy: t, trim: n, number: s } }, r) {
    e[ut] = hn(r);
    const i = s || r.props && r.props.type === "number";
    jt(e, t ? "change" : "input", (o) => {
      if (o.target.composing) return;
      let c = e.value;
      n && (c = c.trim()), i && (c = Hr(c)), e[ut](c);
    }), n && jt(e, "change", () => {
      e.value = e.value.trim();
    }), t || (jt(e, "compositionstart", mv), jt(e, "compositionend", ya), jt(e, "change", ya));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: s, trim: r, number: i } }, o) {
    if (e[ut] = hn(o), e.composing) return;
    const c = (i || e.type === "number") && !/^0\d/.test(e.value) ? Hr(e.value) : e.value, l = t ?? "";
    c !== l && (document.activeElement === e && e.type !== "range" && (s && t === n || r && e.value.trim() === l) || (e.value = l));
  }
};
var jc = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(e, t, n) {
    e[ut] = hn(n), jt(e, "change", () => {
      const s = e._modelValue, r = as(e), i = e.checked, o = e[ut];
      if (F(s)) {
        const c = Oi(s, r), l = c !== -1;
        if (i && !l)
          o(s.concat(r));
        else if (!i && l) {
          const f = [...s];
          f.splice(c, 1), o(f);
        }
      } else if (jn(s)) {
        const c = new Set(s);
        i ? c.add(r) : c.delete(r), o(c);
      } else
        o(Sp(e, i));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: va,
  beforeUpdate(e, t, n) {
    e[ut] = hn(n), va(e, t, n);
  }
};
function va(e, { value: t, oldValue: n }, s) {
  e._modelValue = t;
  let r;
  if (F(t))
    r = Oi(t, s.props.value) > -1;
  else if (jn(t))
    r = t.has(s.props.value);
  else {
    if (t === n) return;
    r = dn(t, Sp(e, true));
  }
  e.checked !== r && (e.checked = r);
}
var Uc = {
  created(e, { value: t }, n) {
    e.checked = dn(t, n.props.value), e[ut] = hn(n), jt(e, "change", () => {
      e[ut](as(e));
    });
  },
  beforeUpdate(e, { value: t, oldValue: n }, s) {
    e[ut] = hn(s), t !== n && (e.checked = dn(t, s.props.value));
  }
};
var Op = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(e, { value: t, modifiers: { number: n } }, s) {
    const r = jn(t);
    jt(e, "change", () => {
      const i = Array.prototype.filter.call(e.options, (o) => o.selected).map(
        (o) => n ? Hr(as(o)) : as(o)
      );
      e[ut](
        e.multiple ? r ? new Set(i) : i : i[0]
      ), e._assigning = true, Ii(() => {
        e._assigning = false;
      });
    }), e[ut] = hn(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: t }) {
    Na(e, t);
  },
  beforeUpdate(e, t, n) {
    e[ut] = hn(n);
  },
  updated(e, { value: t }) {
    e._assigning || Na(e, t);
  }
};
function Na(e, t) {
  const n = e.multiple, s = F(t);
  if (n && !s && !jn(t)) {
    Ne(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(t).slice(8, -1)}.`
    );
    return;
  }
  for (let r = 0, i = e.options.length; r < i; r++) {
    const o = e.options[r], c = as(o);
    if (n)
      if (s) {
        const l = typeof c;
        l === "string" || l === "number" ? o.selected = t.some((f) => String(f) === String(c)) : o.selected = Oi(t, c) > -1;
      } else
        o.selected = t.has(c);
    else if (dn(as(o), t)) {
      e.selectedIndex !== r && (e.selectedIndex = r);
      return;
    }
  }
  !n && e.selectedIndex !== -1 && (e.selectedIndex = -1);
}
function as(e) {
  return "_value" in e ? e._value : e.value;
}
function Sp(e, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t;
}
var Tp = {
  created(e, t, n) {
    Or(e, t, n, null, "created");
  },
  mounted(e, t, n) {
    Or(e, t, n, null, "mounted");
  },
  beforeUpdate(e, t, n, s) {
    Or(e, t, n, s, "beforeUpdate");
  },
  updated(e, t, n, s) {
    Or(e, t, n, s, "updated");
  }
};
function Dp(e, t) {
  switch (e) {
    case "SELECT":
      return Op;
    case "TEXTAREA":
      return ii;
    default:
      switch (t) {
        case "checkbox":
          return jc;
        case "radio":
          return Uc;
        default:
          return ii;
      }
  }
}
function Or(e, t, n, s, r) {
  const o = Dp(
    e.tagName,
    n.props && n.props.type
  )[r];
  o && o(e, t, n, s);
}
function _v() {
  ii.getSSRProps = ({ value: e }) => ({ value: e }), Uc.getSSRProps = ({ value: e }, t) => {
    if (t.props && dn(t.props.value, e))
      return { checked: true };
  }, jc.getSSRProps = ({ value: e }, t) => {
    if (F(e)) {
      if (t.props && Oi(e, t.props.value) > -1)
        return { checked: true };
    } else if (jn(e)) {
      if (t.props && e.has(t.props.value))
        return { checked: true };
    } else if (e)
      return { checked: true };
  }, Tp.getSSRProps = (e, t) => {
    if (typeof t.type != "string")
      return;
    const n = Dp(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      t.type.toUpperCase(),
      t.props && t.props.type
    );
    if (n.getSSRProps)
      return n.getSSRProps(e, t);
  };
}
var Ev = ["ctrl", "shift", "alt", "meta"];
var yv = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => Ev.some((n) => e[`${n}Key`] && !t.includes(n))
};
var vv = (e, t) => {
  const n = e._withMods || (e._withMods = {}), s = t.join(".");
  return n[s] || (n[s] = (r, ...i) => {
    for (let o = 0; o < t.length; o++) {
      const c = yv[t[o]];
      if (c && c(r, t)) return;
    }
    return e(r, ...i);
  });
};
var Nv = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
var bv = (e, t) => {
  const n = e._withKeys || (e._withKeys = {}), s = t.join(".");
  return n[s] || (n[s] = (r) => {
    if (!("key" in r))
      return;
    const i = Fe(r.key);
    if (t.some(
      (o) => o === i || Nv[o] === i
    ))
      return e(r);
  });
};
var wp = te({ patchProp: sv }, Ly);
var Ks;
var ba = false;
function Cp() {
  return Ks || (Ks = Mu(wp));
}
function Vp() {
  return Ks = ba ? Ks : $u(wp), ba = true, Ks;
}
var Ap = (...e) => {
  Cp().render(...e);
};
var Ov = (...e) => {
  Vp().hydrate(...e);
};
var zo = (...e) => {
  const t = Cp().createApp(...e);
  Pp(t), Rp(t);
  const { mount: n } = t;
  return t.mount = (s) => {
    const r = Mp(s);
    if (!r) return;
    const i = t._component;
    !J(i) && !i.render && !i.template && (i.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const o = n(r, false, Ip(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o;
  }, t;
};
var xp = (...e) => {
  const t = Vp().createApp(...e);
  Pp(t), Rp(t);
  const { mount: n } = t;
  return t.mount = (s) => {
    const r = Mp(s);
    if (r)
      return n(r, true, Ip(r));
  }, t;
};
function Ip(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Pp(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => yf(t) || vf(t) || Nf(t),
    writable: false
  });
}
function Rp(e) {
  if (Fc()) {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        Ne(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const n = e.config.compilerOptions, s = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return Ne(s), n;
      },
      set() {
        Ne(s);
      }
    });
  }
}
function Mp(e) {
  if (X(e)) {
    const t = document.querySelector(e);
    return !t && Ne(
      `Failed to mount app: mount target selector "${e}" returned null.`
    ), t;
  }
  return window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && Ne(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e;
}
var Oa = false;
var Sv = () => {
  Oa || (Oa = true, _v(), Ky());
};
var Tv = Object.freeze(Object.defineProperty({
  __proto__: null,
  BaseTransition: fu,
  BaseTransitionPropsValidators: Tc,
  Comment: Ee,
  DeprecationTypes: My,
  EffectScope: hc,
  ErrorCodes: __,
  ErrorTypeStrings: Cy,
  Fragment: De,
  KeepAlive: sE,
  ReactiveEffect: Gs,
  Static: un,
  Suspense: ay,
  Teleport: k_,
  Text: It,
  TrackOpTypes: a_,
  Transition: Hy,
  TransitionGroup: uv,
  TriggerOpTypes: f_,
  VueElement: Ki,
  assertNumber: yc,
  callWithAsyncErrorHandling: dt,
  callWithErrorHandling: Un,
  camelize: de,
  capitalize: Pt,
  cloneVNode: ht,
  compatUtils: Ry,
  computed: ap,
  createApp: zo,
  createBlock: ei,
  createCommentVNode: yy,
  createElementBlock: gy,
  createElementVNode: $c,
  createHydrationRenderer: $u,
  createPropsRestProxy: CE,
  createRenderer: Mu,
  createSSRApp: xp,
  createSlots: fE,
  createStaticVNode: Ey,
  createTextVNode: kc,
  createVNode: ye,
  customRef: Gf,
  defineAsyncComponent: tE,
  defineComponent: Dc,
  defineCustomElement: vp,
  defineEmits: EE,
  defineExpose: yE,
  defineModel: bE,
  defineOptions: vE,
  defineProps: _E,
  defineSSRCustomElement: iv,
  defineSlots: NE,
  devtools: Vy,
  effect: Im,
  effectScope: Vm,
  getCurrentInstance: ze,
  getCurrentScope: wf,
  getCurrentWatcher: u_,
  getTransitionRawChildren: Mi,
  guardReactiveProps: Qu,
  h: fp,
  handleError: gn,
  hasInjectionContext: LE,
  hydrate: Ov,
  hydrateOnIdle: J_,
  hydrateOnInteraction: Q_,
  hydrateOnMediaQuery: Z_,
  hydrateOnVisible: X_,
  initCustomFormatter: up,
  initDirectivesForSSR: Sv,
  inject: Hs,
  isMemoSame: pp,
  isProxy: ss,
  isReactive: Bt,
  isReadonly: Tt,
  isRef: be,
  isRuntimeOnly: Fc,
  isShallow: je,
  isVNode: Rt,
  markRaw: Kf,
  mergeDefaults: DE,
  mergeModels: wE,
  mergeProps: tp,
  nextTick: Ii,
  normalizeClass: Ns,
  normalizeProps: mm,
  normalizeStyle: vs,
  onActivated: gu,
  onBeforeMount: Eu,
  onBeforeUnmount: Li,
  onBeforeUpdate: Cc,
  onDeactivated: mu,
  onErrorCaptured: bu,
  onMounted: ar,
  onRenderTracked: Nu,
  onRenderTriggered: vu,
  onScopeDispose: Am,
  onServerPrefetch: yu,
  onUnmounted: Fi,
  onUpdated: ki,
  onWatcherCleanup: Jf,
  openBlock: er,
  popScopeId: P_,
  provide: Du,
  proxyRefs: Ec,
  pushScopeId: I_,
  queuePostFlushCb: rs,
  reactive: wi,
  readonly: Ci,
  ref: wn,
  registerRuntimeCompiler: ip,
  render: Ap,
  renderList: aE,
  renderSlot: uE,
  resolveComponent: oE,
  resolveDirective: lE,
  resolveDynamicComponent: cE,
  resolveFilter: Py,
  resolveTransitionHooks: is,
  setBlockTracking: $o,
  setDevtoolsHook: Ay,
  setTransitionHooks: qt,
  shallowReactive: Bf,
  shallowReadonly: Et,
  shallowRef: Wf,
  ssrContextKey: Hu,
  ssrUtils: Iy,
  stop: Pm,
  toDisplayString: Sf,
  toHandlerKey: At,
  toHandlers: pE,
  toRaw: Q,
  toRef: o_,
  toRefs: s_,
  toValue: e_,
  transformVNodeArgs: my,
  triggerRef: Qm,
  unref: Ai,
  useAttrs: TE,
  useCssModule: lv,
  useCssVars: Wy,
  useHost: Go,
  useId: F_,
  useModel: sy,
  useSSRContext: ju,
  useShadowRoot: cv,
  useSlots: SE,
  useTemplateRef: H_,
  useTransitionState: Sc,
  vModelCheckbox: jc,
  vModelDynamic: Tp,
  vModelRadio: Uc,
  vModelSelect: Op,
  vModelText: ii,
  vShow: Hc,
  version: Bo,
  warn: Ne,
  watch: ts,
  watchEffect: ey,
  watchPostEffect: ty,
  watchSyncEffect: Uu,
  withAsyncContext: VE,
  withCtx: Oc,
  withDefaults: OE,
  withDirectives: M_,
  withKeys: bv,
  withMemo: wy,
  withModifiers: vv,
  withScopeId: R_
}, Symbol.toStringTag, { value: "Module" }));
var tr = Symbol(true ? "Fragment" : "");
var Ws = Symbol(true ? "Teleport" : "");
var Bc = Symbol(true ? "Suspense" : "");
var oi = Symbol(true ? "KeepAlive" : "");
var $p = Symbol(
  true ? "BaseTransition" : ""
);
var Fn = Symbol(true ? "openBlock" : "");
var kp = Symbol(true ? "createBlock" : "");
var Lp = Symbol(
  true ? "createElementBlock" : ""
);
var Kc = Symbol(true ? "createVNode" : "");
var Wc = Symbol(
  true ? "createElementVNode" : ""
);
var pr = Symbol(
  true ? "createCommentVNode" : ""
);
var qc = Symbol(
  true ? "createTextVNode" : ""
);
var Fp = Symbol(
  true ? "createStaticVNode" : ""
);
var Gc = Symbol(
  true ? "resolveComponent" : ""
);
var zc = Symbol(
  true ? "resolveDynamicComponent" : ""
);
var Jc = Symbol(
  true ? "resolveDirective" : ""
);
var Yc = Symbol(
  true ? "resolveFilter" : ""
);
var Xc = Symbol(
  true ? "withDirectives" : ""
);
var Zc = Symbol(true ? "renderList" : "");
var Hp = Symbol(true ? "renderSlot" : "");
var jp = Symbol(true ? "createSlots" : "");
var Wi = Symbol(
  true ? "toDisplayString" : ""
);
var ci = Symbol(true ? "mergeProps" : "");
var Qc = Symbol(
  true ? "normalizeClass" : ""
);
var el = Symbol(
  true ? "normalizeStyle" : ""
);
var nr = Symbol(
  true ? "normalizeProps" : ""
);
var dr = Symbol(
  true ? "guardReactiveProps" : ""
);
var tl = Symbol(true ? "toHandlers" : "");
var Jo = Symbol(true ? "camelize" : "");
var Dv = Symbol(true ? "capitalize" : "");
var Yo = Symbol(
  true ? "toHandlerKey" : ""
);
var li = Symbol(
  true ? "setBlockTracking" : ""
);
var wv = Symbol(true ? "pushScopeId" : "");
var Cv = Symbol(true ? "popScopeId" : "");
var nl = Symbol(true ? "withCtx" : "");
var Vv = Symbol(true ? "unref" : "");
var Av = Symbol(true ? "isRef" : "");
var sl = Symbol(true ? "withMemo" : "");
var Up = Symbol(true ? "isMemoSame" : "");
var fs = {
  [tr]: "Fragment",
  [Ws]: "Teleport",
  [Bc]: "Suspense",
  [oi]: "KeepAlive",
  [$p]: "BaseTransition",
  [Fn]: "openBlock",
  [kp]: "createBlock",
  [Lp]: "createElementBlock",
  [Kc]: "createVNode",
  [Wc]: "createElementVNode",
  [pr]: "createCommentVNode",
  [qc]: "createTextVNode",
  [Fp]: "createStaticVNode",
  [Gc]: "resolveComponent",
  [zc]: "resolveDynamicComponent",
  [Jc]: "resolveDirective",
  [Yc]: "resolveFilter",
  [Xc]: "withDirectives",
  [Zc]: "renderList",
  [Hp]: "renderSlot",
  [jp]: "createSlots",
  [Wi]: "toDisplayString",
  [ci]: "mergeProps",
  [Qc]: "normalizeClass",
  [el]: "normalizeStyle",
  [nr]: "normalizeProps",
  [dr]: "guardReactiveProps",
  [tl]: "toHandlers",
  [Jo]: "camelize",
  [Dv]: "capitalize",
  [Yo]: "toHandlerKey",
  [li]: "setBlockTracking",
  [wv]: "pushScopeId",
  [Cv]: "popScopeId",
  [nl]: "withCtx",
  [Vv]: "unref",
  [Av]: "isRef",
  [sl]: "withMemo",
  [Up]: "isMemoSame"
};
function xv(e) {
  Object.getOwnPropertySymbols(e).forEach((t) => {
    fs[t] = e[t];
  });
}
var ot = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function Iv(e, t = "") {
  return {
    type: 0,
    source: t,
    children: e,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: ot
  };
}
function sr(e, t, n, s, r, i, o, c = false, l = false, f = false, u = ot) {
  return e && (c ? (e.helper(Fn), e.helper(ds(e.inSSR, f))) : e.helper(ps(e.inSSR, f)), o && e.helper(Xc)), {
    type: 13,
    tag: t,
    props: n,
    children: s,
    patchFlag: r,
    dynamicProps: i,
    directives: o,
    isBlock: c,
    disableTracking: l,
    isComponent: f,
    loc: u
  };
}
function In(e, t = ot) {
  return {
    type: 17,
    loc: t,
    elements: e
  };
}
function ft(e, t = ot) {
  return {
    type: 15,
    loc: t,
    properties: e
  };
}
function Oe(e, t) {
  return {
    type: 16,
    loc: ot,
    key: X(e) ? ee(e, true) : e,
    value: t
  };
}
function ee(e, t = false, n = ot, s = 0) {
  return {
    type: 4,
    loc: n,
    content: e,
    isStatic: t,
    constType: t ? 3 : s
  };
}
function bt(e, t = ot) {
  return {
    type: 8,
    loc: t,
    children: e
  };
}
function Ae(e, t = [], n = ot) {
  return {
    type: 14,
    loc: n,
    callee: e,
    arguments: t
  };
}
function us(e, t = void 0, n = false, s = false, r = ot) {
  return {
    type: 18,
    params: e,
    returns: t,
    newline: n,
    isSlot: s,
    loc: r
  };
}
function Xo(e, t, n, s = true) {
  return {
    type: 19,
    test: e,
    consequent: t,
    alternate: n,
    newline: s,
    loc: ot
  };
}
function Pv(e, t, n = false, s = false) {
  return {
    type: 20,
    index: e,
    value: t,
    needPauseTracking: n,
    inVOnce: s,
    needArraySpread: false,
    loc: ot
  };
}
function Rv(e) {
  return {
    type: 21,
    body: e,
    loc: ot
  };
}
function ps(e, t) {
  return e || t ? Kc : Wc;
}
function ds(e, t) {
  return e || t ? kp : Lp;
}
function rl(e, { helper: t, removeHelper: n, inSSR: s }) {
  e.isBlock || (e.isBlock = true, n(ps(s, e.isComponent)), t(Fn), t(ds(s, e.isComponent)));
}
var Sa = new Uint8Array([123, 123]);
var Ta = new Uint8Array([125, 125]);
function Da(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function rt(e) {
  return e === 32 || e === 10 || e === 9 || e === 12 || e === 13;
}
function Xt(e) {
  return e === 47 || e === 62 || rt(e);
}
function ai(e) {
  const t = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    t[n] = e.charCodeAt(n);
  return t;
}
var Pe = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
var Mv = class {
  constructor(t, n) {
    this.stack = t, this.cbs = n, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = false, this.inXML = false, this.inVPre = false, this.newlines = [], this.mode = 0, this.delimiterOpen = Sa, this.delimiterClose = Ta, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = false, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = Sa, this.delimiterClose = Ta;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(t) {
    let n = 1, s = t + 1;
    for (let r = this.newlines.length - 1; r >= 0; r--) {
      const i = this.newlines[r];
      if (t > i) {
        n = r + 2, s = t - i;
        break;
      }
    }
    return {
      column: s,
      line: n,
      offset: t
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(t) {
    t === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : !this.inVPre && t === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(t));
  }
  stateInterpolationOpen(t) {
    if (t === this.delimiterOpen[this.delimiterIndex])
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const n = this.index + 1 - this.delimiterOpen.length;
        n > this.sectionStart && this.cbs.ontext(this.sectionStart, n), this.state = 3, this.sectionStart = n;
      } else
        this.delimiterIndex++;
    else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(t)) : (this.state = 1, this.stateText(t));
  }
  stateInterpolation(t) {
    t === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(t));
  }
  stateInterpolationClose(t) {
    t === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(t));
  }
  stateSpecialStartSequence(t) {
    const n = this.sequenceIndex === this.currentSequence.length;
    if (!(n ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Xt(t)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (t | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.inRCDATA = false;
    else if (!n) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(t);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(t) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (t === 62 || rt(t)) {
        const n = this.index - this.currentSequence.length;
        if (this.sectionStart < n) {
          const s = this.index;
          this.index = n, this.cbs.ontext(this.sectionStart, n), this.index = s;
        }
        this.sectionStart = n + 2, this.stateInClosingTagName(t), this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    (t | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === Pe.TitleEnd || this.currentSequence === Pe.TextareaEnd && !this.inSFCRoot ? !this.inVPre && t === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(t)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(t === 60);
  }
  stateCDATASequence(t) {
    t === Pe.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === Pe.Cdata.length && (this.state = 28, this.currentSequence = Pe.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(t));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(t) {
    for (; ++this.index < this.buffer.length; ) {
      const n = this.buffer.charCodeAt(this.index);
      if (n === 10 && this.newlines.push(this.index), n === t)
        return true;
    }
    return this.index = this.buffer.length - 1, false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(t) {
    t === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === Pe.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : t !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  startSpecial(t, n) {
    this.enterRCDATA(t, n), this.state = 31;
  }
  enterRCDATA(t, n) {
    this.inRCDATA = true, this.currentSequence = t, this.sequenceIndex = n;
  }
  stateBeforeTagName(t) {
    t === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : t === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : Da(t) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : t === 116 ? this.state = 30 : this.state = t === 115 ? 29 : 6) : t === 47 ? this.state = 8 : (this.state = 1, this.stateText(t));
  }
  stateInTagName(t) {
    Xt(t) && this.handleTagName(t);
  }
  stateInSFCRootTagName(t) {
    if (Xt(t)) {
      const n = this.buffer.slice(this.sectionStart, this.index);
      n !== "template" && this.enterRCDATA(ai("</" + n), 0), this.handleTagName(t);
    }
  }
  handleTagName(t) {
    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(t);
  }
  stateBeforeClosingTagName(t) {
    rt(t) || (t === 62 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = Da(t) ? 9 : 27, this.sectionStart = this.index));
  }
  stateInClosingTagName(t) {
    (t === 62 || rt(t)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(t));
  }
  stateAfterClosingTagName(t) {
    t === 62 && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeAttrName(t) {
    t === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : t === 47 ? (this.state = 7, this.peek() !== 62 && this.cbs.onerr(22, this.index)) : t === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : rt(t) || (t === 61 && this.cbs.onerr(
      19,
      this.index
    ), this.handleAttrStart(t));
  }
  handleAttrStart(t) {
    t === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : t === 46 || t === 58 || t === 64 || t === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(t) {
    t === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = false) : rt(t) || (this.state = 11, this.stateBeforeAttrName(t));
  }
  stateInAttrName(t) {
    t === 61 || Xt(t) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(t)) : (t === 34 || t === 39 || t === 60) && this.cbs.onerr(
      17,
      this.index
    );
  }
  stateInDirName(t) {
    t === 61 || Xt(t) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(t)) : t === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : t === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDirArg(t) {
    t === 61 || Xt(t) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(t)) : t === 91 ? this.state = 15 : t === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDynamicDirArg(t) {
    t === 93 ? this.state = 14 : (t === 61 || Xt(t)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(t), this.cbs.onerr(
      27,
      this.index
    ));
  }
  stateInDirModifier(t) {
    t === 61 || Xt(t) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(t)) : t === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
  }
  handleAttrNameEnd(t) {
    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(t);
  }
  stateAfterAttrName(t) {
    t === 61 ? this.state = 18 : t === 47 || t === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(t)) : rt(t) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(t));
  }
  stateBeforeAttrValue(t) {
    t === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : t === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : rt(t) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(t));
  }
  handleInAttrValue(t, n) {
    (t === n || this.fastForwardTo(n)) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(
      n === 34 ? 3 : 2,
      this.index + 1
    ), this.state = 11);
  }
  stateInAttrValueDoubleQuotes(t) {
    this.handleInAttrValue(t, 34);
  }
  stateInAttrValueSingleQuotes(t) {
    this.handleInAttrValue(t, 39);
  }
  stateInAttrValueNoQuotes(t) {
    rt(t) || t === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(t)) : (t === 34 || t === 39 || t === 60 || t === 61 || t === 96) && this.cbs.onerr(
      18,
      this.index
    );
  }
  stateBeforeDeclaration(t) {
    t === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = t === 45 ? 25 : 23;
  }
  stateInDeclaration(t) {
    (t === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(t) {
    (t === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(t) {
    t === 45 ? (this.state = 28, this.currentSequence = Pe.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
  }
  stateInSpecialComment(t) {
    (t === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(t) {
    t === Pe.ScriptEnd[3] ? this.startSpecial(Pe.ScriptEnd, 4) : t === Pe.StyleEnd[3] ? this.startSpecial(Pe.StyleEnd, 4) : (this.state = 6, this.stateInTagName(t));
  }
  stateBeforeSpecialT(t) {
    t === Pe.TitleEnd[3] ? this.startSpecial(Pe.TitleEnd, 4) : t === Pe.TextareaEnd[3] ? this.startSpecial(Pe.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(t));
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(t) {
    for (this.buffer = t; this.index < this.buffer.length; ) {
      const n = this.buffer.charCodeAt(this.index);
      switch (n === 10 && this.state !== 33 && this.newlines.push(this.index), this.state) {
        case 1: {
          this.stateText(n);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(n);
          break;
        }
        case 3: {
          this.stateInterpolation(n);
          break;
        }
        case 4: {
          this.stateInterpolationClose(n);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(n);
          break;
        }
        case 32: {
          this.stateInRCDATA(n);
          break;
        }
        case 26: {
          this.stateCDATASequence(n);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(n);
          break;
        }
        case 12: {
          this.stateInAttrName(n);
          break;
        }
        case 13: {
          this.stateInDirName(n);
          break;
        }
        case 14: {
          this.stateInDirArg(n);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(n);
          break;
        }
        case 16: {
          this.stateInDirModifier(n);
          break;
        }
        case 28: {
          this.stateInCommentLike(n);
          break;
        }
        case 27: {
          this.stateInSpecialComment(n);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(n);
          break;
        }
        case 6: {
          this.stateInTagName(n);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(n);
          break;
        }
        case 9: {
          this.stateInClosingTagName(n);
          break;
        }
        case 5: {
          this.stateBeforeTagName(n);
          break;
        }
        case 17: {
          this.stateAfterAttrName(n);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(n);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(n);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(n);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(n);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(n);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(n);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(n);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(n);
          break;
        }
        case 23: {
          this.stateInDeclaration(n);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(n);
          break;
        }
        case 25: {
          this.stateBeforeComment(n);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(n);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup(), this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === 19 || this.state === 20 || this.state === 21) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  finish() {
    this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const t = this.buffer.length;
    this.sectionStart >= t || (this.state === 28 ? this.currentSequence === Pe.CdataEnd ? this.cbs.oncdata(this.sectionStart, t) : this.cbs.oncomment(this.sectionStart, t) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, t));
  }
  emitCodePoint(t, n) {
  }
};
var $v = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (e) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e}.sync\` should be changed to \`v-model:${e}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTERS: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function Zo(e, { compatConfig: t }) {
  const n = t && t[e];
  return e === "MODE" ? n || 3 : n;
}
function pn(e, t) {
  const n = Zo("MODE", t), s = Zo(e, t);
  return n === 3 ? s === true : s !== false;
}
function hs(e, t, n, ...s) {
  const r = pn(e, t);
  return r && fi(e, t, n, ...s), r;
}
function fi(e, t, n, ...s) {
  if (Zo(e, t) === "suppress-warning")
    return;
  const { message: i, link: o } = $v[e], c = `(deprecation ${e}) ${typeof i == "function" ? i(...s) : i}${o ? `
  Details: ${o}` : ""}`, l = new SyntaxError(c);
  l.code = e, n && (l.loc = n), t.onWarn(l);
}
function il(e) {
  throw e;
}
function Bp(e) {
  console.warn(`[Vue warn] ${e.message}`);
}
function pe(e, t, n, s) {
  const r = true ? (n || kv)[e] + (s || "") : `https://vuejs.org/error-reference/#compiler-${e}`, i = new SyntaxError(String(r));
  return i.code = e, i.loc = t, i;
}
var kv = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  52: "v-bind with same-name shorthand only allows static argument.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // just to fulfill types
  53: ""
};
var tt = (e) => e.type === 4 && e.isStatic;
function Kp(e) {
  switch (e) {
    case "Teleport":
    case "teleport":
      return Ws;
    case "Suspense":
    case "suspense":
      return Bc;
    case "KeepAlive":
    case "keep-alive":
      return oi;
    case "BaseTransition":
    case "base-transition":
      return $p;
  }
}
var Lv = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
var ol = (e) => !Lv.test(e);
var Fv = /[A-Za-z_$\xA0-\uFFFF]/;
var Hv = /[\.\?\w$\xA0-\uFFFF]/;
var jv = /\s+[.[]\s*|\s*[.[]\s+/g;
var Wp = (e) => e.type === 4 ? e.content : e.loc.source;
var Uv = (e) => {
  const t = Wp(e).trim().replace(jv, (c) => c.trim());
  let n = 0, s = [], r = 0, i = 0, o = null;
  for (let c = 0; c < t.length; c++) {
    const l = t.charAt(c);
    switch (n) {
      case 0:
        if (l === "[")
          s.push(n), n = 1, r++;
        else if (l === "(")
          s.push(n), n = 2, i++;
        else if (!(c === 0 ? Fv : Hv).test(l))
          return false;
        break;
      case 1:
        l === "'" || l === '"' || l === "`" ? (s.push(n), n = 3, o = l) : l === "[" ? r++ : l === "]" && (--r || (n = s.pop()));
        break;
      case 2:
        if (l === "'" || l === '"' || l === "`")
          s.push(n), n = 3, o = l;
        else if (l === "(")
          i++;
        else if (l === ")") {
          if (c === t.length - 1)
            return false;
          --i || (n = s.pop());
        }
        break;
      case 3:
        l === o && (n = s.pop(), o = null);
        break;
    }
  }
  return !r && !i;
};
var qp = Uv;
var Bv = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
var Kv = (e) => Bv.test(Wp(e));
var Wv = Kv;
function wa(e, t) {
  if (!e)
    throw new Error(t || "unexpected compiler condition");
}
function et(e, t, n = false) {
  for (let s = 0; s < e.props.length; s++) {
    const r = e.props[s];
    if (r.type === 7 && (n || r.exp) && (X(t) ? r.name === t : t.test(r.name)))
      return r;
  }
}
function rr(e, t, n = false, s = false) {
  for (let r = 0; r < e.props.length; r++) {
    const i = e.props[r];
    if (i.type === 6) {
      if (n) continue;
      if (i.name === t && (i.value || s))
        return i;
    } else if (i.name === "bind" && (i.exp || s) && cn(i.arg, t))
      return i;
  }
}
function cn(e, t) {
  return !!(e && tt(e) && e.content === t);
}
function qv(e) {
  return e.props.some(
    (t) => t.type === 7 && t.name === "bind" && (!t.arg || // v-bind="obj"
    t.arg.type !== 4 || // v-bind:[_ctx.foo]
    !t.arg.isStatic)
    // v-bind:[foo]
  );
}
function go(e) {
  return e.type === 5 || e.type === 2;
}
function Ca(e) {
  return e.type === 7 && e.name === "pre";
}
function Gv(e) {
  return e.type === 7 && e.name === "slot";
}
function ui(e) {
  return e.type === 1 && e.tagType === 3;
}
function pi(e) {
  return e.type === 1 && e.tagType === 2;
}
var zv = /* @__PURE__ */ new Set([nr, dr]);
function Gp(e, t = []) {
  if (e && !X(e) && e.type === 14) {
    const n = e.callee;
    if (!X(n) && zv.has(n))
      return Gp(
        e.arguments[0],
        t.concat(e)
      );
  }
  return [e, t];
}
function di(e, t, n) {
  let s, r = e.type === 13 ? e.props : e.arguments[2], i = [], o;
  if (r && !X(r) && r.type === 14) {
    const c = Gp(r);
    r = c[0], i = c[1], o = i[i.length - 1];
  }
  if (r == null || X(r))
    s = ft([t]);
  else if (r.type === 14) {
    const c = r.arguments[0];
    !X(c) && c.type === 15 ? Va(t, c) || c.properties.unshift(t) : r.callee === tl ? s = Ae(n.helper(ci), [
      ft([t]),
      r
    ]) : r.arguments.unshift(ft([t])), !s && (s = r);
  } else r.type === 15 ? (Va(t, r) || r.properties.unshift(t), s = r) : (s = Ae(n.helper(ci), [
    ft([t]),
    r
  ]), o && o.callee === dr && (o = i[i.length - 2]));
  e.type === 13 ? o ? o.arguments[0] = s : e.props = s : o ? o.arguments[0] = s : e.arguments[2] = s;
}
function Va(e, t) {
  let n = false;
  if (e.key.type === 4) {
    const s = e.key.content;
    n = t.properties.some(
      (r) => r.key.type === 4 && r.key.content === s
    );
  }
  return n;
}
function ir(e, t) {
  return `_${t}_${e.replace(/[^\w]/g, (n, s) => n === "-" ? "_" : e.charCodeAt(s).toString())}`;
}
function Jv(e) {
  return e.type === 14 && e.callee === sl ? e.arguments[1].returns : e;
}
var Yv = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
var zp = {
  parseMode: "base",
  ns: 0,
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  isVoidTag: As,
  isPreTag: As,
  isIgnoreNewlineTag: As,
  isCustomElement: As,
  onError: il,
  onWarn: Bp,
  comments: true,
  prefixIdentifiers: false
};
var ce = zp;
var or = null;
var Kt = "";
var Le = null;
var re = null;
var Ze = "";
var Lt = -1;
var yn = -1;
var cl = 0;
var sn = false;
var Qo = null;
var ve = [];
var ge = new Mv(ve, {
  onerr: Xe,
  ontext(e, t) {
    Sr(Re(e, t), e, t);
  },
  ontextentity(e, t, n) {
    Sr(e, t, n);
  },
  oninterpolation(e, t) {
    if (sn)
      return Sr(Re(e, t), e, t);
    let n = e + ge.delimiterOpen.length, s = t - ge.delimiterClose.length;
    for (; rt(Kt.charCodeAt(n)); )
      n++;
    for (; rt(Kt.charCodeAt(s - 1)); )
      s--;
    let r = Re(n, s);
    r.includes("&") && (r = ce.decodeEntities(r, false)), ec({
      type: 5,
      content: Rr(r, false, Se(n, s)),
      loc: Se(e, t)
    });
  },
  onopentagname(e, t) {
    const n = Re(e, t);
    Le = {
      type: 1,
      tag: n,
      ns: ce.getNamespace(n, ve[0], ce.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: Se(e - 1, t),
      codegenNode: void 0
    };
  },
  onopentagend(e) {
    xa(e);
  },
  onclosetag(e, t) {
    const n = Re(e, t);
    if (!ce.isVoidTag(n)) {
      let s = false;
      for (let r = 0; r < ve.length; r++)
        if (ve[r].tag.toLowerCase() === n.toLowerCase()) {
          s = true, r > 0 && Xe(24, ve[0].loc.start.offset);
          for (let o = 0; o <= r; o++) {
            const c = ve.shift();
            Pr(c, t, o < r);
          }
          break;
        }
      s || Xe(23, Jp(e, 60));
    }
  },
  onselfclosingtag(e) {
    const t = Le.tag;
    Le.isSelfClosing = true, xa(e), ve[0] && ve[0].tag === t && Pr(ve.shift(), e);
  },
  onattribname(e, t) {
    re = {
      type: 6,
      name: Re(e, t),
      nameLoc: Se(e, t),
      value: void 0,
      loc: Se(e)
    };
  },
  ondirname(e, t) {
    const n = Re(e, t), s = n === "." || n === ":" ? "bind" : n === "@" ? "on" : n === "#" ? "slot" : n.slice(2);
    if (!sn && s === "" && Xe(26, e), sn || s === "")
      re = {
        type: 6,
        name: n,
        nameLoc: Se(e, t),
        value: void 0,
        loc: Se(e)
      };
    else if (re = {
      type: 7,
      name: s,
      rawName: n,
      exp: void 0,
      arg: void 0,
      modifiers: n === "." ? [ee("prop")] : [],
      loc: Se(e)
    }, s === "pre") {
      sn = ge.inVPre = true, Qo = Le;
      const r = Le.props;
      for (let i = 0; i < r.length; i++)
        r[i].type === 7 && (r[i] = cN(r[i]));
    }
  },
  ondirarg(e, t) {
    if (e === t) return;
    const n = Re(e, t);
    if (sn && !Ca(re))
      re.name += n, On(re.nameLoc, t);
    else {
      const s = n[0] !== "[";
      re.arg = Rr(
        s ? n : n.slice(1, -1),
        s,
        Se(e, t),
        s ? 3 : 0
      );
    }
  },
  ondirmodifier(e, t) {
    const n = Re(e, t);
    if (sn && !Ca(re))
      re.name += "." + n, On(re.nameLoc, t);
    else if (re.name === "slot") {
      const s = re.arg;
      s && (s.content += "." + n, On(s.loc, t));
    } else {
      const s = ee(n, true, Se(e, t));
      re.modifiers.push(s);
    }
  },
  onattribdata(e, t) {
    Ze += Re(e, t), Lt < 0 && (Lt = e), yn = t;
  },
  onattribentity(e, t, n) {
    Ze += e, Lt < 0 && (Lt = t), yn = n;
  },
  onattribnameend(e) {
    const t = re.loc.start.offset, n = Re(t, e);
    re.type === 7 && (re.rawName = n), Le.props.some(
      (s) => (s.type === 7 ? s.rawName : s.name) === n
    ) && Xe(2, t);
  },
  onattribend(e, t) {
    if (Le && re) {
      if (On(re.loc, t), e !== 0)
        if (Ze.includes("&") && (Ze = ce.decodeEntities(
          Ze,
          true
        )), re.type === 6)
          re.name === "class" && (Ze = Xp(Ze).trim()), e === 1 && !Ze && Xe(13, t), re.value = {
            type: 2,
            content: Ze,
            loc: e === 1 ? Se(Lt, yn) : Se(Lt - 1, yn + 1)
          }, ge.inSFCRoot && Le.tag === "template" && re.name === "lang" && Ze && Ze !== "html" && ge.enterRCDATA(ai("</template"), 0);
        else {
          let n = 0;
          re.exp = Rr(
            Ze,
            false,
            Se(Lt, yn),
            0,
            n
          ), re.name === "for" && (re.forParseResult = Zv(re.exp));
          let s = -1;
          re.name === "bind" && (s = re.modifiers.findIndex(
            (r) => r.content === "sync"
          )) > -1 && hs(
            "COMPILER_V_BIND_SYNC",
            ce,
            re.loc,
            re.arg.loc.source
          ) && (re.name = "model", re.modifiers.splice(s, 1));
        }
      (re.type !== 7 || re.name !== "pre") && Le.props.push(re);
    }
    Ze = "", Lt = yn = -1;
  },
  oncomment(e, t) {
    ce.comments && ec({
      type: 3,
      content: Re(e, t),
      loc: Se(e - 4, t + 3)
    });
  },
  onend() {
    const e = Kt.length;
    if (ge.state !== 1)
      switch (ge.state) {
        case 5:
        case 8:
          Xe(5, e);
          break;
        case 3:
        case 4:
          Xe(
            25,
            ge.sectionStart
          );
          break;
        case 28:
          ge.currentSequence === Pe.CdataEnd ? Xe(6, e) : Xe(7, e);
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
          Xe(9, e);
          break;
      }
    for (let t = 0; t < ve.length; t++)
      Pr(ve[t], e - 1), Xe(24, ve[t].loc.start.offset);
  },
  oncdata(e, t) {
    ve[0].ns !== 0 ? Sr(Re(e, t), e, t) : Xe(1, e - 9);
  },
  onprocessinginstruction(e) {
    (ve[0] ? ve[0].ns : ce.ns) === 0 && Xe(
      21,
      e - 1
    );
  }
});
var Aa = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var Xv = /^\(|\)$/g;
function Zv(e) {
  const t = e.loc, n = e.content, s = n.match(Yv);
  if (!s) return;
  const [, r, i] = s, o = (a, p, h = false) => {
    const _ = t.start.offset + p, E = _ + a.length;
    return Rr(
      a,
      false,
      Se(_, E),
      0,
      h ? 1 : 0
      /* Normal */
    );
  }, c = {
    source: o(i.trim(), n.indexOf(i, r.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let l = r.trim().replace(Xv, "").trim();
  const f = r.indexOf(l), u = l.match(Aa);
  if (u) {
    l = l.replace(Aa, "").trim();
    const a = u[1].trim();
    let p;
    if (a && (p = n.indexOf(a, f + l.length), c.key = o(a, p, true)), u[2]) {
      const h = u[2].trim();
      h && (c.index = o(
        h,
        n.indexOf(
          h,
          c.key ? p + a.length : f + l.length
        ),
        true
      ));
    }
  }
  return l && (c.value = o(l, f, true)), c;
}
function Re(e, t) {
  return Kt.slice(e, t);
}
function xa(e) {
  ge.inSFCRoot && (Le.innerLoc = Se(e + 1, e + 1)), ec(Le);
  const { tag: t, ns: n } = Le;
  n === 0 && ce.isPreTag(t) && cl++, ce.isVoidTag(t) ? Pr(Le, e) : (ve.unshift(Le), (n === 1 || n === 2) && (ge.inXML = true)), Le = null;
}
function Sr(e, t, n) {
  {
    const i = ve[0] && ve[0].tag;
    i !== "script" && i !== "style" && e.includes("&") && (e = ce.decodeEntities(e, false));
  }
  const s = ve[0] || or, r = s.children[s.children.length - 1];
  r && r.type === 2 ? (r.content += e, On(r.loc, n)) : s.children.push({
    type: 2,
    content: e,
    loc: Se(t, n)
  });
}
function Pr(e, t, n = false) {
  n ? On(e.loc, Jp(t, 60)) : On(e.loc, Qv(t, 62) + 1), ge.inSFCRoot && (e.children.length ? e.innerLoc.end = te({}, e.children[e.children.length - 1].loc.end) : e.innerLoc.end = te({}, e.innerLoc.start), e.innerLoc.source = Re(
    e.innerLoc.start.offset,
    e.innerLoc.end.offset
  ));
  const { tag: s, ns: r, children: i } = e;
  if (sn || (s === "slot" ? e.tagType = 2 : Ia(e) ? e.tagType = 3 : tN(e) && (e.tagType = 1)), ge.inRCDATA || (e.children = Yp(i)), r === 0 && ce.isIgnoreNewlineTag(s)) {
    const o = i[0];
    o && o.type === 2 && (o.content = o.content.replace(/^\r?\n/, ""));
  }
  r === 0 && ce.isPreTag(s) && cl--, Qo === e && (sn = ge.inVPre = false, Qo = null), ge.inXML && (ve[0] ? ve[0].ns : ce.ns) === 0 && (ge.inXML = false);
  {
    const o = e.props;
    if (pn(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      ce
    )) {
      let l = false, f = false;
      for (let u = 0; u < o.length; u++) {
        const a = o[u];
        if (a.type === 7 && (a.name === "if" ? l = true : a.name === "for" && (f = true)), l && f) {
          fi(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            ce,
            e.loc
          );
          break;
        }
      }
    }
    if (!ge.inSFCRoot && pn(
      "COMPILER_NATIVE_TEMPLATE",
      ce
    ) && e.tag === "template" && !Ia(e)) {
      fi(
        "COMPILER_NATIVE_TEMPLATE",
        ce,
        e.loc
      );
      const l = ve[0] || or, f = l.children.indexOf(e);
      l.children.splice(f, 1, ...e.children);
    }
    const c = o.find(
      (l) => l.type === 6 && l.name === "inline-template"
    );
    c && hs(
      "COMPILER_INLINE_TEMPLATE",
      ce,
      c.loc
    ) && e.children.length && (c.value = {
      type: 2,
      content: Re(
        e.children[0].loc.start.offset,
        e.children[e.children.length - 1].loc.end.offset
      ),
      loc: c.loc
    });
  }
}
function Qv(e, t) {
  let n = e;
  for (; Kt.charCodeAt(n) !== t && n < Kt.length - 1; ) n++;
  return n;
}
function Jp(e, t) {
  let n = e;
  for (; Kt.charCodeAt(n) !== t && n >= 0; ) n--;
  return n;
}
var eN = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function Ia({ tag: e, props: t }) {
  if (e === "template") {
    for (let n = 0; n < t.length; n++)
      if (t[n].type === 7 && eN.has(t[n].name))
        return true;
  }
  return false;
}
function tN({ tag: e, props: t }) {
  if (ce.isCustomElement(e))
    return false;
  if (e === "component" || nN(e.charCodeAt(0)) || Kp(e) || ce.isBuiltInComponent && ce.isBuiltInComponent(e) || ce.isNativeTag && !ce.isNativeTag(e))
    return true;
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    if (s.type === 6) {
      if (s.name === "is" && s.value) {
        if (s.value.content.startsWith("vue:"))
          return true;
        if (hs(
          "COMPILER_IS_ON_ELEMENT",
          ce,
          s.loc
        ))
          return true;
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      s.name === "bind" && cn(s.arg, "is") && hs(
        "COMPILER_IS_ON_ELEMENT",
        ce,
        s.loc
      )
    )
      return true;
  }
  return false;
}
function nN(e) {
  return e > 64 && e < 91;
}
var sN = /\r\n/g;
function Yp(e) {
  const t = ce.whitespace !== "preserve";
  let n = false;
  for (let s = 0; s < e.length; s++) {
    const r = e[s];
    if (r.type === 2)
      if (cl)
        r.content = r.content.replace(sN, `
`);
      else if (rN(r.content)) {
        const i = e[s - 1] && e[s - 1].type, o = e[s + 1] && e[s + 1].type;
        !i || !o || t && (i === 3 && (o === 3 || o === 1) || i === 1 && (o === 3 || o === 1 && iN(r.content))) ? (n = true, e[s] = null) : r.content = " ";
      } else t && (r.content = Xp(r.content));
  }
  return n ? e.filter(Boolean) : e;
}
function rN(e) {
  for (let t = 0; t < e.length; t++)
    if (!rt(e.charCodeAt(t)))
      return false;
  return true;
}
function iN(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e.charCodeAt(t);
    if (n === 10 || n === 13)
      return true;
  }
  return false;
}
function Xp(e) {
  let t = "", n = false;
  for (let s = 0; s < e.length; s++)
    rt(e.charCodeAt(s)) ? n || (t += " ", n = true) : (t += e[s], n = false);
  return t;
}
function ec(e) {
  (ve[0] || or).children.push(e);
}
function Se(e, t) {
  return {
    start: ge.getPos(e),
    // @ts-expect-error allow late attachment
    end: t == null ? t : ge.getPos(t),
    // @ts-expect-error allow late attachment
    source: t == null ? t : Re(e, t)
  };
}
function oN(e) {
  return Se(e.start.offset, e.end.offset);
}
function On(e, t) {
  e.end = ge.getPos(t), e.source = Re(e.start.offset, t);
}
function cN(e) {
  const t = {
    type: 6,
    name: e.rawName,
    nameLoc: Se(
      e.loc.start.offset,
      e.loc.start.offset + e.rawName.length
    ),
    value: void 0,
    loc: e.loc
  };
  if (e.exp) {
    const n = e.exp.loc;
    n.end.offset < e.loc.end.offset && (n.start.offset--, n.start.column--, n.end.offset++, n.end.column++), t.value = {
      type: 2,
      content: e.exp.content,
      loc: n
    };
  }
  return t;
}
function Rr(e, t = false, n, s = 0, r = 0) {
  return ee(e, t, n, s);
}
function Xe(e, t, n) {
  ce.onError(
    pe(e, Se(t, t), void 0, n)
  );
}
function lN() {
  ge.reset(), Le = null, re = null, Ze = "", Lt = -1, yn = -1, ve.length = 0;
}
function aN(e, t) {
  if (lN(), Kt = e, ce = te({}, zp), t) {
    let r;
    for (r in t)
      t[r] != null && (ce[r] = t[r]);
  }
  if (!ce.decodeEntities)
    throw new Error(
      "[@vue/compiler-core] decodeEntities option is required in browser builds."
    );
  ge.mode = ce.parseMode === "html" ? 1 : ce.parseMode === "sfc" ? 2 : 0, ge.inXML = ce.ns === 1 || ce.ns === 2;
  const n = t && t.delimiters;
  n && (ge.delimiterOpen = ai(n[0]), ge.delimiterClose = ai(n[1]));
  const s = or = Iv([], e);
  return ge.parse(Kt), s.loc = Se(0, e.length), s.children = Yp(s.children), or = null, s;
}
function fN(e, t) {
  Mr(
    e,
    void 0,
    t,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    !!Zp(e)
  );
}
function Zp(e) {
  const t = e.children.filter((n) => n.type !== 3);
  return t.length === 1 && t[0].type === 1 && !pi(t[0]) ? t[0] : null;
}
function Mr(e, t, n, s = false, r = false) {
  const { children: i } = e, o = [];
  for (let a = 0; a < i.length; a++) {
    const p = i[a];
    if (p.type === 1 && p.tagType === 0) {
      const h = s ? 0 : it(p, n);
      if (h > 0) {
        if (h >= 2) {
          p.codegenNode.patchFlag = -1, o.push(p);
          continue;
        }
      } else {
        const _ = p.codegenNode;
        if (_.type === 13) {
          const E = _.patchFlag;
          if ((E === void 0 || E === 512 || E === 1) && ed(p, n) >= 2) {
            const M = td(p);
            M && (_.props = n.hoist(M));
          }
          _.dynamicProps && (_.dynamicProps = n.hoist(_.dynamicProps));
        }
      }
    } else if (p.type === 12 && (s ? 0 : it(p, n)) >= 2) {
      p.codegenNode.type === 14 && p.codegenNode.arguments.length > 0 && p.codegenNode.arguments.push(
        -1 + (true ? ` /* ${$s[-1]} */` : "")
      ), o.push(p);
      continue;
    }
    if (p.type === 1) {
      const h = p.tagType === 1;
      h && n.scopes.vSlot++, Mr(p, e, n, false, r), h && n.scopes.vSlot--;
    } else if (p.type === 11)
      Mr(p, e, n, p.children.length === 1, true);
    else if (p.type === 9)
      for (let h = 0; h < p.branches.length; h++)
        Mr(
          p.branches[h],
          e,
          n,
          p.branches[h].children.length === 1,
          r
        );
  }
  let c = false;
  const l = [];
  if (o.length === i.length && e.type === 1) {
    if (e.tagType === 0 && e.codegenNode && e.codegenNode.type === 13 && F(e.codegenNode.children))
      e.codegenNode.children = f(
        In(e.codegenNode.children)
      ), c = true;
    else if (e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !F(e.codegenNode.children) && e.codegenNode.children.type === 15) {
      const a = u(e.codegenNode, "default");
      a && (l.push(n.cached.length), a.returns = f(
        In(a.returns)
      ), c = true);
    } else if (e.tagType === 3 && t && t.type === 1 && t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !F(t.codegenNode.children) && t.codegenNode.children.type === 15) {
      const a = et(e, "slot", true), p = a && a.arg && u(t.codegenNode, a.arg);
      p && (l.push(n.cached.length), p.returns = f(
        In(p.returns)
      ), c = true);
    }
  }
  if (!c)
    for (const a of o)
      l.push(n.cached.length), a.codegenNode = n.cache(a.codegenNode);
  l.length && e.type === 1 && e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !F(e.codegenNode.children) && e.codegenNode.children.type === 15 && e.codegenNode.children.properties.push(
    Oe(
      "__",
      ee(JSON.stringify(l), false)
    )
  );
  function f(a) {
    const p = n.cache(a);
    return r && n.hmr && (p.needArraySpread = true), p;
  }
  function u(a, p) {
    if (a.children && !F(a.children) && a.children.type === 15) {
      const h = a.children.properties.find(
        (_) => _.key === p || _.key.content === p
      );
      return h && h.value;
    }
  }
  o.length && n.transformHoist && n.transformHoist(i, n, e);
}
function it(e, t) {
  const { constantCache: n } = t;
  switch (e.type) {
    case 1:
      if (e.tagType !== 0)
        return 0;
      const s = n.get(e);
      if (s !== void 0)
        return s;
      const r = e.codegenNode;
      if (r.type !== 13 || r.isBlock && e.tag !== "svg" && e.tag !== "foreignObject" && e.tag !== "math")
        return 0;
      if (r.patchFlag === void 0) {
        let o = 3;
        const c = ed(e, t);
        if (c === 0)
          return n.set(e, 0), 0;
        c < o && (o = c);
        for (let l = 0; l < e.children.length; l++) {
          const f = it(e.children[l], t);
          if (f === 0)
            return n.set(e, 0), 0;
          f < o && (o = f);
        }
        if (o > 1)
          for (let l = 0; l < e.props.length; l++) {
            const f = e.props[l];
            if (f.type === 7 && f.name === "bind" && f.exp) {
              const u = it(f.exp, t);
              if (u === 0)
                return n.set(e, 0), 0;
              u < o && (o = u);
            }
          }
        if (r.isBlock) {
          for (let l = 0; l < e.props.length; l++)
            if (e.props[l].type === 7)
              return n.set(e, 0), 0;
          t.removeHelper(Fn), t.removeHelper(
            ds(t.inSSR, r.isComponent)
          ), r.isBlock = false, t.helper(ps(t.inSSR, r.isComponent));
        }
        return n.set(e, o), o;
      } else
        return n.set(e, 0), 0;
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return it(e.content, t);
    case 4:
      return e.constType;
    case 8:
      let i = 3;
      for (let o = 0; o < e.children.length; o++) {
        const c = e.children[o];
        if (X(c) || nt(c))
          continue;
        const l = it(c, t);
        if (l === 0)
          return 0;
        l < i && (i = l);
      }
      return i;
    case 20:
      return 2;
    default:
      return "development", 0;
  }
}
var uN = /* @__PURE__ */ new Set([
  Qc,
  el,
  nr,
  dr
]);
function Qp(e, t) {
  if (e.type === 14 && !X(e.callee) && uN.has(e.callee)) {
    const n = e.arguments[0];
    if (n.type === 4)
      return it(n, t);
    if (n.type === 14)
      return Qp(n, t);
  }
  return 0;
}
function ed(e, t) {
  let n = 3;
  const s = td(e);
  if (s && s.type === 15) {
    const { properties: r } = s;
    for (let i = 0; i < r.length; i++) {
      const { key: o, value: c } = r[i], l = it(o, t);
      if (l === 0)
        return l;
      l < n && (n = l);
      let f;
      if (c.type === 4 ? f = it(c, t) : c.type === 14 ? f = Qp(c, t) : f = 0, f === 0)
        return f;
      f < n && (n = f);
    }
  }
  return n;
}
function td(e) {
  const t = e.codegenNode;
  if (t.type === 13)
    return t.props;
}
function pN(e, {
  filename: t = "",
  prefixIdentifiers: n = false,
  hoistStatic: s = false,
  hmr: r = false,
  cacheHandlers: i = false,
  nodeTransforms: o = [],
  directiveTransforms: c = {},
  transformHoist: l = null,
  isBuiltInComponent: f = me,
  isCustomElement: u = me,
  expressionPlugins: a = [],
  scopeId: p = null,
  slotted: h = true,
  ssr: _ = false,
  inSSR: E = false,
  ssrCssVars: M = "",
  bindingMetadata: C = se,
  inline: D = false,
  isTS: g = false,
  onError: N = il,
  onWarn: y = Bp,
  compatConfig: w
}) {
  const H = t.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), V = {
    // options
    filename: t,
    selfName: H && Pt(de(H[1])),
    prefixIdentifiers: n,
    hoistStatic: s,
    hmr: r,
    cacheHandlers: i,
    nodeTransforms: o,
    directiveTransforms: c,
    transformHoist: l,
    isBuiltInComponent: f,
    isCustomElement: u,
    expressionPlugins: a,
    scopeId: p,
    slotted: h,
    ssr: _,
    inSSR: E,
    ssrCssVars: M,
    bindingMetadata: C,
    inline: D,
    isTS: g,
    onError: N,
    onWarn: y,
    compatConfig: w,
    // state
    root: e,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: e,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(v) {
      const S = V.helpers.get(v) || 0;
      return V.helpers.set(v, S + 1), v;
    },
    removeHelper(v) {
      const S = V.helpers.get(v);
      if (S) {
        const R = S - 1;
        R ? V.helpers.set(v, R) : V.helpers.delete(v);
      }
    },
    helperString(v) {
      return `_${fs[V.helper(v)]}`;
    },
    replaceNode(v) {
      if (true) {
        if (!V.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!V.parent)
          throw new Error("Cannot replace root node.");
      }
      V.parent.children[V.childIndex] = V.currentNode = v;
    },
    removeNode(v) {
      if (!V.parent)
        throw new Error("Cannot remove root node.");
      const S = V.parent.children, R = v ? S.indexOf(v) : V.currentNode ? V.childIndex : -1;
      if (R < 0)
        throw new Error("node being removed is not a child of current parent");
      !v || v === V.currentNode ? (V.currentNode = null, V.onNodeRemoved()) : V.childIndex > R && (V.childIndex--, V.onNodeRemoved()), V.parent.children.splice(R, 1);
    },
    onNodeRemoved: me,
    addIdentifiers(v) {
    },
    removeIdentifiers(v) {
    },
    hoist(v) {
      X(v) && (v = ee(v)), V.hoists.push(v);
      const S = ee(
        `_hoisted_${V.hoists.length}`,
        false,
        v.loc,
        2
      );
      return S.hoisted = v, S;
    },
    cache(v, S = false, R = false) {
      const b = Pv(
        V.cached.length,
        v,
        S,
        R
      );
      return V.cached.push(b), b;
    }
  };
  return V.filters = /* @__PURE__ */ new Set(), V;
}
function dN(e, t) {
  const n = pN(e, t);
  qi(e, n), t.hoistStatic && fN(e, n), t.ssr || hN(e, n), e.helpers = /* @__PURE__ */ new Set([...n.helpers.keys()]), e.components = [...n.components], e.directives = [...n.directives], e.imports = n.imports, e.hoists = n.hoists, e.temps = n.temps, e.cached = n.cached, e.transformed = true, e.filters = [...n.filters];
}
function hN(e, t) {
  const { helper: n } = t, { children: s } = e;
  if (s.length === 1) {
    const r = Zp(e);
    if (r && r.codegenNode) {
      const i = r.codegenNode;
      i.type === 13 && rl(i, t), e.codegenNode = i;
    } else
      e.codegenNode = s[0];
  } else if (s.length > 1) {
    let r = 64;
    s.filter((i) => i.type !== 3).length === 1 && (r |= 2048), e.codegenNode = sr(
      t,
      n(tr),
      void 0,
      e.children,
      r,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  }
}
function gN(e, t) {
  let n = 0;
  const s = () => {
    n--;
  };
  for (; n < e.children.length; n++) {
    const r = e.children[n];
    X(r) || (t.grandParent = t.parent, t.parent = e, t.childIndex = n, t.onNodeRemoved = s, qi(r, t));
  }
}
function qi(e, t) {
  t.currentNode = e;
  const { nodeTransforms: n } = t, s = [];
  for (let i = 0; i < n.length; i++) {
    const o = n[i](e, t);
    if (o && (F(o) ? s.push(...o) : s.push(o)), t.currentNode)
      e = t.currentNode;
    else
      return;
  }
  switch (e.type) {
    case 3:
      t.ssr || t.helper(pr);
      break;
    case 5:
      t.ssr || t.helper(Wi);
      break;
    case 9:
      for (let i = 0; i < e.branches.length; i++)
        qi(e.branches[i], t);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      gN(e, t);
      break;
  }
  t.currentNode = e;
  let r = s.length;
  for (; r--; )
    s[r]();
}
function nd(e, t) {
  const n = X(e) ? (s) => s === e : (s) => e.test(s);
  return (s, r) => {
    if (s.type === 1) {
      const { props: i } = s;
      if (s.tagType === 3 && i.some(Gv))
        return;
      const o = [];
      for (let c = 0; c < i.length; c++) {
        const l = i[c];
        if (l.type === 7 && n(l.name)) {
          i.splice(c, 1), c--;
          const f = t(s, l, r);
          f && o.push(f);
        }
      }
      return o;
    }
  };
}
var Gi = "/*@__PURE__*/";
var sd = (e) => `${fs[e]}: _${fs[e]}`;
function mN(e, {
  mode: t = "function",
  prefixIdentifiers: n = t === "module",
  sourceMap: s = false,
  filename: r = "template.vue.html",
  scopeId: i = null,
  optimizeImports: o = false,
  runtimeGlobalName: c = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: f = "vue/server-renderer",
  ssr: u = false,
  isTS: a = false,
  inSSR: p = false
}) {
  const h = {
    mode: t,
    prefixIdentifiers: n,
    sourceMap: s,
    filename: r,
    scopeId: i,
    optimizeImports: o,
    runtimeGlobalName: c,
    runtimeModuleName: l,
    ssrRuntimeModuleName: f,
    ssr: u,
    isTS: a,
    inSSR: p,
    source: e.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(E) {
      return `_${fs[E]}`;
    },
    push(E, M = -2, C) {
      h.code += E;
    },
    indent() {
      _(++h.indentLevel);
    },
    deindent(E = false) {
      E ? --h.indentLevel : _(--h.indentLevel);
    },
    newline() {
      _(h.indentLevel);
    }
  };
  function _(E) {
    h.push(
      `
` + "  ".repeat(E),
      0
      /* Start */
    );
  }
  return h;
}
function _N(e, t = {}) {
  const n = mN(e, t);
  t.onContextCreated && t.onContextCreated(n);
  const {
    mode: s,
    push: r,
    prefixIdentifiers: i,
    indent: o,
    deindent: c,
    newline: l,
    scopeId: f,
    ssr: u
  } = n, a = Array.from(e.helpers), p = a.length > 0, h = !i && s !== "module";
  EN(e, n);
  const E = u ? "ssrRender" : "render", C = (u ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (r(`function ${E}(${C}) {`), o(), h && (r("with (_ctx) {"), o(), p && (r(
    `const { ${a.map(sd).join(", ")} } = _Vue
`,
    -1
    /* End */
  ), l())), e.components.length && (mo(e.components, "component", n), (e.directives.length || e.temps > 0) && l()), e.directives.length && (mo(e.directives, "directive", n), e.temps > 0 && l()), e.filters && e.filters.length && (l(), mo(e.filters, "filter", n), l()), e.temps > 0) {
    r("let ");
    for (let D = 0; D < e.temps; D++)
      r(`${D > 0 ? ", " : ""}_temp${D}`);
  }
  return (e.components.length || e.directives.length || e.temps) && (r(
    `
`,
    0
    /* Start */
  ), l()), u || r("return "), e.codegenNode ? Ue(e.codegenNode, n) : r("null"), h && (c(), r("}")), c(), r("}"), {
    ast: e,
    code: n.code,
    preamble: "",
    map: n.map ? n.map.toJSON() : void 0
  };
}
function EN(e, t) {
  const {
    ssr: n,
    prefixIdentifiers: s,
    push: r,
    newline: i,
    runtimeModuleName: o,
    runtimeGlobalName: c,
    ssrRuntimeModuleName: l
  } = t, f = c, u = Array.from(e.helpers);
  if (u.length > 0 && (r(
    `const _Vue = ${f}
`,
    -1
    /* End */
  ), e.hoists.length)) {
    const a = [
      Kc,
      Wc,
      pr,
      qc,
      Fp
    ].filter((p) => u.includes(p)).map(sd).join(", ");
    r(
      `const { ${a} } = _Vue
`,
      -1
      /* End */
    );
  }
  yN(e.hoists, t), i(), r("return ");
}
function mo(e, t, { helper: n, push: s, newline: r, isTS: i }) {
  const o = n(
    t === "filter" ? Yc : t === "component" ? Gc : Jc
  );
  for (let c = 0; c < e.length; c++) {
    let l = e[c];
    const f = l.endsWith("__self");
    f && (l = l.slice(0, -6)), s(
      `const ${ir(l, t)} = ${o}(${JSON.stringify(l)}${f ? ", true" : ""})${i ? "!" : ""}`
    ), c < e.length - 1 && r();
  }
}
function yN(e, t) {
  if (!e.length)
    return;
  t.pure = true;
  const { push: n, newline: s } = t;
  s();
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i && (n(`const _hoisted_${r + 1} = `), Ue(i, t), s());
  }
  t.pure = false;
}
function vN(e) {
  return X(e) || e.type === 4 || e.type === 2 || e.type === 5 || e.type === 8;
}
function ll(e, t) {
  const n = e.length > 3 || e.some((s) => F(s) || !vN(s));
  t.push("["), n && t.indent(), hr(e, t, n), n && t.deindent(), t.push("]");
}
function hr(e, t, n = false, s = true) {
  const { push: r, newline: i } = t;
  for (let o = 0; o < e.length; o++) {
    const c = e[o];
    X(c) ? r(
      c,
      -3
      /* Unknown */
    ) : F(c) ? ll(c, t) : Ue(c, t), o < e.length - 1 && (n ? (s && r(","), i()) : s && r(", "));
  }
}
function Ue(e, t) {
  if (X(e)) {
    t.push(
      e,
      -3
      /* Unknown */
    );
    return;
  }
  if (nt(e)) {
    t.push(t.helper(e));
    return;
  }
  switch (e.type) {
    case 1:
    case 9:
    case 11:
      wa(
        e.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), Ue(e.codegenNode, t);
      break;
    case 2:
      NN(e, t);
      break;
    case 4:
      rd(e, t);
      break;
    case 5:
      bN(e, t);
      break;
    case 12:
      Ue(e.codegenNode, t);
      break;
    case 8:
      id(e, t);
      break;
    case 3:
      SN(e, t);
      break;
    case 13:
      TN(e, t);
      break;
    case 14:
      wN(e, t);
      break;
    case 15:
      CN(e, t);
      break;
    case 17:
      VN(e, t);
      break;
    case 18:
      AN(e, t);
      break;
    case 19:
      xN(e, t);
      break;
    case 20:
      IN(e, t);
      break;
    case 21:
      hr(e.body, t, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true)
        return wa(false, `unhandled codegen node type: ${e.type}`), e;
  }
}
function NN(e, t) {
  t.push(JSON.stringify(e.content), -3, e);
}
function rd(e, t) {
  const { content: n, isStatic: s } = e;
  t.push(
    s ? JSON.stringify(n) : n,
    -3,
    e
  );
}
function bN(e, t) {
  const { push: n, helper: s, pure: r } = t;
  r && n(Gi), n(`${s(Wi)}(`), Ue(e.content, t), n(")");
}
function id(e, t) {
  for (let n = 0; n < e.children.length; n++) {
    const s = e.children[n];
    X(s) ? t.push(
      s,
      -3
      /* Unknown */
    ) : Ue(s, t);
  }
}
function ON(e, t) {
  const { push: n } = t;
  if (e.type === 8)
    n("["), id(e, t), n("]");
  else if (e.isStatic) {
    const s = ol(e.content) ? e.content : JSON.stringify(e.content);
    n(s, -2, e);
  } else
    n(`[${e.content}]`, -3, e);
}
function SN(e, t) {
  const { push: n, helper: s, pure: r } = t;
  r && n(Gi), n(
    `${s(pr)}(${JSON.stringify(e.content)})`,
    -3,
    e
  );
}
function TN(e, t) {
  const { push: n, helper: s, pure: r } = t, {
    tag: i,
    props: o,
    children: c,
    patchFlag: l,
    dynamicProps: f,
    directives: u,
    isBlock: a,
    disableTracking: p,
    isComponent: h
  } = e;
  let _;
  if (l)
    if (true)
      if (l < 0)
        _ = l + ` /* ${$s[l]} */`;
      else {
        const M = Object.keys($s).map(Number).filter((C) => C > 0 && l & C).map((C) => $s[C]).join(", ");
        _ = l + ` /* ${M} */`;
      }
    else
      _ = String(l);
  u && n(s(Xc) + "("), a && n(`(${s(Fn)}(${p ? "true" : ""}), `), r && n(Gi);
  const E = a ? ds(t.inSSR, h) : ps(t.inSSR, h);
  n(s(E) + "(", -2, e), hr(
    DN([i, o, c, _, f]),
    t
  ), n(")"), a && n(")"), u && (n(", "), Ue(u, t), n(")"));
}
function DN(e) {
  let t = e.length;
  for (; t-- && e[t] == null; )
    ;
  return e.slice(0, t + 1).map((n) => n || "null");
}
function wN(e, t) {
  const { push: n, helper: s, pure: r } = t, i = X(e.callee) ? e.callee : s(e.callee);
  r && n(Gi), n(i + "(", -2, e), hr(e.arguments, t), n(")");
}
function CN(e, t) {
  const { push: n, indent: s, deindent: r, newline: i } = t, { properties: o } = e;
  if (!o.length) {
    n("{}", -2, e);
    return;
  }
  const c = o.length > 1 || o.some((l) => l.value.type !== 4);
  n(c ? "{" : "{ "), c && s();
  for (let l = 0; l < o.length; l++) {
    const { key: f, value: u } = o[l];
    ON(f, t), n(": "), Ue(u, t), l < o.length - 1 && (n(","), i());
  }
  c && r(), n(c ? "}" : " }");
}
function VN(e, t) {
  ll(e.elements, t);
}
function AN(e, t) {
  const { push: n, indent: s, deindent: r } = t, { params: i, returns: o, body: c, newline: l, isSlot: f } = e;
  f && n(`_${fs[nl]}(`), n("(", -2, e), F(i) ? hr(i, t) : i && Ue(i, t), n(") => "), (l || c) && (n("{"), s()), o ? (l && n("return "), F(o) ? ll(o, t) : Ue(o, t)) : c && Ue(c, t), (l || c) && (r(), n("}")), f && (e.isNonScopedSlot && n(", undefined, true"), n(")"));
}
function xN(e, t) {
  const { test: n, consequent: s, alternate: r, newline: i } = e, { push: o, indent: c, deindent: l, newline: f } = t;
  if (n.type === 4) {
    const a = !ol(n.content);
    a && o("("), rd(n, t), a && o(")");
  } else
    o("("), Ue(n, t), o(")");
  i && c(), t.indentLevel++, i || o(" "), o("? "), Ue(s, t), t.indentLevel--, i && f(), i || o(" "), o(": ");
  const u = r.type === 19;
  u || t.indentLevel++, Ue(r, t), u || t.indentLevel--, i && l(
    true
    /* without newline */
  );
}
function IN(e, t) {
  const { push: n, helper: s, indent: r, deindent: i, newline: o } = t, { needPauseTracking: c, needArraySpread: l } = e;
  l && n("[...("), n(`_cache[${e.index}] || (`), c && (r(), n(`${s(li)}(-1`), e.inVOnce && n(", true"), n("),"), o(), n("(")), n(`_cache[${e.index}] = `), Ue(e.value, t), c && (n(`).cacheIndex = ${e.index},`), o(), n(`${s(li)}(1),`), o(), n(`_cache[${e.index}]`), i()), n(")"), l && n(")]");
}
var PN = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
var RN = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function Sn(e, t, n = false, s = false) {
  const r = e.content;
  if (r.trim())
    try {
      new Function(
        s ? ` ${r} ` : `return ${n ? `(${r}) => {}` : `(${r})`}`
      );
    } catch (i) {
      let o = i.message;
      const c = r.replace(RN, "").match(PN);
      c && (o = `avoid using JavaScript keyword as property name: "${c[0]}"`), t.onError(
        pe(
          45,
          e.loc,
          void 0,
          o
        )
      );
    }
}
var MN = (e, t) => {
  if (e.type === 5)
    e.content = _o(
      e.content,
      t
    );
  else if (e.type === 1) {
    const n = et(e, "memo");
    for (let s = 0; s < e.props.length; s++) {
      const r = e.props[s];
      if (r.type === 7 && r.name !== "for") {
        const i = r.exp, o = r.arg;
        i && i.type === 4 && !(r.name === "on" && o) && // key has been processed in transformFor(vMemo + vFor)
        !(n && o && o.type === 4 && o.content === "key") && (r.exp = _o(
          i,
          t,
          // slot args must be processed as function params
          r.name === "slot"
        )), o && o.type === 4 && !o.isStatic && (r.arg = _o(o, t));
      }
    }
  }
};
function _o(e, t, n = false, s = false, r = Object.create(t.identifiers)) {
  return Sn(e, t, n, s), e;
}
var $N = nd(
  /^(if|else|else-if)$/,
  (e, t, n) => kN(e, t, n, (s, r, i) => {
    const o = n.parent.children;
    let c = o.indexOf(s), l = 0;
    for (; c-- >= 0; ) {
      const f = o[c];
      f && f.type === 9 && (l += f.branches.length);
    }
    return () => {
      if (i)
        s.codegenNode = Ra(
          r,
          l,
          n
        );
      else {
        const f = FN(s.codegenNode);
        f.alternate = Ra(
          r,
          l + s.branches.length - 1,
          n
        );
      }
    };
  })
);
function kN(e, t, n, s) {
  if (t.name !== "else" && (!t.exp || !t.exp.content.trim())) {
    const r = t.exp ? t.exp.loc : e.loc;
    n.onError(
      pe(28, t.loc)
    ), t.exp = ee("true", false, r);
  }
  if (t.exp && Sn(t.exp, n), t.name === "if") {
    const r = Pa(e, t), i = {
      type: 9,
      loc: oN(e.loc),
      branches: [r]
    };
    if (n.replaceNode(i), s)
      return s(i, r, true);
  } else {
    const r = n.parent.children, i = [];
    let o = r.indexOf(e);
    for (; o-- >= -1; ) {
      const c = r[o];
      if (c && c.type === 3) {
        n.removeNode(c), i.unshift(c);
        continue;
      }
      if (c && c.type === 2 && !c.content.trim().length) {
        n.removeNode(c);
        continue;
      }
      if (c && c.type === 9) {
        t.name === "else-if" && c.branches[c.branches.length - 1].condition === void 0 && n.onError(
          pe(30, e.loc)
        ), n.removeNode();
        const l = Pa(e, t);
        if (i.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(n.parent && n.parent.type === 1 && (n.parent.tag === "transition" || n.parent.tag === "Transition")) && (l.children = [...i, ...l.children]), true) {
          const u = l.userKey;
          u && c.branches.forEach(({ userKey: a }) => {
            LN(a, u) && n.onError(
              pe(
                29,
                l.userKey.loc
              )
            );
          });
        }
        c.branches.push(l);
        const f = s && s(c, l, false);
        qi(l, n), f && f(), n.currentNode = null;
      } else
        n.onError(
          pe(30, e.loc)
        );
      break;
    }
  }
}
function Pa(e, t) {
  const n = e.tagType === 3;
  return {
    type: 10,
    loc: e.loc,
    condition: t.name === "else" ? void 0 : t.exp,
    children: n && !et(e, "for") ? e.children : [e],
    userKey: rr(e, "key"),
    isTemplateIf: n
  };
}
function Ra(e, t, n) {
  return e.condition ? Xo(
    e.condition,
    Ma(e, t, n),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    Ae(n.helper(pr), [
      true ? '"v-if"' : '""',
      "true"
    ])
  ) : Ma(e, t, n);
}
function Ma(e, t, n) {
  const { helper: s } = n, r = Oe(
    "key",
    ee(
      `${t}`,
      false,
      ot,
      2
    )
  ), { children: i } = e, o = i[0];
  if (i.length !== 1 || o.type !== 1)
    if (i.length === 1 && o.type === 11) {
      const l = o.codegenNode;
      return di(l, r, n), l;
    } else {
      let l = 64;
      return !e.isTemplateIf && i.filter((f) => f.type !== 3).length === 1 && (l |= 2048), sr(
        n,
        s(tr),
        ft([r]),
        i,
        l,
        void 0,
        void 0,
        true,
        false,
        false,
        e.loc
      );
    }
  else {
    const l = o.codegenNode, f = Jv(l);
    return f.type === 13 && rl(f, n), di(f, r, n), l;
  }
}
function LN(e, t) {
  if (!e || e.type !== t.type)
    return false;
  if (e.type === 6) {
    if (e.value.content !== t.value.content)
      return false;
  } else {
    const n = e.exp, s = t.exp;
    if (n.type !== s.type || n.type !== 4 || n.isStatic !== s.isStatic || n.content !== s.content)
      return false;
  }
  return true;
}
function FN(e) {
  for (; ; )
    if (e.type === 19)
      if (e.alternate.type === 19)
        e = e.alternate;
      else
        return e;
    else e.type === 20 && (e = e.value);
}
var HN = (e, t, n) => {
  const { modifiers: s, loc: r } = e, i = e.arg;
  let { exp: o } = e;
  if (o && o.type === 4 && !o.content.trim() && (o = void 0), !o) {
    if (i.type !== 4 || !i.isStatic)
      return n.onError(
        pe(
          52,
          i.loc
        )
      ), {
        props: [
          Oe(i, ee("", true, r))
        ]
      };
    od(e), o = e.exp;
  }
  return i.type !== 4 ? (i.children.unshift("("), i.children.push(') || ""')) : i.isStatic || (i.content = i.content ? `${i.content} || ""` : '""'), s.some((c) => c.content === "camel") && (i.type === 4 ? i.isStatic ? i.content = de(i.content) : i.content = `${n.helperString(Jo)}(${i.content})` : (i.children.unshift(`${n.helperString(Jo)}(`), i.children.push(")"))), n.inSSR || (s.some((c) => c.content === "prop") && $a(i, "."), s.some((c) => c.content === "attr") && $a(i, "^")), {
    props: [Oe(i, o)]
  };
};
var od = (e, t) => {
  const n = e.arg, s = de(n.content);
  e.exp = ee(s, false, n.loc);
};
var $a = (e, t) => {
  e.type === 4 ? e.isStatic ? e.content = t + e.content : e.content = `\`${t}\${${e.content}}\`` : (e.children.unshift(`'${t}' + (`), e.children.push(")"));
};
var jN = nd(
  "for",
  (e, t, n) => {
    const { helper: s, removeHelper: r } = n;
    return UN(e, t, n, (i) => {
      const o = Ae(s(Zc), [
        i.source
      ]), c = ui(e), l = et(e, "memo"), f = rr(e, "key", false, true);
      f && f.type === 7 && !f.exp && od(f);
      let a = f && (f.type === 6 ? f.value ? ee(f.value.content, true) : void 0 : f.exp);
      const p = f && a ? Oe("key", a) : null, h = i.source.type === 4 && i.source.constType > 0, _ = h ? 64 : f ? 128 : 256;
      return i.codegenNode = sr(
        n,
        s(tr),
        void 0,
        o,
        _,
        void 0,
        void 0,
        true,
        !h,
        false,
        e.loc
      ), () => {
        let E;
        const { children: M } = i;
        c && e.children.some((g) => {
          if (g.type === 1) {
            const N = rr(g, "key");
            if (N)
              return n.onError(
                pe(
                  33,
                  N.loc
                )
              ), true;
          }
        });
        const C = M.length !== 1 || M[0].type !== 1, D = pi(e) ? e : c && e.children.length === 1 && pi(e.children[0]) ? e.children[0] : null;
        if (D ? (E = D.codegenNode, c && p && di(E, p, n)) : C ? E = sr(
          n,
          s(tr),
          p ? ft([p]) : void 0,
          e.children,
          64,
          void 0,
          void 0,
          true,
          void 0,
          false
        ) : (E = M[0].codegenNode, c && p && di(E, p, n), E.isBlock !== !h && (E.isBlock ? (r(Fn), r(
          ds(n.inSSR, E.isComponent)
        )) : r(
          ps(n.inSSR, E.isComponent)
        )), E.isBlock = !h, E.isBlock ? (s(Fn), s(ds(n.inSSR, E.isComponent))) : s(ps(n.inSSR, E.isComponent))), l) {
          const g = us(
            tc(i.parseResult, [
              ee("_cached")
            ])
          );
          g.body = Rv([
            bt(["const _memo = (", l.exp, ")"]),
            bt([
              "if (_cached",
              ...a ? [" && _cached.key === ", a] : [],
              ` && ${n.helperString(
                Up
              )}(_cached, _memo)) return _cached`
            ]),
            bt(["const _item = ", E]),
            ee("_item.memo = _memo"),
            ee("return _item")
          ]), o.arguments.push(
            g,
            ee("_cache"),
            ee(String(n.cached.length))
          ), n.cached.push(null);
        } else
          o.arguments.push(
            us(
              tc(i.parseResult),
              E,
              true
            )
          );
      };
    });
  }
);
function UN(e, t, n, s) {
  if (!t.exp) {
    n.onError(
      pe(31, t.loc)
    );
    return;
  }
  const r = t.forParseResult;
  if (!r) {
    n.onError(
      pe(32, t.loc)
    );
    return;
  }
  cd(r, n);
  const { addIdentifiers: i, removeIdentifiers: o, scopes: c } = n, { source: l, value: f, key: u, index: a } = r, p = {
    type: 11,
    loc: t.loc,
    source: l,
    valueAlias: f,
    keyAlias: u,
    objectIndexAlias: a,
    parseResult: r,
    children: ui(e) ? e.children : [e]
  };
  n.replaceNode(p), c.vFor++;
  const h = s && s(p);
  return () => {
    c.vFor--, h && h();
  };
}
function cd(e, t) {
  e.finalized || (Sn(e.source, t), e.key && Sn(
    e.key,
    t,
    true
  ), e.index && Sn(
    e.index,
    t,
    true
  ), e.value && Sn(
    e.value,
    t,
    true
  ), e.finalized = true);
}
function tc({ value: e, key: t, index: n }, s = []) {
  return BN([e, t, n, ...s]);
}
function BN(e) {
  let t = e.length;
  for (; t-- && !e[t]; )
    ;
  return e.slice(0, t + 1).map((n, s) => n || ee("_".repeat(s + 1), false));
}
var ka = ee("undefined", false);
var KN = (e, t) => {
  if (e.type === 1 && (e.tagType === 1 || e.tagType === 3)) {
    const n = et(e, "slot");
    if (n)
      return n.exp, t.scopes.vSlot++, () => {
        t.scopes.vSlot--;
      };
  }
};
var WN = (e, t, n, s) => us(
  e,
  n,
  false,
  true,
  n.length ? n[0].loc : s
);
function qN(e, t, n = WN) {
  t.helper(nl);
  const { children: s, loc: r } = e, i = [], o = [];
  let c = t.scopes.vSlot > 0 || t.scopes.vFor > 0;
  const l = et(e, "slot", true);
  if (l) {
    const { arg: M, exp: C } = l;
    M && !tt(M) && (c = true), i.push(
      Oe(
        M || ee("default", true),
        n(C, void 0, s, r)
      )
    );
  }
  let f = false, u = false;
  const a = [], p = /* @__PURE__ */ new Set();
  let h = 0;
  for (let M = 0; M < s.length; M++) {
    const C = s[M];
    let D;
    if (!ui(C) || !(D = et(C, "slot", true))) {
      C.type !== 3 && a.push(C);
      continue;
    }
    if (l) {
      t.onError(
        pe(37, D.loc)
      );
      break;
    }
    f = true;
    const { children: g, loc: N } = C, {
      arg: y = ee("default", true),
      exp: w,
      loc: H
    } = D;
    let V;
    tt(y) ? V = y ? y.content : "default" : c = true;
    const v = et(C, "for"), S = n(w, v, g, N);
    let R, b;
    if (R = et(C, "if"))
      c = true, o.push(
        Xo(
          R.exp,
          Tr(y, S, h++),
          ka
        )
      );
    else if (b = et(
      C,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let L = M, W;
      for (; L-- && (W = s[L], !(W.type !== 3 && nc(W))); )
        ;
      if (W && ui(W) && et(W, /^(else-)?if$/)) {
        let q = o[o.length - 1];
        for (; q.alternate.type === 19; )
          q = q.alternate;
        q.alternate = b.exp ? Xo(
          b.exp,
          Tr(
            y,
            S,
            h++
          ),
          ka
        ) : Tr(y, S, h++);
      } else
        t.onError(
          pe(30, b.loc)
        );
    } else if (v) {
      c = true;
      const L = v.forParseResult;
      L ? (cd(L, t), o.push(
        Ae(t.helper(Zc), [
          L.source,
          us(
            tc(L),
            Tr(y, S),
            true
          )
        ])
      )) : t.onError(
        pe(
          32,
          v.loc
        )
      );
    } else {
      if (V) {
        if (p.has(V)) {
          t.onError(
            pe(
              38,
              H
            )
          );
          continue;
        }
        p.add(V), V === "default" && (u = true);
      }
      i.push(Oe(y, S));
    }
  }
  if (!l) {
    const M = (C, D) => {
      const g = n(C, void 0, D, r);
      return t.compatConfig && (g.isNonScopedSlot = true), Oe("default", g);
    };
    f ? a.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    a.some((C) => nc(C)) && (u ? t.onError(
      pe(
        39,
        a[0].loc
      )
    ) : i.push(
      M(void 0, a)
    )) : i.push(M(void 0, s));
  }
  const _ = c ? 2 : $r(e.children) ? 3 : 1;
  let E = ft(
    i.concat(
      Oe(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        ee(
          _ + (true ? ` /* ${lm[_]} */` : ""),
          false
        )
      )
    ),
    r
  );
  return o.length && (E = Ae(t.helper(jp), [
    E,
    In(o)
  ])), {
    slots: E,
    hasDynamicSlots: c
  };
}
function Tr(e, t, n) {
  const s = [
    Oe("name", e),
    Oe("fn", t)
  ];
  return n != null && s.push(
    Oe("key", ee(String(n), true))
  ), ft(s);
}
function $r(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    switch (n.type) {
      case 1:
        if (n.tagType === 2 || $r(n.children))
          return true;
        break;
      case 9:
        if ($r(n.branches)) return true;
        break;
      case 10:
      case 11:
        if ($r(n.children)) return true;
        break;
    }
  }
  return false;
}
function nc(e) {
  return e.type !== 2 && e.type !== 12 ? true : e.type === 2 ? !!e.content.trim() : nc(e.content);
}
var ld = /* @__PURE__ */ new WeakMap();
var GN = (e, t) => function() {
  if (e = t.currentNode, !(e.type === 1 && (e.tagType === 0 || e.tagType === 1)))
    return;
  const { tag: s, props: r } = e, i = e.tagType === 1;
  let o = i ? zN(e, t) : `"${s}"`;
  const c = ie(o) && o.callee === zc;
  let l, f, u = 0, a, p, h, _ = (
    // dynamic component may resolve to plain elements
    c || o === Ws || o === Bc || !i && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (s === "svg" || s === "foreignObject" || s === "math")
  );
  if (r.length > 0) {
    const E = ad(
      e,
      t,
      void 0,
      i,
      c
    );
    l = E.props, u = E.patchFlag, p = E.dynamicPropNames;
    const M = E.directives;
    h = M && M.length ? In(
      M.map((C) => YN(C, t))
    ) : void 0, E.shouldUseBlock && (_ = true);
  }
  if (e.children.length > 0)
    if (o === oi && (_ = true, u |= 1024, e.children.length > 1 && t.onError(
      pe(46, {
        start: e.children[0].loc.start,
        end: e.children[e.children.length - 1].loc.end,
        source: ""
      })
    )), i && // Teleport is not a real component and has dedicated runtime handling
    o !== Ws && // explained above.
    o !== oi) {
      const { slots: M, hasDynamicSlots: C } = qN(e, t);
      f = M, C && (u |= 1024);
    } else if (e.children.length === 1 && o !== Ws) {
      const M = e.children[0], C = M.type, D = C === 5 || C === 8;
      D && it(M, t) === 0 && (u |= 1), D || C === 2 ? f = M : f = e.children;
    } else
      f = e.children;
  p && p.length && (a = XN(p)), e.codegenNode = sr(
    t,
    o,
    l,
    f,
    u === 0 ? void 0 : u,
    a,
    h,
    !!_,
    false,
    i,
    e.loc
  );
};
function zN(e, t, n = false) {
  let { tag: s } = e;
  const r = sc(s), i = rr(
    e,
    "is",
    false,
    true
    /* allow empty */
  );
  if (i)
    if (r || pn(
      "COMPILER_IS_ON_ELEMENT",
      t
    )) {
      let c;
      if (i.type === 6 ? c = i.value && ee(i.value.content, true) : (c = i.exp, c || (c = ee("is", false, i.arg.loc))), c)
        return Ae(t.helper(zc), [
          c
        ]);
    } else i.type === 6 && i.value.content.startsWith("vue:") && (s = i.value.content.slice(4));
  const o = Kp(s) || t.isBuiltInComponent(s);
  return o ? (n || t.helper(o), o) : (t.helper(Gc), t.components.add(s), ir(s, "component"));
}
function ad(e, t, n = e.props, s, r, i = false) {
  const { tag: o, loc: c, children: l } = e;
  let f = [];
  const u = [], a = [], p = l.length > 0;
  let h = false, _ = 0, E = false, M = false, C = false, D = false, g = false, N = false;
  const y = [], w = (S) => {
    f.length && (u.push(
      ft(La(f), c)
    ), f = []), S && u.push(S);
  }, H = () => {
    t.scopes.vFor > 0 && f.push(
      Oe(
        ee("ref_for", true),
        ee("true")
      )
    );
  }, V = ({ key: S, value: R }) => {
    if (tt(S)) {
      const b = S.content, L = Wt(b);
      if (L && (!s || r) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      b.toLowerCase() !== "onclick" && // omit v-model handlers
      b !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !ln(b) && (D = true), L && ln(b) && (N = true), L && R.type === 14 && (R = R.arguments[0]), R.type === 20 || (R.type === 4 || R.type === 8) && it(R, t) > 0)
        return;
      b === "ref" ? E = true : b === "class" ? M = true : b === "style" ? C = true : b !== "key" && !y.includes(b) && y.push(b), s && (b === "class" || b === "style") && !y.includes(b) && y.push(b);
    } else
      g = true;
  };
  for (let S = 0; S < n.length; S++) {
    const R = n[S];
    if (R.type === 6) {
      const { loc: b, name: L, nameLoc: W, value: q } = R;
      let K = true;
      if (L === "ref" && (E = true, H()), L === "is" && (sc(o) || q && q.content.startsWith("vue:") || pn(
        "COMPILER_IS_ON_ELEMENT",
        t
      )))
        continue;
      f.push(
        Oe(
          ee(L, true, W),
          ee(
            q ? q.content : "",
            K,
            q ? q.loc : b
          )
        )
      );
    } else {
      const { name: b, arg: L, exp: W, loc: q, modifiers: K } = R, z = b === "bind", B = b === "on";
      if (b === "slot") {
        s || t.onError(
          pe(40, q)
        );
        continue;
      }
      if (b === "once" || b === "memo" || b === "is" || z && cn(L, "is") && (sc(o) || pn(
        "COMPILER_IS_ON_ELEMENT",
        t
      )) || B && i)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (z && cn(L, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        B && p && cn(L, "vue:before-update")) && (h = true), z && cn(L, "ref") && H(), !L && (z || B)
      ) {
        if (g = true, W)
          if (z) {
            if (w(), u.some((ct) => ct.type === 15 ? ct.properties.some(({ key: lt }) => lt.type !== 4 || !lt.isStatic ? true : lt.content !== "class" && lt.content !== "style" && !Wt(lt.content)) : true) && hs(
              "COMPILER_V_BIND_OBJECT_ORDER",
              t,
              q
            ), pn(
              "COMPILER_V_BIND_OBJECT_ORDER",
              t
            )) {
              u.unshift(W);
              continue;
            }
            H(), w(), u.push(W);
          } else
            w({
              type: 14,
              loc: q,
              callee: t.helper(tl),
              arguments: s ? [W] : [W, "true"]
            });
        else
          t.onError(
            pe(
              z ? 34 : 35,
              q
            )
          );
        continue;
      }
      z && K.some((Je) => Je.content === "prop") && (_ |= 32);
      const fe = t.directiveTransforms[b];
      if (fe) {
        const { props: Je, needRuntime: ct } = fe(R, e, t);
        !i && Je.forEach(V), B && L && !tt(L) ? w(ft(Je, c)) : f.push(...Je), ct && (a.push(R), nt(ct) && ld.set(R, ct));
      } else _f(b) || (a.push(R), p && (h = true));
    }
  }
  let v;
  if (u.length ? (w(), u.length > 1 ? v = Ae(
    t.helper(ci),
    u,
    c
  ) : v = u[0]) : f.length && (v = ft(
    La(f),
    c
  )), g ? _ |= 16 : (M && !s && (_ |= 2), C && !s && (_ |= 4), y.length && (_ |= 8), D && (_ |= 32)), !h && (_ === 0 || _ === 32) && (E || N || a.length > 0) && (_ |= 512), !t.inSSR && v)
    switch (v.type) {
      case 15:
        let S = -1, R = -1, b = false;
        for (let q = 0; q < v.properties.length; q++) {
          const K = v.properties[q].key;
          tt(K) ? K.content === "class" ? S = q : K.content === "style" && (R = q) : K.isHandlerKey || (b = true);
        }
        const L = v.properties[S], W = v.properties[R];
        b ? v = Ae(
          t.helper(nr),
          [v]
        ) : (L && !tt(L.value) && (L.value = Ae(
          t.helper(Qc),
          [L.value]
        )), W && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (C || W.value.type === 4 && W.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        W.value.type === 17) && (W.value = Ae(
          t.helper(el),
          [W.value]
        )));
        break;
      case 14:
        break;
      default:
        v = Ae(
          t.helper(nr),
          [
            Ae(t.helper(dr), [
              v
            ])
          ]
        );
        break;
    }
  return {
    props: v,
    directives: a,
    patchFlag: _,
    dynamicPropNames: y,
    shouldUseBlock: h
  };
}
function La(e) {
  const t = /* @__PURE__ */ new Map(), n = [];
  for (let s = 0; s < e.length; s++) {
    const r = e[s];
    if (r.key.type === 8 || !r.key.isStatic) {
      n.push(r);
      continue;
    }
    const i = r.key.content, o = t.get(i);
    o ? (i === "style" || i === "class" || Wt(i)) && JN(o, r) : (t.set(i, r), n.push(r));
  }
  return n;
}
function JN(e, t) {
  e.value.type === 17 ? e.value.elements.push(t.value) : e.value = In(
    [e.value, t.value],
    e.loc
  );
}
function YN(e, t) {
  const n = [], s = ld.get(e);
  s ? n.push(t.helperString(s)) : (t.helper(Jc), t.directives.add(e.name), n.push(ir(e.name, "directive")));
  const { loc: r } = e;
  if (e.exp && n.push(e.exp), e.arg && (e.exp || n.push("void 0"), n.push(e.arg)), Object.keys(e.modifiers).length) {
    e.arg || (e.exp || n.push("void 0"), n.push("void 0"));
    const i = ee("true", false, r);
    n.push(
      ft(
        e.modifiers.map(
          (o) => Oe(o, i)
        ),
        r
      )
    );
  }
  return In(n, e.loc);
}
function XN(e) {
  let t = "[";
  for (let n = 0, s = e.length; n < s; n++)
    t += JSON.stringify(e[n]), n < s - 1 && (t += ", ");
  return t + "]";
}
function sc(e) {
  return e === "component" || e === "Component";
}
var ZN = (e, t) => {
  if (pi(e)) {
    const { children: n, loc: s } = e, { slotName: r, slotProps: i } = QN(e, t), o = [
      t.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      r,
      "{}",
      "undefined",
      "true"
    ];
    let c = 2;
    i && (o[2] = i, c = 3), n.length && (o[3] = us([], n, false, false, s), c = 4), t.scopeId && !t.slotted && (c = 5), o.splice(c), e.codegenNode = Ae(
      t.helper(Hp),
      o,
      s
    );
  }
};
function QN(e, t) {
  let n = '"default"', s;
  const r = [];
  for (let i = 0; i < e.props.length; i++) {
    const o = e.props[i];
    if (o.type === 6)
      o.value && (o.name === "name" ? n = JSON.stringify(o.value.content) : (o.name = de(o.name), r.push(o)));
    else if (o.name === "bind" && cn(o.arg, "name")) {
      if (o.exp)
        n = o.exp;
      else if (o.arg && o.arg.type === 4) {
        const c = de(o.arg.content);
        n = o.exp = ee(c, false, o.arg.loc);
      }
    } else
      o.name === "bind" && o.arg && tt(o.arg) && (o.arg.content = de(o.arg.content)), r.push(o);
  }
  if (r.length > 0) {
    const { props: i, directives: o } = ad(
      e,
      t,
      r,
      false,
      false
    );
    s = i, o.length && t.onError(
      pe(
        36,
        o[0].loc
      )
    );
  }
  return {
    slotName: n,
    slotProps: s
  };
}
var fd = (e, t, n, s) => {
  const { loc: r, modifiers: i, arg: o } = e;
  !e.exp && !i.length && n.onError(pe(35, r));
  let c;
  if (o.type === 4)
    if (o.isStatic) {
      let a = o.content;
      a.startsWith("vnode") && n.onError(pe(51, o.loc)), a.startsWith("vue:") && (a = `vnode-${a.slice(4)}`);
      const p = t.tagType !== 0 || a.startsWith("vnode") || !/[A-Z]/.test(a) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        At(de(a))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${a}`
      );
      c = ee(p, true, o.loc);
    } else
      c = bt([
        `${n.helperString(Yo)}(`,
        o,
        ")"
      ]);
  else
    c = o, c.children.unshift(`${n.helperString(Yo)}(`), c.children.push(")");
  let l = e.exp;
  l && !l.content.trim() && (l = void 0);
  let f = n.cacheHandlers && !l && !n.inVOnce;
  if (l) {
    const a = qp(l), p = !(a || Wv(l)), h = l.content.includes(";");
    Sn(
      l,
      n,
      false,
      h
    ), (p || f && a) && (l = bt([
      `${p ? "$event" : "(...args)"} => ${h ? "{" : "("}`,
      l,
      h ? "}" : ")"
    ]));
  }
  let u = {
    props: [
      Oe(
        c,
        l || ee("() => {}", false, r)
      )
    ]
  };
  return s && (u = s(u)), f && (u.props[0].value = n.cache(u.props[0].value)), u.props.forEach((a) => a.key.isHandlerKey = true), u;
};
var eb = (e, t) => {
  if (e.type === 0 || e.type === 1 || e.type === 11 || e.type === 10)
    return () => {
      const n = e.children;
      let s, r = false;
      for (let i = 0; i < n.length; i++) {
        const o = n[i];
        if (go(o)) {
          r = true;
          for (let c = i + 1; c < n.length; c++) {
            const l = n[c];
            if (go(l))
              s || (s = n[i] = bt(
                [o],
                o.loc
              )), s.children.push(" + ", l), n.splice(c, 1), c--;
            else {
              s = void 0;
              break;
            }
          }
        }
      }
      if (!(!r || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      n.length === 1 && (e.type === 0 || e.type === 1 && e.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !e.props.find(
        (i) => i.type === 7 && !t.directiveTransforms[i.name]
      ) && e.tag !== "template")))
        for (let i = 0; i < n.length; i++) {
          const o = n[i];
          if (go(o) || o.type === 8) {
            const c = [];
            (o.type !== 2 || o.content !== " ") && c.push(o), !t.ssr && it(o, t) === 0 && c.push(
              1 + (true ? ` /* ${$s[1]} */` : "")
            ), n[i] = {
              type: 12,
              content: o,
              loc: o.loc,
              codegenNode: Ae(
                t.helper(qc),
                c
              )
            };
          }
        }
    };
};
var Fa = /* @__PURE__ */ new WeakSet();
var tb = (e, t) => {
  if (e.type === 1 && et(e, "once", true))
    return Fa.has(e) || t.inVOnce || t.inSSR ? void 0 : (Fa.add(e), t.inVOnce = true, t.helper(li), () => {
      t.inVOnce = false;
      const n = t.currentNode;
      n.codegenNode && (n.codegenNode = t.cache(
        n.codegenNode,
        true,
        true
      ));
    });
};
var ud = (e, t, n) => {
  const { exp: s, arg: r } = e;
  if (!s)
    return n.onError(
      pe(41, e.loc)
    ), Dr();
  const i = s.loc.source.trim(), o = s.type === 4 ? s.content : i, c = n.bindingMetadata[i];
  if (c === "props" || c === "props-aliased")
    return n.onError(pe(44, s.loc)), Dr();
  if (!o.trim() || !qp(s))
    return n.onError(
      pe(42, s.loc)
    ), Dr();
  const l = r || ee("modelValue", true), f = r ? tt(r) ? `onUpdate:${de(r.content)}` : bt(['"onUpdate:" + ', r]) : "onUpdate:modelValue";
  let u;
  const a = n.isTS ? "($event: any)" : "$event";
  u = bt([
    `${a} => ((`,
    s,
    ") = $event)"
  ]);
  const p = [
    // modelValue: foo
    Oe(l, e.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Oe(f, u)
  ];
  if (e.modifiers.length && t.tagType === 1) {
    const h = e.modifiers.map((E) => E.content).map((E) => (ol(E) ? E : JSON.stringify(E)) + ": true").join(", "), _ = r ? tt(r) ? `${r.content}Modifiers` : bt([r, ' + "Modifiers"']) : "modelModifiers";
    p.push(
      Oe(
        _,
        ee(
          `{ ${h} }`,
          false,
          e.loc,
          2
        )
      )
    );
  }
  return Dr(p);
};
function Dr(e = []) {
  return { props: e };
}
var nb = /[\w).+\-_$\]]/;
var sb = (e, t) => {
  pn("COMPILER_FILTERS", t) && (e.type === 5 ? hi(e.content, t) : e.type === 1 && e.props.forEach((n) => {
    n.type === 7 && n.name !== "for" && n.exp && hi(n.exp, t);
  }));
};
function hi(e, t) {
  if (e.type === 4)
    Ha(e, t);
  else
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n];
      typeof s == "object" && (s.type === 4 ? Ha(s, t) : s.type === 8 ? hi(e, t) : s.type === 5 && hi(s.content, t));
    }
}
function Ha(e, t) {
  const n = e.content;
  let s = false, r = false, i = false, o = false, c = 0, l = 0, f = 0, u = 0, a, p, h, _, E = [];
  for (h = 0; h < n.length; h++)
    if (p = a, a = n.charCodeAt(h), s)
      a === 39 && p !== 92 && (s = false);
    else if (r)
      a === 34 && p !== 92 && (r = false);
    else if (i)
      a === 96 && p !== 92 && (i = false);
    else if (o)
      a === 47 && p !== 92 && (o = false);
    else if (a === 124 && // pipe
    n.charCodeAt(h + 1) !== 124 && n.charCodeAt(h - 1) !== 124 && !c && !l && !f)
      _ === void 0 ? (u = h + 1, _ = n.slice(0, h).trim()) : M();
    else {
      switch (a) {
        case 34:
          r = true;
          break;
        case 39:
          s = true;
          break;
        case 96:
          i = true;
          break;
        case 40:
          f++;
          break;
        case 41:
          f--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          c++;
          break;
        case 125:
          c--;
          break;
      }
      if (a === 47) {
        let C = h - 1, D;
        for (; C >= 0 && (D = n.charAt(C), D === " "); C--)
          ;
        (!D || !nb.test(D)) && (o = true);
      }
    }
  _ === void 0 ? _ = n.slice(0, h).trim() : u !== 0 && M();
  function M() {
    E.push(n.slice(u, h).trim()), u = h + 1;
  }
  if (E.length) {
    for (fi(
      "COMPILER_FILTERS",
      t,
      e.loc
    ), h = 0; h < E.length; h++)
      _ = rb(_, E[h], t);
    e.content = _, e.ast = void 0;
  }
}
function rb(e, t, n) {
  n.helper(Yc);
  const s = t.indexOf("(");
  if (s < 0)
    return n.filters.add(t), `${ir(t, "filter")}(${e})`;
  {
    const r = t.slice(0, s), i = t.slice(s + 1);
    return n.filters.add(r), `${ir(r, "filter")}(${e}${i !== ")" ? "," + i : i}`;
  }
}
var ja = /* @__PURE__ */ new WeakSet();
var ib = (e, t) => {
  if (e.type === 1) {
    const n = et(e, "memo");
    return !n || ja.has(e) ? void 0 : (ja.add(e), () => {
      const s = e.codegenNode || t.currentNode.codegenNode;
      s && s.type === 13 && (e.tagType !== 1 && rl(s, t), e.codegenNode = Ae(t.helper(sl), [
        n.exp,
        us(void 0, s),
        "_cache",
        String(t.cached.length)
      ]), t.cached.push(null));
    });
  }
};
function ob(e) {
  return [
    [
      tb,
      $N,
      ib,
      jN,
      sb,
      ...true ? [MN] : [],
      ZN,
      GN,
      KN,
      eb
    ],
    {
      on: fd,
      bind: HN,
      model: ud
    }
  ];
}
function cb(e, t = {}) {
  const n = t.onError || il, s = t.mode === "module";
  t.prefixIdentifiers === true ? n(pe(47)) : s && n(pe(48));
  const r = false;
  t.cacheHandlers && n(pe(49)), t.scopeId && !s && n(pe(50));
  const i = te({}, t, {
    prefixIdentifiers: r
  }), o = X(e) ? aN(e, i) : e, [c, l] = ob();
  return dN(
    o,
    te({}, i, {
      nodeTransforms: [
        ...c,
        ...t.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: te(
        {},
        l,
        t.directiveTransforms || {}
        // user transforms
      )
    })
  ), _N(o, i);
}
var lb = () => ({ props: [] });
var pd = Symbol(true ? "vModelRadio" : "");
var dd = Symbol(
  true ? "vModelCheckbox" : ""
);
var hd = Symbol(true ? "vModelText" : "");
var gd = Symbol(
  true ? "vModelSelect" : ""
);
var rc = Symbol(
  true ? "vModelDynamic" : ""
);
var md = Symbol(
  true ? "vOnModifiersGuard" : ""
);
var _d = Symbol(
  true ? "vOnKeysGuard" : ""
);
var Ed = Symbol(true ? "vShow" : "");
var al = Symbol(true ? "Transition" : "");
var yd = Symbol(
  true ? "TransitionGroup" : ""
);
xv({
  [pd]: "vModelRadio",
  [dd]: "vModelCheckbox",
  [hd]: "vModelText",
  [gd]: "vModelSelect",
  [rc]: "vModelDynamic",
  [md]: "withModifiers",
  [_d]: "withKeys",
  [Ed]: "vShow",
  [al]: "Transition",
  [yd]: "TransitionGroup"
});
var qn;
function ab(e, t = false) {
  return qn || (qn = document.createElement("div")), t ? (qn.innerHTML = `<div foo="${e.replace(/"/g, "&quot;")}">`, qn.children[0].getAttribute("foo")) : (qn.innerHTML = e, qn.textContent);
}
var fb = {
  parseMode: "html",
  isVoidTag: Nm,
  isNativeTag: (e) => yf(e) || vf(e) || Nf(e),
  isPreTag: (e) => e === "pre",
  isIgnoreNewlineTag: (e) => e === "pre" || e === "textarea",
  decodeEntities: ab,
  isBuiltInComponent: (e) => {
    if (e === "Transition" || e === "transition")
      return al;
    if (e === "TransitionGroup" || e === "transition-group")
      return yd;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(e, t, n) {
    let s = t ? t.ns : n;
    if (t && s === 2)
      if (t.tag === "annotation-xml") {
        if (e === "svg")
          return 1;
        t.props.some(
          (r) => r.type === 6 && r.name === "encoding" && r.value != null && (r.value.content === "text/html" || r.value.content === "application/xhtml+xml")
        ) && (s = 0);
      } else /^m(?:[ions]|text)$/.test(t.tag) && e !== "mglyph" && e !== "malignmark" && (s = 0);
    else t && s === 1 && (t.tag === "foreignObject" || t.tag === "desc" || t.tag === "title") && (s = 0);
    if (s === 0) {
      if (e === "svg")
        return 1;
      if (e === "math")
        return 2;
    }
    return s;
  }
};
var ub = (e) => {
  e.type === 1 && e.props.forEach((t, n) => {
    t.type === 6 && t.name === "style" && t.value && (e.props[n] = {
      type: 7,
      name: "bind",
      arg: ee("style", true, t.loc),
      exp: pb(t.value.content, t.loc),
      modifiers: [],
      loc: t.loc
    });
  });
};
var pb = (e, t) => {
  const n = Ef(e);
  return ee(
    JSON.stringify(n),
    false,
    t,
    3
  );
};
function vt(e, t) {
  return pe(
    e,
    t,
    true ? db : void 0
  );
}
var db = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
};
var hb = (e, t, n) => {
  const { exp: s, loc: r } = e;
  return s || n.onError(
    vt(53, r)
  ), t.children.length && (n.onError(
    vt(54, r)
  ), t.children.length = 0), {
    props: [
      Oe(
        ee("innerHTML", true, r),
        s || ee("", true)
      )
    ]
  };
};
var gb = (e, t, n) => {
  const { exp: s, loc: r } = e;
  return s || n.onError(
    vt(55, r)
  ), t.children.length && (n.onError(
    vt(56, r)
  ), t.children.length = 0), {
    props: [
      Oe(
        ee("textContent", true),
        s ? it(s, n) > 0 ? s : Ae(
          n.helperString(Wi),
          [s],
          r
        ) : ee("", true)
      )
    ]
  };
};
var mb = (e, t, n) => {
  const s = ud(e, t, n);
  if (!s.props.length || t.tagType === 1)
    return s;
  e.arg && n.onError(
    vt(
      58,
      e.arg.loc
    )
  );
  function r() {
    const c = et(t, "bind");
    c && cn(c.arg, "value") && n.onError(
      vt(
        60,
        c.loc
      )
    );
  }
  const { tag: i } = t, o = n.isCustomElement(i);
  if (i === "input" || i === "textarea" || i === "select" || o) {
    let c = hd, l = false;
    if (i === "input" || o) {
      const f = rr(t, "type");
      if (f) {
        if (f.type === 7)
          c = rc;
        else if (f.value)
          switch (f.value.content) {
            case "radio":
              c = pd;
              break;
            case "checkbox":
              c = dd;
              break;
            case "file":
              l = true, n.onError(
                vt(
                  59,
                  e.loc
                )
              );
              break;
            default:
              r();
              break;
          }
      } else qv(t) ? c = rc : r();
    } else i === "select" ? c = gd : r();
    l || (s.needRuntime = n.helper(c));
  } else
    n.onError(
      vt(
        57,
        e.loc
      )
    );
  return s.props = s.props.filter(
    (c) => !(c.key.type === 4 && c.key.content === "modelValue")
  ), s;
};
var _b = Ie("passive,once,capture");
var Eb = Ie(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
);
var yb = Ie("left,right");
var vd = Ie("onkeyup,onkeydown,onkeypress");
var vb = (e, t, n, s) => {
  const r = [], i = [], o = [];
  for (let c = 0; c < t.length; c++) {
    const l = t[c].content;
    l === "native" && hs(
      "COMPILER_V_ON_NATIVE",
      n,
      s
    ) || _b(l) ? o.push(l) : yb(l) ? tt(e) ? vd(e.content.toLowerCase()) ? r.push(l) : i.push(l) : (r.push(l), i.push(l)) : Eb(l) ? i.push(l) : r.push(l);
  }
  return {
    keyModifiers: r,
    nonKeyModifiers: i,
    eventOptionModifiers: o
  };
};
var Ua = (e, t) => tt(e) && e.content.toLowerCase() === "onclick" ? ee(t, true) : e.type !== 4 ? bt([
  "(",
  e,
  `) === "onClick" ? "${t}" : (`,
  e,
  ")"
]) : e;
var Nb = (e, t, n) => fd(e, t, n, (s) => {
  const { modifiers: r } = e;
  if (!r.length) return s;
  let { key: i, value: o } = s.props[0];
  const { keyModifiers: c, nonKeyModifiers: l, eventOptionModifiers: f } = vb(i, r, n, e.loc);
  if (l.includes("right") && (i = Ua(i, "onContextmenu")), l.includes("middle") && (i = Ua(i, "onMouseup")), l.length && (o = Ae(n.helper(md), [
    o,
    JSON.stringify(l)
  ])), c.length && // if event name is dynamic, always wrap with keys guard
  (!tt(i) || vd(i.content.toLowerCase())) && (o = Ae(n.helper(_d), [
    o,
    JSON.stringify(c)
  ])), f.length) {
    const u = f.map(Pt).join("");
    i = tt(i) ? ee(`${i.content}${u}`, true) : bt(["(", i, `) + "${u}"`]);
  }
  return {
    props: [Oe(i, o)]
  };
});
var bb = (e, t, n) => {
  const { exp: s, loc: r } = e;
  return s || n.onError(
    vt(61, r)
  ), {
    props: [],
    needRuntime: n.helper(Ed)
  };
};
var Ob = (e, t) => {
  if (e.type === 1 && e.tagType === 1 && t.isBuiltInComponent(e.tag) === al)
    return () => {
      if (!e.children.length)
        return;
      Nd(e) && t.onError(
        vt(
          62,
          {
            start: e.children[0].loc.start,
            end: e.children[e.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const s = e.children[0];
      if (s.type === 1)
        for (const r of s.props)
          r.type === 7 && r.name === "show" && e.props.push({
            type: 6,
            name: "persisted",
            nameLoc: e.loc,
            value: void 0,
            loc: e.loc
          });
    };
};
function Nd(e) {
  const t = e.children = e.children.filter(
    (s) => s.type !== 3 && !(s.type === 2 && !s.content.trim())
  ), n = t[0];
  return t.length !== 1 || n.type === 11 || n.type === 9 && n.branches.some(Nd);
}
var Sb = (e, t) => {
  e.type === 1 && e.tagType === 0 && (e.tag === "script" || e.tag === "style") && (t.onError(
    vt(
      63,
      e.loc
    )
  ), t.removeNode());
};
function Tb(e, t) {
  return e === "template" ? true : e in Ba ? Ba[e].has(t) : t in Ka ? Ka[t].has(e) : !(e in Wa && Wa[e].has(t) || t in qa && qa[t].has(e));
}
var Gn = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
var vn = /* @__PURE__ */ new Set([]);
var Ba = {
  head: /* @__PURE__ */ new Set([
    "base",
    "basefront",
    "bgsound",
    "link",
    "meta",
    "title",
    "noscript",
    "noframes",
    "style",
    "script",
    "template"
  ]),
  optgroup: /* @__PURE__ */ new Set(["option"]),
  select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
  // table
  table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
  tr: /* @__PURE__ */ new Set(["td", "th"]),
  colgroup: /* @__PURE__ */ new Set(["col"]),
  tbody: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["tr"]),
  tfoot: /* @__PURE__ */ new Set(["tr"]),
  // these elements can not have any children elements
  script: vn,
  iframe: vn,
  option: vn,
  textarea: vn,
  style: vn,
  title: vn
};
var Ka = {
  // sections
  html: vn,
  body: /* @__PURE__ */ new Set(["html"]),
  head: /* @__PURE__ */ new Set(["html"]),
  // table
  td: /* @__PURE__ */ new Set(["tr"]),
  colgroup: /* @__PURE__ */ new Set(["table"]),
  caption: /* @__PURE__ */ new Set(["table"]),
  tbody: /* @__PURE__ */ new Set(["table"]),
  tfoot: /* @__PURE__ */ new Set(["table"]),
  col: /* @__PURE__ */ new Set(["colgroup"]),
  th: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["table"]),
  tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
  // data list
  dd: /* @__PURE__ */ new Set(["dl", "div"]),
  dt: /* @__PURE__ */ new Set(["dl", "div"]),
  // other
  figcaption: /* @__PURE__ */ new Set(["figure"]),
  // li: new Set(["ul", "ol"]),
  summary: /* @__PURE__ */ new Set(["details"]),
  area: /* @__PURE__ */ new Set(["map"])
};
var Wa = {
  p: /* @__PURE__ */ new Set([
    "address",
    "article",
    "aside",
    "blockquote",
    "center",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "fieldset",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "menu",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
  ]),
  svg: /* @__PURE__ */ new Set([
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "menu",
    "meta",
    "ol",
    "p",
    "pre",
    "ruby",
    "s",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "table",
    "u",
    "ul",
    "var"
  ])
};
var qa = {
  a: /* @__PURE__ */ new Set(["a"]),
  button: /* @__PURE__ */ new Set(["button"]),
  dd: /* @__PURE__ */ new Set(["dd", "dt"]),
  dt: /* @__PURE__ */ new Set(["dd", "dt"]),
  form: /* @__PURE__ */ new Set(["form"]),
  li: /* @__PURE__ */ new Set(["li"]),
  h1: Gn,
  h2: Gn,
  h3: Gn,
  h4: Gn,
  h5: Gn,
  h6: Gn
};
var Db = (e, t) => {
  if (e.type === 1 && e.tagType === 0 && t.parent && t.parent.type === 1 && t.parent.tagType === 0 && !Tb(t.parent.tag, e.tag)) {
    const n = new SyntaxError(
      `<${e.tag}> cannot be child of <${t.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
    );
    n.loc = e.loc, t.onWarn(n);
  }
};
var wb = [
  ub,
  ...true ? [Ob, Db] : []
];
var Cb = {
  cloak: lb,
  html: hb,
  text: gb,
  model: mb,
  // override compiler-core
  on: Nb,
  // override compiler-core
  show: bb
};
function Vb(e, t = {}) {
  return cb(
    e,
    te({}, fb, t, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        Sb,
        ...wb,
        ...t.nodeTransforms || []
      ],
      directiveTransforms: te(
        {},
        Cb,
        t.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function Ab() {
  up();
}
Ab();
var Ga = /* @__PURE__ */ Object.create(null);
function bd(e, t) {
  if (!X(e))
    if (e.nodeType)
      e = e.innerHTML;
    else
      return Ne("invalid template option: ", e), me;
  const n = cm(e, t), s = Ga[n];
  if (s)
    return s;
  if (e[0] === "#") {
    const l = document.querySelector(e);
    !l && Ne(`Template element not found or is empty: ${e}`), e = l ? l.innerHTML : "";
  }
  const r = te(
    {
      hoistStatic: true,
      onError: true ? o : void 0,
      onWarn: true ? (l) => o(l, true) : me
    },
    t
  );
  !r.isCustomElement && typeof customElements < "u" && (r.isCustomElement = (l) => !!customElements.get(l));
  const { code: i } = Vb(e, r);
  function o(l, f = false) {
    const u = f ? l.message : `Template compilation error: ${l.message}`, a = l.loc && um(
      e,
      l.loc.start.offset,
      l.loc.end.offset
    );
    Ne(a ? `${u}
${a}` : u);
  }
  const c = new Function("Vue", i)(Tv);
  return c._rc = true, Ga[n] = c;
}
ip(bd);
var gs = {};
var Od = {};
var xb = [
  "onMounted",
  "onUpdated",
  "onUnmounted",
  "onBeforeMount",
  "onBeforeUpdate",
  "onBeforeUnmount",
  "onActivated",
  "onDeactivated"
];
var Ib = (e, t) => {
  Object.entries(t).forEach(([n, s]) => {
    typeof s == "object" && s && Object.entries(s).forEach(([r, i]) => {
      const o = n ? `.${n}` : "", c = `${e}${o}.${r}`;
      gs[c] = i;
    });
  });
};
var Pb = (e, t) => {
  for (const n of xb) {
    const s = t[n];
    if (s) {
      if (typeof s == "function") {
        const r = `${e}.${n}[0]`;
        gs[r] = s;
      }
      Array.isArray(s) && s.forEach((r, i) => {
        if (typeof r == "function") {
          const o = `${e}.${n}[${i}]`;
          gs[o] = r;
        }
      });
    }
  }
};
var Rb = (e, t) => {
  Object.entries(t).forEach(([n, s]) => {
    const r = n ? `.${n}` : "", i = `${e}${r}`;
    Pb(i, s);
  });
};
var Mb = (e, t) => {
  Object.entries(t).forEach(([n, s]) => {
    if (typeof s == "string") {
      const r = n && n !== "''" ? `.${n}` : "", i = `${e}${r}`;
      Od[i] = s;
    }
  });
};
var $b = (e, t) => {
  const { overwrite: n } = t;
  if (typeof n == "object" && n) {
    const { templates: s, lifeCycles: r, methods: i } = n;
    s && Mb(e, s), r && Rb(e, r), i && Ib(e, i);
  }
};
var kb = (e) => {
  Object.prototype.toString.call(e) === "[object Object]" && Object.entries(e).forEach(([t, n]) => {
    typeof n == "object" && n && !isRef(n) && $b(t, n);
  });
};
var Lb = (e) => {
  if (!e)
    throw new Error("请传递正确的注册表");
  kb(e);
};
var EO = (e, t) => {
  const { metaData: n, ctx: s } = t, r = gs[n == null ? void 0 : n.id];
  if (r) {
    const i = r.entry ? r.entry : r;
    if (typeof i == "function")
      return i(s, e);
  }
  return e;
};
var yO = ({ metaData: e, ctx: t }) => {
  var r;
  const n = e == null ? void 0 : e.id, s = (r = gs[n]) == null ? void 0 : r.before;
  s && s(t);
};
var vO = ({ metaData: e, ctx: t }) => {
  var r;
  const n = e == null ? void 0 : e.id, s = (r = gs[n]) == null ? void 0 : r.after;
  s && s(t);
};
var Jn = {
  JAVASCRIPT: "javascript",
  JSON: "json"
};
async function Fb(e) {
  try {
    const n = (await fetch(e, { method: "HEAD" })).headers.get("content-type");
    return n != null && n.includes(Jn.JAVASCRIPT) ? Jn.JAVASCRIPT : n != null && n.includes(Jn.JSON) ? Jn.JSON : "unknown";
  } catch {
    throw new Error("[hotfix registry] file type check failed, source file is not a valid js or json file");
  }
}
var Hb = async (e) => {
  try {
    const t = await Fb(e);
    let n = null;
    return t === Jn.JAVASCRIPT ? n = (await import(
      /* @vite-ignore */
      e
    )).default : t === Jn.JSON && (n = await fetch(e).then((s) => s.json())), n;
  } catch {
    throw new Error("[hotfix registry] fetch registry failed, please check the url is valid");
  }
};
var NO = async ({
  url: e,
  request: t = Hb
}) => {
  try {
    const n = await t(e);
    if (n)
      return Lb(n), n;
  } catch {
    console.warn("[hotfix registry] Failed to load and register registry. Please verify the URL is valid");
  }
};
var jb = (e) => {
  const t = e.trim();
  return t.startsWith("<template>") && t.endsWith("</template>") ? t.slice(10, -11) : t;
};
var bO = ({ component: e, metaData: t }) => {
  const n = Od[t.id];
  if (n) {
    const s = jb(n), r = bd(s);
    e.render = r;
  }
  return e;
};
var gi = null;
var Pn = { "": {} };
var Ub = ({ topic: e, subscriber: t, callback: n } = {}) => {
  var i;
  const s = Pn[""];
  let r = s;
  if (e && typeof e == "string" && typeof n == "function") {
    t && typeof t == "string" && (r = Pn[t] || {}, Pn[t] = r);
    const o = r[e] || [];
    r[e] = o, o.push(n);
    const c = o.lastEvent || ((i = s[e]) == null ? void 0 : i.lastEvent);
    c && n(c.data);
  }
  return { topic: e, subscriber: t };
};
var Bb = ({ topic: e, subscriber: t } = {}) => {
  if (e && typeof e == "string") {
    const n = (s) => {
      const r = Pn[s];
      r && (delete r[e], s && !Object.getOwnPropertyNames(r).length && delete Pn[s]);
    };
    if (t && typeof t == "string") {
      n(t);
      return;
    }
    for (const s of Object.keys(Pn))
      n(s);
  }
};
var ic = ({ topic: e, data: t } = {}) => {
  if (!(!e || typeof e != "string"))
    for (const n of Object.values(Pn)) {
      const s = n[e] || [];
      if (s.length)
        for (const r of s)
          r(t);
      else
        n[e] = s;
      s.lastEvent = { data: t };
    }
};
var Kb = ({ topic: e, data: t }) => {
  e && typeof e == "string" && (gi = { topic: e, data: t }, ic(gi));
};
var OO = () => (gi && ic(gi), {
  subscribe: Ub,
  unsubscribe: Bb,
  publish: ic,
  broadcast: Kb
});
var Sd = /* @__PURE__ */ new Map();
var SO = (e) => {
  if (Array.isArray(e))
    for (const { name: t, component: n } of e)
      Sd.set(t, n);
};
var TO = (e) => Sd.get(e);
var DO = {
  GlobalService: "engine.service.globalService",
  EditorInfo: "engine.service.editorInfo",
  Http: "engine.service.http",
  App: "engine.service.app",
  GenerateCode: "engine.service.generateCode",
  Layout: "engine.service.layout",
  Breadcrumb: "engine.service.breadcrumb",
  SaveLocal: "engine.service.savelocal",
  History: "engine.service.history",
  Resource: "engine.service.resource",
  Material: "engine.service.material",
  Page: "engine.service.page",
  Block: "engine.service.block",
  DataSource: "engine.service.dataSource",
  Translate: "engine.service.translate",
  Help: "engine.service.help",
  Property: "engine.service.property",
  Properties: "engine.service.properties",
  ThemeSwitch: "engine.service.themeSwitch",
  Style: "engine.service.style"
};
var wO = {
  // 画布视图设置工具
  ViewSetting: "engine.toolbars.viewSetting",
  // layout 插件
  Layout: "engine.layout",
  Logo: "engine.toolbars.logo",
  // 面包屑
  Breadcrumb: "engine.toolbars.breadcrumb",
  Media: "engine.toolbars.media",
  Collaboration: "engine.toolbars.collaboration",
  Clean: "engine.toolbars.clean",
  ThemeSwitch: "engine.toolbars.themeSwitch",
  Refresh: "engine.toolbars.refresh",
  Save: "engine.toolbars.save",
  GenerateCode: "engine.toolbars.generate-code",
  Preview: "engine.toolbars.preview",
  RedoUndo: "engine.toolbars.redoundo",
  Fullscreen: "engine.toolbars.fullscreen",
  Lock: "engine.toolbars.lock",
  Setting: "engine.toolbars.setting",
  Lang: "engine.toolbars.lang",
  Block: "engine.plugins.materials.block",
  Component: "engine.plugins.materials.component",
  Materials: "engine.plugins.materials",
  // 大纲树插件
  OutlineTree: "engine.plugins.outlinetree",
  // 页面管理插件
  AppManage: "engine.plugins.appmanage",
  // 区块管理插件
  BlockManage: "engine.plugins.blockmanage",
  // 数据源插件
  Collections: "engine.plugins.collections",
  // 工具类插件
  Bridge: "engine.plugins.bridge",
  // 国际化插件
  I18n: "engine.plugins.i18n",
  // 页面 JS 插件
  Page: "engine.plugins.pagecontroller",
  // 状态管理插件
  State: "engine.plugins.state",
  // 页面 schema 插件
  Schema: "engine.plugins.schema",
  // 新手帮助/帮助文档
  Help: "engine.plugins.editorhelp",
  // AI 插件
  Robot: "engine.plugins.robot",
  // 属性设置面板
  Props: "engine.setting.props",
  // 样式设置面板
  Styles: "engine.setting.styles",
  // 高级属性设置面板（事件、条件渲染、循环渲染）
  Event: "engine.setting.event",
  Container: "engine.canvas.container",
  // 画布
  Canvas: "engine.canvas",
  Tutorial: "engine.plugins.tutorial"
};
var Td = /* @__PURE__ */ new Map();
var CO = (e) => {
  const { id: t, type: n, initialState: s, options: r, init: i, apis: o } = e;
  if (!t || !n)
    throw new Error("Service id and type are required");
  if (n !== "MetaService")
    throw new Error("Invalid service type. Expected: MetaService");
  const c = {
    id: t,
    type: n,
    options: r,
    apis: {}
  }, l = reactive(s || {});
  return typeof o == "object" && o ? c.apis = o : typeof o == "function" && (c.apis = o({ state: l })), c.apis.setOptions = (f) => {
    c.options = df({}, r, f);
  }, c.apis.getState = () => readonly(l), c.apis.setState = (f) => {
    Object.assign(l, f);
  }, Td.set(c.id, {
    state: l,
    init: typeof i == "function" ? i : () => {
    }
  }), c;
};
var VO = () => {
  [...Ut.values()].filter((t) => t.type === "MetaService").forEach((t) => {
    const n = Td.get(t.id);
    if (n) {
      const { state: s, init: r } = n, { options: i } = t;
      r({ state: s, options: i });
    }
  });
};

export {
  ne,
  qb,
  Gb,
  zb,
  Jb,
  Yb,
  Xb,
  Zb,
  Qb,
  eO,
  tO,
  nO,
  sO,
  rO,
  iO,
  oO,
  cO,
  lO,
  aO,
  fO,
  uO,
  nm,
  pO,
  dO,
  hO,
  gO,
  mO,
  _O,
  Lb,
  EO,
  yO,
  vO,
  NO,
  bO,
  OO,
  SO,
  TO,
  DO,
  wO,
  CO,
  VO
};
/*! Bundled license information:

@opentiny/tiny-engine-meta-register/dist/index.js:
  (**
  * @vue/shared v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)
  (**
  * @vue/reactivity v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/runtime-core v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/runtime-dom v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/compiler-core v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/compiler-dom v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * vue v3.5.18
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=chunk-63I4WYGY.js.map
