# TinyEngine 设计器去依赖改造方案

## 项目背景

当前 TinyEngine 设计器（designer-demo）依赖 mockServer 提供接口数据，包括：
- 页面加载数据
- 组件库加载
- 区块加载
- 用户信息获取

目标是将设计器改造为不依赖任何后端接口，通过 VS Code 扩展程序传递数据，实现设计器的独立运行。

## 接口依赖分析

### 1. 核心接口分组

#### platform-center 接口
- **`/platform-center/api/user/me`**
  - 用途：获取登录用户信息
  - 调用位置：`GlobalService` 初始化时
  - 影响：用户头像、权限判断
  - 替代方案：VS Code 扩展返回静态用户对象

#### app-center 接口
- **读取类接口**：
  - `/app-center/api/apps/list/:platformId` - 应用列表
  - `/app-center/api/apps/detail/:id` - 应用详情
  - `/app-center/v1/api/apps/schema/:id` - 应用 Schema（核心）
  - `/app-center/api/pages/list/:appId` - 页面列表
  - `/app-center/api/pages/detail/:id` - 页面详情
  - `/app-center/api/pages/histories` - 页面历史

- **写入类接口**：
  - `/app-center/api/apps/update/:id` - 更新应用
  - `/app-center/api/pages/create|update|copy|delete` - 页面 CRUD
  - `/app-center/api/schema2code` - 代码生成
  - `/app-center/api/apps/publish/:id` - 发布应用

#### material-center 接口
- **区块管理接口**：
  - `/material-center/api/block-groups` - 区块分组
  - `/material-center/api/block?label=...` - 区块查询
  - `/material-center/api/block/detail/:id` - 区块详情
  - `/material-center/api/block/create|update|delete` - 区块 CRUD

### 2. 关键调用位置

#### HTTP 服务统一入口
```javascript
// designer-demo/src/composable/http/index.js
const preRequest = (config) => {
  const isVsCodeEnv = window.vscodeBridge
  if (isVsCodeEnv) {
    config.baseURL = ''  // VS Code 环境下清空 baseURL
  }
  return config
}
```

#### 全局服务初始化
```javascript
// packages/common/composable/defaultGlobalService.ts
const getUserInfo = () => getMetaApi(META_SERVICE.Http).get('/platform-center/api/user/me')
const fetchAppInfo = (appId) => getMetaApi(META_SERVICE.Http).get(`/app-center/api/apps/detail/${appId}`)
const fetchAppList = (platformId) => getMetaApi(META_SERVICE.Http).get(`/app-center/api/apps/list/${platformId}`)
```

#### 物料加载
```javascript
// designer-demo/src/preview.js
'engine.config': {
  id: 'engine.config',
  theme: 'light',
  material: ['/mock/bundle.json']  // 本地物料文件
}
```

## 改造方案

### 1. VS Code 扩展数据提供方案

#### 扩展侧实现
```javascript
// VS Code 扩展中注入 window.vscodeBridge
window.vscodeBridge = {
  request: async ({ url, method, params, data }) => {
    // 路由到本地文件系统操作
    switch (url) {
      case '/platform-center/api/user/me':
        return { id: 'vscode-user', name: 'VS Code User' }
      
      case '/app-center/v1/api/apps/schema/:id':
        return await readAppSchemaFromWorkspace(id)
      
      case '/app-center/api/pages/list/:appId':
        return await readPagesFromWorkspace(appId)
      
      case '/app-center/api/pages/detail/:id':
        return await readPageFromWorkspace(id)
      
      case '/app-center/api/pages/update/:id':
        return await writePageToWorkspace(id, data)
      
      default:
        throw new Error(`Unsupported API: ${url}`)
    }
  }
}
```

#### 前端适配
```javascript
// designer-demo/src/composable/http/index.js
const createVSCodeAdapter = () => {
  return async (config) => {
    if (window.vscodeBridge) {
      const response = await window.vscodeBridge.request({
        url: config.url,
        method: config.method,
        params: config.params,
        data: config.data
      })
      return { data: { data: response } }
    }
    return axios(config)
  }
}

// 在 axios 配置中使用自定义 adapter
const customizeHttpService = () => {
  const options = {
    axiosConfig: {
      ...getConfig(),
      adapter: createVSCodeAdapter()
    },
    interceptors: {
      request: [preRequest],
      response: [[preResponse, errorResponse]]
    }
  }
  HttpService.apis.setOptions(options)
  return HttpService
}
```

### 2. 物料本地化方案

#### 保持现有 bundle.json 机制
```javascript
// designer-demo/engine.config.js
export default {
  id: 'engine.config',
  theme: 'light',
  material: ['/mock/bundle.json']  // 继续使用本地文件
}
```

#### 区块面板本地化
```javascript
// packages/plugins/materials/src/composable/useMaterial.ts
const fetchBlocksFromBundle = () => {
  // 从 bundle.json 解析区块分组，替代接口调用
  const bundle = require('/mock/bundle.json')
  return bundle.blocks || []
}
```

### 3. 插件裁剪方案

#### 隐藏非核心插件
```javascript
// designer-demo/registry.js
export default {
  [META_SERVICE.Http]: HttpService,
  'engine.config': { ...engineConfig },
  
  // 隐藏需要后端接口的插件
  [META_APP.Block]: false,        // 区块管理
  [META_APP.Datasource]: false,   // 数据源管理
  [META_APP.Bridge]: false,       // 桥接管理
  [META_APP.I18n]: false,         // 国际化管理
  [META_APP.Robot]: false,        // 机器人助手
  [META_APP.Help]: false,         // 帮助文档
  
  // 保留核心编辑插件
  [META_APP.Materials]: Materials,
  [META_APP.Page]: Page,
  [META_APP.Schema]: Schema,
  [META_APP.State]: State,
  [META_APP.Script]: Script
}
```

## 实施步骤

### 阶段一：基础适配（1-2天）
1. **实现 VS Code 扩展数据通道**
   - 扩展侧实现 `window.vscodeBridge.request` 方法
   - 支持核心接口路由：`user/me`、`apps/schema/:id`、`pages/*`

2. **前端 HTTP 服务适配**
   - 修改 `designer-demo/src/composable/http/index.js`
   - 添加 VS Code 环境下的自定义 adapter

### 阶段二：插件裁剪（1天）
1. **修改注册表配置**
   - 更新 `designer-demo/registry.js`
   - 隐藏非核心功能插件

2. **验证核心功能**
   - 确保页面编辑、预览、保存功能正常
   - 验证物料加载和组件拖拽

### 阶段三：功能完善（2-3天）
1. **完善本地文件操作**
   - 实现页面文件的读写
   - 实现应用 Schema 的聚合

2. **优化用户体验**
   - 添加加载状态提示
   - 完善错误处理

### 阶段四：测试验证（1-2天）
1. **功能测试**
   - 验证设计器独立运行
   - 测试 VS Code 扩展集成

2. **性能优化**
   - 优化文件读写性能
   - 减少不必要的接口调用

## 技术可行性评估

### ✅ 高可行性
- **现有架构支持**：代码已有 VS Code 环境判断和通道占位
- **HTTP 服务集中**：统一在 `HttpService` 中，便于改造
- **物料本地化**：已支持本地 `bundle.json` 文件

### ⚠️ 中等风险
- **复杂功能依赖**：发布、数据源管理等需要后端逻辑
- **文件格式规范**：需要定义本地文件存储格式
- **插件兼容性**：部分插件可能依赖特定接口

### 🔧 解决方案
- **分阶段实施**：先实现核心功能，复杂功能后续补齐
- **标准化格式**：定义统一的本地文件格式规范
- **插件隔离**：非核心插件在 VS Code 模式下禁用

## 预期效果

### 改造前
- 需要启动 mockServer 服务
- 依赖多个后端接口
- 无法独立运行设计器

### 改造后
- 设计器可独立运行
- 数据由 VS Code 扩展提供
- 支持本地文件系统操作
- 保持核心编辑功能完整

## 文件结构变化

```
designer-demo/
├── src/
│   └── composable/
│       └── http/
│           └── index.js          # 添加 VS Code adapter
├── registry.js                   # 裁剪非核心插件
└── engine.config.js              # 保持本地物料配置

VS Code Extension/
├── src/
│   ├── webview/
│   │   └── designer.html         # 嵌入设计器
│   └── providers/
│       └── dataProvider.ts       # 实现数据提供逻辑
└── package.json
```

## 总结

该改造方案技术可行性强，通过 VS Code 扩展提供数据、前端适配 HTTP 服务、裁剪非核心插件的方式，可以实现设计器的独立运行。改造后的设计器将专注于前端页面编辑功能，数据来源从后端接口改为本地文件系统，更适合 VS Code 扩展的使用场景。

建议按照分阶段实施的方式推进，先实现核心功能，再逐步完善其他特性。
