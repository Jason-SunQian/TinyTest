import Mv from "../config-files/eslint-rule.js";
if (!Mt)
  var Mt = globalThis || window;
var vn = { exports: {} }, Zf;
function Kv() {
  if (Zf) return vn.exports;
  Zf = 1;
  var i = vn.exports = {}, t, o;
  function f() {
    throw new Error("setTimeout has not been defined");
  }
  function r() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? t = setTimeout : t = f;
    } catch {
      t = f;
    }
    try {
      typeof clearTimeout == "function" ? o = clearTimeout : o = r;
    } catch {
      o = r;
    }
  })();
  function u(g) {
    if (t === setTimeout)
      return setTimeout(g, 0);
    if ((t === f || !t) && setTimeout)
      return t = setTimeout, setTimeout(g, 0);
    try {
      return t(g, 0);
    } catch {
      try {
        return t.call(null, g, 0);
      } catch {
        return t.call(this, g, 0);
      }
    }
  }
  function e(g) {
    if (o === clearTimeout)
      return clearTimeout(g);
    if ((o === r || !o) && clearTimeout)
      return o = clearTimeout, clearTimeout(g);
    try {
      return o(g);
    } catch {
      try {
        return o.call(null, g);
      } catch {
        return o.call(this, g);
      }
    }
  }
  var a = [], n = !1, p, m = -1;
  function h() {
    !n || !p || (n = !1, p.length ? a = p.concat(a) : m = -1, a.length && l());
  }
  function l() {
    if (!n) {
      var g = u(h);
      n = !0;
      for (var d = a.length; d; ) {
        for (p = a, a = []; ++m < d; )
          p && p[m].run();
        m = -1, d = a.length;
      }
      p = null, n = !1, e(g);
    }
  }
  i.nextTick = function(g) {
    var d = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var y = 1; y < arguments.length; y++)
        d[y - 1] = arguments[y];
    a.push(new s(g, d)), a.length === 1 && !n && u(l);
  };
  function s(g, d) {
    this.fun = g, this.array = d;
  }
  s.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
  function c() {
  }
  return i.on = c, i.addListener = c, i.once = c, i.off = c, i.removeListener = c, i.removeAllListeners = c, i.emit = c, i.prependListener = c, i.prependOnceListener = c, i.listeners = function(g) {
    return [];
  }, i.binding = function(g) {
    throw new Error("process.binding is not supported");
  }, i.cwd = function() {
    return "/";
  }, i.chdir = function(g) {
    throw new Error("process.chdir is not supported");
  }, i.umask = function() {
    return 0;
  }, vn.exports;
}
function VC(i, t) {
  for (var o = 0, f = i.length - 1; f >= 0; f--) {
    var r = i[f];
    r === "." ? i.splice(f, 1) : r === ".." ? (i.splice(f, 1), o++) : o && (i.splice(f, 1), o--);
  }
  if (t)
    for (; o--; o)
      i.unshift("..");
  return i;
}
var jv = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Bf = function(i) {
  return jv.exec(i).slice(1);
};
function xf() {
  for (var i = "", t = !1, o = arguments.length - 1; o >= -1 && !t; o--) {
    var f = o >= 0 ? arguments[o] : "/";
    if (typeof f != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!f)
      continue;
    i = f + "/" + i, t = f.charAt(0) === "/";
  }
  return i = VC(Pf(i.split("/"), function(r) {
    return !!r;
  }), !t).join("/"), (t ? "/" : "") + i || ".";
}
function MC(i) {
  var t = KC(i), o = Jv(i, -1) === "/";
  return i = VC(Pf(i.split("/"), function(f) {
    return !!f;
  }), !t).join("/"), !i && !t && (i = "."), i && o && (i += "/"), (t ? "/" : "") + i;
}
function KC(i) {
  return i.charAt(0) === "/";
}
function qv() {
  var i = Array.prototype.slice.call(arguments, 0);
  return MC(Pf(i, function(t, o) {
    if (typeof t != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return t;
  }).join("/"));
}
function $v(i, t) {
  i = xf(i).substr(1), t = xf(t).substr(1);
  function o(p) {
    for (var m = 0; m < p.length && p[m] === ""; m++)
      ;
    for (var h = p.length - 1; h >= 0 && p[h] === ""; h--)
      ;
    return m > h ? [] : p.slice(m, h - m + 1);
  }
  for (var f = o(i.split("/")), r = o(t.split("/")), u = Math.min(f.length, r.length), e = u, a = 0; a < u; a++)
    if (f[a] !== r[a]) {
      e = a;
      break;
    }
  for (var n = [], a = e; a < f.length; a++)
    n.push("..");
  return n = n.concat(r.slice(e)), n.join("/");
}
var Gv = "/", Wv = ":";
function Xv(i) {
  var t = Bf(i), o = t[0], f = t[1];
  return !o && !f ? "." : (f && (f = f.substr(0, f.length - 1)), o + f);
}
function zv(i, t) {
  var o = Bf(i)[2];
  return t && o.substr(-1 * t.length) === t && (o = o.substr(0, o.length - t.length)), o;
}
function Hv(i) {
  return Bf(i)[3];
}
var cn = {
  extname: Hv,
  basename: zv,
  dirname: Xv,
  sep: Gv,
  delimiter: Wv,
  relative: $v,
  join: qv,
  isAbsolute: KC,
  normalize: MC,
  resolve: xf
};
function Pf(i, t) {
  if (i.filter) return i.filter(t);
  for (var o = [], f = 0; f < i.length; f++)
    t(i[f], f, i) && o.push(i[f]);
  return o;
}
var Jv = "ab".substr(-1) === "b" ? function(i, t, o) {
  return i.substr(t, o);
} : function(i, t, o) {
  return t < 0 && (t = i.length + t), i.substr(t, o);
}, Wt = {};
Mt.TYPED_ARRAY_SUPPORT !== void 0 && Mt.TYPED_ARRAY_SUPPORT;
function Ur(i) {
  return i != null && (!!i._isBuffer || jC(i) || Qv(i));
}
function jC(i) {
  return !!i.constructor && typeof i.constructor.isBuffer == "function" && i.constructor.isBuffer(i);
}
function Qv(i) {
  return typeof i.readFloatLE == "function" && typeof i.slice == "function" && jC(i.slice(0, 0));
}
Mt.setTimeout;
Mt.clearTimeout;
var Yv = {}, Pr = Mt.performance || {};
Pr.now || Pr.mozNow || Pr.msNow || Pr.oNow || Pr.webkitNow;
var on = {
  env: Yv
}, Rf;
typeof Object.create == "function" ? Rf = function(t, o) {
  t.super_ = o, t.prototype = Object.create(o.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : Rf = function(t, o) {
  t.super_ = o;
  var f = function() {
  };
  f.prototype = o.prototype, t.prototype = new f(), t.prototype.constructor = t;
};
var qC = Rf, Zv = /%[sdj%]/g;
function If(i) {
  if (!pn(i)) {
    for (var t = [], o = 0; o < arguments.length; o++)
      t.push(tr(arguments[o]));
    return t.join(" ");
  }
  for (var o = 1, f = arguments, r = f.length, u = String(i).replace(Zv, function(a) {
    if (a === "%%") return "%";
    if (o >= r) return a;
    switch (a) {
      case "%s":
        return String(f[o++]);
      case "%d":
        return Number(f[o++]);
      case "%j":
        try {
          return JSON.stringify(f[o++]);
        } catch {
          return "[Circular]";
        }
      default:
        return a;
    }
  }), e = f[o]; o < r; e = f[++o])
    fn(e) || !_r(e) ? u += " " + e : u += " " + tr(e);
  return u;
}
function $C(i, t) {
  if (or(Mt.process))
    return function() {
      return $C(i, t).apply(this, arguments);
    };
  if (on.noDeprecation === !0)
    return i;
  var o = !1;
  function f() {
    if (!o) {
      if (on.throwDeprecation)
        throw new Error(t);
      on.traceDeprecation ? console.trace(t) : console.error(t), o = !0;
    }
    return i.apply(this, arguments);
  }
  return f;
}
var Xr = {}, Sn;
function eS(i) {
  if (or(Sn) && (Sn = on.env.NODE_DEBUG || ""), i = i.toUpperCase(), !Xr[i])
    if (new RegExp("\\b" + i + "\\b", "i").test(Sn)) {
      var t = 0;
      Xr[i] = function() {
        var o = If.apply(null, arguments);
        console.error("%s %d: %s", i, t, o);
      };
    } else
      Xr[i] = function() {
      };
  return Xr[i];
}
function tr(i, t) {
  var o = {
    seen: [],
    stylize: rS
  };
  return arguments.length >= 3 && (o.depth = arguments[2]), arguments.length >= 4 && (o.colors = arguments[3]), Ff(t) ? o.showHidden = t : t && XC(o, t), or(o.showHidden) && (o.showHidden = !1), or(o.depth) && (o.depth = 2), or(o.colors) && (o.colors = !1), or(o.customInspect) && (o.customInspect = !0), o.colors && (o.stylize = tS), ln(o, i, o.depth);
}
tr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
tr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function tS(i, t) {
  var o = tr.styles[t];
  return o ? "\x1B[" + tr.colors[o][0] + "m" + i + "\x1B[" + tr.colors[o][1] + "m" : i;
}
function rS(i, t) {
  return i;
}
function nS(i) {
  var t = {};
  return i.forEach(function(o, f) {
    t[o] = !0;
  }), t;
}
function ln(i, t, o) {
  if (i.customInspect && t && Dr(t.inspect) && // Filter out the util module, it's inspect function is special
  t.inspect !== tr && // Also filter out any prototype objects using the circular check.
  !(t.constructor && t.constructor.prototype === t)) {
    var f = t.inspect(o, i);
    return pn(f) || (f = ln(i, f, o)), f;
  }
  var r = sS(i, t);
  if (r)
    return r;
  var u = Object.keys(t), e = nS(u);
  if (i.showHidden && (u = Object.getOwnPropertyNames(t)), Mr(t) && (u.indexOf("message") >= 0 || u.indexOf("description") >= 0))
    return An(t);
  if (u.length === 0) {
    if (Dr(t)) {
      var a = t.name ? ": " + t.name : "";
      return i.stylize("[Function" + a + "]", "special");
    }
    if (Rr(t))
      return i.stylize(RegExp.prototype.toString.call(t), "regexp");
    if (Kr(t))
      return i.stylize(Date.prototype.toString.call(t), "date");
    if (Mr(t))
      return An(t);
  }
  var n = "", p = !1, m = ["{", "}"];
  if (GC(t) && (p = !0, m = ["[", "]"]), Dr(t)) {
    var h = t.name ? ": " + t.name : "";
    n = " [Function" + h + "]";
  }
  if (Rr(t) && (n = " " + RegExp.prototype.toString.call(t)), Kr(t) && (n = " " + Date.prototype.toUTCString.call(t)), Mr(t) && (n = " " + An(t)), u.length === 0 && (!p || t.length == 0))
    return m[0] + n + m[1];
  if (o < 0)
    return Rr(t) ? i.stylize(RegExp.prototype.toString.call(t), "regexp") : i.stylize("[Object]", "special");
  i.seen.push(t);
  var l;
  return p ? l = iS(i, t, o, e, u) : l = u.map(function(s) {
    return Df(i, t, o, e, s, p);
  }), i.seen.pop(), aS(l, n, m);
}
function sS(i, t) {
  if (or(t))
    return i.stylize("undefined", "undefined");
  if (pn(t)) {
    var o = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return i.stylize(o, "string");
  }
  if (WC(t))
    return i.stylize("" + t, "number");
  if (Ff(t))
    return i.stylize("" + t, "boolean");
  if (fn(t))
    return i.stylize("null", "null");
}
function An(i) {
  return "[" + Error.prototype.toString.call(i) + "]";
}
function iS(i, t, o, f, r) {
  for (var u = [], e = 0, a = t.length; e < a; ++e)
    zC(t, String(e)) ? u.push(Df(
      i,
      t,
      o,
      f,
      String(e),
      !0
    )) : u.push("");
  return r.forEach(function(n) {
    n.match(/^\d+$/) || u.push(Df(
      i,
      t,
      o,
      f,
      n,
      !0
    ));
  }), u;
}
function Df(i, t, o, f, r, u) {
  var e, a, n;
  if (n = Object.getOwnPropertyDescriptor(t, r) || { value: t[r] }, n.get ? n.set ? a = i.stylize("[Getter/Setter]", "special") : a = i.stylize("[Getter]", "special") : n.set && (a = i.stylize("[Setter]", "special")), zC(f, r) || (e = "[" + r + "]"), a || (i.seen.indexOf(n.value) < 0 ? (fn(o) ? a = ln(i, n.value, null) : a = ln(i, n.value, o - 1), a.indexOf(`
`) > -1 && (u ? a = a.split(`
`).map(function(p) {
    return "  " + p;
  }).join(`
`).substr(2) : a = `
` + a.split(`
`).map(function(p) {
    return "   " + p;
  }).join(`
`))) : a = i.stylize("[Circular]", "special")), or(e)) {
    if (u && r.match(/^\d+$/))
      return a;
    e = JSON.stringify("" + r), e.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (e = e.substr(1, e.length - 2), e = i.stylize(e, "name")) : (e = e.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), e = i.stylize(e, "string"));
  }
  return e + ": " + a;
}
function aS(i, t, o) {
  var f = i.reduce(function(r, u) {
    return u.indexOf(`
`) >= 0, r + u.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return f > 60 ? o[0] + (t === "" ? "" : t + `
 `) + " " + i.join(`,
  `) + " " + o[1] : o[0] + t + " " + i.join(", ") + " " + o[1];
}
function GC(i) {
  return Array.isArray(i);
}
function Ff(i) {
  return typeof i == "boolean";
}
function fn(i) {
  return i === null;
}
function oS(i) {
  return i == null;
}
function WC(i) {
  return typeof i == "number";
}
function pn(i) {
  return typeof i == "string";
}
function lS(i) {
  return typeof i == "symbol";
}
function or(i) {
  return i === void 0;
}
function Rr(i) {
  return _r(i) && Nf(i) === "[object RegExp]";
}
function _r(i) {
  return typeof i == "object" && i !== null;
}
function Kr(i) {
  return _r(i) && Nf(i) === "[object Date]";
}
function Mr(i) {
  return _r(i) && (Nf(i) === "[object Error]" || i instanceof Error);
}
function Dr(i) {
  return typeof i == "function";
}
function Lf(i) {
  return i === null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || typeof i == "symbol" || // ES6 symbol
  typeof i > "u";
}
function uS(i) {
  return Buffer.isBuffer(i);
}
function Nf(i) {
  return Object.prototype.toString.call(i);
}
function Tn(i) {
  return i < 10 ? "0" + i.toString(10) : i.toString(10);
}
var cS = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function fS() {
  var i = /* @__PURE__ */ new Date(), t = [
    Tn(i.getHours()),
    Tn(i.getMinutes()),
    Tn(i.getSeconds())
  ].join(":");
  return [i.getDate(), cS[i.getMonth()], t].join(" ");
}
function pS() {
  console.log("%s - %s", fS(), If.apply(null, arguments));
}
function XC(i, t) {
  if (!t || !_r(t)) return i;
  for (var o = Object.keys(t), f = o.length; f--; )
    i[o[f]] = t[o[f]];
  return i;
}
function zC(i, t) {
  return Object.prototype.hasOwnProperty.call(i, t);
}
var HC = {
  inherits: qC,
  _extend: XC,
  log: pS,
  isBuffer: uS,
  isPrimitive: Lf,
  isFunction: Dr,
  isError: Mr,
  isDate: Kr,
  isObject: _r,
  isRegExp: Rr,
  isUndefined: or,
  isSymbol: lS,
  isString: pn,
  isNumber: WC,
  isNullOrUndefined: oS,
  isNull: fn,
  isBoolean: Ff,
  isArray: GC,
  inspect: tr,
  deprecate: $C,
  format: If,
  debuglog: eS
};
function ep(i, t) {
  if (i === t)
    return 0;
  for (var o = i.length, f = t.length, r = 0, u = Math.min(o, f); r < u; ++r)
    if (i[r] !== t[r]) {
      o = i[r], f = t[r];
      break;
    }
  return o < f ? -1 : f < o ? 1 : 0;
}
var hS = Object.prototype.hasOwnProperty, tp = Object.keys || function(i) {
  var t = [];
  for (var o in i)
    hS.call(i, o) && t.push(o);
  return t;
}, rp = Array.prototype.slice, bn;
function JC() {
  return typeof bn < "u" ? bn : bn = function() {
    return (function() {
    }).name === "foo";
  }();
}
function np(i) {
  return Object.prototype.toString.call(i);
}
function sp(i) {
  return Ur(i) || typeof Mt.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i ? !!(i instanceof DataView || i.buffer && i.buffer instanceof ArrayBuffer) : !1;
}
function It(i, t) {
  i || jt(i, !0, t, "==", Uf);
}
var mS = /\s*function\s+([^\(\s]*)\s*/;
function QC(i) {
  if (Dr(i)) {
    if (JC())
      return i.name;
    var t = i.toString(), o = t.match(mS);
    return o && o[1];
  }
}
It.AssertionError = Of;
function Of(i) {
  this.name = "AssertionError", this.actual = i.actual, this.expected = i.expected, this.operator = i.operator, i.message ? (this.message = i.message, this.generatedMessage = !1) : (this.message = gS(this), this.generatedMessage = !0);
  var t = i.stackStartFunction || jt;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, t);
  else {
    var o = new Error();
    if (o.stack) {
      var f = o.stack, r = QC(t), u = f.indexOf(`
` + r);
      if (u >= 0) {
        var e = f.indexOf(`
`, u + 1);
        f = f.substring(e + 1);
      }
      this.stack = f;
    }
  }
}
qC(Of, Error);
function ip(i, t) {
  return typeof i == "string" ? i.length < t ? i : i.slice(0, t) : i;
}
function ap(i) {
  if (JC() || !Dr(i))
    return tr(i);
  var t = QC(i), o = t ? ": " + t : "";
  return "[Function" + o + "]";
}
function gS(i) {
  return ip(ap(i.actual), 128) + " " + i.operator + " " + ip(ap(i.expected), 128);
}
function jt(i, t, o, f, r) {
  throw new Of({
    message: o,
    actual: i,
    expected: t,
    operator: f,
    stackStartFunction: r
  });
}
It.fail = jt;
function Uf(i, t) {
  i || jt(i, !0, t, "==", Uf);
}
It.ok = Uf;
It.equal = YC;
function YC(i, t, o) {
  i != t && jt(i, t, o, "==", YC);
}
It.notEqual = ZC;
function ZC(i, t, o) {
  i == t && jt(i, t, o, "!=", ZC);
}
It.deepEqual = ev;
function ev(i, t, o) {
  Lr(i, t, !1) || jt(i, t, o, "deepEqual", ev);
}
It.deepStrictEqual = tv;
function tv(i, t, o) {
  Lr(i, t, !0) || jt(i, t, o, "deepStrictEqual", tv);
}
function Lr(i, t, o, f) {
  if (i === t)
    return !0;
  if (Ur(i) && Ur(t))
    return ep(i, t) === 0;
  if (Kr(i) && Kr(t))
    return i.getTime() === t.getTime();
  if (Rr(i) && Rr(t))
    return i.source === t.source && i.global === t.global && i.multiline === t.multiline && i.lastIndex === t.lastIndex && i.ignoreCase === t.ignoreCase;
  if ((i === null || typeof i != "object") && (t === null || typeof t != "object"))
    return o ? i === t : i == t;
  if (sp(i) && sp(t) && np(i) === np(t) && !(i instanceof Float32Array || i instanceof Float64Array))
    return ep(
      new Uint8Array(i.buffer),
      new Uint8Array(t.buffer)
    ) === 0;
  if (Ur(i) !== Ur(t))
    return !1;
  f = f || { actual: [], expected: [] };
  var r = f.actual.indexOf(i);
  return r !== -1 && r === f.expected.indexOf(t) ? !0 : (f.actual.push(i), f.expected.push(t), dS(i, t, o, f));
}
function op(i) {
  return Object.prototype.toString.call(i) == "[object Arguments]";
}
function dS(i, t, o, f) {
  if (i == null || t === null || t === void 0)
    return !1;
  if (Lf(i) || Lf(t))
    return i === t;
  if (o && Object.getPrototypeOf(i) !== Object.getPrototypeOf(t))
    return !1;
  var r = op(i), u = op(t);
  if (r && !u || !r && u)
    return !1;
  if (r)
    return i = rp.call(i), t = rp.call(t), Lr(i, t, o);
  var e = tp(i), a = tp(t), n, p;
  if (e.length !== a.length)
    return !1;
  for (e.sort(), a.sort(), p = e.length - 1; p >= 0; p--)
    if (e[p] !== a[p])
      return !1;
  for (p = e.length - 1; p >= 0; p--)
    if (n = e[p], !Lr(i[n], t[n], o, f))
      return !1;
  return !0;
}
It.notDeepEqual = rv;
function rv(i, t, o) {
  Lr(i, t, !1) && jt(i, t, o, "notDeepEqual", rv);
}
It.notDeepStrictEqual = nv;
function nv(i, t, o) {
  Lr(i, t, !0) && jt(i, t, o, "notDeepStrictEqual", nv);
}
It.strictEqual = sv;
function sv(i, t, o) {
  i !== t && jt(i, t, o, "===", sv);
}
It.notStrictEqual = iv;
function iv(i, t, o) {
  i === t && jt(i, t, o, "!==", iv);
}
function lp(i, t) {
  if (!i || !t)
    return !1;
  if (Object.prototype.toString.call(t) == "[object RegExp]")
    return t.test(i);
  try {
    if (i instanceof t)
      return !0;
  } catch {
  }
  return Error.isPrototypeOf(t) ? !1 : t.call({}, i) === !0;
}
function ES(i) {
  var t;
  try {
    i();
  } catch (o) {
    t = o;
  }
  return t;
}
function av(i, t, o, f) {
  var r;
  if (typeof t != "function")
    throw new TypeError('"block" argument must be a function');
  typeof o == "string" && (f = o, o = null), r = ES(t), f = (o && o.name ? " (" + o.name + ")." : ".") + (f ? " " + f : "."), i && !r && jt(r, o, "Missing expected exception" + f);
  var u = typeof f == "string", e = !i && Mr(r), a = !i && r && !o;
  if ((e && u && lp(r, o) || a) && jt(r, o, "Got unwanted exception" + f), i && r && o && !lp(r, o) || !i && r)
    throw r;
}
It.throws = yS;
function yS(i, t, o) {
  av(!0, i, t, o);
}
It.doesNotThrow = CS;
function CS(i, t, o) {
  av(!1, i, t, o);
}
It.ifError = vS;
function vS(i) {
  if (i) throw i;
}
var xn = {}, up;
function ov() {
  return up || (up = 1, function(i) {
    (function t(o) {
      var f, r, u, e, a, n;
      function p(S) {
        var C = {}, x, A;
        for (x in S)
          S.hasOwnProperty(x) && (A = S[x], typeof A == "object" && A !== null ? C[x] = p(A) : C[x] = A);
        return C;
      }
      function m(S, C) {
        var x, A, R, L;
        for (A = S.length, R = 0; A; )
          x = A >>> 1, L = R + x, C(S[L]) ? A = x : (R = L + 1, A -= x + 1);
        return R;
      }
      f = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, u = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, e = {}, a = {}, n = {}, r = {
        Break: e,
        Skip: a,
        Remove: n
      };
      function h(S, C) {
        this.parent = S, this.key = C;
      }
      h.prototype.replace = function(C) {
        this.parent[this.key] = C;
      }, h.prototype.remove = function() {
        return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
      };
      function l(S, C, x, A) {
        this.node = S, this.path = C, this.wrap = x, this.ref = A;
      }
      function s() {
      }
      s.prototype.path = function() {
        var C, x, A, R, L, _;
        function I(O, k) {
          if (Array.isArray(k))
            for (A = 0, R = k.length; A < R; ++A)
              O.push(k[A]);
          else
            O.push(k);
        }
        if (!this.__current.path)
          return null;
        for (L = [], C = 2, x = this.__leavelist.length; C < x; ++C)
          _ = this.__leavelist[C], I(L, _.path);
        return I(L, this.__current.path), L;
      }, s.prototype.type = function() {
        var S = this.current();
        return S.type || this.__current.wrap;
      }, s.prototype.parents = function() {
        var C, x, A;
        for (A = [], C = 1, x = this.__leavelist.length; C < x; ++C)
          A.push(this.__leavelist[C].node);
        return A;
      }, s.prototype.current = function() {
        return this.__current.node;
      }, s.prototype.__execute = function(C, x) {
        var A, R;
        return R = void 0, A = this.__current, this.__current = x, this.__state = null, C && (R = C.call(this, x.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = A, R;
      }, s.prototype.notify = function(C) {
        this.__state = C;
      }, s.prototype.skip = function() {
        this.notify(a);
      }, s.prototype.break = function() {
        this.notify(e);
      }, s.prototype.remove = function() {
        this.notify(n);
      }, s.prototype.__initialize = function(S, C) {
        this.visitor = C, this.root = S, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, C.fallback === "iteration" ? this.__fallback = Object.keys : typeof C.fallback == "function" && (this.__fallback = C.fallback), this.__keys = u, C.keys && (this.__keys = Object.assign(Object.create(this.__keys), C.keys));
      };
      function c(S) {
        return S == null ? !1 : typeof S == "object" && typeof S.type == "string";
      }
      function g(S, C) {
        return (S === f.ObjectExpression || S === f.ObjectPattern) && C === "properties";
      }
      function d(S, C) {
        for (var x = S.length - 1; x >= 0; --x)
          if (S[x].node === C)
            return !0;
        return !1;
      }
      s.prototype.traverse = function(C, x) {
        var A, R, L, _, I, O, k, w, U, q, F, $;
        for (this.__initialize(C, x), $ = {}, A = this.__worklist, R = this.__leavelist, A.push(new l(C, null, null, null)), R.push(new l(null, null, null, null)); A.length; ) {
          if (L = A.pop(), L === $) {
            if (L = R.pop(), O = this.__execute(x.leave, L), this.__state === e || O === e)
              return;
            continue;
          }
          if (L.node) {
            if (O = this.__execute(x.enter, L), this.__state === e || O === e)
              return;
            if (A.push($), R.push(L), this.__state === a || O === a)
              continue;
            if (_ = L.node, I = _.type || L.wrap, q = this.__keys[I], !q)
              if (this.__fallback)
                q = this.__fallback(_);
              else
                throw new Error("Unknown node type " + I + ".");
            for (w = q.length; (w -= 1) >= 0; )
              if (k = q[w], F = _[k], !!F) {
                if (Array.isArray(F)) {
                  for (U = F.length; (U -= 1) >= 0; )
                    if (F[U] && !d(R, F[U])) {
                      if (g(I, q[w]))
                        L = new l(F[U], [k, U], "Property", null);
                      else if (c(F[U]))
                        L = new l(F[U], [k, U], null, null);
                      else
                        continue;
                      A.push(L);
                    }
                } else if (c(F)) {
                  if (d(R, F))
                    continue;
                  A.push(new l(F, k, null, null));
                }
              }
          }
        }
      }, s.prototype.replace = function(C, x) {
        var A, R, L, _, I, O, k, w, U, q, F, $, P;
        function X(Q) {
          var ue, le, Ce, j;
          if (Q.ref.remove()) {
            for (le = Q.ref.key, j = Q.ref.parent, ue = A.length; ue--; )
              if (Ce = A[ue], Ce.ref && Ce.ref.parent === j) {
                if (Ce.ref.key < le)
                  break;
                --Ce.ref.key;
              }
          }
        }
        for (this.__initialize(C, x), F = {}, A = this.__worklist, R = this.__leavelist, $ = {
          root: C
        }, O = new l(C, null, null, new h($, "root")), A.push(O), R.push(O); A.length; ) {
          if (O = A.pop(), O === F) {
            if (O = R.pop(), I = this.__execute(x.leave, O), I !== void 0 && I !== e && I !== a && I !== n && O.ref.replace(I), (this.__state === n || I === n) && X(O), this.__state === e || I === e)
              return $.root;
            continue;
          }
          if (I = this.__execute(x.enter, O), I !== void 0 && I !== e && I !== a && I !== n && (O.ref.replace(I), O.node = I), (this.__state === n || I === n) && (X(O), O.node = null), this.__state === e || I === e)
            return $.root;
          if (L = O.node, !!L && (A.push(F), R.push(O), !(this.__state === a || I === a))) {
            if (_ = L.type || O.wrap, U = this.__keys[_], !U)
              if (this.__fallback)
                U = this.__fallback(L);
              else
                throw new Error("Unknown node type " + _ + ".");
            for (k = U.length; (k -= 1) >= 0; )
              if (P = U[k], q = L[P], !!q)
                if (Array.isArray(q)) {
                  for (w = q.length; (w -= 1) >= 0; )
                    if (q[w]) {
                      if (g(_, U[k]))
                        O = new l(q[w], [P, w], "Property", new h(q, w));
                      else if (c(q[w]))
                        O = new l(q[w], [P, w], null, new h(q, w));
                      else
                        continue;
                      A.push(O);
                    }
                } else c(q) && A.push(new l(q, P, null, new h(L, P)));
          }
        }
        return $.root;
      };
      function y(S, C) {
        var x = new s();
        return x.traverse(S, C);
      }
      function v(S, C) {
        var x = new s();
        return x.replace(S, C);
      }
      function T(S, C) {
        var x;
        return x = m(C, function(R) {
          return R.range[0] > S.range[0];
        }), S.extendedRange = [S.range[0], S.range[1]], x !== C.length && (S.extendedRange[1] = C[x].range[0]), x -= 1, x >= 0 && (S.extendedRange[0] = C[x].range[1]), S;
      }
      function b(S, C, x) {
        var A = [], R, L, _, I;
        if (!S.range)
          throw new Error("attachComments needs range information");
        if (!x.length) {
          if (C.length) {
            for (_ = 0, L = C.length; _ < L; _ += 1)
              R = p(C[_]), R.extendedRange = [0, S.range[0]], A.push(R);
            S.leadingComments = A;
          }
          return S;
        }
        for (_ = 0, L = C.length; _ < L; _ += 1)
          A.push(T(p(C[_]), x));
        return I = 0, y(S, {
          enter: function(O) {
            for (var k; I < A.length && (k = A[I], !(k.extendedRange[1] > O.range[0])); )
              k.extendedRange[1] === O.range[0] ? (O.leadingComments || (O.leadingComments = []), O.leadingComments.push(k), A.splice(I, 1)) : I += 1;
            if (I === A.length)
              return r.Break;
            if (A[I].extendedRange[0] > O.range[1])
              return r.Skip;
          }
        }), I = 0, y(S, {
          leave: function(O) {
            for (var k; I < A.length && (k = A[I], !(O.range[1] < k.extendedRange[0])); )
              O.range[1] === k.extendedRange[0] ? (O.trailingComments || (O.trailingComments = []), O.trailingComments.push(k), A.splice(I, 1)) : I += 1;
            if (I === A.length)
              return r.Break;
            if (A[I].extendedRange[0] > O.range[1])
              return r.Skip;
          }
        }), S;
      }
      return o.Syntax = f, o.traverse = y, o.replace = v, o.attachComments = b, o.VisitorKeys = u, o.VisitorOption = r, o.Controller = s, o.cloneEnvironment = function() {
        return t({});
      }, o;
    })(i);
  }(xn)), xn;
}
var Ir = {}, SS = "4.3.0", AS = {
  version: SS
}, cp;
function TS() {
  return cp || (cp = 1, function() {
    var i = ov();
    function t(r) {
      return r == null ? !1 : typeof r == "object" && typeof r.type == "string";
    }
    function o(r, u) {
      return (r === i.Syntax.ObjectExpression || r === i.Syntax.ObjectPattern) && u === "properties";
    }
    function f(r, u) {
      u = u || {}, this.__visitor = r || this, this.__childVisitorKeys = u.childVisitorKeys ? Object.assign({}, i.VisitorKeys, u.childVisitorKeys) : i.VisitorKeys, u.fallback === "iteration" ? this.__fallback = Object.keys : typeof u.fallback == "function" && (this.__fallback = u.fallback);
    }
    f.prototype.visitChildren = function(r) {
      var u, e, a, n, p, m, h;
      if (r != null) {
        if (u = r.type || i.Syntax.Property, e = this.__childVisitorKeys[u], !e)
          if (this.__fallback)
            e = this.__fallback(r);
          else
            throw new Error("Unknown node type " + u + ".");
        for (a = 0, n = e.length; a < n; ++a)
          if (h = r[e[a]], h)
            if (Array.isArray(h))
              for (p = 0, m = h.length; p < m; ++p)
                h[p] && (t(h[p]) || o(u, e[a])) && this.visit(h[p]);
            else t(h) && this.visit(h);
      }
    }, f.prototype.visit = function(r) {
      var u;
      if (r != null) {
        if (u = r.type || i.Syntax.Property, this.__visitor[u]) {
          this.__visitor[u].call(this, r);
          return;
        }
        this.visitChildren(r);
      }
    }, Ir.version = AS.version, Ir.Visitor = f, Ir.visit = function(r, u, e) {
      var a = new f(u, e);
      a.visit(r);
    };
  }()), Ir;
}
var fp;
function lv() {
  if (fp) return Wt;
  fp = 1, Object.defineProperty(Wt, "__esModule", { value: !0 });
  var i = It, t = ov(), o = TS();
  function f(H) {
    return H && typeof H == "object" && "default" in H ? H : { default: H };
  }
  var r = /* @__PURE__ */ f(i), u = /* @__PURE__ */ f(t), e = /* @__PURE__ */ f(o);
  const a = 1, n = 2, p = a | n;
  class m {
    constructor(N, G, M, Z, Ee, ke, Ie) {
      this.identifier = N, this.from = G, this.tainted = !1, this.resolved = null, this.flag = M, this.isWrite() && (this.writeExpr = Z, this.partial = ke, this.init = Ie), this.__maybeImplicitGlobal = Ee;
    }
    /**
     * Whether the reference is static.
     * @function Reference#isStatic
     * @returns {boolean} static
     */
    isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }
    /**
     * Whether the reference is writeable.
     * @function Reference#isWrite
     * @returns {boolean} write
     */
    isWrite() {
      return !!(this.flag & m.WRITE);
    }
    /**
     * Whether the reference is readable.
     * @function Reference#isRead
     * @returns {boolean} read
     */
    isRead() {
      return !!(this.flag & m.READ);
    }
    /**
     * Whether the reference is read-only.
     * @function Reference#isReadOnly
     * @returns {boolean} read only
     */
    isReadOnly() {
      return this.flag === m.READ;
    }
    /**
     * Whether the reference is write-only.
     * @function Reference#isWriteOnly
     * @returns {boolean} write only
     */
    isWriteOnly() {
      return this.flag === m.WRITE;
    }
    /**
     * Whether the reference is read-write.
     * @function Reference#isReadWrite
     * @returns {boolean} read write
     */
    isReadWrite() {
      return this.flag === m.RW;
    }
  }
  m.READ = a, m.WRITE = n, m.RW = p;
  class h {
    constructor(N, G) {
      this.name = N, this.identifiers = [], this.references = [], this.defs = [], this.tainted = !1, this.stack = !0, this.scope = G;
    }
  }
  h.CatchClause = "CatchClause", h.Parameter = "Parameter", h.FunctionName = "FunctionName", h.ClassName = "ClassName", h.Variable = "Variable", h.ImportBinding = "ImportBinding", h.ImplicitGlobalVariable = "ImplicitGlobalVariable";
  class l {
    constructor(N, G, M, Z, Ee, ke) {
      this.type = N, this.name = G, this.node = M, this.parent = Z, this.index = Ee, this.kind = ke;
    }
  }
  class s extends l {
    constructor(N, G, M, Z) {
      super(h.Parameter, N, G, null, M, null), this.rest = Z;
    }
  }
  const { Syntax: c } = u.default;
  function g(H, N, G, M) {
    let Z;
    if (H.upper && H.upper.isStrict || G || H.type === "class" || H.type === "module")
      return !0;
    if (H.type === "block" || H.type === "switch")
      return !1;
    if (H.type === "function") {
      if (N.type === c.ArrowFunctionExpression && N.body.type !== c.BlockStatement || (N.type === c.Program ? Z = N : Z = N.body, !Z))
        return !1;
    } else if (H.type === "global")
      Z = N;
    else
      return !1;
    if (M)
      for (let Ee = 0, ke = Z.body.length; Ee < ke; ++Ee) {
        const Ie = Z.body[Ee];
        if (Ie.type !== c.DirectiveStatement)
          break;
        if (Ie.raw === '"use strict"' || Ie.raw === "'use strict'")
          return !0;
      }
    else
      for (let Ee = 0, ke = Z.body.length; Ee < ke; ++Ee) {
        const Ie = Z.body[Ee];
        if (Ie.type !== c.ExpressionStatement)
          break;
        const Je = Ie.expression;
        if (Je.type !== c.Literal || typeof Je.value != "string")
          break;
        if (Je.raw !== null && Je.raw !== void 0) {
          if (Je.raw === '"use strict"' || Je.raw === "'use strict'")
            return !0;
        } else if (Je.value === "use strict")
          return !0;
      }
    return !1;
  }
  function d(H, N) {
    H.scopes.push(N);
    const G = H.__nodeToScope.get(N.block);
    G ? G.push(N) : H.__nodeToScope.set(N.block, [N]);
  }
  function y(H) {
    return H.type === h.ClassName || H.type === h.Variable && H.parent.kind !== "var";
  }
  class v {
    constructor(N, G, M, Z, Ee) {
      this.type = G, this.set = /* @__PURE__ */ new Map(), this.taints = /* @__PURE__ */ new Map(), this.dynamic = this.type === "global" || this.type === "with", this.block = Z, this.through = [], this.variables = [], this.references = [], this.variableScope = this.type === "global" || this.type === "module" || this.type === "function" || this.type === "class-field-initializer" || this.type === "class-static-block" ? this : M.variableScope, this.functionExpressionScope = !1, this.directCallToEvalScope = !1, this.thisFound = !1, this.__left = [], this.upper = M, this.isStrict = N.isStrictModeSupported() ? g(this, Z, Ee, N.__useDirective()) : !1, this.childScopes = [], this.upper && this.upper.childScopes.push(this), this.__declaredVariables = N.__declaredVariables, d(N, this);
    }
    __shouldStaticallyClose(N) {
      return !this.dynamic || N.__isOptimistic();
    }
    __shouldStaticallyCloseForGlobal(N) {
      const G = N.identifier.name;
      if (!this.set.has(G))
        return !1;
      const Z = this.set.get(G).defs;
      return Z.length > 0 && Z.every(y);
    }
    __staticCloseRef(N) {
      this.__resolve(N) || this.__delegateToUpperScope(N);
    }
    __dynamicCloseRef(N) {
      let G = this;
      do
        G.through.push(N), G = G.upper;
      while (G);
    }
    __globalCloseRef(N) {
      this.__shouldStaticallyCloseForGlobal(N) ? this.__staticCloseRef(N) : this.__dynamicCloseRef(N);
    }
    __close(N) {
      let G;
      this.__shouldStaticallyClose(N) ? G = this.__staticCloseRef : this.type !== "global" ? G = this.__dynamicCloseRef : G = this.__globalCloseRef;
      for (let M = 0, Z = this.__left.length; M < Z; ++M) {
        const Ee = this.__left[M];
        G.call(this, Ee);
      }
      return this.__left = null, this.upper;
    }
    // To override by function scopes.
    // References in default parameters isn't resolved to variables which are in their function body.
    __isValidResolution(N, G) {
      return !0;
    }
    __resolve(N) {
      const G = N.identifier.name;
      if (!this.set.has(G))
        return !1;
      const M = this.set.get(G);
      return this.__isValidResolution(N, M) ? (M.references.push(N), M.stack = M.stack && N.from.variableScope === this.variableScope, N.tainted && (M.tainted = !0, this.taints.set(M.name, !0)), N.resolved = M, !0) : !1;
    }
    __delegateToUpperScope(N) {
      this.upper && this.upper.__left.push(N), this.through.push(N);
    }
    __addDeclaredVariablesOfNode(N, G) {
      if (G == null)
        return;
      let M = this.__declaredVariables.get(G);
      M == null && (M = [], this.__declaredVariables.set(G, M)), M.indexOf(N) === -1 && M.push(N);
    }
    __defineGeneric(N, G, M, Z, Ee) {
      let ke;
      ke = G.get(N), ke || (ke = new h(N, this), G.set(N, ke), M.push(ke)), Ee && (ke.defs.push(Ee), this.__addDeclaredVariablesOfNode(ke, Ee.node), this.__addDeclaredVariablesOfNode(ke, Ee.parent)), Z && ke.identifiers.push(Z);
    }
    __define(N, G) {
      N && N.type === c.Identifier && this.__defineGeneric(
        N.name,
        this.set,
        this.variables,
        N,
        G
      );
    }
    __referencing(N, G, M, Z, Ee, ke) {
      if (!N || N.type !== c.Identifier || N.name === "super")
        return;
      const Ie = new m(N, this, G || m.READ, M, Z, !!Ee, !!ke);
      this.references.push(Ie), this.__left.push(Ie);
    }
    __detectEval() {
      let N = this;
      this.directCallToEvalScope = !0;
      do
        N.dynamic = !0, N = N.upper;
      while (N);
    }
    __detectThis() {
      this.thisFound = !0;
    }
    __isClosed() {
      return this.__left === null;
    }
    /**
     * returns resolved {Reference}
     * @function Scope#resolve
     * @param {Espree.Identifier} ident identifier to be resolved.
     * @returns {Reference} reference
     */
    resolve(N) {
      let G, M, Z;
      for (r.default(this.__isClosed(), "Scope should be closed."), r.default(N.type === c.Identifier, "Target should be identifier."), M = 0, Z = this.references.length; M < Z; ++M)
        if (G = this.references[M], G.identifier === N)
          return G;
      return null;
    }
    /**
     * returns this scope is static
     * @function Scope#isStatic
     * @returns {boolean} static
     */
    isStatic() {
      return !this.dynamic;
    }
    /**
     * returns this scope has materialized arguments
     * @function Scope#isArgumentsMaterialized
     * @returns {boolean} arguemnts materialized
     */
    isArgumentsMaterialized() {
      return !0;
    }
    /**
     * returns this scope has materialized `this` reference
     * @function Scope#isThisMaterialized
     * @returns {boolean} this materialized
     */
    isThisMaterialized() {
      return !0;
    }
    isUsedName(N) {
      if (this.set.has(N))
        return !0;
      for (let G = 0, M = this.through.length; G < M; ++G)
        if (this.through[G].identifier.name === N)
          return !0;
      return !1;
    }
  }
  class T extends v {
    constructor(N, G) {
      super(N, "global", null, G, !1), this.implicit = {
        set: /* @__PURE__ */ new Map(),
        variables: [],
        /**
         * List of {@link Reference}s that are left to be resolved (i.e. which
         * need to be linked to the variable they refer to).
         * @member {Reference[]} Scope#implicit#left
         */
        left: []
      };
    }
    __close(N) {
      const G = [];
      for (let M = 0, Z = this.__left.length; M < Z; ++M) {
        const Ee = this.__left[M];
        Ee.__maybeImplicitGlobal && !this.set.has(Ee.identifier.name) && G.push(Ee.__maybeImplicitGlobal);
      }
      for (let M = 0, Z = G.length; M < Z; ++M) {
        const Ee = G[M];
        this.__defineImplicit(
          Ee.pattern,
          new l(
            h.ImplicitGlobalVariable,
            Ee.pattern,
            Ee.node,
            null,
            null,
            null
          )
        );
      }
      return this.implicit.left = this.__left, super.__close(N);
    }
    __defineImplicit(N, G) {
      N && N.type === c.Identifier && this.__defineGeneric(
        N.name,
        this.implicit.set,
        this.implicit.variables,
        N,
        G
      );
    }
  }
  class b extends v {
    constructor(N, G, M) {
      super(N, "module", G, M, !1);
    }
  }
  class S extends v {
    constructor(N, G, M) {
      super(N, "function-expression-name", G, M, !1), this.__define(
        M.id,
        new l(
          h.FunctionName,
          M.id,
          M,
          null,
          null,
          null
        )
      ), this.functionExpressionScope = !0;
    }
  }
  class C extends v {
    constructor(N, G, M) {
      super(N, "catch", G, M, !1);
    }
  }
  class x extends v {
    constructor(N, G, M) {
      super(N, "with", G, M, !1);
    }
    __close(N) {
      if (this.__shouldStaticallyClose(N))
        return super.__close(N);
      for (let G = 0, M = this.__left.length; G < M; ++G) {
        const Z = this.__left[G];
        Z.tainted = !0, this.__delegateToUpperScope(Z);
      }
      return this.__left = null, this.upper;
    }
  }
  class A extends v {
    constructor(N, G, M) {
      super(N, "block", G, M, !1);
    }
  }
  class R extends v {
    constructor(N, G, M) {
      super(N, "switch", G, M, !1);
    }
  }
  class L extends v {
    constructor(N, G, M, Z) {
      super(N, "function", G, M, Z), this.block.type !== c.ArrowFunctionExpression && this.__defineArguments();
    }
    isArgumentsMaterialized() {
      if (this.block.type === c.ArrowFunctionExpression)
        return !1;
      if (!this.isStatic())
        return !0;
      const N = this.set.get("arguments");
      return r.default(N, "Always have arguments variable."), N.tainted || N.references.length !== 0;
    }
    isThisMaterialized() {
      return this.isStatic() ? this.thisFound : !0;
    }
    __defineArguments() {
      this.__defineGeneric(
        "arguments",
        this.set,
        this.variables,
        null,
        null
      ), this.taints.set("arguments", !0);
    }
    // References in default parameters isn't resolved to variables which are in their function body.
    //     const x = 1
    //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
    //         const x = 2
    //         console.log(a)
    //     }
    __isValidResolution(N, G) {
      if (this.block.type === "Program")
        return !0;
      const M = this.block.body.range[0];
      return !(G.scope === this && N.identifier.range[0] < M && // the reference is in the parameter part.
      G.defs.every((Z) => Z.name.range[0] >= M));
    }
  }
  class _ extends v {
    constructor(N, G, M) {
      super(N, "for", G, M, !1);
    }
  }
  class I extends v {
    constructor(N, G, M) {
      super(N, "class", G, M, !1);
    }
  }
  class O extends v {
    constructor(N, G, M) {
      super(N, "class-field-initializer", G, M, !0);
    }
  }
  class k extends v {
    constructor(N, G, M) {
      super(N, "class-static-block", G, M, !0);
    }
  }
  class w {
    constructor(N) {
      this.scopes = [], this.globalScope = null, this.__nodeToScope = /* @__PURE__ */ new WeakMap(), this.__currentScope = null, this.__options = N, this.__declaredVariables = /* @__PURE__ */ new WeakMap();
    }
    __useDirective() {
      return this.__options.directive;
    }
    __isOptimistic() {
      return this.__options.optimistic;
    }
    __ignoreEval() {
      return this.__options.ignoreEval;
    }
    isGlobalReturn() {
      return this.__options.nodejsScope || this.__options.sourceType === "commonjs";
    }
    isModule() {
      return this.__options.sourceType === "module";
    }
    isImpliedStrict() {
      return this.__options.impliedStrict;
    }
    isStrictModeSupported() {
      return this.__options.ecmaVersion >= 5;
    }
    // Returns appropriate scope for this node.
    __get(N) {
      return this.__nodeToScope.get(N);
    }
    /**
     * Get variables that are declared by the node.
     *
     * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
     * If the node declares nothing, this method returns an empty array.
     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
     * @param {Espree.Node} node a node to get.
     * @returns {Variable[]} variables that declared by the node.
     */
    getDeclaredVariables(N) {
      return this.__declaredVariables.get(N) || [];
    }
    /**
     * acquire scope from node.
     * @function ScopeManager#acquire
     * @param {Espree.Node} node node for the acquired scope.
     * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
     * @returns {Scope?} Scope from node
     */
    acquire(N, G) {
      function M(Ee) {
        return !(Ee.type === "function" && Ee.functionExpressionScope);
      }
      const Z = this.__get(N);
      if (!Z || Z.length === 0)
        return null;
      if (Z.length === 1)
        return Z[0];
      if (G)
        for (let Ee = Z.length - 1; Ee >= 0; --Ee) {
          const ke = Z[Ee];
          if (M(ke))
            return ke;
        }
      else
        for (let Ee = 0, ke = Z.length; Ee < ke; ++Ee) {
          const Ie = Z[Ee];
          if (M(Ie))
            return Ie;
        }
      return null;
    }
    /**
     * acquire all scopes from node.
     * @function ScopeManager#acquireAll
     * @param {Espree.Node} node node for the acquired scope.
     * @returns {Scopes?} Scope array
     */
    acquireAll(N) {
      return this.__get(N);
    }
    /**
     * release the node.
     * @function ScopeManager#release
     * @param {Espree.Node} node releasing node.
     * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
     * @returns {Scope?} upper scope for the node.
     */
    release(N, G) {
      const M = this.__get(N);
      if (M && M.length) {
        const Z = M[0].upper;
        return Z ? this.acquire(Z.block, G) : null;
      }
      return null;
    }
    attach() {
    }
    // eslint-disable-line class-methods-use-this
    detach() {
    }
    // eslint-disable-line class-methods-use-this
    __nestScope(N) {
      return N instanceof T && (r.default(this.__currentScope === null), this.globalScope = N), this.__currentScope = N, N;
    }
    __nestGlobalScope(N) {
      return this.__nestScope(new T(this, N));
    }
    __nestBlockScope(N) {
      return this.__nestScope(new A(this, this.__currentScope, N));
    }
    __nestFunctionScope(N, G) {
      return this.__nestScope(new L(this, this.__currentScope, N, G));
    }
    __nestForScope(N) {
      return this.__nestScope(new _(this, this.__currentScope, N));
    }
    __nestCatchScope(N) {
      return this.__nestScope(new C(this, this.__currentScope, N));
    }
    __nestWithScope(N) {
      return this.__nestScope(new x(this, this.__currentScope, N));
    }
    __nestClassScope(N) {
      return this.__nestScope(new I(this, this.__currentScope, N));
    }
    __nestClassFieldInitializerScope(N) {
      return this.__nestScope(new O(this, this.__currentScope, N));
    }
    __nestClassStaticBlockScope(N) {
      return this.__nestScope(new k(this, this.__currentScope, N));
    }
    __nestSwitchScope(N) {
      return this.__nestScope(new R(this, this.__currentScope, N));
    }
    __nestModuleScope(N) {
      return this.__nestScope(new b(this, this.__currentScope, N));
    }
    __nestFunctionExpressionNameScope(N) {
      return this.__nestScope(new S(this, this.__currentScope, N));
    }
    __isES6() {
      return this.__options.ecmaVersion >= 6;
    }
  }
  const { Syntax: U } = u.default;
  function q(H) {
    return H[H.length - 1] || null;
  }
  class F extends e.default.Visitor {
    static isPattern(N) {
      const G = N.type;
      return G === U.Identifier || G === U.ObjectPattern || G === U.ArrayPattern || G === U.SpreadElement || G === U.RestElement || G === U.AssignmentPattern;
    }
    constructor(N, G, M) {
      super(null, N), this.rootPattern = G, this.callback = M, this.assignments = [], this.rightHandNodes = [], this.restElements = [];
    }
    Identifier(N) {
      const G = q(this.restElements);
      this.callback(N, {
        topLevel: N === this.rootPattern,
        rest: G != null && G.argument === N,
        assignments: this.assignments
      });
    }
    Property(N) {
      N.computed && this.rightHandNodes.push(N.key), this.visit(N.value);
    }
    ArrayPattern(N) {
      for (let G = 0, M = N.elements.length; G < M; ++G) {
        const Z = N.elements[G];
        this.visit(Z);
      }
    }
    AssignmentPattern(N) {
      this.assignments.push(N), this.visit(N.left), this.rightHandNodes.push(N.right), this.assignments.pop();
    }
    RestElement(N) {
      this.restElements.push(N), this.visit(N.argument), this.restElements.pop();
    }
    MemberExpression(N) {
      N.computed && this.rightHandNodes.push(N.property), this.rightHandNodes.push(N.object);
    }
    //
    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
    // By spec, LeftHandSideExpression is Pattern or MemberExpression.
    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
    // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
    //
    SpreadElement(N) {
      this.visit(N.argument);
    }
    ArrayExpression(N) {
      N.elements.forEach(this.visit, this);
    }
    AssignmentExpression(N) {
      this.assignments.push(N), this.visit(N.left), this.rightHandNodes.push(N.right), this.assignments.pop();
    }
    CallExpression(N) {
      N.arguments.forEach((G) => {
        this.rightHandNodes.push(G);
      }), this.visit(N.callee);
    }
  }
  const { Syntax: $ } = u.default;
  function P(H, N, G, M) {
    const Z = new F(H, N, M);
    Z.visit(N), G != null && Z.rightHandNodes.forEach(G.visit, G);
  }
  class X extends e.default.Visitor {
    constructor(N, G) {
      super(null, G.options), this.declaration = N, this.referencer = G;
    }
    visitImport(N, G) {
      this.referencer.visitPattern(N, (M) => {
        this.referencer.currentScope().__define(
          M,
          new l(
            h.ImportBinding,
            M,
            G,
            this.declaration,
            null,
            null
          )
        );
      });
    }
    ImportNamespaceSpecifier(N) {
      const G = N.local || N.id;
      G && this.visitImport(G, N);
    }
    ImportDefaultSpecifier(N) {
      const G = N.local || N.id;
      this.visitImport(G, N);
    }
    ImportSpecifier(N) {
      const G = N.local || N.id;
      N.name ? this.visitImport(N.name, N) : this.visitImport(G, N);
    }
  }
  class Q extends e.default.Visitor {
    constructor(N, G) {
      super(null, N), this.options = N, this.scopeManager = G, this.parent = null, this.isInnerMethodDefinition = !1;
    }
    currentScope() {
      return this.scopeManager.__currentScope;
    }
    close(N) {
      for (; this.currentScope() && N === this.currentScope().block; )
        this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
    }
    pushInnerMethodDefinition(N) {
      const G = this.isInnerMethodDefinition;
      return this.isInnerMethodDefinition = N, G;
    }
    popInnerMethodDefinition(N) {
      this.isInnerMethodDefinition = N;
    }
    referencingDefaultValue(N, G, M, Z) {
      const Ee = this.currentScope();
      G.forEach((ke) => {
        Ee.__referencing(
          N,
          m.WRITE,
          ke.right,
          M,
          N !== ke.left,
          Z
        );
      });
    }
    visitPattern(N, G, M) {
      let Z = G, Ee = M;
      typeof G == "function" && (Ee = G, Z = { processRightHandNodes: !1 }), P(
        this.options,
        N,
        Z.processRightHandNodes ? this : null,
        Ee
      );
    }
    visitFunction(N) {
      let G, M;
      N.type === $.FunctionDeclaration && this.currentScope().__define(
        N.id,
        new l(
          h.FunctionName,
          N.id,
          N,
          null,
          null,
          null
        )
      ), N.type === $.FunctionExpression && N.id && this.scopeManager.__nestFunctionExpressionNameScope(N), this.scopeManager.__nestFunctionScope(N, this.isInnerMethodDefinition);
      const Z = this;
      function Ee(ke, Ie) {
        Z.currentScope().__define(
          ke,
          new s(
            ke,
            N,
            G,
            Ie.rest
          )
        ), Z.referencingDefaultValue(ke, Ie.assignments, null, !0);
      }
      for (G = 0, M = N.params.length; G < M; ++G)
        this.visitPattern(N.params[G], { processRightHandNodes: !0 }, Ee);
      N.rest && this.visitPattern({
        type: "RestElement",
        argument: N.rest
      }, (ke) => {
        this.currentScope().__define(
          ke,
          new s(
            ke,
            N,
            N.params.length,
            !0
          )
        );
      }), N.body && (N.body.type === $.BlockStatement ? this.visitChildren(N.body) : this.visit(N.body)), this.close(N);
    }
    visitClass(N) {
      N.type === $.ClassDeclaration && this.currentScope().__define(
        N.id,
        new l(
          h.ClassName,
          N.id,
          N,
          null,
          null,
          null
        )
      ), this.visit(N.superClass), this.scopeManager.__nestClassScope(N), N.id && this.currentScope().__define(
        N.id,
        new l(
          h.ClassName,
          N.id,
          N
        )
      ), this.visit(N.body), this.close(N);
    }
    visitProperty(N) {
      let G;
      N.computed && this.visit(N.key);
      const M = N.type === $.MethodDefinition;
      M && (G = this.pushInnerMethodDefinition(!0)), this.visit(N.value), M && this.popInnerMethodDefinition(G);
    }
    visitForIn(N) {
      N.left.type === $.VariableDeclaration && N.left.kind !== "var" && this.scopeManager.__nestForScope(N), N.left.type === $.VariableDeclaration ? (this.visit(N.left), this.visitPattern(N.left.declarations[0].id, (G) => {
        this.currentScope().__referencing(G, m.WRITE, N.right, null, !0, !0);
      })) : this.visitPattern(N.left, { processRightHandNodes: !0 }, (G, M) => {
        let Z = null;
        this.currentScope().isStrict || (Z = {
          pattern: G,
          node: N
        }), this.referencingDefaultValue(G, M.assignments, Z, !1), this.currentScope().__referencing(G, m.WRITE, N.right, Z, !0, !1);
      }), this.visit(N.right), this.visit(N.body), this.close(N);
    }
    visitVariableDeclaration(N, G, M, Z) {
      const Ee = M.declarations[Z], ke = Ee.init;
      this.visitPattern(Ee.id, { processRightHandNodes: !0 }, (Ie, Je) => {
        N.__define(
          Ie,
          new l(
            G,
            Ie,
            Ee,
            M,
            Z,
            M.kind
          )
        ), this.referencingDefaultValue(Ie, Je.assignments, null, !0), ke && this.currentScope().__referencing(Ie, m.WRITE, ke, null, !Je.topLevel, !0);
      });
    }
    AssignmentExpression(N) {
      F.isPattern(N.left) ? N.operator === "=" ? this.visitPattern(N.left, { processRightHandNodes: !0 }, (G, M) => {
        let Z = null;
        this.currentScope().isStrict || (Z = {
          pattern: G,
          node: N
        }), this.referencingDefaultValue(G, M.assignments, Z, !1), this.currentScope().__referencing(G, m.WRITE, N.right, Z, !M.topLevel, !1);
      }) : this.currentScope().__referencing(N.left, m.RW, N.right) : this.visit(N.left), this.visit(N.right);
    }
    CatchClause(N) {
      this.scopeManager.__nestCatchScope(N), this.visitPattern(N.param, { processRightHandNodes: !0 }, (G, M) => {
        this.currentScope().__define(
          G,
          new l(
            h.CatchClause,
            N.param,
            N,
            null,
            null,
            null
          )
        ), this.referencingDefaultValue(G, M.assignments, null, !0);
      }), this.visit(N.body), this.close(N);
    }
    Program(N) {
      this.scopeManager.__nestGlobalScope(N), this.scopeManager.isGlobalReturn() && (this.currentScope().isStrict = !1, this.scopeManager.__nestFunctionScope(N, !1)), this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(N), this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), this.visitChildren(N), this.close(N);
    }
    Identifier(N) {
      this.currentScope().__referencing(N);
    }
    // eslint-disable-next-line class-methods-use-this
    PrivateIdentifier() {
    }
    UpdateExpression(N) {
      F.isPattern(N.argument) ? this.currentScope().__referencing(N.argument, m.RW, null) : this.visitChildren(N);
    }
    MemberExpression(N) {
      this.visit(N.object), N.computed && this.visit(N.property);
    }
    Property(N) {
      this.visitProperty(N);
    }
    PropertyDefinition(N) {
      const { computed: G, key: M, value: Z } = N;
      G && this.visit(M), Z && (this.scopeManager.__nestClassFieldInitializerScope(Z), this.visit(Z), this.close(Z));
    }
    StaticBlock(N) {
      this.scopeManager.__nestClassStaticBlockScope(N), this.visitChildren(N), this.close(N);
    }
    MethodDefinition(N) {
      this.visitProperty(N);
    }
    BreakStatement() {
    }
    // eslint-disable-line class-methods-use-this
    ContinueStatement() {
    }
    // eslint-disable-line class-methods-use-this
    LabeledStatement(N) {
      this.visit(N.body);
    }
    ForStatement(N) {
      N.init && N.init.type === $.VariableDeclaration && N.init.kind !== "var" && this.scopeManager.__nestForScope(N), this.visitChildren(N), this.close(N);
    }
    ClassExpression(N) {
      this.visitClass(N);
    }
    ClassDeclaration(N) {
      this.visitClass(N);
    }
    CallExpression(N) {
      !this.scopeManager.__ignoreEval() && N.callee.type === $.Identifier && N.callee.name === "eval" && this.currentScope().variableScope.__detectEval(), this.visitChildren(N);
    }
    BlockStatement(N) {
      this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(N), this.visitChildren(N), this.close(N);
    }
    ThisExpression() {
      this.currentScope().variableScope.__detectThis();
    }
    WithStatement(N) {
      this.visit(N.object), this.scopeManager.__nestWithScope(N), this.visit(N.body), this.close(N);
    }
    VariableDeclaration(N) {
      const G = N.kind === "var" ? this.currentScope().variableScope : this.currentScope();
      for (let M = 0, Z = N.declarations.length; M < Z; ++M) {
        const Ee = N.declarations[M];
        this.visitVariableDeclaration(G, h.Variable, N, M), Ee.init && this.visit(Ee.init);
      }
    }
    // sec 13.11.8
    SwitchStatement(N) {
      this.visit(N.discriminant), this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(N);
      for (let G = 0, M = N.cases.length; G < M; ++G)
        this.visit(N.cases[G]);
      this.close(N);
    }
    FunctionDeclaration(N) {
      this.visitFunction(N);
    }
    FunctionExpression(N) {
      this.visitFunction(N);
    }
    ForOfStatement(N) {
      this.visitForIn(N);
    }
    ForInStatement(N) {
      this.visitForIn(N);
    }
    ArrowFunctionExpression(N) {
      this.visitFunction(N);
    }
    ImportDeclaration(N) {
      r.default(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context."), new X(N, this).visit(N);
    }
    visitExportDeclaration(N) {
      if (!N.source) {
        if (N.declaration) {
          this.visit(N.declaration);
          return;
        }
        this.visitChildren(N);
      }
    }
    // TODO: ExportDeclaration doesn't exist. for bc?
    ExportDeclaration(N) {
      this.visitExportDeclaration(N);
    }
    ExportAllDeclaration(N) {
      this.visitExportDeclaration(N);
    }
    ExportDefaultDeclaration(N) {
      this.visitExportDeclaration(N);
    }
    ExportNamedDeclaration(N) {
      this.visitExportDeclaration(N);
    }
    ExportSpecifier(N) {
      const G = N.id || N.local;
      this.visit(G);
    }
    MetaProperty() {
    }
  }
  const ue = "7.2.2";
  function le() {
    return {
      optimistic: !1,
      directive: !1,
      nodejsScope: !1,
      impliedStrict: !1,
      sourceType: "script",
      // one of ['script', 'module', 'commonjs']
      ecmaVersion: 5,
      childVisitorKeys: null,
      fallback: "iteration"
    };
  }
  function Ce(H, N) {
    function G(M) {
      return typeof M == "object" && M instanceof Object && !(M instanceof Array) && !(M instanceof RegExp);
    }
    for (const M in N)
      if (Object.prototype.hasOwnProperty.call(N, M)) {
        const Z = N[M];
        G(Z) ? G(H[M]) ? Ce(H[M], Z) : H[M] = Ce({}, Z) : H[M] = Z;
      }
    return H;
  }
  function j(H, N) {
    const G = Ce(le(), N), M = new w(G);
    return new Q(G, M).visit(H), r.default(M.__currentScope === null, "currentScope should be null."), M;
  }
  return Wt.Definition = l, Wt.PatternVisitor = F, Wt.Reference = m, Wt.Referencer = Q, Wt.Scope = v, Wt.ScopeManager = w, Wt.Variable = h, Wt.analyze = j, Wt.version = ue, Wt;
}
var Tr = {}, pp;
function qr() {
  if (pp) return Tr;
  pp = 1, Object.defineProperty(Tr, "__esModule", { value: !0 });
  const i = {
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    AwaitExpression: [
      "argument"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BlockStatement: [
      "body"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ExportAllDeclaration: [
      "exported",
      "source"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source"
    ],
    ExportSpecifier: [
      "exported",
      "local"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportDeclaration: [
      "specifiers",
      "source"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXClosingFragment: [],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXOpeningFragment: [],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXSpreadChild: [
      "expression"
    ],
    JSXText: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    Literal: [],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    PrivateIdentifier: [],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    PropertyDefinition: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    StaticBlock: [
      "body"
    ],
    Super: [],
    SwitchCase: [
      "test",
      "consequent"
    ],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  }, t = Object.keys(i);
  for (const e of t)
    Object.freeze(i[e]);
  Object.freeze(i);
  const o = /* @__PURE__ */ new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function f(e) {
    return !o.has(e) && e[0] !== "_";
  }
  function r(e) {
    return Object.keys(e).filter(f);
  }
  function u(e) {
    const a = (
      /** @type {{
          [type: string]: ReadonlyArray<string>
      }} */
      Object.assign({}, i)
    );
    for (const n of Object.keys(e))
      if (Object.prototype.hasOwnProperty.call(a, n)) {
        const p = new Set(e[n]);
        for (const m of a[n])
          p.add(m);
        a[n] = Object.freeze(Array.from(p));
      } else
        a[n] = Object.freeze(Array.from(e[n]));
    return Object.freeze(a);
  }
  return Tr.KEYS = i, Tr.getKeys = r, Tr.unionWith = u, Tr;
}
var Jt = {}, zr = { exports: {} }, hp;
function _f() {
  return hp || (hp = 1, function(i, t) {
    (function(o, f) {
      f(t);
    })(this, function(o) {
      var f = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], r = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], u = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", e = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", a = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, n = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", p = {
        5: n,
        "5module": n + " export import",
        6: n + " const class extends export import super"
      }, m = /^in(stanceof)?$/, h = new RegExp("[" + e + "]"), l = new RegExp("[" + e + u + "]");
      function s(E, D) {
        for (var K = 65536, J = 0; J < D.length; J += 2) {
          if (K += D[J], K > E)
            return !1;
          if (K += D[J + 1], K >= E)
            return !0;
        }
        return !1;
      }
      function c(E, D) {
        return E < 65 ? E === 36 : E < 91 ? !0 : E < 97 ? E === 95 : E < 123 ? !0 : E <= 65535 ? E >= 170 && h.test(String.fromCharCode(E)) : D === !1 ? !1 : s(E, r);
      }
      function g(E, D) {
        return E < 48 ? E === 36 : E < 58 ? !0 : E < 65 ? !1 : E < 91 ? !0 : E < 97 ? E === 95 : E < 123 ? !0 : E <= 65535 ? E >= 170 && l.test(String.fromCharCode(E)) : D === !1 ? !1 : s(E, r) || s(E, f);
      }
      var d = function(D, K) {
        K === void 0 && (K = {}), this.label = D, this.keyword = K.keyword, this.beforeExpr = !!K.beforeExpr, this.startsExpr = !!K.startsExpr, this.isLoop = !!K.isLoop, this.isAssign = !!K.isAssign, this.prefix = !!K.prefix, this.postfix = !!K.postfix, this.binop = K.binop || null, this.updateContext = null;
      };
      function y(E, D) {
        return new d(E, { beforeExpr: !0, binop: D });
      }
      var v = { beforeExpr: !0 }, T = { startsExpr: !0 }, b = {};
      function S(E, D) {
        return D === void 0 && (D = {}), D.keyword = E, b[E] = new d(E, D);
      }
      var C = {
        num: new d("num", T),
        regexp: new d("regexp", T),
        string: new d("string", T),
        name: new d("name", T),
        privateId: new d("privateId", T),
        eof: new d("eof"),
        // Punctuation token types.
        bracketL: new d("[", { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new d("]"),
        braceL: new d("{", { beforeExpr: !0, startsExpr: !0 }),
        braceR: new d("}"),
        parenL: new d("(", { beforeExpr: !0, startsExpr: !0 }),
        parenR: new d(")"),
        comma: new d(",", v),
        semi: new d(";", v),
        colon: new d(":", v),
        dot: new d("."),
        question: new d("?", v),
        questionDot: new d("?."),
        arrow: new d("=>", v),
        template: new d("template"),
        invalidTemplate: new d("invalidTemplate"),
        ellipsis: new d("...", v),
        backQuote: new d("`", T),
        dollarBraceL: new d("${", { beforeExpr: !0, startsExpr: !0 }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new d("=", { beforeExpr: !0, isAssign: !0 }),
        assign: new d("_=", { beforeExpr: !0, isAssign: !0 }),
        incDec: new d("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new d("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: y("||", 1),
        logicalAND: y("&&", 2),
        bitwiseOR: y("|", 3),
        bitwiseXOR: y("^", 4),
        bitwiseAND: y("&", 5),
        equality: y("==/!=/===/!==", 6),
        relational: y("</>/<=/>=", 7),
        bitShift: y("<</>>/>>>", 8),
        plusMin: new d("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: y("%", 10),
        star: y("*", 10),
        slash: y("/", 10),
        starstar: new d("**", { beforeExpr: !0 }),
        coalesce: y("??", 1),
        // Keyword token types.
        _break: S("break"),
        _case: S("case", v),
        _catch: S("catch"),
        _continue: S("continue"),
        _debugger: S("debugger"),
        _default: S("default", v),
        _do: S("do", { isLoop: !0, beforeExpr: !0 }),
        _else: S("else", v),
        _finally: S("finally"),
        _for: S("for", { isLoop: !0 }),
        _function: S("function", T),
        _if: S("if"),
        _return: S("return", v),
        _switch: S("switch"),
        _throw: S("throw", v),
        _try: S("try"),
        _var: S("var"),
        _const: S("const"),
        _while: S("while", { isLoop: !0 }),
        _with: S("with"),
        _new: S("new", { beforeExpr: !0, startsExpr: !0 }),
        _this: S("this", T),
        _super: S("super", T),
        _class: S("class", T),
        _extends: S("extends", v),
        _export: S("export"),
        _import: S("import", T),
        _null: S("null", T),
        _true: S("true", T),
        _false: S("false", T),
        _in: S("in", { beforeExpr: !0, binop: 7 }),
        _instanceof: S("instanceof", { beforeExpr: !0, binop: 7 }),
        _typeof: S("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: S("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: S("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
      }, x = /\r\n?|\n|\u2028|\u2029/, A = new RegExp(x.source, "g");
      function R(E) {
        return E === 10 || E === 13 || E === 8232 || E === 8233;
      }
      function L(E, D, K) {
        K === void 0 && (K = E.length);
        for (var J = D; J < K; J++) {
          var me = E.charCodeAt(J);
          if (R(me))
            return J < K - 1 && me === 13 && E.charCodeAt(J + 1) === 10 ? J + 2 : J + 1;
        }
        return -1;
      }
      var _ = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, I = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, O = Object.prototype, k = O.hasOwnProperty, w = O.toString, U = Object.hasOwn || function(E, D) {
        return k.call(E, D);
      }, q = Array.isArray || function(E) {
        return w.call(E) === "[object Array]";
      };
      function F(E) {
        return new RegExp("^(?:" + E.replace(/ /g, "|") + ")$");
      }
      function $(E) {
        return E <= 65535 ? String.fromCharCode(E) : (E -= 65536, String.fromCharCode((E >> 10) + 55296, (E & 1023) + 56320));
      }
      var P = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, X = function(D, K) {
        this.line = D, this.column = K;
      };
      X.prototype.offset = function(D) {
        return new X(this.line, this.column + D);
      };
      var Q = function(D, K, J) {
        this.start = K, this.end = J, D.sourceFile !== null && (this.source = D.sourceFile);
      };
      function ue(E, D) {
        for (var K = 1, J = 0; ; ) {
          var me = L(E, J, D);
          if (me < 0)
            return new X(K, D - J);
          ++K, J = me;
        }
      }
      var le = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: !1,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: !1,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: !1,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: !1,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: !1,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: !1
      }, Ce = !1;
      function j(E) {
        var D = {};
        for (var K in le)
          D[K] = E && U(E, K) ? E[K] : le[K];
        if (D.ecmaVersion === "latest" ? D.ecmaVersion = 1e8 : D.ecmaVersion == null ? (!Ce && typeof console == "object" && console.warn && (Ce = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), D.ecmaVersion = 11) : D.ecmaVersion >= 2015 && (D.ecmaVersion -= 2009), D.allowReserved == null && (D.allowReserved = D.ecmaVersion < 5), (!E || E.allowHashBang == null) && (D.allowHashBang = D.ecmaVersion >= 14), q(D.onToken)) {
          var J = D.onToken;
          D.onToken = function(me) {
            return J.push(me);
          };
        }
        return q(D.onComment) && (D.onComment = H(D, D.onComment)), D;
      }
      function H(E, D) {
        return function(K, J, me, Le, Fe, ze) {
          var Qe = {
            type: K ? "Block" : "Line",
            value: J,
            start: me,
            end: Le
          };
          E.locations && (Qe.loc = new Q(this, Fe, ze)), E.ranges && (Qe.range = [me, Le]), D.push(Qe);
        };
      }
      var N = 1, G = 2, M = 4, Z = 8, Ee = 16, ke = 32, Ie = 64, Je = 128, at = 256, lt = N | G | at;
      function mt(E, D) {
        return G | (E ? M : 0) | (D ? Z : 0);
      }
      var Y = 0, Te = 1, Ke = 2, et = 3, nt = 4, rt = 5, ot = function(D, K, J) {
        this.options = D = j(D), this.sourceFile = D.sourceFile, this.keywords = F(p[D.ecmaVersion >= 6 ? 6 : D.sourceType === "module" ? "5module" : 5]);
        var me = "";
        D.allowReserved !== !0 && (me = a[D.ecmaVersion >= 6 ? 6 : D.ecmaVersion === 5 ? 5 : 3], D.sourceType === "module" && (me += " await")), this.reservedWords = F(me);
        var Le = (me ? me + " " : "") + a.strict;
        this.reservedWordsStrict = F(Le), this.reservedWordsStrictBind = F(Le + " " + a.strictBind), this.input = String(K), this.containsEsc = !1, J ? (this.pos = J, this.lineStart = this.input.lastIndexOf(`
`, J - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(x).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = C.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = D.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && D.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(N), this.regexpState = null, this.privateNameStack = [];
      }, Ct = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
      ot.prototype.parse = function() {
        var D = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(D);
      }, Ct.inFunction.get = function() {
        return (this.currentVarScope().flags & G) > 0;
      }, Ct.inGenerator.get = function() {
        return (this.currentVarScope().flags & Z) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Ct.inAsync.get = function() {
        return (this.currentVarScope().flags & M) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Ct.canAwait.get = function() {
        for (var E = this.scopeStack.length - 1; E >= 0; E--) {
          var D = this.scopeStack[E];
          if (D.inClassFieldInit || D.flags & at)
            return !1;
          if (D.flags & G)
            return (D.flags & M) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      }, Ct.allowSuper.get = function() {
        var E = this.currentThisScope(), D = E.flags, K = E.inClassFieldInit;
        return (D & Ie) > 0 || K || this.options.allowSuperOutsideMethod;
      }, Ct.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & Je) > 0;
      }, Ct.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, Ct.allowNewDotTarget.get = function() {
        var E = this.currentThisScope(), D = E.flags, K = E.inClassFieldInit;
        return (D & (G | at)) > 0 || K;
      }, Ct.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & at) > 0;
      }, ot.extend = function() {
        for (var D = [], K = arguments.length; K--; ) D[K] = arguments[K];
        for (var J = this, me = 0; me < D.length; me++)
          J = D[me](J);
        return J;
      }, ot.parse = function(D, K) {
        return new this(K, D).parse();
      }, ot.parseExpressionAt = function(D, K, J) {
        var me = new this(J, D, K);
        return me.nextToken(), me.parseExpression();
      }, ot.tokenizer = function(D, K) {
        return new this(K, D);
      }, Object.defineProperties(ot.prototype, Ct);
      var dt = ot.prototype, vt = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      dt.strictDirective = function(E) {
        if (this.options.ecmaVersion < 5)
          return !1;
        for (; ; ) {
          I.lastIndex = E, E += I.exec(this.input)[0].length;
          var D = vt.exec(this.input.slice(E));
          if (!D)
            return !1;
          if ((D[1] || D[2]) === "use strict") {
            I.lastIndex = E + D[0].length;
            var K = I.exec(this.input), J = K.index + K[0].length, me = this.input.charAt(J);
            return me === ";" || me === "}" || x.test(K[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(me) || me === "!" && this.input.charAt(J + 1) === "=");
          }
          E += D[0].length, I.lastIndex = E, E += I.exec(this.input)[0].length, this.input[E] === ";" && E++;
        }
      }, dt.eat = function(E) {
        return this.type === E ? (this.next(), !0) : !1;
      }, dt.isContextual = function(E) {
        return this.type === C.name && this.value === E && !this.containsEsc;
      }, dt.eatContextual = function(E) {
        return this.isContextual(E) ? (this.next(), !0) : !1;
      }, dt.expectContextual = function(E) {
        this.eatContextual(E) || this.unexpected();
      }, dt.canInsertSemicolon = function() {
        return this.type === C.eof || this.type === C.braceR || x.test(this.input.slice(this.lastTokEnd, this.start));
      }, dt.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
      }, dt.semicolon = function() {
        !this.eat(C.semi) && !this.insertSemicolon() && this.unexpected();
      }, dt.afterTrailingComma = function(E, D) {
        if (this.type === E)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), D || this.next(), !0;
      }, dt.expect = function(E) {
        this.eat(E) || this.unexpected();
      }, dt.unexpected = function(E) {
        this.raise(E ?? this.start, "Unexpected token");
      };
      var W = function() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      dt.checkPatternErrors = function(E, D) {
        if (E) {
          E.trailingComma > -1 && this.raiseRecoverable(E.trailingComma, "Comma is not permitted after the rest element");
          var K = D ? E.parenthesizedAssign : E.parenthesizedBind;
          K > -1 && this.raiseRecoverable(K, D ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      }, dt.checkExpressionErrors = function(E, D) {
        if (!E)
          return !1;
        var K = E.shorthandAssign, J = E.doubleProto;
        if (!D)
          return K >= 0 || J >= 0;
        K >= 0 && this.raise(K, "Shorthand property assignments are valid only in destructuring patterns"), J >= 0 && this.raiseRecoverable(J, "Redefinition of __proto__ property");
      }, dt.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, dt.isSimpleAssignTarget = function(E) {
        return E.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(E.expression) : E.type === "Identifier" || E.type === "MemberExpression";
      };
      var Ye = ot.prototype;
      Ye.parseTopLevel = function(E) {
        var D = /* @__PURE__ */ Object.create(null);
        for (E.body || (E.body = []); this.type !== C.eof; ) {
          var K = this.parseStatement(null, !0, D);
          E.body.push(K);
        }
        if (this.inModule)
          for (var J = 0, me = Object.keys(this.undefinedExports); J < me.length; J += 1) {
            var Le = me[J];
            this.raiseRecoverable(this.undefinedExports[Le].start, "Export '" + Le + "' is not defined");
          }
        return this.adaptDirectivePrologue(E.body), this.next(), E.sourceType = this.options.sourceType, this.finishNode(E, "Program");
      };
      var Ue = { kind: "loop" }, Ve = { kind: "switch" };
      Ye.isLet = function(E) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return !1;
        I.lastIndex = this.pos;
        var D = I.exec(this.input), K = this.pos + D[0].length, J = this.input.charCodeAt(K);
        if (J === 91 || J === 92)
          return !0;
        if (E)
          return !1;
        if (J === 123 || J > 55295 && J < 56320)
          return !0;
        if (c(J, !0)) {
          for (var me = K + 1; g(J = this.input.charCodeAt(me), !0); )
            ++me;
          if (J === 92 || J > 55295 && J < 56320)
            return !0;
          var Le = this.input.slice(K, me);
          if (!m.test(Le))
            return !0;
        }
        return !1;
      }, Ye.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return !1;
        I.lastIndex = this.pos;
        var E = I.exec(this.input), D = this.pos + E[0].length, K;
        return !x.test(this.input.slice(this.pos, D)) && this.input.slice(D, D + 8) === "function" && (D + 8 === this.input.length || !(g(K = this.input.charCodeAt(D + 8)) || K > 55295 && K < 56320));
      }, Ye.parseStatement = function(E, D, K) {
        var J = this.type, me = this.startNode(), Le;
        switch (this.isLet(E) && (J = C._var, Le = "let"), J) {
          case C._break:
          case C._continue:
            return this.parseBreakContinueStatement(me, J.keyword);
          case C._debugger:
            return this.parseDebuggerStatement(me);
          case C._do:
            return this.parseDoStatement(me);
          case C._for:
            return this.parseForStatement(me);
          case C._function:
            return E && (this.strict || E !== "if" && E !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(me, !1, !E);
          case C._class:
            return E && this.unexpected(), this.parseClass(me, !0);
          case C._if:
            return this.parseIfStatement(me);
          case C._return:
            return this.parseReturnStatement(me);
          case C._switch:
            return this.parseSwitchStatement(me);
          case C._throw:
            return this.parseThrowStatement(me);
          case C._try:
            return this.parseTryStatement(me);
          case C._const:
          case C._var:
            return Le = Le || this.value, E && Le !== "var" && this.unexpected(), this.parseVarStatement(me, Le);
          case C._while:
            return this.parseWhileStatement(me);
          case C._with:
            return this.parseWithStatement(me);
          case C.braceL:
            return this.parseBlock(!0, me);
          case C.semi:
            return this.parseEmptyStatement(me);
          case C._export:
          case C._import:
            if (this.options.ecmaVersion > 10 && J === C._import) {
              I.lastIndex = this.pos;
              var Fe = I.exec(this.input), ze = this.pos + Fe[0].length, Qe = this.input.charCodeAt(ze);
              if (Qe === 40 || Qe === 46)
                return this.parseExpressionStatement(me, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (D || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), J === C._import ? this.parseImport(me) : this.parseExport(me, K);
          default:
            if (this.isAsyncFunction())
              return E && this.unexpected(), this.next(), this.parseFunctionStatement(me, !0, !E);
            var pt = this.value, Et = this.parseExpression();
            return J === C.name && Et.type === "Identifier" && this.eat(C.colon) ? this.parseLabeledStatement(me, pt, Et, E) : this.parseExpressionStatement(me, Et);
        }
      }, Ye.parseBreakContinueStatement = function(E, D) {
        var K = D === "break";
        this.next(), this.eat(C.semi) || this.insertSemicolon() ? E.label = null : this.type !== C.name ? this.unexpected() : (E.label = this.parseIdent(), this.semicolon());
        for (var J = 0; J < this.labels.length; ++J) {
          var me = this.labels[J];
          if ((E.label == null || me.name === E.label.name) && (me.kind != null && (K || me.kind === "loop") || E.label && K))
            break;
        }
        return J === this.labels.length && this.raise(E.start, "Unsyntactic " + D), this.finishNode(E, K ? "BreakStatement" : "ContinueStatement");
      }, Ye.parseDebuggerStatement = function(E) {
        return this.next(), this.semicolon(), this.finishNode(E, "DebuggerStatement");
      }, Ye.parseDoStatement = function(E) {
        return this.next(), this.labels.push(Ue), E.body = this.parseStatement("do"), this.labels.pop(), this.expect(C._while), E.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(C.semi) : this.semicolon(), this.finishNode(E, "DoWhileStatement");
      }, Ye.parseForStatement = function(E) {
        this.next();
        var D = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(Ue), this.enterScope(0), this.expect(C.parenL), this.type === C.semi)
          return D > -1 && this.unexpected(D), this.parseFor(E, null);
        var K = this.isLet();
        if (this.type === C._var || this.type === C._const || K) {
          var J = this.startNode(), me = K ? "let" : this.value;
          return this.next(), this.parseVar(J, !0, me), this.finishNode(J, "VariableDeclaration"), (this.type === C._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && J.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === C._in ? D > -1 && this.unexpected(D) : E.await = D > -1), this.parseForIn(E, J)) : (D > -1 && this.unexpected(D), this.parseFor(E, J));
        }
        var Le = this.isContextual("let"), Fe = !1, ze = new W(), Qe = this.parseExpression(D > -1 ? "await" : !0, ze);
        return this.type === C._in || (Fe = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === C._in ? D > -1 && this.unexpected(D) : E.await = D > -1), Le && Fe && this.raise(Qe.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Qe, !1, ze), this.checkLValPattern(Qe), this.parseForIn(E, Qe)) : (this.checkExpressionErrors(ze, !0), D > -1 && this.unexpected(D), this.parseFor(E, Qe));
      }, Ye.parseFunctionStatement = function(E, D, K) {
        return this.next(), this.parseFunction(E, re | (K ? 0 : ne), !1, D);
      }, Ye.parseIfStatement = function(E) {
        return this.next(), E.test = this.parseParenExpression(), E.consequent = this.parseStatement("if"), E.alternate = this.eat(C._else) ? this.parseStatement("if") : null, this.finishNode(E, "IfStatement");
      }, Ye.parseReturnStatement = function(E) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(C.semi) || this.insertSemicolon() ? E.argument = null : (E.argument = this.parseExpression(), this.semicolon()), this.finishNode(E, "ReturnStatement");
      }, Ye.parseSwitchStatement = function(E) {
        this.next(), E.discriminant = this.parseParenExpression(), E.cases = [], this.expect(C.braceL), this.labels.push(Ve), this.enterScope(0);
        for (var D, K = !1; this.type !== C.braceR; )
          if (this.type === C._case || this.type === C._default) {
            var J = this.type === C._case;
            D && this.finishNode(D, "SwitchCase"), E.cases.push(D = this.startNode()), D.consequent = [], this.next(), J ? D.test = this.parseExpression() : (K && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), K = !0, D.test = null), this.expect(C.colon);
          } else
            D || this.unexpected(), D.consequent.push(this.parseStatement(null));
        return this.exitScope(), D && this.finishNode(D, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(E, "SwitchStatement");
      }, Ye.parseThrowStatement = function(E) {
        return this.next(), x.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), E.argument = this.parseExpression(), this.semicolon(), this.finishNode(E, "ThrowStatement");
      };
      var xe = [];
      Ye.parseCatchClauseParam = function() {
        var E = this.parseBindingAtom(), D = E.type === "Identifier";
        return this.enterScope(D ? ke : 0), this.checkLValPattern(E, D ? nt : Ke), this.expect(C.parenR), E;
      }, Ye.parseTryStatement = function(E) {
        if (this.next(), E.block = this.parseBlock(), E.handler = null, this.type === C._catch) {
          var D = this.startNode();
          this.next(), this.eat(C.parenL) ? D.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), D.param = null, this.enterScope(0)), D.body = this.parseBlock(!1), this.exitScope(), E.handler = this.finishNode(D, "CatchClause");
        }
        return E.finalizer = this.eat(C._finally) ? this.parseBlock() : null, !E.handler && !E.finalizer && this.raise(E.start, "Missing catch or finally clause"), this.finishNode(E, "TryStatement");
      }, Ye.parseVarStatement = function(E, D, K) {
        return this.next(), this.parseVar(E, !1, D, K), this.semicolon(), this.finishNode(E, "VariableDeclaration");
      }, Ye.parseWhileStatement = function(E) {
        return this.next(), E.test = this.parseParenExpression(), this.labels.push(Ue), E.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(E, "WhileStatement");
      }, Ye.parseWithStatement = function(E) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), E.object = this.parseParenExpression(), E.body = this.parseStatement("with"), this.finishNode(E, "WithStatement");
      }, Ye.parseEmptyStatement = function(E) {
        return this.next(), this.finishNode(E, "EmptyStatement");
      }, Ye.parseLabeledStatement = function(E, D, K, J) {
        for (var me = 0, Le = this.labels; me < Le.length; me += 1) {
          var Fe = Le[me];
          Fe.name === D && this.raise(K.start, "Label '" + D + "' is already declared");
        }
        for (var ze = this.type.isLoop ? "loop" : this.type === C._switch ? "switch" : null, Qe = this.labels.length - 1; Qe >= 0; Qe--) {
          var pt = this.labels[Qe];
          if (pt.statementStart === E.start)
            pt.statementStart = this.start, pt.kind = ze;
          else
            break;
        }
        return this.labels.push({ name: D, kind: ze, statementStart: this.start }), E.body = this.parseStatement(J ? J.indexOf("label") === -1 ? J + "label" : J : "label"), this.labels.pop(), E.label = K, this.finishNode(E, "LabeledStatement");
      }, Ye.parseExpressionStatement = function(E, D) {
        return E.expression = D, this.semicolon(), this.finishNode(E, "ExpressionStatement");
      }, Ye.parseBlock = function(E, D, K) {
        for (E === void 0 && (E = !0), D === void 0 && (D = this.startNode()), D.body = [], this.expect(C.braceL), E && this.enterScope(0); this.type !== C.braceR; ) {
          var J = this.parseStatement(null);
          D.body.push(J);
        }
        return K && (this.strict = !1), this.next(), E && this.exitScope(), this.finishNode(D, "BlockStatement");
      }, Ye.parseFor = function(E, D) {
        return E.init = D, this.expect(C.semi), E.test = this.type === C.semi ? null : this.parseExpression(), this.expect(C.semi), E.update = this.type === C.parenR ? null : this.parseExpression(), this.expect(C.parenR), E.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(E, "ForStatement");
      }, Ye.parseForIn = function(E, D) {
        var K = this.type === C._in;
        return this.next(), D.type === "VariableDeclaration" && D.declarations[0].init != null && (!K || this.options.ecmaVersion < 8 || this.strict || D.kind !== "var" || D.declarations[0].id.type !== "Identifier") && this.raise(
          D.start,
          (K ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ), E.left = D, E.right = K ? this.parseExpression() : this.parseMaybeAssign(), this.expect(C.parenR), E.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(E, K ? "ForInStatement" : "ForOfStatement");
      }, Ye.parseVar = function(E, D, K, J) {
        for (E.declarations = [], E.kind = K; ; ) {
          var me = this.startNode();
          if (this.parseVarId(me, K), this.eat(C.eq) ? me.init = this.parseMaybeAssign(D) : !J && K === "const" && !(this.type === C._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !J && me.id.type !== "Identifier" && !(D && (this.type === C._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : me.init = null, E.declarations.push(this.finishNode(me, "VariableDeclarator")), !this.eat(C.comma))
            break;
        }
        return E;
      }, Ye.parseVarId = function(E, D) {
        E.id = this.parseBindingAtom(), this.checkLValPattern(E.id, D === "var" ? Te : Ke, !1);
      };
      var re = 1, ne = 2, ae = 4;
      Ye.parseFunction = function(E, D, K, J, me) {
        this.initFunction(E), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !J) && (this.type === C.star && D & ne && this.unexpected(), E.generator = this.eat(C.star)), this.options.ecmaVersion >= 8 && (E.async = !!J), D & re && (E.id = D & ae && this.type !== C.name ? null : this.parseIdent(), E.id && !(D & ne) && this.checkLValSimple(E.id, this.strict || E.generator || E.async ? this.treatFunctionsAsVar ? Te : Ke : et));
        var Le = this.yieldPos, Fe = this.awaitPos, ze = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(mt(E.async, E.generator)), D & re || (E.id = this.type === C.name ? this.parseIdent() : null), this.parseFunctionParams(E), this.parseFunctionBody(E, K, !1, me), this.yieldPos = Le, this.awaitPos = Fe, this.awaitIdentPos = ze, this.finishNode(E, D & re ? "FunctionDeclaration" : "FunctionExpression");
      }, Ye.parseFunctionParams = function(E) {
        this.expect(C.parenL), E.params = this.parseBindingList(C.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, Ye.parseClass = function(E, D) {
        this.next();
        var K = this.strict;
        this.strict = !0, this.parseClassId(E, D), this.parseClassSuper(E);
        var J = this.enterClassBody(), me = this.startNode(), Le = !1;
        for (me.body = [], this.expect(C.braceL); this.type !== C.braceR; ) {
          var Fe = this.parseClassElement(E.superClass !== null);
          Fe && (me.body.push(Fe), Fe.type === "MethodDefinition" && Fe.kind === "constructor" ? (Le && this.raiseRecoverable(Fe.start, "Duplicate constructor in the same class"), Le = !0) : Fe.key && Fe.key.type === "PrivateIdentifier" && fe(J, Fe) && this.raiseRecoverable(Fe.key.start, "Identifier '#" + Fe.key.name + "' has already been declared"));
        }
        return this.strict = K, this.next(), E.body = this.finishNode(me, "ClassBody"), this.exitClassBody(), this.finishNode(E, D ? "ClassDeclaration" : "ClassExpression");
      }, Ye.parseClassElement = function(E) {
        if (this.eat(C.semi))
          return null;
        var D = this.options.ecmaVersion, K = this.startNode(), J = "", me = !1, Le = !1, Fe = "method", ze = !1;
        if (this.eatContextual("static")) {
          if (D >= 13 && this.eat(C.braceL))
            return this.parseClassStaticBlock(K), K;
          this.isClassElementNameStart() || this.type === C.star ? ze = !0 : J = "static";
        }
        if (K.static = ze, !J && D >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === C.star) && !this.canInsertSemicolon() ? Le = !0 : J = "async"), !J && (D >= 9 || !Le) && this.eat(C.star) && (me = !0), !J && !Le && !me) {
          var Qe = this.value;
          (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? Fe = Qe : J = Qe);
        }
        if (J ? (K.computed = !1, K.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), K.key.name = J, this.finishNode(K.key, "Identifier")) : this.parseClassElementName(K), D < 13 || this.type === C.parenL || Fe !== "method" || me || Le) {
          var pt = !K.static && de(K, "constructor"), Et = pt && E;
          pt && Fe !== "method" && this.raise(K.key.start, "Constructor can't have get/set modifier"), K.kind = pt ? "constructor" : Fe, this.parseClassMethod(K, me, Le, Et);
        } else
          this.parseClassField(K);
        return K;
      }, Ye.isClassElementNameStart = function() {
        return this.type === C.name || this.type === C.privateId || this.type === C.num || this.type === C.string || this.type === C.bracketL || this.type.keyword;
      }, Ye.parseClassElementName = function(E) {
        this.type === C.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), E.computed = !1, E.key = this.parsePrivateIdent()) : this.parsePropertyName(E);
      }, Ye.parseClassMethod = function(E, D, K, J) {
        var me = E.key;
        E.kind === "constructor" ? (D && this.raise(me.start, "Constructor can't be a generator"), K && this.raise(me.start, "Constructor can't be an async method")) : E.static && de(E, "prototype") && this.raise(me.start, "Classes may not have a static property named prototype");
        var Le = E.value = this.parseMethod(D, K, J);
        return E.kind === "get" && Le.params.length !== 0 && this.raiseRecoverable(Le.start, "getter should have no params"), E.kind === "set" && Le.params.length !== 1 && this.raiseRecoverable(Le.start, "setter should have exactly one param"), E.kind === "set" && Le.params[0].type === "RestElement" && this.raiseRecoverable(Le.params[0].start, "Setter cannot use rest params"), this.finishNode(E, "MethodDefinition");
      }, Ye.parseClassField = function(E) {
        if (de(E, "constructor") ? this.raise(E.key.start, "Classes can't have a field named 'constructor'") : E.static && de(E, "prototype") && this.raise(E.key.start, "Classes can't have a static field named 'prototype'"), this.eat(C.eq)) {
          var D = this.currentThisScope(), K = D.inClassFieldInit;
          D.inClassFieldInit = !0, E.value = this.parseMaybeAssign(), D.inClassFieldInit = K;
        } else
          E.value = null;
        return this.semicolon(), this.finishNode(E, "PropertyDefinition");
      }, Ye.parseClassStaticBlock = function(E) {
        E.body = [];
        var D = this.labels;
        for (this.labels = [], this.enterScope(at | Ie); this.type !== C.braceR; ) {
          var K = this.parseStatement(null);
          E.body.push(K);
        }
        return this.next(), this.exitScope(), this.labels = D, this.finishNode(E, "StaticBlock");
      }, Ye.parseClassId = function(E, D) {
        this.type === C.name ? (E.id = this.parseIdent(), D && this.checkLValSimple(E.id, Ke, !1)) : (D === !0 && this.unexpected(), E.id = null);
      }, Ye.parseClassSuper = function(E) {
        E.superClass = this.eat(C._extends) ? this.parseExprSubscripts(null, !1) : null;
      }, Ye.enterClassBody = function() {
        var E = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        return this.privateNameStack.push(E), E.declared;
      }, Ye.exitClassBody = function() {
        for (var E = this.privateNameStack.pop(), D = E.declared, K = E.used, J = this.privateNameStack.length, me = J === 0 ? null : this.privateNameStack[J - 1], Le = 0; Le < K.length; ++Le) {
          var Fe = K[Le];
          U(D, Fe.name) || (me ? me.used.push(Fe) : this.raiseRecoverable(Fe.start, "Private field '#" + Fe.name + "' must be declared in an enclosing class"));
        }
      };
      function fe(E, D) {
        var K = D.key.name, J = E[K], me = "true";
        return D.type === "MethodDefinition" && (D.kind === "get" || D.kind === "set") && (me = (D.static ? "s" : "i") + D.kind), J === "iget" && me === "iset" || J === "iset" && me === "iget" || J === "sget" && me === "sset" || J === "sset" && me === "sget" ? (E[K] = "true", !1) : J ? !0 : (E[K] = me, !1);
      }
      function de(E, D) {
        var K = E.computed, J = E.key;
        return !K && (J.type === "Identifier" && J.name === D || J.type === "Literal" && J.value === D);
      }
      Ye.parseExportAllDeclaration = function(E, D) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (E.exported = this.parseModuleExportName(), this.checkExport(D, E.exported, this.lastTokStart)) : E.exported = null), this.expectContextual("from"), this.type !== C.string && this.unexpected(), E.source = this.parseExprAtom(), this.semicolon(), this.finishNode(E, "ExportAllDeclaration");
      }, Ye.parseExport = function(E, D) {
        if (this.next(), this.eat(C.star))
          return this.parseExportAllDeclaration(E, D);
        if (this.eat(C._default))
          return this.checkExport(D, "default", this.lastTokStart), E.declaration = this.parseExportDefaultDeclaration(), this.finishNode(E, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement())
          E.declaration = this.parseExportDeclaration(E), E.declaration.type === "VariableDeclaration" ? this.checkVariableExport(D, E.declaration.declarations) : this.checkExport(D, E.declaration.id, E.declaration.id.start), E.specifiers = [], E.source = null;
        else {
          if (E.declaration = null, E.specifiers = this.parseExportSpecifiers(D), this.eatContextual("from"))
            this.type !== C.string && this.unexpected(), E.source = this.parseExprAtom();
          else {
            for (var K = 0, J = E.specifiers; K < J.length; K += 1) {
              var me = J[K];
              this.checkUnreserved(me.local), this.checkLocalExport(me.local), me.local.type === "Literal" && this.raise(me.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            E.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(E, "ExportNamedDeclaration");
      }, Ye.parseExportDeclaration = function(E) {
        return this.parseStatement(null);
      }, Ye.parseExportDefaultDeclaration = function() {
        var E;
        if (this.type === C._function || (E = this.isAsyncFunction())) {
          var D = this.startNode();
          return this.next(), E && this.next(), this.parseFunction(D, re | ae, !1, E);
        } else if (this.type === C._class) {
          var K = this.startNode();
          return this.parseClass(K, "nullableID");
        } else {
          var J = this.parseMaybeAssign();
          return this.semicolon(), J;
        }
      }, Ye.checkExport = function(E, D, K) {
        E && (typeof D != "string" && (D = D.type === "Identifier" ? D.name : D.value), U(E, D) && this.raiseRecoverable(K, "Duplicate export '" + D + "'"), E[D] = !0);
      }, Ye.checkPatternExport = function(E, D) {
        var K = D.type;
        if (K === "Identifier")
          this.checkExport(E, D, D.start);
        else if (K === "ObjectPattern")
          for (var J = 0, me = D.properties; J < me.length; J += 1) {
            var Le = me[J];
            this.checkPatternExport(E, Le);
          }
        else if (K === "ArrayPattern")
          for (var Fe = 0, ze = D.elements; Fe < ze.length; Fe += 1) {
            var Qe = ze[Fe];
            Qe && this.checkPatternExport(E, Qe);
          }
        else K === "Property" ? this.checkPatternExport(E, D.value) : K === "AssignmentPattern" ? this.checkPatternExport(E, D.left) : K === "RestElement" ? this.checkPatternExport(E, D.argument) : K === "ParenthesizedExpression" && this.checkPatternExport(E, D.expression);
      }, Ye.checkVariableExport = function(E, D) {
        if (E)
          for (var K = 0, J = D; K < J.length; K += 1) {
            var me = J[K];
            this.checkPatternExport(E, me.id);
          }
      }, Ye.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, Ye.parseExportSpecifier = function(E) {
        var D = this.startNode();
        return D.local = this.parseModuleExportName(), D.exported = this.eatContextual("as") ? this.parseModuleExportName() : D.local, this.checkExport(
          E,
          D.exported,
          D.exported.start
        ), this.finishNode(D, "ExportSpecifier");
      }, Ye.parseExportSpecifiers = function(E) {
        var D = [], K = !0;
        for (this.expect(C.braceL); !this.eat(C.braceR); ) {
          if (K)
            K = !1;
          else if (this.expect(C.comma), this.afterTrailingComma(C.braceR))
            break;
          D.push(this.parseExportSpecifier(E));
        }
        return D;
      }, Ye.parseImport = function(E) {
        return this.next(), this.type === C.string ? (E.specifiers = xe, E.source = this.parseExprAtom()) : (E.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), E.source = this.type === C.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(E, "ImportDeclaration");
      }, Ye.parseImportSpecifier = function() {
        var E = this.startNode();
        return E.imported = this.parseModuleExportName(), this.eatContextual("as") ? E.local = this.parseIdent() : (this.checkUnreserved(E.imported), E.local = E.imported), this.checkLValSimple(E.local, Ke), this.finishNode(E, "ImportSpecifier");
      }, Ye.parseImportDefaultSpecifier = function() {
        var E = this.startNode();
        return E.local = this.parseIdent(), this.checkLValSimple(E.local, Ke), this.finishNode(E, "ImportDefaultSpecifier");
      }, Ye.parseImportNamespaceSpecifier = function() {
        var E = this.startNode();
        return this.next(), this.expectContextual("as"), E.local = this.parseIdent(), this.checkLValSimple(E.local, Ke), this.finishNode(E, "ImportNamespaceSpecifier");
      }, Ye.parseImportSpecifiers = function() {
        var E = [], D = !0;
        if (this.type === C.name && (E.push(this.parseImportDefaultSpecifier()), !this.eat(C.comma)))
          return E;
        if (this.type === C.star)
          return E.push(this.parseImportNamespaceSpecifier()), E;
        for (this.expect(C.braceL); !this.eat(C.braceR); ) {
          if (D)
            D = !1;
          else if (this.expect(C.comma), this.afterTrailingComma(C.braceR))
            break;
          E.push(this.parseImportSpecifier());
        }
        return E;
      }, Ye.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === C.string) {
          var E = this.parseLiteral(this.value);
          return P.test(E.value) && this.raise(E.start, "An export name cannot include a lone surrogate."), E;
        }
        return this.parseIdent(!0);
      }, Ye.adaptDirectivePrologue = function(E) {
        for (var D = 0; D < E.length && this.isDirectiveCandidate(E[D]); ++D)
          E[D].directive = E[D].expression.raw.slice(1, -1);
      }, Ye.isDirectiveCandidate = function(E) {
        return this.options.ecmaVersion >= 5 && E.type === "ExpressionStatement" && E.expression.type === "Literal" && typeof E.expression.value == "string" && // Reject parenthesized strings.
        (this.input[E.start] === '"' || this.input[E.start] === "'");
      };
      var ee = ot.prototype;
      ee.toAssignable = function(E, D, K) {
        if (this.options.ecmaVersion >= 6 && E)
          switch (E.type) {
            case "Identifier":
              this.inAsync && E.name === "await" && this.raise(E.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              E.type = "ObjectPattern", K && this.checkPatternErrors(K, !0);
              for (var J = 0, me = E.properties; J < me.length; J += 1) {
                var Le = me[J];
                this.toAssignable(Le, D), Le.type === "RestElement" && (Le.argument.type === "ArrayPattern" || Le.argument.type === "ObjectPattern") && this.raise(Le.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              E.kind !== "init" && this.raise(E.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(E.value, D);
              break;
            case "ArrayExpression":
              E.type = "ArrayPattern", K && this.checkPatternErrors(K, !0), this.toAssignableList(E.elements, D);
              break;
            case "SpreadElement":
              E.type = "RestElement", this.toAssignable(E.argument, D), E.argument.type === "AssignmentPattern" && this.raise(E.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              E.operator !== "=" && this.raise(E.left.end, "Only '=' operator can be used for specifying default value."), E.type = "AssignmentPattern", delete E.operator, this.toAssignable(E.left, D);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(E.expression, D, K);
              break;
            case "ChainExpression":
              this.raiseRecoverable(E.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!D)
                break;
            default:
              this.raise(E.start, "Assigning to rvalue");
          }
        else K && this.checkPatternErrors(K, !0);
        return E;
      }, ee.toAssignableList = function(E, D) {
        for (var K = E.length, J = 0; J < K; J++) {
          var me = E[J];
          me && this.toAssignable(me, D);
        }
        if (K) {
          var Le = E[K - 1];
          this.options.ecmaVersion === 6 && D && Le && Le.type === "RestElement" && Le.argument.type !== "Identifier" && this.unexpected(Le.argument.start);
        }
        return E;
      }, ee.parseSpread = function(E) {
        var D = this.startNode();
        return this.next(), D.argument = this.parseMaybeAssign(!1, E), this.finishNode(D, "SpreadElement");
      }, ee.parseRestBinding = function() {
        var E = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== C.name && this.unexpected(), E.argument = this.parseBindingAtom(), this.finishNode(E, "RestElement");
      }, ee.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case C.bracketL:
              var E = this.startNode();
              return this.next(), E.elements = this.parseBindingList(C.bracketR, !0, !0), this.finishNode(E, "ArrayPattern");
            case C.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }, ee.parseBindingList = function(E, D, K, J) {
        for (var me = [], Le = !0; !this.eat(E); )
          if (Le ? Le = !1 : this.expect(C.comma), D && this.type === C.comma)
            me.push(null);
          else {
            if (K && this.afterTrailingComma(E))
              break;
            if (this.type === C.ellipsis) {
              var Fe = this.parseRestBinding();
              this.parseBindingListItem(Fe), me.push(Fe), this.type === C.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(E);
              break;
            } else
              me.push(this.parseAssignableListItem(J));
          }
        return me;
      }, ee.parseAssignableListItem = function(E) {
        var D = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(D), D;
      }, ee.parseBindingListItem = function(E) {
        return E;
      }, ee.parseMaybeDefault = function(E, D, K) {
        if (K = K || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(C.eq))
          return K;
        var J = this.startNodeAt(E, D);
        return J.left = K, J.right = this.parseMaybeAssign(), this.finishNode(J, "AssignmentPattern");
      }, ee.checkLValSimple = function(E, D, K) {
        D === void 0 && (D = Y);
        var J = D !== Y;
        switch (E.type) {
          case "Identifier":
            this.strict && this.reservedWordsStrictBind.test(E.name) && this.raiseRecoverable(E.start, (J ? "Binding " : "Assigning to ") + E.name + " in strict mode"), J && (D === Ke && E.name === "let" && this.raiseRecoverable(E.start, "let is disallowed as a lexically bound name"), K && (U(K, E.name) && this.raiseRecoverable(E.start, "Argument name clash"), K[E.name] = !0), D !== rt && this.declareName(E.name, D, E.start));
            break;
          case "ChainExpression":
            this.raiseRecoverable(E.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            J && this.raiseRecoverable(E.start, "Binding member expression");
            break;
          case "ParenthesizedExpression":
            return J && this.raiseRecoverable(E.start, "Binding parenthesized expression"), this.checkLValSimple(E.expression, D, K);
          default:
            this.raise(E.start, (J ? "Binding" : "Assigning to") + " rvalue");
        }
      }, ee.checkLValPattern = function(E, D, K) {
        switch (D === void 0 && (D = Y), E.type) {
          case "ObjectPattern":
            for (var J = 0, me = E.properties; J < me.length; J += 1) {
              var Le = me[J];
              this.checkLValInnerPattern(Le, D, K);
            }
            break;
          case "ArrayPattern":
            for (var Fe = 0, ze = E.elements; Fe < ze.length; Fe += 1) {
              var Qe = ze[Fe];
              Qe && this.checkLValInnerPattern(Qe, D, K);
            }
            break;
          default:
            this.checkLValSimple(E, D, K);
        }
      }, ee.checkLValInnerPattern = function(E, D, K) {
        switch (D === void 0 && (D = Y), E.type) {
          case "Property":
            this.checkLValInnerPattern(E.value, D, K);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(E.left, D, K);
            break;
          case "RestElement":
            this.checkLValPattern(E.argument, D, K);
            break;
          default:
            this.checkLValPattern(E, D, K);
        }
      };
      var te = function(D, K, J, me, Le) {
        this.token = D, this.isExpr = !!K, this.preserveSpace = !!J, this.override = me, this.generator = !!Le;
      }, B = {
        b_stat: new te("{", !1),
        b_expr: new te("{", !0),
        b_tmpl: new te("${", !1),
        p_stat: new te("(", !1),
        p_expr: new te("(", !0),
        q_tmpl: new te("`", !0, !0, function(E) {
          return E.tryReadTemplateToken();
        }),
        f_stat: new te("function", !1),
        f_expr: new te("function", !0),
        f_expr_gen: new te("function", !0, !1, null, !0),
        f_gen: new te("function", !1, !1, null, !0)
      }, z = ot.prototype;
      z.initialContext = function() {
        return [B.b_stat];
      }, z.curContext = function() {
        return this.context[this.context.length - 1];
      }, z.braceIsBlock = function(E) {
        var D = this.curContext();
        return D === B.f_expr || D === B.f_stat ? !0 : E === C.colon && (D === B.b_stat || D === B.b_expr) ? !D.isExpr : E === C._return || E === C.name && this.exprAllowed ? x.test(this.input.slice(this.lastTokEnd, this.start)) : E === C._else || E === C.semi || E === C.eof || E === C.parenR || E === C.arrow ? !0 : E === C.braceL ? D === B.b_stat : E === C._var || E === C._const || E === C.name ? !1 : !this.exprAllowed;
      }, z.inGeneratorContext = function() {
        for (var E = this.context.length - 1; E >= 1; E--) {
          var D = this.context[E];
          if (D.token === "function")
            return D.generator;
        }
        return !1;
      }, z.updateContext = function(E) {
        var D, K = this.type;
        K.keyword && E === C.dot ? this.exprAllowed = !1 : (D = K.updateContext) ? D.call(this, E) : this.exprAllowed = K.beforeExpr;
      }, z.overrideContext = function(E) {
        this.curContext() !== E && (this.context[this.context.length - 1] = E);
      }, C.parenR.updateContext = C.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = !0;
          return;
        }
        var E = this.context.pop();
        E === B.b_stat && this.curContext().token === "function" && (E = this.context.pop()), this.exprAllowed = !E.isExpr;
      }, C.braceL.updateContext = function(E) {
        this.context.push(this.braceIsBlock(E) ? B.b_stat : B.b_expr), this.exprAllowed = !0;
      }, C.dollarBraceL.updateContext = function() {
        this.context.push(B.b_tmpl), this.exprAllowed = !0;
      }, C.parenL.updateContext = function(E) {
        var D = E === C._if || E === C._for || E === C._with || E === C._while;
        this.context.push(D ? B.p_stat : B.p_expr), this.exprAllowed = !0;
      }, C.incDec.updateContext = function() {
      }, C._function.updateContext = C._class.updateContext = function(E) {
        E.beforeExpr && E !== C._else && !(E === C.semi && this.curContext() !== B.p_stat) && !(E === C._return && x.test(this.input.slice(this.lastTokEnd, this.start))) && !((E === C.colon || E === C.braceL) && this.curContext() === B.b_stat) ? this.context.push(B.f_expr) : this.context.push(B.f_stat), this.exprAllowed = !1;
      }, C.backQuote.updateContext = function() {
        this.curContext() === B.q_tmpl ? this.context.pop() : this.context.push(B.q_tmpl), this.exprAllowed = !1;
      }, C.star.updateContext = function(E) {
        if (E === C._function) {
          var D = this.context.length - 1;
          this.context[D] === B.f_expr ? this.context[D] = B.f_expr_gen : this.context[D] = B.f_gen;
        }
        this.exprAllowed = !0;
      }, C.name.updateContext = function(E) {
        var D = !1;
        this.options.ecmaVersion >= 6 && E !== C.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (D = !0), this.exprAllowed = D;
      };
      var ce = ot.prototype;
      ce.checkPropClash = function(E, D, K) {
        if (!(this.options.ecmaVersion >= 9 && E.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (E.computed || E.method || E.shorthand))) {
          var J = E.key, me;
          switch (J.type) {
            case "Identifier":
              me = J.name;
              break;
            case "Literal":
              me = String(J.value);
              break;
            default:
              return;
          }
          var Le = E.kind;
          if (this.options.ecmaVersion >= 6) {
            me === "__proto__" && Le === "init" && (D.proto && (K ? K.doubleProto < 0 && (K.doubleProto = J.start) : this.raiseRecoverable(J.start, "Redefinition of __proto__ property")), D.proto = !0);
            return;
          }
          me = "$" + me;
          var Fe = D[me];
          if (Fe) {
            var ze;
            Le === "init" ? ze = this.strict && Fe.init || Fe.get || Fe.set : ze = Fe.init || Fe[Le], ze && this.raiseRecoverable(J.start, "Redefinition of property");
          } else
            Fe = D[me] = {
              init: !1,
              get: !1,
              set: !1
            };
          Fe[Le] = !0;
        }
      }, ce.parseExpression = function(E, D) {
        var K = this.start, J = this.startLoc, me = this.parseMaybeAssign(E, D);
        if (this.type === C.comma) {
          var Le = this.startNodeAt(K, J);
          for (Le.expressions = [me]; this.eat(C.comma); )
            Le.expressions.push(this.parseMaybeAssign(E, D));
          return this.finishNode(Le, "SequenceExpression");
        }
        return me;
      }, ce.parseMaybeAssign = function(E, D, K) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(E);
          this.exprAllowed = !1;
        }
        var J = !1, me = -1, Le = -1, Fe = -1;
        D ? (me = D.parenthesizedAssign, Le = D.trailingComma, Fe = D.doubleProto, D.parenthesizedAssign = D.trailingComma = -1) : (D = new W(), J = !0);
        var ze = this.start, Qe = this.startLoc;
        (this.type === C.parenL || this.type === C.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = E === "await");
        var pt = this.parseMaybeConditional(E, D);
        if (K && (pt = K.call(this, pt, ze, Qe)), this.type.isAssign) {
          var Et = this.startNodeAt(ze, Qe);
          return Et.operator = this.value, this.type === C.eq && (pt = this.toAssignable(pt, !1, D)), J || (D.parenthesizedAssign = D.trailingComma = D.doubleProto = -1), D.shorthandAssign >= pt.start && (D.shorthandAssign = -1), this.type === C.eq ? this.checkLValPattern(pt) : this.checkLValSimple(pt), Et.left = pt, this.next(), Et.right = this.parseMaybeAssign(E), Fe > -1 && (D.doubleProto = Fe), this.finishNode(Et, "AssignmentExpression");
        } else
          J && this.checkExpressionErrors(D, !0);
        return me > -1 && (D.parenthesizedAssign = me), Le > -1 && (D.trailingComma = Le), pt;
      }, ce.parseMaybeConditional = function(E, D) {
        var K = this.start, J = this.startLoc, me = this.parseExprOps(E, D);
        if (this.checkExpressionErrors(D))
          return me;
        if (this.eat(C.question)) {
          var Le = this.startNodeAt(K, J);
          return Le.test = me, Le.consequent = this.parseMaybeAssign(), this.expect(C.colon), Le.alternate = this.parseMaybeAssign(E), this.finishNode(Le, "ConditionalExpression");
        }
        return me;
      }, ce.parseExprOps = function(E, D) {
        var K = this.start, J = this.startLoc, me = this.parseMaybeUnary(D, !1, !1, E);
        return this.checkExpressionErrors(D) || me.start === K && me.type === "ArrowFunctionExpression" ? me : this.parseExprOp(me, K, J, -1, E);
      }, ce.parseExprOp = function(E, D, K, J, me) {
        var Le = this.type.binop;
        if (Le != null && (!me || this.type !== C._in) && Le > J) {
          var Fe = this.type === C.logicalOR || this.type === C.logicalAND, ze = this.type === C.coalesce;
          ze && (Le = C.logicalAND.binop);
          var Qe = this.value;
          this.next();
          var pt = this.start, Et = this.startLoc, _t = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, me), pt, Et, Le, me), ir = this.buildBinary(D, K, E, _t, Qe, Fe || ze);
          return (Fe && this.type === C.coalesce || ze && (this.type === C.logicalOR || this.type === C.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(ir, D, K, J, me);
        }
        return E;
      }, ce.buildBinary = function(E, D, K, J, me, Le) {
        J.type === "PrivateIdentifier" && this.raise(J.start, "Private identifier can only be left side of binary expression");
        var Fe = this.startNodeAt(E, D);
        return Fe.left = K, Fe.operator = me, Fe.right = J, this.finishNode(Fe, Le ? "LogicalExpression" : "BinaryExpression");
      }, ce.parseMaybeUnary = function(E, D, K, J) {
        var me = this.start, Le = this.startLoc, Fe;
        if (this.isContextual("await") && this.canAwait)
          Fe = this.parseAwait(J), D = !0;
        else if (this.type.prefix) {
          var ze = this.startNode(), Qe = this.type === C.incDec;
          ze.operator = this.value, ze.prefix = !0, this.next(), ze.argument = this.parseMaybeUnary(null, !0, Qe, J), this.checkExpressionErrors(E, !0), Qe ? this.checkLValSimple(ze.argument) : this.strict && ze.operator === "delete" && ze.argument.type === "Identifier" ? this.raiseRecoverable(ze.start, "Deleting local variable in strict mode") : ze.operator === "delete" && ye(ze.argument) ? this.raiseRecoverable(ze.start, "Private fields can not be deleted") : D = !0, Fe = this.finishNode(ze, Qe ? "UpdateExpression" : "UnaryExpression");
        } else if (!D && this.type === C.privateId)
          (J || this.privateNameStack.length === 0) && this.unexpected(), Fe = this.parsePrivateIdent(), this.type !== C._in && this.unexpected();
        else {
          if (Fe = this.parseExprSubscripts(E, J), this.checkExpressionErrors(E))
            return Fe;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var pt = this.startNodeAt(me, Le);
            pt.operator = this.value, pt.prefix = !1, pt.argument = Fe, this.checkLValSimple(Fe), this.next(), Fe = this.finishNode(pt, "UpdateExpression");
          }
        }
        if (!K && this.eat(C.starstar))
          if (D)
            this.unexpected(this.lastTokStart);
          else
            return this.buildBinary(me, Le, Fe, this.parseMaybeUnary(null, !1, !1, J), "**", !1);
        else
          return Fe;
      };
      function ye(E) {
        return E.type === "MemberExpression" && E.property.type === "PrivateIdentifier" || E.type === "ChainExpression" && ye(E.expression);
      }
      ce.parseExprSubscripts = function(E, D) {
        var K = this.start, J = this.startLoc, me = this.parseExprAtom(E, D);
        if (me.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return me;
        var Le = this.parseSubscripts(me, K, J, !1, D);
        return E && Le.type === "MemberExpression" && (E.parenthesizedAssign >= Le.start && (E.parenthesizedAssign = -1), E.parenthesizedBind >= Le.start && (E.parenthesizedBind = -1), E.trailingComma >= Le.start && (E.trailingComma = -1)), Le;
      }, ce.parseSubscripts = function(E, D, K, J, me) {
        for (var Le = this.options.ecmaVersion >= 8 && E.type === "Identifier" && E.name === "async" && this.lastTokEnd === E.end && !this.canInsertSemicolon() && E.end - E.start === 5 && this.potentialArrowAt === E.start, Fe = !1; ; ) {
          var ze = this.parseSubscript(E, D, K, J, Le, Fe, me);
          if (ze.optional && (Fe = !0), ze === E || ze.type === "ArrowFunctionExpression") {
            if (Fe) {
              var Qe = this.startNodeAt(D, K);
              Qe.expression = ze, ze = this.finishNode(Qe, "ChainExpression");
            }
            return ze;
          }
          E = ze;
        }
      }, ce.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(C.arrow);
      }, ce.parseSubscriptAsyncArrow = function(E, D, K, J) {
        return this.parseArrowExpression(this.startNodeAt(E, D), K, !0, J);
      }, ce.parseSubscript = function(E, D, K, J, me, Le, Fe) {
        var ze = this.options.ecmaVersion >= 11, Qe = ze && this.eat(C.questionDot);
        J && Qe && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var pt = this.eat(C.bracketL);
        if (pt || Qe && this.type !== C.parenL && this.type !== C.backQuote || this.eat(C.dot)) {
          var Et = this.startNodeAt(D, K);
          Et.object = E, pt ? (Et.property = this.parseExpression(), this.expect(C.bracketR)) : this.type === C.privateId && E.type !== "Super" ? Et.property = this.parsePrivateIdent() : Et.property = this.parseIdent(this.options.allowReserved !== "never"), Et.computed = !!pt, ze && (Et.optional = Qe), E = this.finishNode(Et, "MemberExpression");
        } else if (!J && this.eat(C.parenL)) {
          var _t = new W(), ir = this.yieldPos, pr = this.awaitPos, hr = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var yr = this.parseExprList(C.parenR, this.options.ecmaVersion >= 8, !1, _t);
          if (me && !Qe && this.shouldParseAsyncArrow())
            return this.checkPatternErrors(_t, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = ir, this.awaitPos = pr, this.awaitIdentPos = hr, this.parseSubscriptAsyncArrow(D, K, yr, Fe);
          this.checkExpressionErrors(_t, !0), this.yieldPos = ir || this.yieldPos, this.awaitPos = pr || this.awaitPos, this.awaitIdentPos = hr || this.awaitIdentPos;
          var mr = this.startNodeAt(D, K);
          mr.callee = E, mr.arguments = yr, ze && (mr.optional = Qe), E = this.finishNode(mr, "CallExpression");
        } else if (this.type === C.backQuote) {
          (Qe || Le) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var gr = this.startNodeAt(D, K);
          gr.tag = E, gr.quasi = this.parseTemplate({ isTagged: !0 }), E = this.finishNode(gr, "TaggedTemplateExpression");
        }
        return E;
      }, ce.parseExprAtom = function(E, D, K) {
        this.type === C.slash && this.readRegexp();
        var J, me = this.potentialArrowAt === this.start;
        switch (this.type) {
          case C._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), J = this.startNode(), this.next(), this.type === C.parenL && !this.allowDirectSuper && this.raise(J.start, "super() call outside constructor of a subclass"), this.type !== C.dot && this.type !== C.bracketL && this.type !== C.parenL && this.unexpected(), this.finishNode(J, "Super");
          case C._this:
            return J = this.startNode(), this.next(), this.finishNode(J, "ThisExpression");
          case C.name:
            var Le = this.start, Fe = this.startLoc, ze = this.containsEsc, Qe = this.parseIdent(!1);
            if (this.options.ecmaVersion >= 8 && !ze && Qe.name === "async" && !this.canInsertSemicolon() && this.eat(C._function))
              return this.overrideContext(B.f_expr), this.parseFunction(this.startNodeAt(Le, Fe), 0, !1, !0, D);
            if (me && !this.canInsertSemicolon()) {
              if (this.eat(C.arrow))
                return this.parseArrowExpression(this.startNodeAt(Le, Fe), [Qe], !1, D);
              if (this.options.ecmaVersion >= 8 && Qe.name === "async" && this.type === C.name && !ze && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                return Qe = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(C.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(Le, Fe), [Qe], !0, D);
            }
            return Qe;
          case C.regexp:
            var pt = this.value;
            return J = this.parseLiteral(pt.value), J.regex = { pattern: pt.pattern, flags: pt.flags }, J;
          case C.num:
          case C.string:
            return this.parseLiteral(this.value);
          case C._null:
          case C._true:
          case C._false:
            return J = this.startNode(), J.value = this.type === C._null ? null : this.type === C._true, J.raw = this.type.keyword, this.next(), this.finishNode(J, "Literal");
          case C.parenL:
            var Et = this.start, _t = this.parseParenAndDistinguishExpression(me, D);
            return E && (E.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(_t) && (E.parenthesizedAssign = Et), E.parenthesizedBind < 0 && (E.parenthesizedBind = Et)), _t;
          case C.bracketL:
            return J = this.startNode(), this.next(), J.elements = this.parseExprList(C.bracketR, !0, !0, E), this.finishNode(J, "ArrayExpression");
          case C.braceL:
            return this.overrideContext(B.b_expr), this.parseObj(!1, E);
          case C._function:
            return J = this.startNode(), this.next(), this.parseFunction(J, 0);
          case C._class:
            return this.parseClass(this.startNode(), !1);
          case C._new:
            return this.parseNew();
          case C.backQuote:
            return this.parseTemplate();
          case C._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(K) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }, ce.parseExprAtomDefault = function() {
        this.unexpected();
      }, ce.parseExprImport = function(E) {
        var D = this.startNode();
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        var K = this.parseIdent(!0);
        if (this.type === C.parenL && !E)
          return this.parseDynamicImport(D);
        if (this.type === C.dot)
          return D.meta = K, this.parseImportMeta(D);
        this.unexpected();
      }, ce.parseDynamicImport = function(E) {
        if (this.next(), E.source = this.parseMaybeAssign(), !this.eat(C.parenR)) {
          var D = this.start;
          this.eat(C.comma) && this.eat(C.parenR) ? this.raiseRecoverable(D, "Trailing comma is not allowed in import()") : this.unexpected(D);
        }
        return this.finishNode(E, "ImportExpression");
      }, ce.parseImportMeta = function(E) {
        this.next();
        var D = this.containsEsc;
        return E.property = this.parseIdent(!0), E.property.name !== "meta" && this.raiseRecoverable(E.property.start, "The only valid meta property for import is 'import.meta'"), D && this.raiseRecoverable(E.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(E.start, "Cannot use 'import.meta' outside a module"), this.finishNode(E, "MetaProperty");
      }, ce.parseLiteral = function(E) {
        var D = this.startNode();
        return D.value = E, D.raw = this.input.slice(this.start, this.end), D.raw.charCodeAt(D.raw.length - 1) === 110 && (D.bigint = D.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(D, "Literal");
      }, ce.parseParenExpression = function() {
        this.expect(C.parenL);
        var E = this.parseExpression();
        return this.expect(C.parenR), E;
      }, ce.shouldParseArrow = function(E) {
        return !this.canInsertSemicolon();
      }, ce.parseParenAndDistinguishExpression = function(E, D) {
        var K = this.start, J = this.startLoc, me, Le = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var Fe = this.start, ze = this.startLoc, Qe = [], pt = !0, Et = !1, _t = new W(), ir = this.yieldPos, pr = this.awaitPos, hr;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== C.parenR; )
            if (pt ? pt = !1 : this.expect(C.comma), Le && this.afterTrailingComma(C.parenR, !0)) {
              Et = !0;
              break;
            } else if (this.type === C.ellipsis) {
              hr = this.start, Qe.push(this.parseParenItem(this.parseRestBinding())), this.type === C.comma && this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
              break;
            } else
              Qe.push(this.parseMaybeAssign(!1, _t, this.parseParenItem));
          var yr = this.lastTokEnd, mr = this.lastTokEndLoc;
          if (this.expect(C.parenR), E && this.shouldParseArrow(Qe) && this.eat(C.arrow))
            return this.checkPatternErrors(_t, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = ir, this.awaitPos = pr, this.parseParenArrowList(K, J, Qe, D);
          (!Qe.length || Et) && this.unexpected(this.lastTokStart), hr && this.unexpected(hr), this.checkExpressionErrors(_t, !0), this.yieldPos = ir || this.yieldPos, this.awaitPos = pr || this.awaitPos, Qe.length > 1 ? (me = this.startNodeAt(Fe, ze), me.expressions = Qe, this.finishNodeAt(me, "SequenceExpression", yr, mr)) : me = Qe[0];
        } else
          me = this.parseParenExpression();
        if (this.options.preserveParens) {
          var gr = this.startNodeAt(K, J);
          return gr.expression = me, this.finishNode(gr, "ParenthesizedExpression");
        } else
          return me;
      }, ce.parseParenItem = function(E) {
        return E;
      }, ce.parseParenArrowList = function(E, D, K, J) {
        return this.parseArrowExpression(this.startNodeAt(E, D), K, !1, J);
      };
      var Be = [];
      ce.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var E = this.startNode(), D = this.parseIdent(!0);
        if (this.options.ecmaVersion >= 6 && this.eat(C.dot)) {
          E.meta = D;
          var K = this.containsEsc;
          return E.property = this.parseIdent(!0), E.property.name !== "target" && this.raiseRecoverable(E.property.start, "The only valid meta property for new is 'new.target'"), K && this.raiseRecoverable(E.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(E.start, "'new.target' can only be used in functions and class static block"), this.finishNode(E, "MetaProperty");
        }
        var J = this.start, me = this.startLoc;
        return E.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), J, me, !0, !1), this.eat(C.parenL) ? E.arguments = this.parseExprList(C.parenR, this.options.ecmaVersion >= 8, !1) : E.arguments = Be, this.finishNode(E, "NewExpression");
      }, ce.parseTemplateElement = function(E) {
        var D = E.isTagged, K = this.startNode();
        return this.type === C.invalidTemplate ? (D || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), K.value = {
          raw: this.value,
          cooked: null
        }) : K.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), K.tail = this.type === C.backQuote, this.finishNode(K, "TemplateElement");
      }, ce.parseTemplate = function(E) {
        E === void 0 && (E = {});
        var D = E.isTagged;
        D === void 0 && (D = !1);
        var K = this.startNode();
        this.next(), K.expressions = [];
        var J = this.parseTemplateElement({ isTagged: D });
        for (K.quasis = [J]; !J.tail; )
          this.type === C.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(C.dollarBraceL), K.expressions.push(this.parseExpression()), this.expect(C.braceR), K.quasis.push(J = this.parseTemplateElement({ isTagged: D }));
        return this.next(), this.finishNode(K, "TemplateLiteral");
      }, ce.isAsyncProp = function(E) {
        return !E.computed && E.key.type === "Identifier" && E.key.name === "async" && (this.type === C.name || this.type === C.num || this.type === C.string || this.type === C.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === C.star) && !x.test(this.input.slice(this.lastTokEnd, this.start));
      }, ce.parseObj = function(E, D) {
        var K = this.startNode(), J = !0, me = {};
        for (K.properties = [], this.next(); !this.eat(C.braceR); ) {
          if (J)
            J = !1;
          else if (this.expect(C.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(C.braceR))
            break;
          var Le = this.parseProperty(E, D);
          E || this.checkPropClash(Le, me, D), K.properties.push(Le);
        }
        return this.finishNode(K, E ? "ObjectPattern" : "ObjectExpression");
      }, ce.parseProperty = function(E, D) {
        var K = this.startNode(), J, me, Le, Fe;
        if (this.options.ecmaVersion >= 9 && this.eat(C.ellipsis))
          return E ? (K.argument = this.parseIdent(!1), this.type === C.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(K, "RestElement")) : (K.argument = this.parseMaybeAssign(!1, D), this.type === C.comma && D && D.trailingComma < 0 && (D.trailingComma = this.start), this.finishNode(K, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (K.method = !1, K.shorthand = !1, (E || D) && (Le = this.start, Fe = this.startLoc), E || (J = this.eat(C.star)));
        var ze = this.containsEsc;
        return this.parsePropertyName(K), !E && !ze && this.options.ecmaVersion >= 8 && !J && this.isAsyncProp(K) ? (me = !0, J = this.options.ecmaVersion >= 9 && this.eat(C.star), this.parsePropertyName(K)) : me = !1, this.parsePropertyValue(K, E, J, me, Le, Fe, D, ze), this.finishNode(K, "Property");
      }, ce.parseGetterSetter = function(E) {
        E.kind = E.key.name, this.parsePropertyName(E), E.value = this.parseMethod(!1);
        var D = E.kind === "get" ? 0 : 1;
        if (E.value.params.length !== D) {
          var K = E.value.start;
          E.kind === "get" ? this.raiseRecoverable(K, "getter should have no params") : this.raiseRecoverable(K, "setter should have exactly one param");
        } else
          E.kind === "set" && E.value.params[0].type === "RestElement" && this.raiseRecoverable(E.value.params[0].start, "Setter cannot use rest params");
      }, ce.parsePropertyValue = function(E, D, K, J, me, Le, Fe, ze) {
        (K || J) && this.type === C.colon && this.unexpected(), this.eat(C.colon) ? (E.value = D ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, Fe), E.kind = "init") : this.options.ecmaVersion >= 6 && this.type === C.parenL ? (D && this.unexpected(), E.kind = "init", E.method = !0, E.value = this.parseMethod(K, J)) : !D && !ze && this.options.ecmaVersion >= 5 && !E.computed && E.key.type === "Identifier" && (E.key.name === "get" || E.key.name === "set") && this.type !== C.comma && this.type !== C.braceR && this.type !== C.eq ? ((K || J) && this.unexpected(), this.parseGetterSetter(E)) : this.options.ecmaVersion >= 6 && !E.computed && E.key.type === "Identifier" ? ((K || J) && this.unexpected(), this.checkUnreserved(E.key), E.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = me), E.kind = "init", D ? E.value = this.parseMaybeDefault(me, Le, this.copyNode(E.key)) : this.type === C.eq && Fe ? (Fe.shorthandAssign < 0 && (Fe.shorthandAssign = this.start), E.value = this.parseMaybeDefault(me, Le, this.copyNode(E.key))) : E.value = this.copyNode(E.key), E.shorthand = !0) : this.unexpected();
      }, ce.parsePropertyName = function(E) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(C.bracketL))
            return E.computed = !0, E.key = this.parseMaybeAssign(), this.expect(C.bracketR), E.key;
          E.computed = !1;
        }
        return E.key = this.type === C.num || this.type === C.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, ce.initFunction = function(E) {
        E.id = null, this.options.ecmaVersion >= 6 && (E.generator = E.expression = !1), this.options.ecmaVersion >= 8 && (E.async = !1);
      }, ce.parseMethod = function(E, D, K) {
        var J = this.startNode(), me = this.yieldPos, Le = this.awaitPos, Fe = this.awaitIdentPos;
        return this.initFunction(J), this.options.ecmaVersion >= 6 && (J.generator = E), this.options.ecmaVersion >= 8 && (J.async = !!D), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(mt(D, J.generator) | Ie | (K ? Je : 0)), this.expect(C.parenL), J.params = this.parseBindingList(C.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(J, !1, !0, !1), this.yieldPos = me, this.awaitPos = Le, this.awaitIdentPos = Fe, this.finishNode(J, "FunctionExpression");
      }, ce.parseArrowExpression = function(E, D, K, J) {
        var me = this.yieldPos, Le = this.awaitPos, Fe = this.awaitIdentPos;
        return this.enterScope(mt(K, !1) | Ee), this.initFunction(E), this.options.ecmaVersion >= 8 && (E.async = !!K), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, E.params = this.toAssignableList(D, !0), this.parseFunctionBody(E, !0, !1, J), this.yieldPos = me, this.awaitPos = Le, this.awaitIdentPos = Fe, this.finishNode(E, "ArrowFunctionExpression");
      }, ce.parseFunctionBody = function(E, D, K, J) {
        var me = D && this.type !== C.braceL, Le = this.strict, Fe = !1;
        if (me)
          E.body = this.parseMaybeAssign(J), E.expression = !0, this.checkParams(E, !1);
        else {
          var ze = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(E.params);
          (!Le || ze) && (Fe = this.strictDirective(this.end), Fe && ze && this.raiseRecoverable(E.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var Qe = this.labels;
          this.labels = [], Fe && (this.strict = !0), this.checkParams(E, !Le && !Fe && !D && !K && this.isSimpleParamList(E.params)), this.strict && E.id && this.checkLValSimple(E.id, rt), E.body = this.parseBlock(!1, void 0, Fe && !Le), E.expression = !1, this.adaptDirectivePrologue(E.body.body), this.labels = Qe;
        }
        this.exitScope();
      }, ce.isSimpleParamList = function(E) {
        for (var D = 0, K = E; D < K.length; D += 1) {
          var J = K[D];
          if (J.type !== "Identifier")
            return !1;
        }
        return !0;
      }, ce.checkParams = function(E, D) {
        for (var K = /* @__PURE__ */ Object.create(null), J = 0, me = E.params; J < me.length; J += 1) {
          var Le = me[J];
          this.checkLValInnerPattern(Le, Te, D ? null : K);
        }
      }, ce.parseExprList = function(E, D, K, J) {
        for (var me = [], Le = !0; !this.eat(E); ) {
          if (Le)
            Le = !1;
          else if (this.expect(C.comma), D && this.afterTrailingComma(E))
            break;
          var Fe = void 0;
          K && this.type === C.comma ? Fe = null : this.type === C.ellipsis ? (Fe = this.parseSpread(J), J && this.type === C.comma && J.trailingComma < 0 && (J.trailingComma = this.start)) : Fe = this.parseMaybeAssign(!1, J), me.push(Fe);
        }
        return me;
      }, ce.checkUnreserved = function(E) {
        var D = E.start, K = E.end, J = E.name;
        if (this.inGenerator && J === "yield" && this.raiseRecoverable(D, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && J === "await" && this.raiseRecoverable(D, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && J === "arguments" && this.raiseRecoverable(D, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (J === "arguments" || J === "await") && this.raise(D, "Cannot use " + J + " in class static initialization block"), this.keywords.test(J) && this.raise(D, "Unexpected keyword '" + J + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(D, K).indexOf("\\") !== -1)) {
          var me = this.strict ? this.reservedWordsStrict : this.reservedWords;
          me.test(J) && (!this.inAsync && J === "await" && this.raiseRecoverable(D, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(D, "The keyword '" + J + "' is reserved"));
        }
      }, ce.parseIdent = function(E) {
        var D = this.parseIdentNode();
        return this.next(!!E), this.finishNode(D, "Identifier"), E || (this.checkUnreserved(D), D.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = D.start)), D;
      }, ce.parseIdentNode = function() {
        var E = this.startNode();
        return this.type === C.name ? E.name = this.value : this.type.keyword ? (E.name = this.type.keyword, (E.name === "class" || E.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), E;
      }, ce.parsePrivateIdent = function() {
        var E = this.startNode();
        return this.type === C.privateId ? E.name = this.value : this.unexpected(), this.next(), this.finishNode(E, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(E.start, "Private field '#" + E.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(E), E;
      }, ce.parseYield = function(E) {
        this.yieldPos || (this.yieldPos = this.start);
        var D = this.startNode();
        return this.next(), this.type === C.semi || this.canInsertSemicolon() || this.type !== C.star && !this.type.startsExpr ? (D.delegate = !1, D.argument = null) : (D.delegate = this.eat(C.star), D.argument = this.parseMaybeAssign(E)), this.finishNode(D, "YieldExpression");
      }, ce.parseAwait = function(E) {
        this.awaitPos || (this.awaitPos = this.start);
        var D = this.startNode();
        return this.next(), D.argument = this.parseMaybeUnary(null, !0, !1, E), this.finishNode(D, "AwaitExpression");
      };
      var we = ot.prototype;
      we.raise = function(E, D) {
        var K = ue(this.input, E);
        D += " (" + K.line + ":" + K.column + ")";
        var J = new SyntaxError(D);
        throw J.pos = E, J.loc = K, J.raisedAt = this.pos, J;
      }, we.raiseRecoverable = we.raise, we.curPosition = function() {
        if (this.options.locations)
          return new X(this.curLine, this.pos - this.lineStart);
      };
      var Pe = ot.prototype, st = function(D) {
        this.flags = D, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
      };
      Pe.enterScope = function(E) {
        this.scopeStack.push(new st(E));
      }, Pe.exitScope = function() {
        this.scopeStack.pop();
      }, Pe.treatFunctionsAsVarInScope = function(E) {
        return E.flags & G || !this.inModule && E.flags & N;
      }, Pe.declareName = function(E, D, K) {
        var J = !1;
        if (D === Ke) {
          var me = this.currentScope();
          J = me.lexical.indexOf(E) > -1 || me.functions.indexOf(E) > -1 || me.var.indexOf(E) > -1, me.lexical.push(E), this.inModule && me.flags & N && delete this.undefinedExports[E];
        } else if (D === nt) {
          var Le = this.currentScope();
          Le.lexical.push(E);
        } else if (D === et) {
          var Fe = this.currentScope();
          this.treatFunctionsAsVar ? J = Fe.lexical.indexOf(E) > -1 : J = Fe.lexical.indexOf(E) > -1 || Fe.var.indexOf(E) > -1, Fe.functions.push(E);
        } else
          for (var ze = this.scopeStack.length - 1; ze >= 0; --ze) {
            var Qe = this.scopeStack[ze];
            if (Qe.lexical.indexOf(E) > -1 && !(Qe.flags & ke && Qe.lexical[0] === E) || !this.treatFunctionsAsVarInScope(Qe) && Qe.functions.indexOf(E) > -1) {
              J = !0;
              break;
            }
            if (Qe.var.push(E), this.inModule && Qe.flags & N && delete this.undefinedExports[E], Qe.flags & lt)
              break;
          }
        J && this.raiseRecoverable(K, "Identifier '" + E + "' has already been declared");
      }, Pe.checkLocalExport = function(E) {
        this.scopeStack[0].lexical.indexOf(E.name) === -1 && this.scopeStack[0].var.indexOf(E.name) === -1 && (this.undefinedExports[E.name] = E);
      }, Pe.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, Pe.currentVarScope = function() {
        for (var E = this.scopeStack.length - 1; ; E--) {
          var D = this.scopeStack[E];
          if (D.flags & lt)
            return D;
        }
      }, Pe.currentThisScope = function() {
        for (var E = this.scopeStack.length - 1; ; E--) {
          var D = this.scopeStack[E];
          if (D.flags & lt && !(D.flags & Ee))
            return D;
        }
      };
      var We = function(D, K, J) {
        this.type = "", this.start = K, this.end = 0, D.options.locations && (this.loc = new Q(D, J)), D.options.directSourceFile && (this.sourceFile = D.options.directSourceFile), D.options.ranges && (this.range = [K, 0]);
      }, _e = ot.prototype;
      _e.startNode = function() {
        return new We(this, this.start, this.startLoc);
      }, _e.startNodeAt = function(E, D) {
        return new We(this, E, D);
      };
      function je(E, D, K, J) {
        return E.type = D, E.end = K, this.options.locations && (E.loc.end = J), this.options.ranges && (E.range[1] = K), E;
      }
      _e.finishNode = function(E, D) {
        return je.call(this, E, D, this.lastTokEnd, this.lastTokEndLoc);
      }, _e.finishNodeAt = function(E, D, K, J) {
        return je.call(this, E, D, K, J);
      }, _e.copyNode = function(E) {
        var D = new We(this, E.start, this.startLoc);
        for (var K in E)
          D[K] = E[K];
        return D;
      };
      var $e = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Ae = $e + " Extended_Pictographic", oe = Ae, se = oe + " EBase EComp EMod EPres ExtPict", pe = se, ve = pe, Se = {
        9: $e,
        10: Ae,
        11: oe,
        12: se,
        13: pe,
        14: ve
      }, Ge = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", Ze = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: Ge
      }, ft = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", gt = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", At = gt + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ht = At + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", qe = ht + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", He = qe + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Xe = He + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", Me = {
        9: gt,
        10: At,
        11: ht,
        12: qe,
        13: He,
        14: Xe
      }, it = {};
      function ut(E) {
        var D = it[E] = {
          binary: F(Se[E] + " " + ft),
          binaryOfStrings: F(Ze[E]),
          nonBinary: {
            General_Category: F(ft),
            Script: F(Me[E])
          }
        };
        D.nonBinary.Script_Extensions = D.nonBinary.Script, D.nonBinary.gc = D.nonBinary.General_Category, D.nonBinary.sc = D.nonBinary.Script, D.nonBinary.scx = D.nonBinary.Script_Extensions;
      }
      for (var Tt = 0, Rt = [9, 10, 11, 12, 13, 14]; Tt < Rt.length; Tt += 1) {
        var xt = Rt[Tt];
        ut(xt);
      }
      var tt = ot.prototype, Lt = function(D) {
        this.parser = D, this.validFlags = "gim" + (D.options.ecmaVersion >= 6 ? "uy" : "") + (D.options.ecmaVersion >= 9 ? "s" : "") + (D.options.ecmaVersion >= 13 ? "d" : "") + (D.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = it[D.options.ecmaVersion >= 14 ? 14 : D.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
      };
      Lt.prototype.reset = function(D, K, J) {
        var me = J.indexOf("v") !== -1, Le = J.indexOf("u") !== -1;
        this.start = D | 0, this.source = K + "", this.flags = J, me && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = Le && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = Le && this.parser.options.ecmaVersion >= 9);
      }, Lt.prototype.raise = function(D) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + D);
      }, Lt.prototype.at = function(D, K) {
        K === void 0 && (K = !1);
        var J = this.source, me = J.length;
        if (D >= me)
          return -1;
        var Le = J.charCodeAt(D);
        if (!(K || this.switchU) || Le <= 55295 || Le >= 57344 || D + 1 >= me)
          return Le;
        var Fe = J.charCodeAt(D + 1);
        return Fe >= 56320 && Fe <= 57343 ? (Le << 10) + Fe - 56613888 : Le;
      }, Lt.prototype.nextIndex = function(D, K) {
        K === void 0 && (K = !1);
        var J = this.source, me = J.length;
        if (D >= me)
          return me;
        var Le = J.charCodeAt(D), Fe;
        return !(K || this.switchU) || Le <= 55295 || Le >= 57344 || D + 1 >= me || (Fe = J.charCodeAt(D + 1)) < 56320 || Fe > 57343 ? D + 1 : D + 2;
      }, Lt.prototype.current = function(D) {
        return D === void 0 && (D = !1), this.at(this.pos, D);
      }, Lt.prototype.lookahead = function(D) {
        return D === void 0 && (D = !1), this.at(this.nextIndex(this.pos, D), D);
      }, Lt.prototype.advance = function(D) {
        D === void 0 && (D = !1), this.pos = this.nextIndex(this.pos, D);
      }, Lt.prototype.eat = function(D, K) {
        return K === void 0 && (K = !1), this.current(K) === D ? (this.advance(K), !0) : !1;
      }, Lt.prototype.eatChars = function(D, K) {
        K === void 0 && (K = !1);
        for (var J = this.pos, me = 0, Le = D; me < Le.length; me += 1) {
          var Fe = Le[me], ze = this.at(J, K);
          if (ze === -1 || ze !== Fe)
            return !1;
          J = this.nextIndex(J, K);
        }
        return this.pos = J, !0;
      }, tt.validateRegExpFlags = function(E) {
        for (var D = E.validFlags, K = E.flags, J = !1, me = !1, Le = 0; Le < K.length; Le++) {
          var Fe = K.charAt(Le);
          D.indexOf(Fe) === -1 && this.raise(E.start, "Invalid regular expression flag"), K.indexOf(Fe, Le + 1) > -1 && this.raise(E.start, "Duplicate regular expression flag"), Fe === "u" && (J = !0), Fe === "v" && (me = !0);
        }
        this.options.ecmaVersion >= 15 && J && me && this.raise(E.start, "Invalid regular expression flag");
      }, tt.validateRegExpPattern = function(E) {
        this.regexp_pattern(E), !E.switchN && this.options.ecmaVersion >= 9 && E.groupNames.length > 0 && (E.switchN = !0, this.regexp_pattern(E));
      }, tt.regexp_pattern = function(E) {
        E.pos = 0, E.lastIntValue = 0, E.lastStringValue = "", E.lastAssertionIsQuantifiable = !1, E.numCapturingParens = 0, E.maxBackReference = 0, E.groupNames.length = 0, E.backReferenceNames.length = 0, this.regexp_disjunction(E), E.pos !== E.source.length && (E.eat(
          41
          /* ) */
        ) && E.raise("Unmatched ')'"), (E.eat(
          93
          /* ] */
        ) || E.eat(
          125
          /* } */
        )) && E.raise("Lone quantifier brackets")), E.maxBackReference > E.numCapturingParens && E.raise("Invalid escape");
        for (var D = 0, K = E.backReferenceNames; D < K.length; D += 1) {
          var J = K[D];
          E.groupNames.indexOf(J) === -1 && E.raise("Invalid named capture referenced");
        }
      }, tt.regexp_disjunction = function(E) {
        for (this.regexp_alternative(E); E.eat(
          124
          /* | */
        ); )
          this.regexp_alternative(E);
        this.regexp_eatQuantifier(E, !0) && E.raise("Nothing to repeat"), E.eat(
          123
          /* { */
        ) && E.raise("Lone quantifier brackets");
      }, tt.regexp_alternative = function(E) {
        for (; E.pos < E.source.length && this.regexp_eatTerm(E); )
          ;
      }, tt.regexp_eatTerm = function(E) {
        return this.regexp_eatAssertion(E) ? (E.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(E) && E.switchU && E.raise("Invalid quantifier"), !0) : (E.switchU ? this.regexp_eatAtom(E) : this.regexp_eatExtendedAtom(E)) ? (this.regexp_eatQuantifier(E), !0) : !1;
      }, tt.regexp_eatAssertion = function(E) {
        var D = E.pos;
        if (E.lastAssertionIsQuantifiable = !1, E.eat(
          94
          /* ^ */
        ) || E.eat(
          36
          /* $ */
        ))
          return !0;
        if (E.eat(
          92
          /* \ */
        )) {
          if (E.eat(
            66
            /* B */
          ) || E.eat(
            98
            /* b */
          ))
            return !0;
          E.pos = D;
        }
        if (E.eat(
          40
          /* ( */
        ) && E.eat(
          63
          /* ? */
        )) {
          var K = !1;
          if (this.options.ecmaVersion >= 9 && (K = E.eat(
            60
            /* < */
          )), E.eat(
            61
            /* = */
          ) || E.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(E), E.eat(
              41
              /* ) */
            ) || E.raise("Unterminated group"), E.lastAssertionIsQuantifiable = !K, !0;
        }
        return E.pos = D, !1;
      }, tt.regexp_eatQuantifier = function(E, D) {
        return D === void 0 && (D = !1), this.regexp_eatQuantifierPrefix(E, D) ? (E.eat(
          63
          /* ? */
        ), !0) : !1;
      }, tt.regexp_eatQuantifierPrefix = function(E, D) {
        return E.eat(
          42
          /* * */
        ) || E.eat(
          43
          /* + */
        ) || E.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(E, D);
      }, tt.regexp_eatBracedQuantifier = function(E, D) {
        var K = E.pos;
        if (E.eat(
          123
          /* { */
        )) {
          var J = 0, me = -1;
          if (this.regexp_eatDecimalDigits(E) && (J = E.lastIntValue, E.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(E) && (me = E.lastIntValue), E.eat(
            125
            /* } */
          )))
            return me !== -1 && me < J && !D && E.raise("numbers out of order in {} quantifier"), !0;
          E.switchU && !D && E.raise("Incomplete quantifier"), E.pos = K;
        }
        return !1;
      }, tt.regexp_eatAtom = function(E) {
        return this.regexp_eatPatternCharacters(E) || E.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(E) || this.regexp_eatCharacterClass(E) || this.regexp_eatUncapturingGroup(E) || this.regexp_eatCapturingGroup(E);
      }, tt.regexp_eatReverseSolidusAtomEscape = function(E) {
        var D = E.pos;
        if (E.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(E))
            return !0;
          E.pos = D;
        }
        return !1;
      }, tt.regexp_eatUncapturingGroup = function(E) {
        var D = E.pos;
        if (E.eat(
          40
          /* ( */
        )) {
          if (E.eat(
            63
            /* ? */
          ) && E.eat(
            58
            /* : */
          )) {
            if (this.regexp_disjunction(E), E.eat(
              41
              /* ) */
            ))
              return !0;
            E.raise("Unterminated group");
          }
          E.pos = D;
        }
        return !1;
      }, tt.regexp_eatCapturingGroup = function(E) {
        if (E.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(E) : E.current() === 63 && E.raise("Invalid group"), this.regexp_disjunction(E), E.eat(
            41
            /* ) */
          ))
            return E.numCapturingParens += 1, !0;
          E.raise("Unterminated group");
        }
        return !1;
      }, tt.regexp_eatExtendedAtom = function(E) {
        return E.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(E) || this.regexp_eatCharacterClass(E) || this.regexp_eatUncapturingGroup(E) || this.regexp_eatCapturingGroup(E) || this.regexp_eatInvalidBracedQuantifier(E) || this.regexp_eatExtendedPatternCharacter(E);
      }, tt.regexp_eatInvalidBracedQuantifier = function(E) {
        return this.regexp_eatBracedQuantifier(E, !0) && E.raise("Nothing to repeat"), !1;
      }, tt.regexp_eatSyntaxCharacter = function(E) {
        var D = E.current();
        return Bt(D) ? (E.lastIntValue = D, E.advance(), !0) : !1;
      };
      function Bt(E) {
        return E === 36 || E >= 40 && E <= 43 || E === 46 || E === 63 || E >= 91 && E <= 94 || E >= 123 && E <= 125;
      }
      tt.regexp_eatPatternCharacters = function(E) {
        for (var D = E.pos, K = 0; (K = E.current()) !== -1 && !Bt(K); )
          E.advance();
        return E.pos !== D;
      }, tt.regexp_eatExtendedPatternCharacter = function(E) {
        var D = E.current();
        return D !== -1 && D !== 36 && !(D >= 40 && D <= 43) && D !== 46 && D !== 63 && D !== 91 && D !== 94 && D !== 124 ? (E.advance(), !0) : !1;
      }, tt.regexp_groupSpecifier = function(E) {
        if (E.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(E)) {
            E.groupNames.indexOf(E.lastStringValue) !== -1 && E.raise("Duplicate capture group name"), E.groupNames.push(E.lastStringValue);
            return;
          }
          E.raise("Invalid group");
        }
      }, tt.regexp_eatGroupName = function(E) {
        if (E.lastStringValue = "", E.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(E) && E.eat(
            62
            /* > */
          ))
            return !0;
          E.raise("Invalid capture group name");
        }
        return !1;
      }, tt.regexp_eatRegExpIdentifierName = function(E) {
        if (E.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(E)) {
          for (E.lastStringValue += $(E.lastIntValue); this.regexp_eatRegExpIdentifierPart(E); )
            E.lastStringValue += $(E.lastIntValue);
          return !0;
        }
        return !1;
      }, tt.regexp_eatRegExpIdentifierStart = function(E) {
        var D = E.pos, K = this.options.ecmaVersion >= 11, J = E.current(K);
        return E.advance(K), J === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(E, K) && (J = E.lastIntValue), Ut(J) ? (E.lastIntValue = J, !0) : (E.pos = D, !1);
      };
      function Ut(E) {
        return c(E, !0) || E === 36 || E === 95;
      }
      tt.regexp_eatRegExpIdentifierPart = function(E) {
        var D = E.pos, K = this.options.ecmaVersion >= 11, J = E.current(K);
        return E.advance(K), J === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(E, K) && (J = E.lastIntValue), Kt(J) ? (E.lastIntValue = J, !0) : (E.pos = D, !1);
      };
      function Kt(E) {
        return g(E, !0) || E === 36 || E === 95 || E === 8204 || E === 8205;
      }
      tt.regexp_eatAtomEscape = function(E) {
        return this.regexp_eatBackReference(E) || this.regexp_eatCharacterClassEscape(E) || this.regexp_eatCharacterEscape(E) || E.switchN && this.regexp_eatKGroupName(E) ? !0 : (E.switchU && (E.current() === 99 && E.raise("Invalid unicode escape"), E.raise("Invalid escape")), !1);
      }, tt.regexp_eatBackReference = function(E) {
        var D = E.pos;
        if (this.regexp_eatDecimalEscape(E)) {
          var K = E.lastIntValue;
          if (E.switchU)
            return K > E.maxBackReference && (E.maxBackReference = K), !0;
          if (K <= E.numCapturingParens)
            return !0;
          E.pos = D;
        }
        return !1;
      }, tt.regexp_eatKGroupName = function(E) {
        if (E.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(E))
            return E.backReferenceNames.push(E.lastStringValue), !0;
          E.raise("Invalid named reference");
        }
        return !1;
      }, tt.regexp_eatCharacterEscape = function(E) {
        return this.regexp_eatControlEscape(E) || this.regexp_eatCControlLetter(E) || this.regexp_eatZero(E) || this.regexp_eatHexEscapeSequence(E) || this.regexp_eatRegExpUnicodeEscapeSequence(E, !1) || !E.switchU && this.regexp_eatLegacyOctalEscapeSequence(E) || this.regexp_eatIdentityEscape(E);
      }, tt.regexp_eatCControlLetter = function(E) {
        var D = E.pos;
        if (E.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(E))
            return !0;
          E.pos = D;
        }
        return !1;
      }, tt.regexp_eatZero = function(E) {
        return E.current() === 48 && !er(E.lookahead()) ? (E.lastIntValue = 0, E.advance(), !0) : !1;
      }, tt.regexp_eatControlEscape = function(E) {
        var D = E.current();
        return D === 116 ? (E.lastIntValue = 9, E.advance(), !0) : D === 110 ? (E.lastIntValue = 10, E.advance(), !0) : D === 118 ? (E.lastIntValue = 11, E.advance(), !0) : D === 102 ? (E.lastIntValue = 12, E.advance(), !0) : D === 114 ? (E.lastIntValue = 13, E.advance(), !0) : !1;
      }, tt.regexp_eatControlLetter = function(E) {
        var D = E.current();
        return Nt(D) ? (E.lastIntValue = D % 32, E.advance(), !0) : !1;
      };
      function Nt(E) {
        return E >= 65 && E <= 90 || E >= 97 && E <= 122;
      }
      tt.regexp_eatRegExpUnicodeEscapeSequence = function(E, D) {
        D === void 0 && (D = !1);
        var K = E.pos, J = D || E.switchU;
        if (E.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(E, 4)) {
            var me = E.lastIntValue;
            if (J && me >= 55296 && me <= 56319) {
              var Le = E.pos;
              if (E.eat(
                92
                /* \ */
              ) && E.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(E, 4)) {
                var Fe = E.lastIntValue;
                if (Fe >= 56320 && Fe <= 57343)
                  return E.lastIntValue = (me - 55296) * 1024 + (Fe - 56320) + 65536, !0;
              }
              E.pos = Le, E.lastIntValue = me;
            }
            return !0;
          }
          if (J && E.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(E) && E.eat(
            125
            /* } */
          ) && $t(E.lastIntValue))
            return !0;
          J && E.raise("Invalid unicode escape"), E.pos = K;
        }
        return !1;
      };
      function $t(E) {
        return E >= 0 && E <= 1114111;
      }
      tt.regexp_eatIdentityEscape = function(E) {
        if (E.switchU)
          return this.regexp_eatSyntaxCharacter(E) ? !0 : E.eat(
            47
            /* / */
          ) ? (E.lastIntValue = 47, !0) : !1;
        var D = E.current();
        return D !== 99 && (!E.switchN || D !== 107) ? (E.lastIntValue = D, E.advance(), !0) : !1;
      }, tt.regexp_eatDecimalEscape = function(E) {
        E.lastIntValue = 0;
        var D = E.current();
        if (D >= 49 && D <= 57) {
          do
            E.lastIntValue = 10 * E.lastIntValue + (D - 48), E.advance();
          while ((D = E.current()) >= 48 && D <= 57);
          return !0;
        }
        return !1;
      };
      var nr = 0, Vt = 1, Pt = 2;
      tt.regexp_eatCharacterClassEscape = function(E) {
        var D = E.current();
        if (Yt(D))
          return E.lastIntValue = -1, E.advance(), Vt;
        var K = !1;
        if (E.switchU && this.options.ecmaVersion >= 9 && ((K = D === 80) || D === 112)) {
          E.lastIntValue = -1, E.advance();
          var J;
          if (E.eat(
            123
            /* { */
          ) && (J = this.regexp_eatUnicodePropertyValueExpression(E)) && E.eat(
            125
            /* } */
          ))
            return K && J === Pt && E.raise("Invalid property name"), J;
          E.raise("Invalid property name");
        }
        return nr;
      };
      function Yt(E) {
        return E === 100 || E === 68 || E === 115 || E === 83 || E === 119 || E === 87;
      }
      tt.regexp_eatUnicodePropertyValueExpression = function(E) {
        var D = E.pos;
        if (this.regexp_eatUnicodePropertyName(E) && E.eat(
          61
          /* = */
        )) {
          var K = E.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(E)) {
            var J = E.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(E, K, J), Vt;
          }
        }
        if (E.pos = D, this.regexp_eatLoneUnicodePropertyNameOrValue(E)) {
          var me = E.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(E, me);
        }
        return nr;
      }, tt.regexp_validateUnicodePropertyNameAndValue = function(E, D, K) {
        U(E.unicodeProperties.nonBinary, D) || E.raise("Invalid property name"), E.unicodeProperties.nonBinary[D].test(K) || E.raise("Invalid property value");
      }, tt.regexp_validateUnicodePropertyNameOrValue = function(E, D) {
        if (E.unicodeProperties.binary.test(D))
          return Vt;
        if (E.switchV && E.unicodeProperties.binaryOfStrings.test(D))
          return Pt;
        E.raise("Invalid property name");
      }, tt.regexp_eatUnicodePropertyName = function(E) {
        var D = 0;
        for (E.lastStringValue = ""; Gt(D = E.current()); )
          E.lastStringValue += $(D), E.advance();
        return E.lastStringValue !== "";
      };
      function Gt(E) {
        return Nt(E) || E === 95;
      }
      tt.regexp_eatUnicodePropertyValue = function(E) {
        var D = 0;
        for (E.lastStringValue = ""; lr(D = E.current()); )
          E.lastStringValue += $(D), E.advance();
        return E.lastStringValue !== "";
      };
      function lr(E) {
        return Gt(E) || er(E);
      }
      tt.regexp_eatLoneUnicodePropertyNameOrValue = function(E) {
        return this.regexp_eatUnicodePropertyValue(E);
      }, tt.regexp_eatCharacterClass = function(E) {
        if (E.eat(
          91
          /* [ */
        )) {
          var D = E.eat(
            94
            /* ^ */
          ), K = this.regexp_classContents(E);
          return E.eat(
            93
            /* ] */
          ) || E.raise("Unterminated character class"), D && K === Pt && E.raise("Negated character class may contain strings"), !0;
        }
        return !1;
      }, tt.regexp_classContents = function(E) {
        return E.current() === 93 ? Vt : E.switchV ? this.regexp_classSetExpression(E) : (this.regexp_nonEmptyClassRanges(E), Vt);
      }, tt.regexp_nonEmptyClassRanges = function(E) {
        for (; this.regexp_eatClassAtom(E); ) {
          var D = E.lastIntValue;
          if (E.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(E)) {
            var K = E.lastIntValue;
            E.switchU && (D === -1 || K === -1) && E.raise("Invalid character class"), D !== -1 && K !== -1 && D > K && E.raise("Range out of order in character class");
          }
        }
      }, tt.regexp_eatClassAtom = function(E) {
        var D = E.pos;
        if (E.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(E))
            return !0;
          if (E.switchU) {
            var K = E.current();
            (K === 99 || cr(K)) && E.raise("Invalid class escape"), E.raise("Invalid escape");
          }
          E.pos = D;
        }
        var J = E.current();
        return J !== 93 ? (E.lastIntValue = J, E.advance(), !0) : !1;
      }, tt.regexp_eatClassEscape = function(E) {
        var D = E.pos;
        if (E.eat(
          98
          /* b */
        ))
          return E.lastIntValue = 8, !0;
        if (E.switchU && E.eat(
          45
          /* - */
        ))
          return E.lastIntValue = 45, !0;
        if (!E.switchU && E.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(E))
            return !0;
          E.pos = D;
        }
        return this.regexp_eatCharacterClassEscape(E) || this.regexp_eatCharacterEscape(E);
      }, tt.regexp_classSetExpression = function(E) {
        var D = Vt, K;
        if (!this.regexp_eatClassSetRange(E)) if (K = this.regexp_eatClassSetOperand(E)) {
          K === Pt && (D = Pt);
          for (var J = E.pos; E.eatChars(
            [38, 38]
            /* && */
          ); ) {
            if (E.current() !== 38 && (K = this.regexp_eatClassSetOperand(E))) {
              K !== Pt && (D = Vt);
              continue;
            }
            E.raise("Invalid character in character class");
          }
          if (J !== E.pos)
            return D;
          for (; E.eatChars(
            [45, 45]
            /* -- */
          ); )
            this.regexp_eatClassSetOperand(E) || E.raise("Invalid character in character class");
          if (J !== E.pos)
            return D;
        } else
          E.raise("Invalid character in character class");
        for (; ; )
          if (!this.regexp_eatClassSetRange(E)) {
            if (K = this.regexp_eatClassSetOperand(E), !K)
              return D;
            K === Pt && (D = Pt);
          }
      }, tt.regexp_eatClassSetRange = function(E) {
        var D = E.pos;
        if (this.regexp_eatClassSetCharacter(E)) {
          var K = E.lastIntValue;
          if (E.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(E)) {
            var J = E.lastIntValue;
            return K !== -1 && J !== -1 && K > J && E.raise("Range out of order in character class"), !0;
          }
          E.pos = D;
        }
        return !1;
      }, tt.regexp_eatClassSetOperand = function(E) {
        return this.regexp_eatClassSetCharacter(E) ? Vt : this.regexp_eatClassStringDisjunction(E) || this.regexp_eatNestedClass(E);
      }, tt.regexp_eatNestedClass = function(E) {
        var D = E.pos;
        if (E.eat(
          91
          /* [ */
        )) {
          var K = E.eat(
            94
            /* ^ */
          ), J = this.regexp_classContents(E);
          if (E.eat(
            93
            /* ] */
          ))
            return K && J === Pt && E.raise("Negated character class may contain strings"), J;
          E.pos = D;
        }
        if (E.eat(
          92
          /* \ */
        )) {
          var me = this.regexp_eatCharacterClassEscape(E);
          if (me)
            return me;
          E.pos = D;
        }
        return null;
      }, tt.regexp_eatClassStringDisjunction = function(E) {
        var D = E.pos;
        if (E.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (E.eat(
            123
            /* { */
          )) {
            var K = this.regexp_classStringDisjunctionContents(E);
            if (E.eat(
              125
              /* } */
            ))
              return K;
          } else
            E.raise("Invalid escape");
          E.pos = D;
        }
        return null;
      }, tt.regexp_classStringDisjunctionContents = function(E) {
        for (var D = this.regexp_classString(E); E.eat(
          124
          /* | */
        ); )
          this.regexp_classString(E) === Pt && (D = Pt);
        return D;
      }, tt.regexp_classString = function(E) {
        for (var D = 0; this.regexp_eatClassSetCharacter(E); )
          D++;
        return D === 1 ? Vt : Pt;
      }, tt.regexp_eatClassSetCharacter = function(E) {
        var D = E.pos;
        if (E.eat(
          92
          /* \ */
        ))
          return this.regexp_eatCharacterEscape(E) || this.regexp_eatClassSetReservedPunctuator(E) ? !0 : E.eat(
            98
            /* b */
          ) ? (E.lastIntValue = 8, !0) : (E.pos = D, !1);
        var K = E.current();
        return K < 0 || K === E.lookahead() && Zt(K) || zt(K) ? !1 : (E.advance(), E.lastIntValue = K, !0);
      };
      function Zt(E) {
        return E === 33 || E >= 35 && E <= 38 || E >= 42 && E <= 44 || E === 46 || E >= 58 && E <= 64 || E === 94 || E === 96 || E === 126;
      }
      function zt(E) {
        return E === 40 || E === 41 || E === 45 || E === 47 || E >= 91 && E <= 93 || E >= 123 && E <= 125;
      }
      tt.regexp_eatClassSetReservedPunctuator = function(E) {
        var D = E.current();
        return ur(D) ? (E.lastIntValue = D, E.advance(), !0) : !1;
      };
      function ur(E) {
        return E === 33 || E === 35 || E === 37 || E === 38 || E === 44 || E === 45 || E >= 58 && E <= 62 || E === 64 || E === 96 || E === 126;
      }
      tt.regexp_eatClassControlLetter = function(E) {
        var D = E.current();
        return er(D) || D === 95 ? (E.lastIntValue = D % 32, E.advance(), !0) : !1;
      }, tt.regexp_eatHexEscapeSequence = function(E) {
        var D = E.pos;
        if (E.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(E, 2))
            return !0;
          E.switchU && E.raise("Invalid escape"), E.pos = D;
        }
        return !1;
      }, tt.regexp_eatDecimalDigits = function(E) {
        var D = E.pos, K = 0;
        for (E.lastIntValue = 0; er(K = E.current()); )
          E.lastIntValue = 10 * E.lastIntValue + (K - 48), E.advance();
        return E.pos !== D;
      };
      function er(E) {
        return E >= 48 && E <= 57;
      }
      tt.regexp_eatHexDigits = function(E) {
        var D = E.pos, K = 0;
        for (E.lastIntValue = 0; sr(K = E.current()); )
          E.lastIntValue = 16 * E.lastIntValue + Ar(K), E.advance();
        return E.pos !== D;
      };
      function sr(E) {
        return E >= 48 && E <= 57 || E >= 65 && E <= 70 || E >= 97 && E <= 102;
      }
      function Ar(E) {
        return E >= 65 && E <= 70 ? 10 + (E - 65) : E >= 97 && E <= 102 ? 10 + (E - 97) : E - 48;
      }
      tt.regexp_eatLegacyOctalEscapeSequence = function(E) {
        if (this.regexp_eatOctalDigit(E)) {
          var D = E.lastIntValue;
          if (this.regexp_eatOctalDigit(E)) {
            var K = E.lastIntValue;
            D <= 3 && this.regexp_eatOctalDigit(E) ? E.lastIntValue = D * 64 + K * 8 + E.lastIntValue : E.lastIntValue = D * 8 + K;
          } else
            E.lastIntValue = D;
          return !0;
        }
        return !1;
      }, tt.regexp_eatOctalDigit = function(E) {
        var D = E.current();
        return cr(D) ? (E.lastIntValue = D - 48, E.advance(), !0) : (E.lastIntValue = 0, !1);
      };
      function cr(E) {
        return E >= 48 && E <= 55;
      }
      tt.regexp_eatFixedHexDigits = function(E, D) {
        var K = E.pos;
        E.lastIntValue = 0;
        for (var J = 0; J < D; ++J) {
          var me = E.current();
          if (!sr(me))
            return E.pos = K, !1;
          E.lastIntValue = 16 * E.lastIntValue + Ar(me), E.advance();
        }
        return !0;
      };
      var fr = function(D) {
        this.type = D.type, this.value = D.value, this.start = D.start, this.end = D.end, D.options.locations && (this.loc = new Q(D, D.startLoc, D.endLoc)), D.options.ranges && (this.range = [D.start, D.end]);
      }, yt = ot.prototype;
      yt.next = function(E) {
        !E && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new fr(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, yt.getToken = function() {
        return this.next(), new fr(this);
      }, typeof Symbol < "u" && (yt[Symbol.iterator] = function() {
        var E = this;
        return {
          next: function() {
            var D = E.getToken();
            return {
              done: D.type === C.eof,
              value: D
            };
          }
        };
      }), yt.nextToken = function() {
        var E = this.curContext();
        if ((!E || !E.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(C.eof);
        if (E.override)
          return E.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, yt.readToken = function(E) {
        return c(E, this.options.ecmaVersion >= 6) || E === 92 ? this.readWord() : this.getTokenFromCode(E);
      }, yt.fullCharCodeAtPos = function() {
        var E = this.input.charCodeAt(this.pos);
        if (E <= 55295 || E >= 56320)
          return E;
        var D = this.input.charCodeAt(this.pos + 1);
        return D <= 56319 || D >= 57344 ? E : (E << 10) + D - 56613888;
      }, yt.skipBlockComment = function() {
        var E = this.options.onComment && this.curPosition(), D = this.pos, K = this.input.indexOf("*/", this.pos += 2);
        if (K === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = K + 2, this.options.locations)
          for (var J = void 0, me = D; (J = L(this.input, me, this.pos)) > -1; )
            ++this.curLine, me = this.lineStart = J;
        this.options.onComment && this.options.onComment(
          !0,
          this.input.slice(D + 2, K),
          D,
          this.pos,
          E,
          this.curPosition()
        );
      }, yt.skipLineComment = function(E) {
        for (var D = this.pos, K = this.options.onComment && this.curPosition(), J = this.input.charCodeAt(this.pos += E); this.pos < this.input.length && !R(J); )
          J = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          !1,
          this.input.slice(D + E, this.pos),
          D,
          this.pos,
          K,
          this.curPosition()
        );
      }, yt.skipSpace = function() {
        e: for (; this.pos < this.input.length; ) {
          var E = this.input.charCodeAt(this.pos);
          switch (E) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (E > 8 && E < 14 || E >= 5760 && _.test(String.fromCharCode(E)))
                ++this.pos;
              else
                break e;
          }
        }
      }, yt.finishToken = function(E, D) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var K = this.type;
        this.type = E, this.value = D, this.updateContext(K);
      }, yt.readToken_dot = function() {
        var E = this.input.charCodeAt(this.pos + 1);
        if (E >= 48 && E <= 57)
          return this.readNumber(!0);
        var D = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && E === 46 && D === 46 ? (this.pos += 3, this.finishToken(C.ellipsis)) : (++this.pos, this.finishToken(C.dot));
      }, yt.readToken_slash = function() {
        var E = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : E === 61 ? this.finishOp(C.assign, 2) : this.finishOp(C.slash, 1);
      }, yt.readToken_mult_modulo_exp = function(E) {
        var D = this.input.charCodeAt(this.pos + 1), K = 1, J = E === 42 ? C.star : C.modulo;
        return this.options.ecmaVersion >= 7 && E === 42 && D === 42 && (++K, J = C.starstar, D = this.input.charCodeAt(this.pos + 2)), D === 61 ? this.finishOp(C.assign, K + 1) : this.finishOp(J, K);
      }, yt.readToken_pipe_amp = function(E) {
        var D = this.input.charCodeAt(this.pos + 1);
        if (D === E) {
          if (this.options.ecmaVersion >= 12) {
            var K = this.input.charCodeAt(this.pos + 2);
            if (K === 61)
              return this.finishOp(C.assign, 3);
          }
          return this.finishOp(E === 124 ? C.logicalOR : C.logicalAND, 2);
        }
        return D === 61 ? this.finishOp(C.assign, 2) : this.finishOp(E === 124 ? C.bitwiseOR : C.bitwiseAND, 1);
      }, yt.readToken_caret = function() {
        var E = this.input.charCodeAt(this.pos + 1);
        return E === 61 ? this.finishOp(C.assign, 2) : this.finishOp(C.bitwiseXOR, 1);
      }, yt.readToken_plus_min = function(E) {
        var D = this.input.charCodeAt(this.pos + 1);
        return D === E ? D === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || x.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(C.incDec, 2) : D === 61 ? this.finishOp(C.assign, 2) : this.finishOp(C.plusMin, 1);
      }, yt.readToken_lt_gt = function(E) {
        var D = this.input.charCodeAt(this.pos + 1), K = 1;
        return D === E ? (K = E === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + K) === 61 ? this.finishOp(C.assign, K + 1) : this.finishOp(C.bitShift, K)) : D === 33 && E === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (D === 61 && (K = 2), this.finishOp(C.relational, K));
      }, yt.readToken_eq_excl = function(E) {
        var D = this.input.charCodeAt(this.pos + 1);
        return D === 61 ? this.finishOp(C.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : E === 61 && D === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(C.arrow)) : this.finishOp(E === 61 ? C.eq : C.prefix, 1);
      }, yt.readToken_question = function() {
        var E = this.options.ecmaVersion;
        if (E >= 11) {
          var D = this.input.charCodeAt(this.pos + 1);
          if (D === 46) {
            var K = this.input.charCodeAt(this.pos + 2);
            if (K < 48 || K > 57)
              return this.finishOp(C.questionDot, 2);
          }
          if (D === 63) {
            if (E >= 12) {
              var J = this.input.charCodeAt(this.pos + 2);
              if (J === 61)
                return this.finishOp(C.assign, 3);
            }
            return this.finishOp(C.coalesce, 2);
          }
        }
        return this.finishOp(C.question, 1);
      }, yt.readToken_numberSign = function() {
        var E = this.options.ecmaVersion, D = 35;
        if (E >= 13 && (++this.pos, D = this.fullCharCodeAtPos(), c(D, !0) || D === 92))
          return this.finishToken(C.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + $(D) + "'");
      }, yt.getTokenFromCode = function(E) {
        switch (E) {
          case 46:
            return this.readToken_dot();
          case 40:
            return ++this.pos, this.finishToken(C.parenL);
          case 41:
            return ++this.pos, this.finishToken(C.parenR);
          case 59:
            return ++this.pos, this.finishToken(C.semi);
          case 44:
            return ++this.pos, this.finishToken(C.comma);
          case 91:
            return ++this.pos, this.finishToken(C.bracketL);
          case 93:
            return ++this.pos, this.finishToken(C.bracketR);
          case 123:
            return ++this.pos, this.finishToken(C.braceL);
          case 125:
            return ++this.pos, this.finishToken(C.braceR);
          case 58:
            return ++this.pos, this.finishToken(C.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(C.backQuote);
          case 48:
            var D = this.input.charCodeAt(this.pos + 1);
            if (D === 120 || D === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (D === 111 || D === 79)
                return this.readRadixNumber(8);
              if (D === 98 || D === 66)
                return this.readRadixNumber(2);
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          case 34:
          case 39:
            return this.readString(E);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(E);
          case 124:
          case 38:
            return this.readToken_pipe_amp(E);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(E);
          case 60:
          case 62:
            return this.readToken_lt_gt(E);
          case 61:
          case 33:
            return this.readToken_eq_excl(E);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(C.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + $(E) + "'");
      }, yt.finishOp = function(E, D) {
        var K = this.input.slice(this.pos, this.pos + D);
        return this.pos += D, this.finishToken(E, K);
      }, yt.readRegexp = function() {
        for (var E, D, K = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(K, "Unterminated regular expression");
          var J = this.input.charAt(this.pos);
          if (x.test(J) && this.raise(K, "Unterminated regular expression"), E)
            E = !1;
          else {
            if (J === "[")
              D = !0;
            else if (J === "]" && D)
              D = !1;
            else if (J === "/" && !D)
              break;
            E = J === "\\";
          }
          ++this.pos;
        }
        var me = this.input.slice(K, this.pos);
        ++this.pos;
        var Le = this.pos, Fe = this.readWord1();
        this.containsEsc && this.unexpected(Le);
        var ze = this.regexpState || (this.regexpState = new Lt(this));
        ze.reset(K, me, Fe), this.validateRegExpFlags(ze), this.validateRegExpPattern(ze);
        var Qe = null;
        try {
          Qe = new RegExp(me, Fe);
        } catch {
        }
        return this.finishToken(C.regexp, { pattern: me, flags: Fe, value: Qe });
      }, yt.readInt = function(E, D, K) {
        for (var J = this.options.ecmaVersion >= 12 && D === void 0, me = K && this.input.charCodeAt(this.pos) === 48, Le = this.pos, Fe = 0, ze = 0, Qe = 0, pt = D ?? 1 / 0; Qe < pt; ++Qe, ++this.pos) {
          var Et = this.input.charCodeAt(this.pos), _t = void 0;
          if (J && Et === 95) {
            me && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), ze === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), Qe === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), ze = Et;
            continue;
          }
          if (Et >= 97 ? _t = Et - 97 + 10 : Et >= 65 ? _t = Et - 65 + 10 : Et >= 48 && Et <= 57 ? _t = Et - 48 : _t = 1 / 0, _t >= E)
            break;
          ze = Et, Fe = Fe * E + _t;
        }
        return J && ze === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === Le || D != null && this.pos - Le !== D ? null : Fe;
      };
      function kr(E, D) {
        return D ? parseInt(E, 8) : parseFloat(E.replace(/_/g, ""));
      }
      function Er(E) {
        return typeof BigInt != "function" ? null : BigInt(E.replace(/_/g, ""));
      }
      yt.readRadixNumber = function(E) {
        var D = this.pos;
        this.pos += 2;
        var K = this.readInt(E);
        return K == null && this.raise(this.start + 2, "Expected number in radix " + E), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (K = Er(this.input.slice(D, this.pos)), ++this.pos) : c(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(C.num, K);
      }, yt.readNumber = function(E) {
        var D = this.pos;
        !E && this.readInt(10, void 0, !0) === null && this.raise(D, "Invalid number");
        var K = this.pos - D >= 2 && this.input.charCodeAt(D) === 48;
        K && this.strict && this.raise(D, "Invalid number");
        var J = this.input.charCodeAt(this.pos);
        if (!K && !E && this.options.ecmaVersion >= 11 && J === 110) {
          var me = Er(this.input.slice(D, this.pos));
          return ++this.pos, c(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(C.num, me);
        }
        K && /[89]/.test(this.input.slice(D, this.pos)) && (K = !1), J === 46 && !K && (++this.pos, this.readInt(10), J = this.input.charCodeAt(this.pos)), (J === 69 || J === 101) && !K && (J = this.input.charCodeAt(++this.pos), (J === 43 || J === 45) && ++this.pos, this.readInt(10) === null && this.raise(D, "Invalid number")), c(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var Le = kr(this.input.slice(D, this.pos), K);
        return this.finishToken(C.num, Le);
      }, yt.readCodePoint = function() {
        var E = this.input.charCodeAt(this.pos), D;
        if (E === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var K = ++this.pos;
          D = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, D > 1114111 && this.invalidStringToken(K, "Code point out of bounds");
        } else
          D = this.readHexChar(4);
        return D;
      }, yt.readString = function(E) {
        for (var D = "", K = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var J = this.input.charCodeAt(this.pos);
          if (J === E)
            break;
          J === 92 ? (D += this.input.slice(K, this.pos), D += this.readEscapedChar(!1), K = this.pos) : J === 8232 || J === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (R(J) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return D += this.input.slice(K, this.pos++), this.finishToken(C.string, D);
      };
      var Oe = {};
      yt.tryReadTemplateToken = function() {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (E) {
          if (E === Oe)
            this.readInvalidTemplateToken();
          else
            throw E;
        }
        this.inTemplateElement = !1;
      }, yt.invalidStringToken = function(E, D) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw Oe;
        this.raise(E, D);
      }, yt.readTmplToken = function() {
        for (var E = "", D = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var K = this.input.charCodeAt(this.pos);
          if (K === 96 || K === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === C.template || this.type === C.invalidTemplate) ? K === 36 ? (this.pos += 2, this.finishToken(C.dollarBraceL)) : (++this.pos, this.finishToken(C.backQuote)) : (E += this.input.slice(D, this.pos), this.finishToken(C.template, E));
          if (K === 92)
            E += this.input.slice(D, this.pos), E += this.readEscapedChar(!0), D = this.pos;
          else if (R(K)) {
            switch (E += this.input.slice(D, this.pos), ++this.pos, K) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                E += `
`;
                break;
              default:
                E += String.fromCharCode(K);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), D = this.pos;
          } else
            ++this.pos;
        }
      }, yt.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            case "`":
              return this.finishToken(C.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        this.raise(this.start, "Unterminated template");
      }, yt.readEscapedChar = function(E) {
        var D = this.input.charCodeAt(++this.pos);
        switch (++this.pos, D) {
          case 110:
            return `
`;
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return $(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (this.strict && this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            ), E) {
              var K = this.pos - 1;
              this.invalidStringToken(
                K,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (D >= 48 && D <= 55) {
              var J = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], me = parseInt(J, 8);
              return me > 255 && (J = J.slice(0, -1), me = parseInt(J, 8)), this.pos += J.length - 1, D = this.input.charCodeAt(this.pos), (J !== "0" || D === 56 || D === 57) && (this.strict || E) && this.invalidStringToken(
                this.pos - 1 - J.length,
                E ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(me);
            }
            return R(D) ? "" : String.fromCharCode(D);
        }
      }, yt.readHexChar = function(E) {
        var D = this.pos, K = this.readInt(16, E);
        return K === null && this.invalidStringToken(D, "Bad character escape sequence"), K;
      }, yt.readWord1 = function() {
        this.containsEsc = !1;
        for (var E = "", D = !0, K = this.pos, J = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var me = this.fullCharCodeAtPos();
          if (g(me, J))
            this.pos += me <= 65535 ? 1 : 2;
          else if (me === 92) {
            this.containsEsc = !0, E += this.input.slice(K, this.pos);
            var Le = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var Fe = this.readCodePoint();
            (D ? c : g)(Fe, J) || this.invalidStringToken(Le, "Invalid Unicode escape"), E += $(Fe), K = this.pos;
          } else
            break;
          D = !1;
        }
        return E + this.input.slice(K, this.pos);
      }, yt.readWord = function() {
        var E = this.readWord1(), D = C.name;
        return this.keywords.test(E) && (D = b[E]), this.finishToken(D, E);
      };
      var V = "8.9.0";
      ot.acorn = {
        Parser: ot,
        version: V,
        defaultOptions: le,
        Position: X,
        SourceLocation: Q,
        getLineInfo: ue,
        Node: We,
        TokenType: d,
        tokTypes: C,
        keywordTypes: b,
        TokContext: te,
        tokContexts: B,
        isIdentifierChar: g,
        isIdentifierStart: c,
        Token: fr,
        isNewLine: R,
        lineBreak: x,
        lineBreakG: A,
        nonASCIIwhitespace: _
      };
      function ie(E, D) {
        return ot.parse(E, D);
      }
      function he(E, D, K) {
        return ot.parseExpressionAt(E, D, K);
      }
      function De(E, D) {
        return ot.tokenizer(E, D);
      }
      o.Node = We, o.Parser = ot, o.Position = X, o.SourceLocation = Q, o.TokContext = te, o.Token = fr, o.TokenType = d, o.defaultOptions = le, o.getLineInfo = ue, o.isIdentifierChar = g, o.isIdentifierStart = c, o.isNewLine = R, o.keywordTypes = b, o.lineBreak = x, o.lineBreakG = A, o.nonASCIIwhitespace = _, o.parse = ie, o.parseExpressionAt = he, o.tokContexts = B, o.tokTypes = C, o.tokenizer = De, o.version = V;
    });
  }(zr, zr.exports)), zr.exports;
}
var Rn = { exports: {} }, Dn, mp;
function bS() {
  return mp || (mp = 1, Dn = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }), Dn;
}
var gp;
function xS() {
  return gp || (gp = 1, function(i) {
    const t = bS(), o = /^[\da-fA-F]+$/, f = /^\d+$/, r = /* @__PURE__ */ new WeakMap();
    function u(n) {
      n = n.Parser.acorn || n;
      let p = r.get(n);
      if (!p) {
        const m = n.tokTypes, h = n.TokContext, l = n.TokenType, s = new h("<tag", !1), c = new h("</tag", !1), g = new h("<tag>...</tag>", !0, !0), d = {
          tc_oTag: s,
          tc_cTag: c,
          tc_expr: g
        }, y = {
          jsxName: new l("jsxName"),
          jsxText: new l("jsxText", { beforeExpr: !0 }),
          jsxTagStart: new l("jsxTagStart", { startsExpr: !0 }),
          jsxTagEnd: new l("jsxTagEnd")
        };
        y.jsxTagStart.updateContext = function() {
          this.context.push(g), this.context.push(s), this.exprAllowed = !1;
        }, y.jsxTagEnd.updateContext = function(v) {
          let T = this.context.pop();
          T === s && v === m.slash || T === c ? (this.context.pop(), this.exprAllowed = this.curContext() === g) : this.exprAllowed = !0;
        }, p = { tokContexts: d, tokTypes: y }, r.set(n, p);
      }
      return p;
    }
    function e(n) {
      if (!n)
        return n;
      if (n.type === "JSXIdentifier")
        return n.name;
      if (n.type === "JSXNamespacedName")
        return n.namespace.name + ":" + n.name.name;
      if (n.type === "JSXMemberExpression")
        return e(n.object) + "." + e(n.property);
    }
    i.exports = function(n) {
      return n = n || {}, function(p) {
        return a({
          allowNamespaces: n.allowNamespaces !== !1,
          allowNamespacedObjects: !!n.allowNamespacedObjects
        }, p);
      };
    }, Object.defineProperty(i.exports, "tokTypes", {
      get: function() {
        return u(_f()).tokTypes;
      },
      configurable: !0,
      enumerable: !0
    });
    function a(n, p) {
      const m = p.acorn || _f(), h = u(m), l = m.tokTypes, s = h.tokTypes, c = m.tokContexts, g = h.tokContexts.tc_oTag, d = h.tokContexts.tc_cTag, y = h.tokContexts.tc_expr, v = m.isNewLine, T = m.isIdentifierStart, b = m.isIdentifierChar;
      return class extends p {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return h;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let S = "", C = this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
            let x = this.input.charCodeAt(this.pos);
            switch (x) {
              case 60:
              case 123:
                return this.pos === this.start ? x === 60 && this.exprAllowed ? (++this.pos, this.finishToken(s.jsxTagStart)) : this.getTokenFromCode(x) : (S += this.input.slice(C, this.pos), this.finishToken(s.jsxText, S));
              case 38:
                S += this.input.slice(C, this.pos), S += this.jsx_readEntity(), C = this.pos;
                break;
              case 62:
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (x === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                v(x) ? (S += this.input.slice(C, this.pos), S += this.jsx_readNewLine(!0), C = this.pos) : ++this.pos;
            }
          }
        }
        jsx_readNewLine(S) {
          let C = this.input.charCodeAt(this.pos), x;
          return ++this.pos, C === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, x = S ? `
` : `\r
`) : x = String.fromCharCode(C), this.options.locations && (++this.curLine, this.lineStart = this.pos), x;
        }
        jsx_readString(S) {
          let C = "", x = ++this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            let A = this.input.charCodeAt(this.pos);
            if (A === S) break;
            A === 38 ? (C += this.input.slice(x, this.pos), C += this.jsx_readEntity(), x = this.pos) : v(A) ? (C += this.input.slice(x, this.pos), C += this.jsx_readNewLine(!1), x = this.pos) : ++this.pos;
          }
          return C += this.input.slice(x, this.pos++), this.finishToken(l.string, C);
        }
        jsx_readEntity() {
          let S = "", C = 0, x, A = this.input[this.pos];
          A !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
          let R = ++this.pos;
          for (; this.pos < this.input.length && C++ < 10; ) {
            if (A = this.input[this.pos++], A === ";") {
              S[0] === "#" ? S[1] === "x" ? (S = S.substr(2), o.test(S) && (x = String.fromCharCode(parseInt(S, 16)))) : (S = S.substr(1), f.test(S) && (x = String.fromCharCode(parseInt(S, 10)))) : x = t[S];
              break;
            }
            S += A;
          }
          return x || (this.pos = R, "&");
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let S, C = this.pos;
          do
            S = this.input.charCodeAt(++this.pos);
          while (b(S) || S === 45);
          return this.finishToken(s.jsxName, this.input.slice(C, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let S = this.startNode();
          return this.type === s.jsxName ? S.name = this.value : this.type.keyword ? S.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(S, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let S = this.start, C = this.startLoc, x = this.jsx_parseIdentifier();
          if (!n.allowNamespaces || !this.eat(l.colon)) return x;
          var A = this.startNodeAt(S, C);
          return A.namespace = x, A.name = this.jsx_parseIdentifier(), this.finishNode(A, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === s.jsxTagEnd) return "";
          let S = this.start, C = this.startLoc, x = this.jsx_parseNamespacedName();
          for (this.type === l.dot && x.type === "JSXNamespacedName" && !n.allowNamespacedObjects && this.unexpected(); this.eat(l.dot); ) {
            let A = this.startNodeAt(S, C);
            A.object = x, A.property = this.jsx_parseIdentifier(), x = this.finishNode(A, "JSXMemberExpression");
          }
          return x;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case l.braceL:
              let S = this.jsx_parseExpressionContainer();
              return S.expression.type === "JSXEmptyExpression" && this.raise(S.start, "JSX attributes must only be assigned a non-empty expression"), S;
            case s.jsxTagStart:
            case l.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let S = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(S, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let S = this.startNode();
          return this.next(), S.expression = this.type === l.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(l.braceR), this.finishNode(S, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let S = this.startNode();
          return this.eat(l.braceL) ? (this.expect(l.ellipsis), S.argument = this.parseMaybeAssign(), this.expect(l.braceR), this.finishNode(S, "JSXSpreadAttribute")) : (S.name = this.jsx_parseNamespacedName(), S.value = this.eat(l.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(S, "JSXAttribute"));
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(S, C) {
          let x = this.startNodeAt(S, C);
          x.attributes = [];
          let A = this.jsx_parseElementName();
          for (A && (x.name = A); this.type !== l.slash && this.type !== s.jsxTagEnd; )
            x.attributes.push(this.jsx_parseAttribute());
          return x.selfClosing = this.eat(l.slash), this.expect(s.jsxTagEnd), this.finishNode(x, A ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(S, C) {
          let x = this.startNodeAt(S, C), A = this.jsx_parseElementName();
          return A && (x.name = A), this.expect(s.jsxTagEnd), this.finishNode(x, A ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(S, C) {
          let x = this.startNodeAt(S, C), A = [], R = this.jsx_parseOpeningElementAt(S, C), L = null;
          if (!R.selfClosing) {
            e: for (; ; )
              switch (this.type) {
                case s.jsxTagStart:
                  if (S = this.start, C = this.startLoc, this.next(), this.eat(l.slash)) {
                    L = this.jsx_parseClosingElementAt(S, C);
                    break e;
                  }
                  A.push(this.jsx_parseElementAt(S, C));
                  break;
                case s.jsxText:
                  A.push(this.parseExprAtom());
                  break;
                case l.braceL:
                  A.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            e(L.name) !== e(R.name) && this.raise(
              L.start,
              "Expected corresponding JSX closing tag for <" + e(R.name) + ">"
            );
          }
          let _ = R.name ? "Element" : "Fragment";
          return x["opening" + _] = R, x["closing" + _] = L, x.children = A, this.type === l.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(x, "JSX" + _);
        }
        // Parse JSX text
        jsx_parseText() {
          let S = this.parseLiteral(this.value);
          return S.type = "JSXText", S;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let S = this.start, C = this.startLoc;
          return this.next(), this.jsx_parseElementAt(S, C);
        }
        parseExprAtom(S) {
          return this.type === s.jsxText ? this.jsx_parseText() : this.type === s.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(S);
        }
        readToken(S) {
          let C = this.curContext();
          if (C === y) return this.jsx_readToken();
          if (C === g || C === d) {
            if (T(S)) return this.jsx_readWord();
            if (S == 62)
              return ++this.pos, this.finishToken(s.jsxTagEnd);
            if ((S === 34 || S === 39) && C == g)
              return this.jsx_readString(S);
          }
          return S === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(s.jsxTagStart)) : super.readToken(S);
        }
        updateContext(S) {
          if (this.type == l.braceL) {
            var C = this.curContext();
            C == g ? this.context.push(c.b_expr) : C == y ? this.context.push(c.b_tmpl) : super.updateContext(S), this.exprAllowed = !0;
          } else if (this.type === l.slash && S === s.jsxTagStart)
            this.context.length -= 2, this.context.push(d), this.exprAllowed = !1;
          else
            return super.updateContext(S);
        }
      };
    }
  }(Rn)), Rn.exports;
}
var dp;
function hn() {
  if (dp) return Jt;
  dp = 1, Object.defineProperty(Jt, "__esModule", { value: !0 });
  var i = _f(), t = xS(), o = qr();
  function f(w) {
    return w && typeof w == "object" && "default" in w ? w : { default: w };
  }
  function r(w) {
    if (w && w.__esModule) return w;
    var U = /* @__PURE__ */ Object.create(null);
    return w && Object.keys(w).forEach(function(q) {
      if (q !== "default") {
        var F = Object.getOwnPropertyDescriptor(w, q);
        Object.defineProperty(U, q, F.get ? F : {
          enumerable: !0,
          get: function() {
            return w[q];
          }
        });
      }
    }), U.default = w, Object.freeze(U);
  }
  var u = /* @__PURE__ */ r(i), e = /* @__PURE__ */ f(t), a = /* @__PURE__ */ r(o);
  const n = {
    Boolean: "Boolean",
    Identifier: "Identifier",
    PrivateIdentifier: "PrivateIdentifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
  };
  function p(w, U) {
    const q = w[0], F = w[w.length - 1], $ = {
      type: n.Template,
      value: U.slice(q.start, F.end)
    };
    return q.loc && ($.loc = {
      start: q.loc.start,
      end: F.loc.end
    }), q.range && ($.start = q.range[0], $.end = F.range[1], $.range = [$.start, $.end]), $;
  }
  function m(w, U) {
    this._acornTokTypes = w, this._tokens = [], this._curlyBrace = null, this._code = U;
  }
  m.prototype = {
    constructor: m,
    /**
     * Translates a single Esprima token to a single Acorn token. This may be
     * inaccurate due to how templates are handled differently in Esprima and
     * Acorn, but should be accurate for all other tokens.
     * @param {AcornToken} token The Acorn token to translate.
     * @param {Object} extra Espree extra object.
     * @returns {EsprimaToken} The Esprima version of the token.
     */
    translate(w, U) {
      const q = w.type, F = this._acornTokTypes;
      if (q === F.name)
        w.type = n.Identifier, w.value === "static" && (w.type = n.Keyword), U.ecmaVersion > 5 && (w.value === "yield" || w.value === "let") && (w.type = n.Keyword);
      else if (q === F.privateId)
        w.type = n.PrivateIdentifier;
      else if (q === F.semi || q === F.comma || q === F.parenL || q === F.parenR || q === F.braceL || q === F.braceR || q === F.dot || q === F.bracketL || q === F.colon || q === F.question || q === F.bracketR || q === F.ellipsis || q === F.arrow || q === F.jsxTagStart || q === F.incDec || q === F.starstar || q === F.jsxTagEnd || q === F.prefix || q === F.questionDot || q.binop && !q.keyword || q.isAssign)
        w.type = n.Punctuator, w.value = this._code.slice(w.start, w.end);
      else if (q === F.jsxName)
        w.type = n.JSXIdentifier;
      else if (q.label === "jsxText" || q === F.jsxAttrValueToken)
        w.type = n.JSXText;
      else if (q.keyword)
        q.keyword === "true" || q.keyword === "false" ? w.type = n.Boolean : q.keyword === "null" ? w.type = n.Null : w.type = n.Keyword;
      else if (q === F.num)
        w.type = n.Numeric, w.value = this._code.slice(w.start, w.end);
      else if (q === F.string)
        U.jsxAttrValueToken ? (U.jsxAttrValueToken = !1, w.type = n.JSXText) : w.type = n.String, w.value = this._code.slice(w.start, w.end);
      else if (q === F.regexp) {
        w.type = n.RegularExpression;
        const $ = w.value;
        w.regex = {
          flags: $.flags,
          pattern: $.pattern
        }, w.value = `/${$.pattern}/${$.flags}`;
      }
      return w;
    },
    /**
     * Function to call during Acorn's onToken handler.
     * @param {AcornToken} token The Acorn token.
     * @param {Object} extra The Espree extra object.
     * @returns {void}
     */
    onToken(w, U) {
      const q = this._acornTokTypes, F = U.tokens, $ = this._tokens, P = () => {
        F.push(p(this._tokens, this._code)), this._tokens = [];
      };
      if (w.type === q.eof) {
        this._curlyBrace && F.push(this.translate(this._curlyBrace, U));
        return;
      }
      if (w.type === q.backQuote) {
        this._curlyBrace && (F.push(this.translate(this._curlyBrace, U)), this._curlyBrace = null), $.push(w), $.length > 1 && P();
        return;
      }
      if (w.type === q.dollarBraceL) {
        $.push(w), P();
        return;
      }
      if (w.type === q.braceR) {
        this._curlyBrace && F.push(this.translate(this._curlyBrace, U)), this._curlyBrace = w;
        return;
      }
      if (w.type === q.template || w.type === q.invalidTemplate) {
        this._curlyBrace && ($.push(this._curlyBrace), this._curlyBrace = null), $.push(w);
        return;
      }
      this._curlyBrace && (F.push(this.translate(this._curlyBrace, U)), this._curlyBrace = null), F.push(this.translate(w, U));
    }
  };
  const h = [
    3,
    5,
    6,
    // 2015
    7,
    // 2016
    8,
    // 2017
    9,
    // 2018
    10,
    // 2019
    11,
    // 2020
    12,
    // 2021
    13,
    // 2022
    14,
    // 2023
    15
    // 2024
  ];
  function l() {
    return h[h.length - 1];
  }
  function s() {
    return [...h];
  }
  function c(w = 5) {
    let U = w === "latest" ? l() : w;
    if (typeof U != "number")
      throw new Error(`ecmaVersion must be a number or "latest". Received value of type ${typeof w} instead.`);
    if (U >= 2015 && (U -= 2009), !h.includes(U))
      throw new Error("Invalid ecmaVersion.");
    return U;
  }
  function g(w = "script") {
    if (w === "script" || w === "module")
      return w;
    if (w === "commonjs")
      return "script";
    throw new Error("Invalid sourceType.");
  }
  function d(w) {
    const U = c(w.ecmaVersion), q = g(w.sourceType), F = w.range === !0, $ = w.loc === !0;
    if (U !== 3 && w.allowReserved)
      throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
    if (typeof w.allowReserved < "u" && typeof w.allowReserved != "boolean")
      throw new Error("`allowReserved`, when present, must be `true` or `false`");
    const P = U === 3 ? w.allowReserved || "never" : !1, X = w.ecmaFeatures || {}, Q = w.sourceType === "commonjs" || !!X.globalReturn;
    if (q === "module" && U < 6)
      throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
    return Object.assign({}, w, {
      ecmaVersion: U,
      sourceType: q,
      ranges: F,
      locations: $,
      allowReserved: P,
      allowReturnOutsideFunction: Q
    });
  }
  const y = Symbol("espree's internal state"), v = Symbol("espree's esprimaFinishNode");
  function T(w, U, q, F, $, P, X) {
    let Q;
    w ? Q = "Block" : X.slice(q, q + 2) === "#!" ? Q = "Hashbang" : Q = "Line";
    const ue = {
      type: Q,
      value: U
    };
    return typeof q == "number" && (ue.start = q, ue.end = F, ue.range = [q, F]), typeof $ == "object" && (ue.loc = {
      start: $,
      end: P
    }), ue;
  }
  var b = () => (w) => {
    const U = Object.assign({}, w.acorn.tokTypes);
    return w.acornJsx && Object.assign(U, w.acornJsx.tokTypes), class extends w {
      constructor(F, $) {
        (typeof F != "object" || F === null) && (F = {}), typeof $ != "string" && !($ instanceof String) && ($ = String($));
        const P = F.sourceType, X = d(F), Q = X.ecmaFeatures || {}, ue = X.tokens === !0 ? new m(U, $) : null, le = {
          originalSourceType: P || X.sourceType,
          tokens: ue ? [] : null,
          comments: X.comment === !0 ? [] : null,
          impliedStrict: Q.impliedStrict === !0 && X.ecmaVersion >= 5,
          ecmaVersion: X.ecmaVersion,
          jsxAttrValueToken: !1,
          lastToken: null,
          templateElements: []
        };
        super({
          // do not use spread, because we don't want to pass any unknown options to acorn
          ecmaVersion: X.ecmaVersion,
          sourceType: X.sourceType,
          ranges: X.ranges,
          locations: X.locations,
          allowReserved: X.allowReserved,
          // Truthy value is true for backward compatibility.
          allowReturnOutsideFunction: X.allowReturnOutsideFunction,
          // Collect tokens
          onToken(Ce) {
            ue && ue.onToken(Ce, le), Ce.type !== U.eof && (le.lastToken = Ce);
          },
          // Collect comments
          onComment(Ce, j, H, N, G, M) {
            if (le.comments) {
              const Z = T(Ce, j, H, N, G, M, $);
              le.comments.push(Z);
            }
          }
        }, $), this[y] = le;
      }
      tokenize() {
        do
          this.next();
        while (this.type !== U.eof);
        this.next();
        const F = this[y], $ = F.tokens;
        return F.comments && ($.comments = F.comments), $;
      }
      finishNode(...F) {
        const $ = super.finishNode(...F);
        return this[v]($);
      }
      finishNodeAt(...F) {
        const $ = super.finishNodeAt(...F);
        return this[v]($);
      }
      parse() {
        const F = this[y], $ = super.parse();
        if ($.sourceType = F.originalSourceType, F.comments && ($.comments = F.comments), F.tokens && ($.tokens = F.tokens), $.body.length) {
          const [P] = $.body;
          $.range && ($.range[0] = P.range[0]), $.loc && ($.loc.start = P.loc.start), $.start = P.start;
        }
        return F.lastToken && ($.range && ($.range[1] = F.lastToken.range[1]), $.loc && ($.loc.end = F.lastToken.loc.end), $.end = F.lastToken.end), this[y].templateElements.forEach((P) => {
          const Q = P.tail ? 1 : 2;
          P.start += -1, P.end += Q, P.range && (P.range[0] += -1, P.range[1] += Q), P.loc && (P.loc.start.column += -1, P.loc.end.column += Q);
        }), $;
      }
      parseTopLevel(F) {
        return this[y].impliedStrict && (this.strict = !0), super.parseTopLevel(F);
      }
      /**
       * Overwrites the default raise method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @param {string} message The error message.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      raise(F, $) {
        const P = w.acorn.getLineInfo(this.input, F), X = new SyntaxError($);
        throw X.index = F, X.lineNumber = P.line, X.column = P.column + 1, X;
      }
      /**
       * Overwrites the default raise method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @param {string} message The error message.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      raiseRecoverable(F, $) {
        this.raise(F, $);
      }
      /**
       * Overwrites the default unexpected method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      unexpected(F) {
        let $ = "Unexpected token";
        if (F != null) {
          if (this.pos = F, this.options.locations)
            for (; this.pos < this.lineStart; )
              this.lineStart = this.input.lastIndexOf(`
`, this.lineStart - 2) + 1, --this.curLine;
          this.nextToken();
        }
        this.end > this.start && ($ += ` ${this.input.slice(this.start, this.end)}`), this.raise(this.start, $);
      }
      /*
      * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
      * uses regular tt.string without any distinction between this and regular JS
      * strings. As such, we intercept an attempt to read a JSX string and set a flag
      * on extra so that when tokens are converted, the next token will be switched
      * to JSXText via onToken.
      */
      jsx_readString(F) {
        const $ = super.jsx_readString(F);
        return this.type === U.string && (this[y].jsxAttrValueToken = !0), $;
      }
      /**
       * Performs last-minute Esprima-specific compatibility checks and fixes.
       * @param {ASTNode} result The node to check.
       * @returns {ASTNode} The finished node.
       */
      [v](F) {
        return F.type === "TemplateElement" && this[y].templateElements.push(F), F.type.includes("Function") && !F.generator && (F.generator = !1), F;
      }
    };
  };
  const S = "9.6.1", C = {
    _regular: null,
    _jsx: null,
    get regular() {
      return this._regular === null && (this._regular = u.Parser.extend(b())), this._regular;
    },
    get jsx() {
      return this._jsx === null && (this._jsx = u.Parser.extend(e.default(), b())), this._jsx;
    },
    get(w) {
      return !!(w && w.ecmaFeatures && w.ecmaFeatures.jsx) ? this.jsx : this.regular;
    }
  };
  function x(w, U) {
    const q = C.get(U);
    return (!U || U.tokens !== !0) && (U = Object.assign({}, U, { tokens: !0 })), new q(U, w).tokenize();
  }
  function A(w, U) {
    const q = C.get(U);
    return new q(U, w).parse();
  }
  const R = S, L = "espree", _ = function() {
    return a.KEYS;
  }(), I = function() {
    let w, U = {};
    typeof Object.create == "function" && (U = /* @__PURE__ */ Object.create(null));
    for (w in _)
      Object.hasOwnProperty.call(_, w) && (U[w] = w);
    return typeof Object.freeze == "function" && Object.freeze(U), U;
  }(), O = l(), k = s();
  return Jt.Syntax = I, Jt.VisitorKeys = _, Jt.latestEcmaVersion = O, Jt.name = L, Jt.parse = A, Jt.supportedEcmaVersions = k, Jt.tokenize = x, Jt.version = R, Jt;
}
var Vr = { exports: {} };
Vr.exports;
var Ep;
function RS() {
  return Ep || (Ep = 1, function(i, t) {
    var o = 200, f = "__lodash_hash_undefined__", r = 800, u = 16, e = 9007199254740991, a = "[object Arguments]", n = "[object Array]", p = "[object AsyncFunction]", m = "[object Boolean]", h = "[object Date]", l = "[object Error]", s = "[object Function]", c = "[object GeneratorFunction]", g = "[object Map]", d = "[object Number]", y = "[object Null]", v = "[object Object]", T = "[object Proxy]", b = "[object RegExp]", S = "[object Set]", C = "[object String]", x = "[object Undefined]", A = "[object WeakMap]", R = "[object ArrayBuffer]", L = "[object DataView]", _ = "[object Float32Array]", I = "[object Float64Array]", O = "[object Int8Array]", k = "[object Int16Array]", w = "[object Int32Array]", U = "[object Uint8Array]", q = "[object Uint8ClampedArray]", F = "[object Uint16Array]", $ = "[object Uint32Array]", P = /[\\^$.*+?()[\]{}|]/g, X = /^\[object .+?Constructor\]$/, Q = /^(?:0|[1-9]\d*)$/, ue = {};
    ue[_] = ue[I] = ue[O] = ue[k] = ue[w] = ue[U] = ue[q] = ue[F] = ue[$] = !0, ue[a] = ue[n] = ue[R] = ue[m] = ue[L] = ue[h] = ue[l] = ue[s] = ue[g] = ue[d] = ue[v] = ue[b] = ue[S] = ue[C] = ue[A] = !1;
    var le = typeof Mt == "object" && Mt && Mt.Object === Object && Mt, Ce = typeof self == "object" && self && self.Object === Object && self, j = le || Ce || Function("return this")(), H = t && !t.nodeType && t, N = H && !0 && i && !i.nodeType && i, G = N && N.exports === H, M = G && le.process, Z = function() {
      try {
        var ge = N && N.require && N.require("util").types;
        return ge || M && M.binding && M.binding("util");
      } catch {
      }
    }(), Ee = Z && Z.isTypedArray;
    function ke(ge, be, Ne) {
      switch (Ne.length) {
        case 0:
          return ge.call(be);
        case 1:
          return ge.call(be, Ne[0]);
        case 2:
          return ge.call(be, Ne[0], Ne[1]);
        case 3:
          return ge.call(be, Ne[0], Ne[1], Ne[2]);
      }
      return ge.apply(be, Ne);
    }
    function Ie(ge, be) {
      for (var Ne = -1, ct = Array(ge); ++Ne < ge; )
        ct[Ne] = be(Ne);
      return ct;
    }
    function Je(ge) {
      return function(be) {
        return ge(be);
      };
    }
    function at(ge, be) {
      return ge == null ? void 0 : ge[be];
    }
    function lt(ge, be) {
      return function(Ne) {
        return ge(be(Ne));
      };
    }
    var mt = Array.prototype, Y = Function.prototype, Te = Object.prototype, Ke = j["__core-js_shared__"], et = Y.toString, nt = Te.hasOwnProperty, rt = function() {
      var ge = /[^.]+$/.exec(Ke && Ke.keys && Ke.keys.IE_PROTO || "");
      return ge ? "Symbol(src)_1." + ge : "";
    }(), ot = Te.toString, Ct = et.call(Object), dt = RegExp(
      "^" + et.call(nt).replace(P, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), vt = G ? j.Buffer : void 0, W = j.Symbol, Ye = j.Uint8Array;
    vt && vt.allocUnsafe;
    var Ue = lt(Object.getPrototypeOf, Object), Ve = Object.create, xe = Te.propertyIsEnumerable, re = mt.splice, ne = W ? W.toStringTag : void 0, ae = function() {
      try {
        var ge = er(Object, "defineProperty");
        return ge({}, "", {}), ge;
      } catch {
      }
    }(), fe = vt ? vt.isBuffer : void 0, de = Math.max, ee = Date.now, te = er(j, "Map"), B = er(Object, "create"), z = /* @__PURE__ */ function() {
      function ge() {
      }
      return function(be) {
        if (!Et(be))
          return {};
        if (Ve)
          return Ve(be);
        ge.prototype = be;
        var Ne = new ge();
        return ge.prototype = void 0, Ne;
      };
    }();
    function ce(ge) {
      var be = -1, Ne = ge == null ? 0 : ge.length;
      for (this.clear(); ++be < Ne; ) {
        var ct = ge[be];
        this.set(ct[0], ct[1]);
      }
    }
    function ye() {
      this.__data__ = B ? B(null) : {}, this.size = 0;
    }
    function Be(ge) {
      var be = this.has(ge) && delete this.__data__[ge];
      return this.size -= be ? 1 : 0, be;
    }
    function we(ge) {
      var be = this.__data__;
      if (B) {
        var Ne = be[ge];
        return Ne === f ? void 0 : Ne;
      }
      return nt.call(be, ge) ? be[ge] : void 0;
    }
    function Pe(ge) {
      var be = this.__data__;
      return B ? be[ge] !== void 0 : nt.call(be, ge);
    }
    function st(ge, be) {
      var Ne = this.__data__;
      return this.size += this.has(ge) ? 0 : 1, Ne[ge] = B && be === void 0 ? f : be, this;
    }
    ce.prototype.clear = ye, ce.prototype.delete = Be, ce.prototype.get = we, ce.prototype.has = Pe, ce.prototype.set = st;
    function We(ge) {
      var be = -1, Ne = ge == null ? 0 : ge.length;
      for (this.clear(); ++be < Ne; ) {
        var ct = ge[be];
        this.set(ct[0], ct[1]);
      }
    }
    function _e() {
      this.__data__ = [], this.size = 0;
    }
    function je(ge) {
      var be = this.__data__, Ne = ut(be, ge);
      if (Ne < 0)
        return !1;
      var ct = be.length - 1;
      return Ne == ct ? be.pop() : re.call(be, Ne, 1), --this.size, !0;
    }
    function $e(ge) {
      var be = this.__data__, Ne = ut(be, ge);
      return Ne < 0 ? void 0 : be[Ne][1];
    }
    function Ae(ge) {
      return ut(this.__data__, ge) > -1;
    }
    function oe(ge, be) {
      var Ne = this.__data__, ct = ut(Ne, ge);
      return ct < 0 ? (++this.size, Ne.push([ge, be])) : Ne[ct][1] = be, this;
    }
    We.prototype.clear = _e, We.prototype.delete = je, We.prototype.get = $e, We.prototype.has = Ae, We.prototype.set = oe;
    function se(ge) {
      var be = -1, Ne = ge == null ? 0 : ge.length;
      for (this.clear(); ++be < Ne; ) {
        var ct = ge[be];
        this.set(ct[0], ct[1]);
      }
    }
    function pe() {
      this.size = 0, this.__data__ = {
        hash: new ce(),
        map: new (te || We)(),
        string: new ce()
      };
    }
    function ve(ge) {
      var be = ur(this, ge).delete(ge);
      return this.size -= be ? 1 : 0, be;
    }
    function Se(ge) {
      return ur(this, ge).get(ge);
    }
    function Ge(ge) {
      return ur(this, ge).has(ge);
    }
    function Ze(ge, be) {
      var Ne = ur(this, ge), ct = Ne.size;
      return Ne.set(ge, be), this.size += Ne.size == ct ? 0 : 1, this;
    }
    se.prototype.clear = pe, se.prototype.delete = ve, se.prototype.get = Se, se.prototype.has = Ge, se.prototype.set = Ze;
    function ft(ge) {
      var be = this.__data__ = new We(ge);
      this.size = be.size;
    }
    function gt() {
      this.__data__ = new We(), this.size = 0;
    }
    function At(ge) {
      var be = this.__data__, Ne = be.delete(ge);
      return this.size = be.size, Ne;
    }
    function ht(ge) {
      return this.__data__.get(ge);
    }
    function qe(ge) {
      return this.__data__.has(ge);
    }
    function He(ge, be) {
      var Ne = this.__data__;
      if (Ne instanceof We) {
        var ct = Ne.__data__;
        if (!te || ct.length < o - 1)
          return ct.push([ge, be]), this.size = ++Ne.size, this;
        Ne = this.__data__ = new se(ct);
      }
      return Ne.set(ge, be), this.size = Ne.size, this;
    }
    ft.prototype.clear = gt, ft.prototype.delete = At, ft.prototype.get = ht, ft.prototype.has = qe, ft.prototype.set = He;
    function Xe(ge, be) {
      var Ne = me(ge), ct = !Ne && J(ge), St = !Ne && !ct && ze(ge), Dt = !Ne && !ct && !St && pr(ge), wt = Ne || ct || St || Dt, bt = wt ? Ie(ge.length, String) : [], kt = bt.length;
      for (var Ht in ge)
        wt && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Ht == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        St && (Ht == "offset" || Ht == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        Dt && (Ht == "buffer" || Ht == "byteLength" || Ht == "byteOffset") || // Skip index properties.
        cr(Ht, kt)) || bt.push(Ht);
      return bt;
    }
    function Me(ge, be, Ne) {
      (Ne !== void 0 && !K(ge[be], Ne) || Ne === void 0 && !(be in ge)) && Tt(ge, be, Ne);
    }
    function it(ge, be, Ne) {
      var ct = ge[be];
      (!(nt.call(ge, be) && K(ct, Ne)) || Ne === void 0 && !(be in ge)) && Tt(ge, be, Ne);
    }
    function ut(ge, be) {
      for (var Ne = ge.length; Ne--; )
        if (K(ge[Ne][0], be))
          return Ne;
      return -1;
    }
    function Tt(ge, be, Ne) {
      be == "__proto__" && ae ? ae(ge, be, {
        configurable: !0,
        enumerable: !0,
        value: Ne,
        writable: !0
      }) : ge[be] = Ne;
    }
    var Rt = zt();
    function xt(ge) {
      return ge == null ? ge === void 0 ? x : y : ne && ne in Object(ge) ? sr(ge) : V(ge);
    }
    function tt(ge) {
      return _t(ge) && xt(ge) == a;
    }
    function Lt(ge) {
      if (!Et(ge) || kr(ge))
        return !1;
      var be = Qe(ge) ? dt : X;
      return be.test(D(ge));
    }
    function Bt(ge) {
      return _t(ge) && pt(ge.length) && !!ue[xt(ge)];
    }
    function Ut(ge) {
      if (!Et(ge))
        return Oe(ge);
      var be = Er(ge), Ne = [];
      for (var ct in ge)
        ct == "constructor" && (be || !nt.call(ge, ct)) || Ne.push(ct);
      return Ne;
    }
    function Kt(ge, be, Ne, ct, St) {
      ge !== be && Rt(be, function(Dt, wt) {
        if (St || (St = new ft()), Et(Dt))
          Nt(ge, be, wt, Ne, Kt, ct, St);
        else {
          var bt = ct ? ct(he(ge, wt), Dt, wt + "", ge, be, St) : void 0;
          bt === void 0 && (bt = Dt), Me(ge, wt, bt);
        }
      }, yr);
    }
    function Nt(ge, be, Ne, ct, St, Dt, wt) {
      var bt = he(ge, Ne), kt = he(be, Ne), Ht = wt.get(kt);
      if (Ht) {
        Me(ge, Ne, Ht);
        return;
      }
      var qt = Dt ? Dt(bt, kt, Ne + "", ge, be, wt) : void 0, Br = qt === void 0;
      if (Br) {
        var yn = me(kt), Cn = !yn && ze(kt), Yf = !yn && !Cn && pr(kt);
        qt = kt, yn || Cn || Yf ? me(bt) ? qt = bt : Fe(bt) ? qt = Gt(bt) : Cn ? (Br = !1, qt = Vt(kt)) : Yf ? (Br = !1, qt = Yt(kt)) : qt = [] : ir(kt) || J(kt) ? (qt = bt, J(bt) ? qt = hr(bt) : (!Et(bt) || Qe(bt)) && (qt = Ar(kt))) : Br = !1;
      }
      Br && (wt.set(kt, qt), St(qt, kt, ct, Dt, wt), wt.delete(kt)), Me(ge, Ne, qt);
    }
    function $t(ge, be) {
      return De(ie(ge, be, Qf), ge + "");
    }
    var nr = ae ? function(ge, be) {
      return ae(ge, "toString", {
        configurable: !0,
        enumerable: !1,
        value: gr(be),
        writable: !0
      });
    } : Qf;
    function Vt(ge, be) {
      return ge.slice();
    }
    function Pt(ge) {
      var be = new ge.constructor(ge.byteLength);
      return new Ye(be).set(new Ye(ge)), be;
    }
    function Yt(ge, be) {
      var Ne = Pt(ge.buffer);
      return new ge.constructor(Ne, ge.byteOffset, ge.length);
    }
    function Gt(ge, be) {
      var Ne = -1, ct = ge.length;
      for (be || (be = Array(ct)); ++Ne < ct; )
        be[Ne] = ge[Ne];
      return be;
    }
    function lr(ge, be, Ne, ct) {
      var St = !Ne;
      Ne || (Ne = {});
      for (var Dt = -1, wt = be.length; ++Dt < wt; ) {
        var bt = be[Dt], kt = void 0;
        kt === void 0 && (kt = ge[bt]), St ? Tt(Ne, bt, kt) : it(Ne, bt, kt);
      }
      return Ne;
    }
    function Zt(ge) {
      return $t(function(be, Ne) {
        var ct = -1, St = Ne.length, Dt = St > 1 ? Ne[St - 1] : void 0, wt = St > 2 ? Ne[2] : void 0;
        for (Dt = ge.length > 3 && typeof Dt == "function" ? (St--, Dt) : void 0, wt && fr(Ne[0], Ne[1], wt) && (Dt = St < 3 ? void 0 : Dt, St = 1), be = Object(be); ++ct < St; ) {
          var bt = Ne[ct];
          bt && ge(be, bt, ct, Dt);
        }
        return be;
      });
    }
    function zt(ge) {
      return function(be, Ne, ct) {
        for (var St = -1, Dt = Object(be), wt = ct(be), bt = wt.length; bt--; ) {
          var kt = wt[++St];
          if (Ne(Dt[kt], kt, Dt) === !1)
            break;
        }
        return be;
      };
    }
    function ur(ge, be) {
      var Ne = ge.__data__;
      return yt(be) ? Ne[typeof be == "string" ? "string" : "hash"] : Ne.map;
    }
    function er(ge, be) {
      var Ne = at(ge, be);
      return Lt(Ne) ? Ne : void 0;
    }
    function sr(ge) {
      var be = nt.call(ge, ne), Ne = ge[ne];
      try {
        ge[ne] = void 0;
        var ct = !0;
      } catch {
      }
      var St = ot.call(ge);
      return ct && (be ? ge[ne] = Ne : delete ge[ne]), St;
    }
    function Ar(ge) {
      return typeof ge.constructor == "function" && !Er(ge) ? z(Ue(ge)) : {};
    }
    function cr(ge, be) {
      var Ne = typeof ge;
      return be = be ?? e, !!be && (Ne == "number" || Ne != "symbol" && Q.test(ge)) && ge > -1 && ge % 1 == 0 && ge < be;
    }
    function fr(ge, be, Ne) {
      if (!Et(Ne))
        return !1;
      var ct = typeof be;
      return (ct == "number" ? Le(Ne) && cr(be, Ne.length) : ct == "string" && be in Ne) ? K(Ne[be], ge) : !1;
    }
    function yt(ge) {
      var be = typeof ge;
      return be == "string" || be == "number" || be == "symbol" || be == "boolean" ? ge !== "__proto__" : ge === null;
    }
    function kr(ge) {
      return !!rt && rt in ge;
    }
    function Er(ge) {
      var be = ge && ge.constructor, Ne = typeof be == "function" && be.prototype || Te;
      return ge === Ne;
    }
    function Oe(ge) {
      var be = [];
      if (ge != null)
        for (var Ne in Object(ge))
          be.push(Ne);
      return be;
    }
    function V(ge) {
      return ot.call(ge);
    }
    function ie(ge, be, Ne) {
      return be = de(be === void 0 ? ge.length - 1 : be, 0), function() {
        for (var ct = arguments, St = -1, Dt = de(ct.length - be, 0), wt = Array(Dt); ++St < Dt; )
          wt[St] = ct[be + St];
        St = -1;
        for (var bt = Array(be + 1); ++St < be; )
          bt[St] = ct[St];
        return bt[be] = Ne(wt), ke(ge, this, bt);
      };
    }
    function he(ge, be) {
      if (!(be === "constructor" && typeof ge[be] == "function") && be != "__proto__")
        return ge[be];
    }
    var De = E(nr);
    function E(ge) {
      var be = 0, Ne = 0;
      return function() {
        var ct = ee(), St = u - (ct - Ne);
        if (Ne = ct, St > 0) {
          if (++be >= r)
            return arguments[0];
        } else
          be = 0;
        return ge.apply(void 0, arguments);
      };
    }
    function D(ge) {
      if (ge != null) {
        try {
          return et.call(ge);
        } catch {
        }
        try {
          return ge + "";
        } catch {
        }
      }
      return "";
    }
    function K(ge, be) {
      return ge === be || ge !== ge && be !== be;
    }
    var J = tt(/* @__PURE__ */ function() {
      return arguments;
    }()) ? tt : function(ge) {
      return _t(ge) && nt.call(ge, "callee") && !xe.call(ge, "callee");
    }, me = Array.isArray;
    function Le(ge) {
      return ge != null && pt(ge.length) && !Qe(ge);
    }
    function Fe(ge) {
      return _t(ge) && Le(ge);
    }
    var ze = fe || Vv;
    function Qe(ge) {
      if (!Et(ge))
        return !1;
      var be = xt(ge);
      return be == s || be == c || be == p || be == T;
    }
    function pt(ge) {
      return typeof ge == "number" && ge > -1 && ge % 1 == 0 && ge <= e;
    }
    function Et(ge) {
      var be = typeof ge;
      return ge != null && (be == "object" || be == "function");
    }
    function _t(ge) {
      return ge != null && typeof ge == "object";
    }
    function ir(ge) {
      if (!_t(ge) || xt(ge) != v)
        return !1;
      var be = Ue(ge);
      if (be === null)
        return !0;
      var Ne = nt.call(be, "constructor") && be.constructor;
      return typeof Ne == "function" && Ne instanceof Ne && et.call(Ne) == Ct;
    }
    var pr = Ee ? Je(Ee) : Bt;
    function hr(ge) {
      return lr(ge, yr(ge));
    }
    function yr(ge) {
      return Le(ge) ? Xe(ge) : Ut(ge);
    }
    var mr = Zt(function(ge, be, Ne) {
      Kt(ge, be, Ne);
    });
    function gr(ge) {
      return function() {
        return ge;
      };
    }
    function Qf(ge) {
      return ge;
    }
    function Vv() {
      return !1;
    }
    i.exports = mr;
  }(Vr, Vr.exports)), Vr.exports;
}
var DS = "8.57.0", LS = {
  version: DS
}, Ln, yp;
function mn() {
  if (yp) return Ln;
  yp = 1;
  const i = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u, t = /\r\n|[\r\n\u2028\u2029]/u, o = /^#!([^\r\n]+)/u;
  function f() {
    return new RegExp(t.source, "gu");
  }
  return Ln = {
    breakableTypePattern: i,
    lineBreakPattern: t,
    createGlobalLinebreakMatcher: f,
    shebangPattern: o
  }, Ln;
}
var _n, Cp;
function gn() {
  return Cp || (Cp = 1, _n = {
    directivesPattern: /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u
  }), _n;
}
var Hr = {}, Jr = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
var vp;
function _S() {
  return vp || (vp = 1, function(i, t) {
    (function(o, f) {
      f(t);
    })(this, function(o) {
      function f() {
        for (var oe = arguments.length, se = Array(oe), pe = 0; pe < oe; pe++)
          se[pe] = arguments[pe];
        if (se.length > 1) {
          se[0] = se[0].slice(0, -1);
          for (var ve = se.length - 1, Se = 1; Se < ve; ++Se)
            se[Se] = se[Se].slice(1, -1);
          return se[ve] = se[ve].slice(1), se.join("");
        } else
          return se[0];
      }
      function r(oe) {
        return "(?:" + oe + ")";
      }
      function u(oe) {
        return oe === void 0 ? "undefined" : oe === null ? "null" : Object.prototype.toString.call(oe).split(" ").pop().split("]").shift().toLowerCase();
      }
      function e(oe) {
        return oe.toUpperCase();
      }
      function a(oe) {
        return oe != null ? oe instanceof Array ? oe : typeof oe.length != "number" || oe.split || oe.setInterval || oe.call ? [oe] : Array.prototype.slice.call(oe) : [];
      }
      function n(oe, se) {
        var pe = oe;
        if (se)
          for (var ve in se)
            pe[ve] = se[ve];
        return pe;
      }
      function p(oe) {
        var se = "[A-Za-z]", pe = "[0-9]", ve = f(pe, "[A-Fa-f]"), Se = r(r("%[EFef]" + ve + "%" + ve + ve + "%" + ve + ve) + "|" + r("%[89A-Fa-f]" + ve + "%" + ve + ve) + "|" + r("%" + ve + ve)), Ge = "[\\:\\/\\?\\#\\[\\]\\@]", Ze = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", ft = f(Ge, Ze), gt = oe ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", At = oe ? "[\\uE000-\\uF8FF]" : "[]", ht = f(se, pe, "[\\-\\.\\_\\~]", gt);
        r(se + f(se, pe, "[\\+\\-\\.]") + "*"), r(r(Se + "|" + f(ht, Ze, "[\\:]")) + "*");
        var qe = r(r("25[0-5]") + "|" + r("2[0-4]" + pe) + "|" + r("1" + pe + pe) + "|" + r("0?[1-9]" + pe) + "|0?0?" + pe), He = r(qe + "\\." + qe + "\\." + qe + "\\." + qe), Xe = r(ve + "{1,4}"), Me = r(r(Xe + "\\:" + Xe) + "|" + He), it = r(r(Xe + "\\:") + "{6}" + Me), ut = r("\\:\\:" + r(Xe + "\\:") + "{5}" + Me), Tt = r(r(Xe) + "?\\:\\:" + r(Xe + "\\:") + "{4}" + Me), Rt = r(r(r(Xe + "\\:") + "{0,1}" + Xe) + "?\\:\\:" + r(Xe + "\\:") + "{3}" + Me), xt = r(r(r(Xe + "\\:") + "{0,2}" + Xe) + "?\\:\\:" + r(Xe + "\\:") + "{2}" + Me), tt = r(r(r(Xe + "\\:") + "{0,3}" + Xe) + "?\\:\\:" + Xe + "\\:" + Me), Lt = r(r(r(Xe + "\\:") + "{0,4}" + Xe) + "?\\:\\:" + Me), Bt = r(r(r(Xe + "\\:") + "{0,5}" + Xe) + "?\\:\\:" + Xe), Ut = r(r(r(Xe + "\\:") + "{0,6}" + Xe) + "?\\:\\:"), Kt = r([it, ut, Tt, Rt, xt, tt, Lt, Bt, Ut].join("|")), Nt = r(r(ht + "|" + Se) + "+");
        r("[vV]" + ve + "+\\." + f(ht, Ze, "[\\:]") + "+"), r(r(Se + "|" + f(ht, Ze)) + "*");
        var $t = r(Se + "|" + f(ht, Ze, "[\\:\\@]"));
        return r(r(Se + "|" + f(ht, Ze, "[\\@]")) + "+"), r(r($t + "|" + f("[\\/\\?]", At)) + "*"), {
          NOT_SCHEME: new RegExp(f("[^]", se, pe, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(f("[^\\%\\:]", ht, Ze), "g"),
          NOT_HOST: new RegExp(f("[^\\%\\[\\]\\:]", ht, Ze), "g"),
          NOT_PATH: new RegExp(f("[^\\%\\/\\:\\@]", ht, Ze), "g"),
          NOT_PATH_NOSCHEME: new RegExp(f("[^\\%\\/\\@]", ht, Ze), "g"),
          NOT_QUERY: new RegExp(f("[^\\%]", ht, Ze, "[\\:\\@\\/\\?]", At), "g"),
          NOT_FRAGMENT: new RegExp(f("[^\\%]", ht, Ze, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(f("[^]", ht, Ze), "g"),
          UNRESERVED: new RegExp(ht, "g"),
          OTHER_CHARS: new RegExp(f("[^\\%]", ht, ft), "g"),
          PCT_ENCODED: new RegExp(Se, "g"),
          IPV4ADDRESS: new RegExp("^(" + He + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + Kt + ")" + r(r("\\%25|\\%(?!" + ve + "{2})") + "(" + Nt + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var m = p(!1), h = p(!0), l = /* @__PURE__ */ function() {
        function oe(se, pe) {
          var ve = [], Se = !0, Ge = !1, Ze = void 0;
          try {
            for (var ft = se[Symbol.iterator](), gt; !(Se = (gt = ft.next()).done) && (ve.push(gt.value), !(pe && ve.length === pe)); Se = !0)
              ;
          } catch (At) {
            Ge = !0, Ze = At;
          } finally {
            try {
              !Se && ft.return && ft.return();
            } finally {
              if (Ge) throw Ze;
            }
          }
          return ve;
        }
        return function(se, pe) {
          if (Array.isArray(se))
            return se;
          if (Symbol.iterator in Object(se))
            return oe(se, pe);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }(), s = function(oe) {
        if (Array.isArray(oe)) {
          for (var se = 0, pe = Array(oe.length); se < oe.length; se++) pe[se] = oe[se];
          return pe;
        } else
          return Array.from(oe);
      }, c = 2147483647, g = 36, d = 1, y = 26, v = 38, T = 700, b = 72, S = 128, C = "-", x = /^xn--/, A = /[^\0-\x7E]/, R = /[\x2E\u3002\uFF0E\uFF61]/g, L = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, _ = g - d, I = Math.floor, O = String.fromCharCode;
      function k(oe) {
        throw new RangeError(L[oe]);
      }
      function w(oe, se) {
        for (var pe = [], ve = oe.length; ve--; )
          pe[ve] = se(oe[ve]);
        return pe;
      }
      function U(oe, se) {
        var pe = oe.split("@"), ve = "";
        pe.length > 1 && (ve = pe[0] + "@", oe = pe[1]), oe = oe.replace(R, ".");
        var Se = oe.split("."), Ge = w(Se, se).join(".");
        return ve + Ge;
      }
      function q(oe) {
        for (var se = [], pe = 0, ve = oe.length; pe < ve; ) {
          var Se = oe.charCodeAt(pe++);
          if (Se >= 55296 && Se <= 56319 && pe < ve) {
            var Ge = oe.charCodeAt(pe++);
            (Ge & 64512) == 56320 ? se.push(((Se & 1023) << 10) + (Ge & 1023) + 65536) : (se.push(Se), pe--);
          } else
            se.push(Se);
        }
        return se;
      }
      var F = function(se) {
        return String.fromCodePoint.apply(String, s(se));
      }, $ = function(se) {
        return se - 48 < 10 ? se - 22 : se - 65 < 26 ? se - 65 : se - 97 < 26 ? se - 97 : g;
      }, P = function(se, pe) {
        return se + 22 + 75 * (se < 26) - ((pe != 0) << 5);
      }, X = function(se, pe, ve) {
        var Se = 0;
        for (
          se = ve ? I(se / T) : se >> 1, se += I(se / pe);
          /* no initialization */
          se > _ * y >> 1;
          Se += g
        )
          se = I(se / _);
        return I(Se + (_ + 1) * se / (se + v));
      }, Q = function(se) {
        var pe = [], ve = se.length, Se = 0, Ge = S, Ze = b, ft = se.lastIndexOf(C);
        ft < 0 && (ft = 0);
        for (var gt = 0; gt < ft; ++gt)
          se.charCodeAt(gt) >= 128 && k("not-basic"), pe.push(se.charCodeAt(gt));
        for (var At = ft > 0 ? ft + 1 : 0; At < ve; ) {
          for (
            var ht = Se, qe = 1, He = g;
            ;
            /* no condition */
            He += g
          ) {
            At >= ve && k("invalid-input");
            var Xe = $(se.charCodeAt(At++));
            (Xe >= g || Xe > I((c - Se) / qe)) && k("overflow"), Se += Xe * qe;
            var Me = He <= Ze ? d : He >= Ze + y ? y : He - Ze;
            if (Xe < Me)
              break;
            var it = g - Me;
            qe > I(c / it) && k("overflow"), qe *= it;
          }
          var ut = pe.length + 1;
          Ze = X(Se - ht, ut, ht == 0), I(Se / ut) > c - Ge && k("overflow"), Ge += I(Se / ut), Se %= ut, pe.splice(Se++, 0, Ge);
        }
        return String.fromCodePoint.apply(String, pe);
      }, ue = function(se) {
        var pe = [];
        se = q(se);
        var ve = se.length, Se = S, Ge = 0, Ze = b, ft = !0, gt = !1, At = void 0;
        try {
          for (var ht = se[Symbol.iterator](), qe; !(ft = (qe = ht.next()).done); ft = !0) {
            var He = qe.value;
            He < 128 && pe.push(O(He));
          }
        } catch (zt) {
          gt = !0, At = zt;
        } finally {
          try {
            !ft && ht.return && ht.return();
          } finally {
            if (gt)
              throw At;
          }
        }
        var Xe = pe.length, Me = Xe;
        for (Xe && pe.push(C); Me < ve; ) {
          var it = c, ut = !0, Tt = !1, Rt = void 0;
          try {
            for (var xt = se[Symbol.iterator](), tt; !(ut = (tt = xt.next()).done); ut = !0) {
              var Lt = tt.value;
              Lt >= Se && Lt < it && (it = Lt);
            }
          } catch (zt) {
            Tt = !0, Rt = zt;
          } finally {
            try {
              !ut && xt.return && xt.return();
            } finally {
              if (Tt)
                throw Rt;
            }
          }
          var Bt = Me + 1;
          it - Se > I((c - Ge) / Bt) && k("overflow"), Ge += (it - Se) * Bt, Se = it;
          var Ut = !0, Kt = !1, Nt = void 0;
          try {
            for (var $t = se[Symbol.iterator](), nr; !(Ut = (nr = $t.next()).done); Ut = !0) {
              var Vt = nr.value;
              if (Vt < Se && ++Ge > c && k("overflow"), Vt == Se) {
                for (
                  var Pt = Ge, Yt = g;
                  ;
                  /* no condition */
                  Yt += g
                ) {
                  var Gt = Yt <= Ze ? d : Yt >= Ze + y ? y : Yt - Ze;
                  if (Pt < Gt)
                    break;
                  var lr = Pt - Gt, Zt = g - Gt;
                  pe.push(O(P(Gt + lr % Zt, 0))), Pt = I(lr / Zt);
                }
                pe.push(O(P(Pt, 0))), Ze = X(Ge, Bt, Me == Xe), Ge = 0, ++Me;
              }
            }
          } catch (zt) {
            Kt = !0, Nt = zt;
          } finally {
            try {
              !Ut && $t.return && $t.return();
            } finally {
              if (Kt)
                throw Nt;
            }
          }
          ++Ge, ++Se;
        }
        return pe.join("");
      }, le = function(se) {
        return U(se, function(pe) {
          return x.test(pe) ? Q(pe.slice(4).toLowerCase()) : pe;
        });
      }, Ce = function(se) {
        return U(se, function(pe) {
          return A.test(pe) ? "xn--" + ue(pe) : pe;
        });
      }, j = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: q,
          encode: F
        },
        decode: Q,
        encode: ue,
        toASCII: Ce,
        toUnicode: le
      }, H = {};
      function N(oe) {
        var se = oe.charCodeAt(0), pe = void 0;
        return se < 16 ? pe = "%0" + se.toString(16).toUpperCase() : se < 128 ? pe = "%" + se.toString(16).toUpperCase() : se < 2048 ? pe = "%" + (se >> 6 | 192).toString(16).toUpperCase() + "%" + (se & 63 | 128).toString(16).toUpperCase() : pe = "%" + (se >> 12 | 224).toString(16).toUpperCase() + "%" + (se >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (se & 63 | 128).toString(16).toUpperCase(), pe;
      }
      function G(oe) {
        for (var se = "", pe = 0, ve = oe.length; pe < ve; ) {
          var Se = parseInt(oe.substr(pe + 1, 2), 16);
          if (Se < 128)
            se += String.fromCharCode(Se), pe += 3;
          else if (Se >= 194 && Se < 224) {
            if (ve - pe >= 6) {
              var Ge = parseInt(oe.substr(pe + 4, 2), 16);
              se += String.fromCharCode((Se & 31) << 6 | Ge & 63);
            } else
              se += oe.substr(pe, 6);
            pe += 6;
          } else if (Se >= 224) {
            if (ve - pe >= 9) {
              var Ze = parseInt(oe.substr(pe + 4, 2), 16), ft = parseInt(oe.substr(pe + 7, 2), 16);
              se += String.fromCharCode((Se & 15) << 12 | (Ze & 63) << 6 | ft & 63);
            } else
              se += oe.substr(pe, 9);
            pe += 9;
          } else
            se += oe.substr(pe, 3), pe += 3;
        }
        return se;
      }
      function M(oe, se) {
        function pe(ve) {
          var Se = G(ve);
          return Se.match(se.UNRESERVED) ? Se : ve;
        }
        return oe.scheme && (oe.scheme = String(oe.scheme).replace(se.PCT_ENCODED, pe).toLowerCase().replace(se.NOT_SCHEME, "")), oe.userinfo !== void 0 && (oe.userinfo = String(oe.userinfo).replace(se.PCT_ENCODED, pe).replace(se.NOT_USERINFO, N).replace(se.PCT_ENCODED, e)), oe.host !== void 0 && (oe.host = String(oe.host).replace(se.PCT_ENCODED, pe).toLowerCase().replace(se.NOT_HOST, N).replace(se.PCT_ENCODED, e)), oe.path !== void 0 && (oe.path = String(oe.path).replace(se.PCT_ENCODED, pe).replace(oe.scheme ? se.NOT_PATH : se.NOT_PATH_NOSCHEME, N).replace(se.PCT_ENCODED, e)), oe.query !== void 0 && (oe.query = String(oe.query).replace(se.PCT_ENCODED, pe).replace(se.NOT_QUERY, N).replace(se.PCT_ENCODED, e)), oe.fragment !== void 0 && (oe.fragment = String(oe.fragment).replace(se.PCT_ENCODED, pe).replace(se.NOT_FRAGMENT, N).replace(se.PCT_ENCODED, e)), oe;
      }
      function Z(oe) {
        return oe.replace(/^0*(.*)/, "$1") || "0";
      }
      function Ee(oe, se) {
        var pe = oe.match(se.IPV4ADDRESS) || [], ve = l(pe, 2), Se = ve[1];
        return Se ? Se.split(".").map(Z).join(".") : oe;
      }
      function ke(oe, se) {
        var pe = oe.match(se.IPV6ADDRESS) || [], ve = l(pe, 3), Se = ve[1], Ge = ve[2];
        if (Se) {
          for (var Ze = Se.toLowerCase().split("::").reverse(), ft = l(Ze, 2), gt = ft[0], At = ft[1], ht = At ? At.split(":").map(Z) : [], qe = gt.split(":").map(Z), He = se.IPV4ADDRESS.test(qe[qe.length - 1]), Xe = He ? 7 : 8, Me = qe.length - Xe, it = Array(Xe), ut = 0; ut < Xe; ++ut)
            it[ut] = ht[ut] || qe[Me + ut] || "";
          He && (it[Xe - 1] = Ee(it[Xe - 1], se));
          var Tt = it.reduce(function(Bt, Ut, Kt) {
            if (!Ut || Ut === "0") {
              var Nt = Bt[Bt.length - 1];
              Nt && Nt.index + Nt.length === Kt ? Nt.length++ : Bt.push({ index: Kt, length: 1 });
            }
            return Bt;
          }, []), Rt = Tt.sort(function(Bt, Ut) {
            return Ut.length - Bt.length;
          })[0], xt = void 0;
          if (Rt && Rt.length > 1) {
            var tt = it.slice(0, Rt.index), Lt = it.slice(Rt.index + Rt.length);
            xt = tt.join(":") + "::" + Lt.join(":");
          } else
            xt = it.join(":");
          return Ge && (xt += "%" + Ge), xt;
        } else
          return oe;
      }
      var Ie = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Je = "".match(/(){0}/)[1] === void 0;
      function at(oe) {
        var se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, pe = {}, ve = se.iri !== !1 ? h : m;
        se.reference === "suffix" && (oe = (se.scheme ? se.scheme + ":" : "") + "//" + oe);
        var Se = oe.match(Ie);
        if (Se) {
          Je ? (pe.scheme = Se[1], pe.userinfo = Se[3], pe.host = Se[4], pe.port = parseInt(Se[5], 10), pe.path = Se[6] || "", pe.query = Se[7], pe.fragment = Se[8], isNaN(pe.port) && (pe.port = Se[5])) : (pe.scheme = Se[1] || void 0, pe.userinfo = oe.indexOf("@") !== -1 ? Se[3] : void 0, pe.host = oe.indexOf("//") !== -1 ? Se[4] : void 0, pe.port = parseInt(Se[5], 10), pe.path = Se[6] || "", pe.query = oe.indexOf("?") !== -1 ? Se[7] : void 0, pe.fragment = oe.indexOf("#") !== -1 ? Se[8] : void 0, isNaN(pe.port) && (pe.port = oe.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? Se[4] : void 0)), pe.host && (pe.host = ke(Ee(pe.host, ve), ve)), pe.scheme === void 0 && pe.userinfo === void 0 && pe.host === void 0 && pe.port === void 0 && !pe.path && pe.query === void 0 ? pe.reference = "same-document" : pe.scheme === void 0 ? pe.reference = "relative" : pe.fragment === void 0 ? pe.reference = "absolute" : pe.reference = "uri", se.reference && se.reference !== "suffix" && se.reference !== pe.reference && (pe.error = pe.error || "URI is not a " + se.reference + " reference.");
          var Ge = H[(se.scheme || pe.scheme || "").toLowerCase()];
          if (!se.unicodeSupport && (!Ge || !Ge.unicodeSupport)) {
            if (pe.host && (se.domainHost || Ge && Ge.domainHost))
              try {
                pe.host = j.toASCII(pe.host.replace(ve.PCT_ENCODED, G).toLowerCase());
              } catch (Ze) {
                pe.error = pe.error || "Host's domain name can not be converted to ASCII via punycode: " + Ze;
              }
            M(pe, m);
          } else
            M(pe, ve);
          Ge && Ge.parse && Ge.parse(pe, se);
        } else
          pe.error = pe.error || "URI can not be parsed.";
        return pe;
      }
      function lt(oe, se) {
        var pe = se.iri !== !1 ? h : m, ve = [];
        return oe.userinfo !== void 0 && (ve.push(oe.userinfo), ve.push("@")), oe.host !== void 0 && ve.push(ke(Ee(String(oe.host), pe), pe).replace(pe.IPV6ADDRESS, function(Se, Ge, Ze) {
          return "[" + Ge + (Ze ? "%25" + Ze : "") + "]";
        })), (typeof oe.port == "number" || typeof oe.port == "string") && (ve.push(":"), ve.push(String(oe.port))), ve.length ? ve.join("") : void 0;
      }
      var mt = /^\.\.?\//, Y = /^\/\.(\/|$)/, Te = /^\/\.\.(\/|$)/, Ke = /^\/?(?:.|\n)*?(?=\/|$)/;
      function et(oe) {
        for (var se = []; oe.length; )
          if (oe.match(mt))
            oe = oe.replace(mt, "");
          else if (oe.match(Y))
            oe = oe.replace(Y, "/");
          else if (oe.match(Te))
            oe = oe.replace(Te, "/"), se.pop();
          else if (oe === "." || oe === "..")
            oe = "";
          else {
            var pe = oe.match(Ke);
            if (pe) {
              var ve = pe[0];
              oe = oe.slice(ve.length), se.push(ve);
            } else
              throw new Error("Unexpected dot segment condition");
          }
        return se.join("");
      }
      function nt(oe) {
        var se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, pe = se.iri ? h : m, ve = [], Se = H[(se.scheme || oe.scheme || "").toLowerCase()];
        if (Se && Se.serialize && Se.serialize(oe, se), oe.host && !pe.IPV6ADDRESS.test(oe.host)) {
          if (se.domainHost || Se && Se.domainHost)
            try {
              oe.host = se.iri ? j.toUnicode(oe.host) : j.toASCII(oe.host.replace(pe.PCT_ENCODED, G).toLowerCase());
            } catch (ft) {
              oe.error = oe.error || "Host's domain name can not be converted to " + (se.iri ? "Unicode" : "ASCII") + " via punycode: " + ft;
            }
        }
        M(oe, pe), se.reference !== "suffix" && oe.scheme && (ve.push(oe.scheme), ve.push(":"));
        var Ge = lt(oe, se);
        if (Ge !== void 0 && (se.reference !== "suffix" && ve.push("//"), ve.push(Ge), oe.path && oe.path.charAt(0) !== "/" && ve.push("/")), oe.path !== void 0) {
          var Ze = oe.path;
          !se.absolutePath && (!Se || !Se.absolutePath) && (Ze = et(Ze)), Ge === void 0 && (Ze = Ze.replace(/^\/\//, "/%2F")), ve.push(Ze);
        }
        return oe.query !== void 0 && (ve.push("?"), ve.push(oe.query)), oe.fragment !== void 0 && (ve.push("#"), ve.push(oe.fragment)), ve.join("");
      }
      function rt(oe, se) {
        var pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ve = arguments[3], Se = {};
        return ve || (oe = at(nt(oe, pe), pe), se = at(nt(se, pe), pe)), pe = pe || {}, !pe.tolerant && se.scheme ? (Se.scheme = se.scheme, Se.userinfo = se.userinfo, Se.host = se.host, Se.port = se.port, Se.path = et(se.path || ""), Se.query = se.query) : (se.userinfo !== void 0 || se.host !== void 0 || se.port !== void 0 ? (Se.userinfo = se.userinfo, Se.host = se.host, Se.port = se.port, Se.path = et(se.path || ""), Se.query = se.query) : (se.path ? (se.path.charAt(0) === "/" ? Se.path = et(se.path) : ((oe.userinfo !== void 0 || oe.host !== void 0 || oe.port !== void 0) && !oe.path ? Se.path = "/" + se.path : oe.path ? Se.path = oe.path.slice(0, oe.path.lastIndexOf("/") + 1) + se.path : Se.path = se.path, Se.path = et(Se.path)), Se.query = se.query) : (Se.path = oe.path, se.query !== void 0 ? Se.query = se.query : Se.query = oe.query), Se.userinfo = oe.userinfo, Se.host = oe.host, Se.port = oe.port), Se.scheme = oe.scheme), Se.fragment = se.fragment, Se;
      }
      function ot(oe, se, pe) {
        var ve = n({ scheme: "null" }, pe);
        return nt(rt(at(oe, ve), at(se, ve), ve, !0), ve);
      }
      function Ct(oe, se) {
        return typeof oe == "string" ? oe = nt(at(oe, se), se) : u(oe) === "object" && (oe = at(nt(oe, se), se)), oe;
      }
      function dt(oe, se, pe) {
        return typeof oe == "string" ? oe = nt(at(oe, pe), pe) : u(oe) === "object" && (oe = nt(oe, pe)), typeof se == "string" ? se = nt(at(se, pe), pe) : u(se) === "object" && (se = nt(se, pe)), oe === se;
      }
      function vt(oe, se) {
        return oe && oe.toString().replace(!se || !se.iri ? m.ESCAPE : h.ESCAPE, N);
      }
      function W(oe, se) {
        return oe && oe.toString().replace(!se || !se.iri ? m.PCT_ENCODED : h.PCT_ENCODED, G);
      }
      var Ye = {
        scheme: "http",
        domainHost: !0,
        parse: function(se, pe) {
          return se.host || (se.error = se.error || "HTTP URIs must have a host."), se;
        },
        serialize: function(se, pe) {
          var ve = String(se.scheme).toLowerCase() === "https";
          return (se.port === (ve ? 443 : 80) || se.port === "") && (se.port = void 0), se.path || (se.path = "/"), se;
        }
      }, Ue = {
        scheme: "https",
        domainHost: Ye.domainHost,
        parse: Ye.parse,
        serialize: Ye.serialize
      };
      function Ve(oe) {
        return typeof oe.secure == "boolean" ? oe.secure : String(oe.scheme).toLowerCase() === "wss";
      }
      var xe = {
        scheme: "ws",
        domainHost: !0,
        parse: function(se, pe) {
          var ve = se;
          return ve.secure = Ve(ve), ve.resourceName = (ve.path || "/") + (ve.query ? "?" + ve.query : ""), ve.path = void 0, ve.query = void 0, ve;
        },
        serialize: function(se, pe) {
          if ((se.port === (Ve(se) ? 443 : 80) || se.port === "") && (se.port = void 0), typeof se.secure == "boolean" && (se.scheme = se.secure ? "wss" : "ws", se.secure = void 0), se.resourceName) {
            var ve = se.resourceName.split("?"), Se = l(ve, 2), Ge = Se[0], Ze = Se[1];
            se.path = Ge && Ge !== "/" ? Ge : void 0, se.query = Ze, se.resourceName = void 0;
          }
          return se.fragment = void 0, se;
        }
      }, re = {
        scheme: "wss",
        domainHost: xe.domainHost,
        parse: xe.parse,
        serialize: xe.serialize
      }, ne = {}, ae = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", fe = "[0-9A-Fa-f]", de = r(r("%[EFef]" + fe + "%" + fe + fe + "%" + fe + fe) + "|" + r("%[89A-Fa-f]" + fe + "%" + fe + fe) + "|" + r("%" + fe + fe)), ee = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", te = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", B = f(te, '[\\"\\\\]'), z = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", ce = new RegExp(ae, "g"), ye = new RegExp(de, "g"), Be = new RegExp(f("[^]", ee, "[\\.]", '[\\"]', B), "g"), we = new RegExp(f("[^]", ae, z), "g"), Pe = we;
      function st(oe) {
        var se = G(oe);
        return se.match(ce) ? se : oe;
      }
      var We = {
        scheme: "mailto",
        parse: function(se, pe) {
          var ve = se, Se = ve.to = ve.path ? ve.path.split(",") : [];
          if (ve.path = void 0, ve.query) {
            for (var Ge = !1, Ze = {}, ft = ve.query.split("&"), gt = 0, At = ft.length; gt < At; ++gt) {
              var ht = ft[gt].split("=");
              switch (ht[0]) {
                case "to":
                  for (var qe = ht[1].split(","), He = 0, Xe = qe.length; He < Xe; ++He)
                    Se.push(qe[He]);
                  break;
                case "subject":
                  ve.subject = W(ht[1], pe);
                  break;
                case "body":
                  ve.body = W(ht[1], pe);
                  break;
                default:
                  Ge = !0, Ze[W(ht[0], pe)] = W(ht[1], pe);
                  break;
              }
            }
            Ge && (ve.headers = Ze);
          }
          ve.query = void 0;
          for (var Me = 0, it = Se.length; Me < it; ++Me) {
            var ut = Se[Me].split("@");
            if (ut[0] = W(ut[0]), pe.unicodeSupport)
              ut[1] = W(ut[1], pe).toLowerCase();
            else
              try {
                ut[1] = j.toASCII(W(ut[1], pe).toLowerCase());
              } catch (Tt) {
                ve.error = ve.error || "Email address's domain name can not be converted to ASCII via punycode: " + Tt;
              }
            Se[Me] = ut.join("@");
          }
          return ve;
        },
        serialize: function(se, pe) {
          var ve = se, Se = a(se.to);
          if (Se) {
            for (var Ge = 0, Ze = Se.length; Ge < Ze; ++Ge) {
              var ft = String(Se[Ge]), gt = ft.lastIndexOf("@"), At = ft.slice(0, gt).replace(ye, st).replace(ye, e).replace(Be, N), ht = ft.slice(gt + 1);
              try {
                ht = pe.iri ? j.toUnicode(ht) : j.toASCII(W(ht, pe).toLowerCase());
              } catch (Me) {
                ve.error = ve.error || "Email address's domain name can not be converted to " + (pe.iri ? "Unicode" : "ASCII") + " via punycode: " + Me;
              }
              Se[Ge] = At + "@" + ht;
            }
            ve.path = Se.join(",");
          }
          var qe = se.headers = se.headers || {};
          se.subject && (qe.subject = se.subject), se.body && (qe.body = se.body);
          var He = [];
          for (var Xe in qe)
            qe[Xe] !== ne[Xe] && He.push(Xe.replace(ye, st).replace(ye, e).replace(we, N) + "=" + qe[Xe].replace(ye, st).replace(ye, e).replace(Pe, N));
          return He.length && (ve.query = He.join("&")), ve;
        }
      }, _e = /^([^\:]+)\:(.*)/, je = {
        scheme: "urn",
        parse: function(se, pe) {
          var ve = se.path && se.path.match(_e), Se = se;
          if (ve) {
            var Ge = pe.scheme || Se.scheme || "urn", Ze = ve[1].toLowerCase(), ft = ve[2], gt = Ge + ":" + (pe.nid || Ze), At = H[gt];
            Se.nid = Ze, Se.nss = ft, Se.path = void 0, At && (Se = At.parse(Se, pe));
          } else
            Se.error = Se.error || "URN can not be parsed.";
          return Se;
        },
        serialize: function(se, pe) {
          var ve = pe.scheme || se.scheme || "urn", Se = se.nid, Ge = ve + ":" + (pe.nid || Se), Ze = H[Ge];
          Ze && (se = Ze.serialize(se, pe));
          var ft = se, gt = se.nss;
          return ft.path = (Se || pe.nid) + ":" + gt, ft;
        }
      }, $e = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Ae = {
        scheme: "urn:uuid",
        parse: function(se, pe) {
          var ve = se;
          return ve.uuid = ve.nss, ve.nss = void 0, !pe.tolerant && (!ve.uuid || !ve.uuid.match($e)) && (ve.error = ve.error || "UUID is not valid."), ve;
        },
        serialize: function(se, pe) {
          var ve = se;
          return ve.nss = (se.uuid || "").toLowerCase(), ve;
        }
      };
      H[Ye.scheme] = Ye, H[Ue.scheme] = Ue, H[xe.scheme] = xe, H[re.scheme] = re, H[We.scheme] = We, H[je.scheme] = je, H[Ae.scheme] = Ae, o.SCHEMES = H, o.pctEncChar = N, o.pctDecChars = G, o.parse = at, o.removeDotSegments = et, o.serialize = nt, o.resolveComponents = rt, o.resolve = ot, o.normalize = Ct, o.equal = dt, o.escapeComponent = vt, o.unescapeComponent = W, Object.defineProperty(o, "__esModule", { value: !0 });
    });
  }(Jr, Jr.exports)), Jr.exports;
}
var wn, Sp;
function Vf() {
  return Sp || (Sp = 1, wn = function i(t, o) {
    if (t === o) return !0;
    if (t && o && typeof t == "object" && typeof o == "object") {
      if (t.constructor !== o.constructor) return !1;
      var f, r, u;
      if (Array.isArray(t)) {
        if (f = t.length, f != o.length) return !1;
        for (r = f; r-- !== 0; )
          if (!i(t[r], o[r])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === o.source && t.flags === o.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === o.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === o.toString();
      if (u = Object.keys(t), f = u.length, f !== Object.keys(o).length) return !1;
      for (r = f; r-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(o, u[r])) return !1;
      for (r = f; r-- !== 0; ) {
        var e = u[r];
        if (!i(t[e], o[e])) return !1;
      }
      return !0;
    }
    return t !== t && o !== o;
  }), wn;
}
var kn, Ap;
function wS() {
  return Ap || (Ap = 1, kn = function(t) {
    for (var o = 0, f = t.length, r = 0, u; r < f; )
      o++, u = t.charCodeAt(r++), u >= 55296 && u <= 56319 && r < f && (u = t.charCodeAt(r), (u & 64512) == 56320 && r++);
    return o;
  }), kn;
}
var Bn, Tp;
function wr() {
  if (Tp) return Bn;
  Tp = 1, Bn = {
    copy: i,
    checkDataType: t,
    checkDataTypes: o,
    coerceToTypes: r,
    toHash: u,
    getProperty: n,
    escapeQuotes: p,
    equal: Vf(),
    ucs2length: wS(),
    varOccurences: m,
    varReplace: h,
    schemaHasRules: l,
    schemaHasRulesExcept: s,
    schemaUnknownRules: c,
    toQuotedString: g,
    getPathExpr: d,
    getPath: y,
    getData: b,
    unescapeFragment: C,
    unescapeJsonPointer: R,
    escapeFragment: x,
    escapeJsonPointer: A
  };
  function i(L, _) {
    _ = _ || {};
    for (var I in L) _[I] = L[I];
    return _;
  }
  function t(L, _, I, O) {
    var k = O ? " !== " : " === ", w = O ? " || " : " && ", U = O ? "!" : "", q = O ? "" : "!";
    switch (L) {
      case "null":
        return _ + k + "null";
      case "array":
        return U + "Array.isArray(" + _ + ")";
      case "object":
        return "(" + U + _ + w + "typeof " + _ + k + '"object"' + w + q + "Array.isArray(" + _ + "))";
      case "integer":
        return "(typeof " + _ + k + '"number"' + w + q + "(" + _ + " % 1)" + w + _ + k + _ + (I ? w + U + "isFinite(" + _ + ")" : "") + ")";
      case "number":
        return "(typeof " + _ + k + '"' + L + '"' + (I ? w + U + "isFinite(" + _ + ")" : "") + ")";
      default:
        return "typeof " + _ + k + '"' + L + '"';
    }
  }
  function o(L, _, I) {
    switch (L.length) {
      case 1:
        return t(L[0], _, I, !0);
      default:
        var O = "", k = u(L);
        k.array && k.object && (O = k.null ? "(" : "(!" + _ + " || ", O += "typeof " + _ + ' !== "object")', delete k.null, delete k.array, delete k.object), k.number && delete k.integer;
        for (var w in k)
          O += (O ? " && " : "") + t(w, _, I, !0);
        return O;
    }
  }
  var f = u(["string", "number", "integer", "boolean", "null"]);
  function r(L, _) {
    if (Array.isArray(_)) {
      for (var I = [], O = 0; O < _.length; O++) {
        var k = _[O];
        (f[k] || L === "array" && k === "array") && (I[I.length] = k);
      }
      if (I.length) return I;
    } else {
      if (f[_])
        return [_];
      if (L === "array" && _ === "array")
        return ["array"];
    }
  }
  function u(L) {
    for (var _ = {}, I = 0; I < L.length; I++) _[L[I]] = !0;
    return _;
  }
  var e = /^[a-z$_][a-z$_0-9]*$/i, a = /'|\\/g;
  function n(L) {
    return typeof L == "number" ? "[" + L + "]" : e.test(L) ? "." + L : "['" + p(L) + "']";
  }
  function p(L) {
    return L.replace(a, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function m(L, _) {
    _ += "[^0-9]";
    var I = L.match(new RegExp(_, "g"));
    return I ? I.length : 0;
  }
  function h(L, _, I) {
    return _ += "([^0-9])", I = I.replace(/\$/g, "$$$$"), L.replace(new RegExp(_, "g"), I + "$1");
  }
  function l(L, _) {
    if (typeof L == "boolean") return !L;
    for (var I in L) if (_[I]) return !0;
  }
  function s(L, _, I) {
    if (typeof L == "boolean") return !L && I != "not";
    for (var O in L) if (O != I && _[O]) return !0;
  }
  function c(L, _) {
    if (typeof L != "boolean") {
      for (var I in L) if (!_[I]) return I;
    }
  }
  function g(L) {
    return "'" + p(L) + "'";
  }
  function d(L, _, I, O) {
    var k = I ? "'/' + " + _ + (O ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : O ? "'[' + " + _ + " + ']'" : "'[\\'' + " + _ + " + '\\']'";
    return S(L, k);
  }
  function y(L, _, I) {
    var O = g(I ? "/" + A(_) : n(_));
    return S(L, O);
  }
  var v = /^\/(?:[^~]|~0|~1)*$/, T = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function b(L, _, I) {
    var O, k, w, U;
    if (L === "") return "rootData";
    if (L[0] == "/") {
      if (!v.test(L)) throw new Error("Invalid JSON-pointer: " + L);
      k = L, w = "rootData";
    } else {
      if (U = L.match(T), !U) throw new Error("Invalid JSON-pointer: " + L);
      if (O = +U[1], k = U[2], k == "#") {
        if (O >= _) throw new Error("Cannot access property/index " + O + " levels up, current level is " + _);
        return I[_ - O];
      }
      if (O > _) throw new Error("Cannot access data " + O + " levels up, current level is " + _);
      if (w = "data" + (_ - O || ""), !k) return w;
    }
    for (var q = w, F = k.split("/"), $ = 0; $ < F.length; $++) {
      var P = F[$];
      P && (w += n(R(P)), q += " && " + w);
    }
    return q;
  }
  function S(L, _) {
    return L == '""' ? _ : (L + " + " + _).replace(/([^\\])' \+ '/g, "$1");
  }
  function C(L) {
    return R(decodeURIComponent(L));
  }
  function x(L) {
    return encodeURIComponent(A(L));
  }
  function A(L) {
    return L.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function R(L) {
    return L.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  return Bn;
}
var Pn, bp;
function uv() {
  if (bp) return Pn;
  bp = 1;
  var i = wr();
  Pn = t;
  function t(o) {
    i.copy(o, this);
  }
  return Pn;
}
var In = { exports: {} }, xp;
function kS() {
  if (xp) return In.exports;
  xp = 1;
  var i = In.exports = function(f, r, u) {
    typeof r == "function" && (u = r, r = {}), u = r.cb || u;
    var e = typeof u == "function" ? u : u.pre || function() {
    }, a = u.post || function() {
    };
    t(r, e, a, f, "", f);
  };
  i.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0
  }, i.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, i.propsKeywords = {
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, i.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(f, r, u, e, a, n, p, m, h, l) {
    if (e && typeof e == "object" && !Array.isArray(e)) {
      r(e, a, n, p, m, h, l);
      for (var s in e) {
        var c = e[s];
        if (Array.isArray(c)) {
          if (s in i.arrayKeywords)
            for (var g = 0; g < c.length; g++)
              t(f, r, u, c[g], a + "/" + s + "/" + g, n, a, s, e, g);
        } else if (s in i.propsKeywords) {
          if (c && typeof c == "object")
            for (var d in c)
              t(f, r, u, c[d], a + "/" + s + "/" + o(d), n, a, s, e, d);
        } else (s in i.keywords || f.allKeys && !(s in i.skipKeywords)) && t(f, r, u, c, a + "/" + s, n, a, s, e);
      }
      u(e, a, n, p, m, h, l);
    }
  }
  function o(f) {
    return f.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return In.exports;
}
var Fn, Rp;
function Mf() {
  if (Rp) return Fn;
  Rp = 1;
  var i = _S(), t = Vf(), o = wr(), f = uv(), r = kS();
  Fn = u, u.normalizeId = y, u.fullPath = c, u.url = v, u.ids = T, u.inlineRef = h, u.schema = e;
  function u(b, S, C) {
    var x = this._refs[C];
    if (typeof x == "string")
      if (this._refs[x]) x = this._refs[x];
      else return u.call(this, b, S, x);
    if (x = x || this._schemas[C], x instanceof f)
      return h(x.schema, this._opts.inlineRefs) ? x.schema : x.validate || this._compile(x);
    var A = e.call(this, S, C), R, L, _;
    return A && (R = A.schema, S = A.root, _ = A.baseId), R instanceof f ? L = R.validate || b.call(this, R.schema, S, void 0, _) : R !== void 0 && (L = h(R, this._opts.inlineRefs) ? R : b.call(this, R, S, void 0, _)), L;
  }
  function e(b, S) {
    var C = i.parse(S), x = g(C), A = c(this._getId(b.schema));
    if (Object.keys(b.schema).length === 0 || x !== A) {
      var R = y(x), L = this._refs[R];
      if (typeof L == "string")
        return a.call(this, b, L, C);
      if (L instanceof f)
        L.validate || this._compile(L), b = L;
      else if (L = this._schemas[R], L instanceof f) {
        if (L.validate || this._compile(L), R == y(S))
          return { schema: L, root: b, baseId: A };
        b = L;
      } else
        return;
      if (!b.schema) return;
      A = c(this._getId(b.schema));
    }
    return p.call(this, C, A, b.schema, b);
  }
  function a(b, S, C) {
    var x = e.call(this, b, S);
    if (x) {
      var A = x.schema, R = x.baseId;
      b = x.root;
      var L = this._getId(A);
      return L && (R = v(R, L)), p.call(this, C, R, A, b);
    }
  }
  var n = o.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function p(b, S, C, x) {
    if (b.fragment = b.fragment || "", b.fragment.slice(0, 1) == "/") {
      for (var A = b.fragment.split("/"), R = 1; R < A.length; R++) {
        var L = A[R];
        if (L) {
          if (L = o.unescapeFragment(L), C = C[L], C === void 0) break;
          var _;
          if (!n[L] && (_ = this._getId(C), _ && (S = v(S, _)), C.$ref)) {
            var I = v(S, C.$ref), O = e.call(this, x, I);
            O && (C = O.schema, x = O.root, S = O.baseId);
          }
        }
      }
      if (C !== void 0 && C !== x.schema)
        return { schema: C, root: x, baseId: S };
    }
  }
  var m = o.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function h(b, S) {
    if (S === !1) return !1;
    if (S === void 0 || S === !0) return l(b);
    if (S) return s(b) <= S;
  }
  function l(b) {
    var S;
    if (Array.isArray(b)) {
      for (var C = 0; C < b.length; C++)
        if (S = b[C], typeof S == "object" && !l(S)) return !1;
    } else
      for (var x in b)
        if (x == "$ref" || (S = b[x], typeof S == "object" && !l(S))) return !1;
    return !0;
  }
  function s(b) {
    var S = 0, C;
    if (Array.isArray(b)) {
      for (var x = 0; x < b.length; x++)
        if (C = b[x], typeof C == "object" && (S += s(C)), S == 1 / 0) return 1 / 0;
    } else
      for (var A in b) {
        if (A == "$ref") return 1 / 0;
        if (m[A])
          S++;
        else if (C = b[A], typeof C == "object" && (S += s(C) + 1), S == 1 / 0) return 1 / 0;
      }
    return S;
  }
  function c(b, S) {
    S !== !1 && (b = y(b));
    var C = i.parse(b);
    return g(C);
  }
  function g(b) {
    return i.serialize(b).split("#")[0] + "#";
  }
  var d = /#\/?$/;
  function y(b) {
    return b ? b.replace(d, "") : "";
  }
  function v(b, S) {
    return S = y(S), i.resolve(b, S);
  }
  function T(b) {
    var S = y(this._getId(b)), C = { "": S }, x = { "": c(S, !1) }, A = {}, R = this;
    return r(b, { allKeys: !0 }, function(L, _, I, O, k, w, U) {
      if (_ !== "") {
        var q = R._getId(L), F = C[O], $ = x[O] + "/" + k;
        if (U !== void 0 && ($ += "/" + (typeof U == "number" ? U : o.escapeFragment(U))), typeof q == "string") {
          q = F = y(F ? i.resolve(F, q) : q);
          var P = R._refs[q];
          if (typeof P == "string" && (P = R._refs[P]), P && P.schema) {
            if (!t(L, P.schema))
              throw new Error('id "' + q + '" resolves to more than one schema');
          } else if (q != y($))
            if (q[0] == "#") {
              if (A[q] && !t(L, A[q]))
                throw new Error('id "' + q + '" resolves to more than one schema');
              A[q] = L;
            } else
              R._refs[q] = $;
        }
        C[_] = F, x[_] = $;
      }
    }), A;
  }
  return Fn;
}
var Nn, Dp;
function Kf() {
  if (Dp) return Nn;
  Dp = 1;
  var i = Mf();
  Nn = {
    Validation: f(t),
    MissingRef: f(o)
  };
  function t(r) {
    this.message = "validation failed", this.errors = r, this.ajv = this.validation = !0;
  }
  o.message = function(r, u) {
    return "can't resolve reference " + u + " from id " + r;
  };
  function o(r, u, e) {
    this.message = e || o.message(r, u), this.missingRef = i.url(r, u), this.missingSchema = i.normalizeId(i.fullPath(this.missingRef));
  }
  function f(r) {
    return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;
  }
  return Nn;
}
var On, Lp;
function cv() {
  return Lp || (Lp = 1, On = function(i, t) {
    t || (t = {}), typeof t == "function" && (t = { cmp: t });
    var o = typeof t.cycles == "boolean" ? t.cycles : !1, f = t.cmp && /* @__PURE__ */ function(u) {
      return function(e) {
        return function(a, n) {
          var p = { key: a, value: e[a] }, m = { key: n, value: e[n] };
          return u(p, m);
        };
      };
    }(t.cmp), r = [];
    return function u(e) {
      if (e && e.toJSON && typeof e.toJSON == "function" && (e = e.toJSON()), e !== void 0) {
        if (typeof e == "number") return isFinite(e) ? "" + e : "null";
        if (typeof e != "object") return JSON.stringify(e);
        var a, n;
        if (Array.isArray(e)) {
          for (n = "[", a = 0; a < e.length; a++)
            a && (n += ","), n += u(e[a]) || "null";
          return n + "]";
        }
        if (e === null) return "null";
        if (r.indexOf(e) !== -1) {
          if (o) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var p = r.push(e) - 1, m = Object.keys(e).sort(f && f(e));
        for (n = "", a = 0; a < m.length; a++) {
          var h = m[a], l = u(e[h]);
          l && (n && (n += ","), n += JSON.stringify(h) + ":" + l);
        }
        return r.splice(p, 1), "{" + n + "}";
      }
    }(i);
  }), On;
}
var Un, _p;
function fv() {
  return _p || (_p = 1, Un = function(t, o, f) {
    var r = "", u = t.schema.$async === !0, e = t.util.schemaHasRulesExcept(t.schema, t.RULES.all, "$ref"), a = t.self._getId(t.schema);
    if (t.opts.strictKeywords) {
      var n = t.util.schemaUnknownRules(t.schema, t.RULES.keywords);
      if (n) {
        var p = "unknown keyword: " + n;
        if (t.opts.strictKeywords === "log") t.logger.warn(p);
        else throw new Error(p);
      }
    }
    if (t.isTop && (r += " var validate = ", u && (t.async = !0, r += "async "), r += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", a && (t.opts.sourceCode || t.opts.processCode) && (r += " " + ("/*# sourceURL=" + a + " */") + " ")), typeof t.schema == "boolean" || !(e || t.schema.$ref)) {
      var o = "false schema", m = t.level, h = t.dataLevel, l = t.schema[o], s = t.schemaPath + t.util.getProperty(o), c = t.errSchemaPath + "/" + o, S = !t.opts.allErrors, A, g = "data" + (h || ""), b = "valid" + m;
      if (t.schema === !1) {
        t.isTop ? S = !0 : r += " var " + b + " = false; ";
        var d = d || [];
        d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (A || "false schema") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(c) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: 'boolean schema is false' "), t.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + t.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
        var y = r;
        r = d.pop(), !t.compositeRule && S ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      } else
        t.isTop ? u ? r += " return data; " : r += " validate.errors = null; return true; " : r += " var " + b + " = true; ";
      return t.isTop && (r += " }; return validate; "), r;
    }
    if (t.isTop) {
      var v = t.isTop, m = t.level = 0, h = t.dataLevel = 0, g = "data";
      if (t.rootId = t.resolve.fullPath(t.self._getId(t.root.schema)), t.baseId = t.baseId || t.rootId, delete t.isTop, t.dataPathArr = [""], t.schema.default !== void 0 && t.opts.useDefaults && t.opts.strictDefaults) {
        var T = "default is ignored in the schema root";
        if (t.opts.strictDefaults === "log") t.logger.warn(T);
        else throw new Error(T);
      }
      r += " var vErrors = null; ", r += " var errors = 0;     ", r += " if (rootData === undefined) rootData = data; ";
    } else {
      var m = t.level, h = t.dataLevel, g = "data" + (h || "");
      if (a && (t.baseId = t.resolve.url(t.baseId, a)), u && !t.async) throw new Error("async schema in sync schema");
      r += " var errs_" + m + " = errors;";
    }
    var b = "valid" + m, S = !t.opts.allErrors, C = "", x = "", A, R = t.schema.type, L = Array.isArray(R);
    if (R && t.opts.nullable && t.schema.nullable === !0 && (L ? R.indexOf("null") == -1 && (R = R.concat("null")) : R != "null" && (R = [R, "null"], L = !0)), L && R.length == 1 && (R = R[0], L = !1), t.schema.$ref && e) {
      if (t.opts.extendRefs == "fail")
        throw new Error('$ref: validation keywords used in schema at path "' + t.errSchemaPath + '" (see option extendRefs)');
      t.opts.extendRefs !== !0 && (e = !1, t.logger.warn('$ref: keywords ignored in schema at path "' + t.errSchemaPath + '"'));
    }
    if (t.schema.$comment && t.opts.$comment && (r += " " + t.RULES.all.$comment.code(t, "$comment")), R) {
      if (t.opts.coerceTypes)
        var _ = t.util.coerceToTypes(t.opts.coerceTypes, R);
      var I = t.RULES.types[R];
      if (_ || L || I === !0 || I && !Y(I)) {
        var s = t.schemaPath + ".type", c = t.errSchemaPath + "/type", s = t.schemaPath + ".type", c = t.errSchemaPath + "/type", O = L ? "checkDataTypes" : "checkDataType";
        if (r += " if (" + t.util[O](R, g, t.opts.strictNumbers, !0) + ") { ", _) {
          var k = "dataType" + m, w = "coerced" + m;
          r += " var " + k + " = typeof " + g + "; var " + w + " = undefined; ", t.opts.coerceTypes == "array" && (r += " if (" + k + " == 'object' && Array.isArray(" + g + ") && " + g + ".length == 1) { " + g + " = " + g + "[0]; " + k + " = typeof " + g + "; if (" + t.util.checkDataType(t.schema.type, g, t.opts.strictNumbers) + ") " + w + " = " + g + "; } "), r += " if (" + w + " !== undefined) ; ";
          var U = _;
          if (U)
            for (var q, F = -1, $ = U.length - 1; F < $; )
              q = U[F += 1], q == "string" ? r += " else if (" + k + " == 'number' || " + k + " == 'boolean') " + w + " = '' + " + g + "; else if (" + g + " === null) " + w + " = ''; " : q == "number" || q == "integer" ? (r += " else if (" + k + " == 'boolean' || " + g + " === null || (" + k + " == 'string' && " + g + " && " + g + " == +" + g + " ", q == "integer" && (r += " && !(" + g + " % 1)"), r += ")) " + w + " = +" + g + "; ") : q == "boolean" ? r += " else if (" + g + " === 'false' || " + g + " === 0 || " + g + " === null) " + w + " = false; else if (" + g + " === 'true' || " + g + " === 1) " + w + " = true; " : q == "null" ? r += " else if (" + g + " === '' || " + g + " === 0 || " + g + " === false) " + w + " = null; " : t.opts.coerceTypes == "array" && q == "array" && (r += " else if (" + k + " == 'string' || " + k + " == 'number' || " + k + " == 'boolean' || " + g + " == null) " + w + " = [" + g + "]; ");
          r += " else {   ";
          var d = d || [];
          d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (A || "type") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(c) + " , params: { type: '", L ? r += "" + R.join(",") : r += "" + R, r += "' } ", t.opts.messages !== !1 && (r += " , message: 'should be ", L ? r += "" + R.join(",") : r += "" + R, r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + s + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
          var y = r;
          r = d.pop(), !t.compositeRule && S ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } if (" + w + " !== undefined) {  ";
          var P = h ? "data" + (h - 1 || "") : "parentData", X = h ? t.dataPathArr[h] : "parentDataProperty";
          r += " " + g + " = " + w + "; ", h || (r += "if (" + P + " !== undefined)"), r += " " + P + "[" + X + "] = " + w + "; } ";
        } else {
          var d = d || [];
          d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (A || "type") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(c) + " , params: { type: '", L ? r += "" + R.join(",") : r += "" + R, r += "' } ", t.opts.messages !== !1 && (r += " , message: 'should be ", L ? r += "" + R.join(",") : r += "" + R, r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + s + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
          var y = r;
          r = d.pop(), !t.compositeRule && S ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        r += " } ";
      }
    }
    if (t.schema.$ref && !e)
      r += " " + t.RULES.all.$ref.code(t, "$ref") + " ", S && (r += " } if (errors === ", v ? r += "0" : r += "errs_" + m, r += ") { ", x += "}");
    else {
      var Q = t.RULES;
      if (Q) {
        for (var I, ue = -1, le = Q.length - 1; ue < le; )
          if (I = Q[ue += 1], Y(I)) {
            if (I.type && (r += " if (" + t.util.checkDataType(I.type, g, t.opts.strictNumbers) + ") { "), t.opts.useDefaults) {
              if (I.type == "object" && t.schema.properties) {
                var l = t.schema.properties, Ce = Object.keys(l), j = Ce;
                if (j)
                  for (var H, N = -1, G = j.length - 1; N < G; ) {
                    H = j[N += 1];
                    var M = l[H];
                    if (M.default !== void 0) {
                      var Z = g + t.util.getProperty(H);
                      if (t.compositeRule) {
                        if (t.opts.strictDefaults) {
                          var T = "default is ignored for: " + Z;
                          if (t.opts.strictDefaults === "log") t.logger.warn(T);
                          else throw new Error(T);
                        }
                      } else
                        r += " if (" + Z + " === undefined ", t.opts.useDefaults == "empty" && (r += " || " + Z + " === null || " + Z + " === '' "), r += " ) " + Z + " = ", t.opts.useDefaults == "shared" ? r += " " + t.useDefault(M.default) + " " : r += " " + JSON.stringify(M.default) + " ", r += "; ";
                    }
                  }
              } else if (I.type == "array" && Array.isArray(t.schema.items)) {
                var Ee = t.schema.items;
                if (Ee) {
                  for (var M, F = -1, ke = Ee.length - 1; F < ke; )
                    if (M = Ee[F += 1], M.default !== void 0) {
                      var Z = g + "[" + F + "]";
                      if (t.compositeRule) {
                        if (t.opts.strictDefaults) {
                          var T = "default is ignored for: " + Z;
                          if (t.opts.strictDefaults === "log") t.logger.warn(T);
                          else throw new Error(T);
                        }
                      } else
                        r += " if (" + Z + " === undefined ", t.opts.useDefaults == "empty" && (r += " || " + Z + " === null || " + Z + " === '' "), r += " ) " + Z + " = ", t.opts.useDefaults == "shared" ? r += " " + t.useDefault(M.default) + " " : r += " " + JSON.stringify(M.default) + " ", r += "; ";
                    }
                }
              }
            }
            var Ie = I.rules;
            if (Ie) {
              for (var Je, at = -1, lt = Ie.length - 1; at < lt; )
                if (Je = Ie[at += 1], Te(Je)) {
                  var mt = Je.code(t, Je.keyword, I.type);
                  mt && (r += " " + mt + " ", S && (C += "}"));
                }
            }
            if (S && (r += " " + C + " ", C = ""), I.type && (r += " } ", R && R === I.type && !_)) {
              r += " else { ";
              var s = t.schemaPath + ".type", c = t.errSchemaPath + "/type", d = d || [];
              d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (A || "type") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(c) + " , params: { type: '", L ? r += "" + R.join(",") : r += "" + R, r += "' } ", t.opts.messages !== !1 && (r += " , message: 'should be ", L ? r += "" + R.join(",") : r += "" + R, r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + s + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
              var y = r;
              r = d.pop(), !t.compositeRule && S ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ";
            }
            S && (r += " if (errors === ", v ? r += "0" : r += "errs_" + m, r += ") { ", x += "}");
          }
      }
    }
    S && (r += " " + x + " "), v ? (u ? (r += " if (errors === 0) return data;           ", r += " else throw new ValidationError(vErrors); ") : (r += " validate.errors = vErrors; ", r += " return errors === 0;       "), r += " }; return validate;") : r += " var " + b + " = errors === errs_" + m + ";";
    function Y(et) {
      for (var nt = et.rules, rt = 0; rt < nt.length; rt++)
        if (Te(nt[rt])) return !0;
    }
    function Te(et) {
      return t.schema[et.keyword] !== void 0 || et.implements && Ke(et);
    }
    function Ke(et) {
      for (var nt = et.implements, rt = 0; rt < nt.length; rt++)
        if (t.schema[nt[rt]] !== void 0) return !0;
    }
    return r;
  }), Un;
}
var Vn, wp;
function BS() {
  if (wp) return Vn;
  wp = 1;
  var i = Mf(), t = wr(), o = Kf(), f = cv(), r = fv(), u = t.ucs2length, e = Vf(), a = o.Validation;
  Vn = n;
  function n(y, v, T, b) {
    var S = this, C = this._opts, x = [void 0], A = {}, R = [], L = {}, _ = [], I = {}, O = [];
    v = v || { schema: y, refVal: x, refs: A };
    var k = p.call(this, y, v, b), w = this._compilations[k.index];
    if (k.compiling) return w.callValidate = P;
    var U = this._formats, q = this.RULES;
    try {
      var F = X(y, v, T, b);
      w.validate = F;
      var $ = w.callValidate;
      return $ && ($.schema = F.schema, $.errors = null, $.refs = F.refs, $.refVal = F.refVal, $.root = F.root, $.$async = F.$async, C.sourceCode && ($.source = F.source)), F;
    } finally {
      m.call(this, y, v, b);
    }
    function P() {
      var M = w.validate, Z = M.apply(this, arguments);
      return P.errors = M.errors, Z;
    }
    function X(M, Z, Ee, ke) {
      var Ie = !Z || Z && Z.schema == M;
      if (Z.schema != v.schema)
        return n.call(S, M, Z, Ee, ke);
      var Je = M.$async === !0, at = r({
        isTop: !0,
        schema: M,
        isRoot: Ie,
        baseId: ke,
        root: Z,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: o.MissingRef,
        RULES: q,
        validate: r,
        util: t,
        resolve: i,
        resolveRef: Q,
        usePattern: H,
        useDefault: N,
        useCustomRule: G,
        opts: C,
        formats: U,
        logger: S.logger,
        self: S
      });
      at = d(x, c) + d(R, l) + d(_, s) + d(O, g) + at, C.processCode && (at = C.processCode(at, M));
      var lt;
      try {
        var mt = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          at
        );
        lt = mt(
          S,
          q,
          U,
          v,
          x,
          _,
          O,
          e,
          u,
          a
        ), x[0] = lt;
      } catch (Y) {
        throw S.logger.error("Error compiling schema, function code:", at), Y;
      }
      return lt.schema = M, lt.errors = null, lt.refs = A, lt.refVal = x, lt.root = Ie ? lt : Z, Je && (lt.$async = !0), C.sourceCode === !0 && (lt.source = {
        code: at,
        patterns: R,
        defaults: _
      }), lt;
    }
    function Q(M, Z, Ee) {
      Z = i.url(M, Z);
      var ke = A[Z], Ie, Je;
      if (ke !== void 0)
        return Ie = x[ke], Je = "refVal[" + ke + "]", j(Ie, Je);
      if (!Ee && v.refs) {
        var at = v.refs[Z];
        if (at !== void 0)
          return Ie = v.refVal[at], Je = ue(Z, Ie), j(Ie, Je);
      }
      Je = ue(Z);
      var lt = i.call(S, X, v, Z);
      if (lt === void 0) {
        var mt = T && T[Z];
        mt && (lt = i.inlineRef(mt, C.inlineRefs) ? mt : n.call(S, mt, v, T, M));
      }
      if (lt === void 0)
        le(Z);
      else
        return Ce(Z, lt), j(lt, Je);
    }
    function ue(M, Z) {
      var Ee = x.length;
      return x[Ee] = Z, A[M] = Ee, "refVal" + Ee;
    }
    function le(M) {
      delete A[M];
    }
    function Ce(M, Z) {
      var Ee = A[M];
      x[Ee] = Z;
    }
    function j(M, Z) {
      return typeof M == "object" || typeof M == "boolean" ? { code: Z, schema: M, inline: !0 } : { code: Z, $async: M && !!M.$async };
    }
    function H(M) {
      var Z = L[M];
      return Z === void 0 && (Z = L[M] = R.length, R[Z] = M), "pattern" + Z;
    }
    function N(M) {
      switch (typeof M) {
        case "boolean":
        case "number":
          return "" + M;
        case "string":
          return t.toQuotedString(M);
        case "object":
          if (M === null) return "null";
          var Z = f(M), Ee = I[Z];
          return Ee === void 0 && (Ee = I[Z] = _.length, _[Ee] = M), "default" + Ee;
      }
    }
    function G(M, Z, Ee, ke) {
      if (S._opts.validateSchema !== !1) {
        var Ie = M.definition.dependencies;
        if (Ie && !Ie.every(function(nt) {
          return Object.prototype.hasOwnProperty.call(Ee, nt);
        }))
          throw new Error("parent schema must have all required keywords: " + Ie.join(","));
        var Je = M.definition.validateSchema;
        if (Je) {
          var at = Je(Z);
          if (!at) {
            var lt = "keyword schema is invalid: " + S.errorsText(Je.errors);
            if (S._opts.validateSchema == "log") S.logger.error(lt);
            else throw new Error(lt);
          }
        }
      }
      var mt = M.definition.compile, Y = M.definition.inline, Te = M.definition.macro, Ke;
      if (mt)
        Ke = mt.call(S, Z, Ee, ke);
      else if (Te)
        Ke = Te.call(S, Z, Ee, ke), C.validateSchema !== !1 && S.validateSchema(Ke, !0);
      else if (Y)
        Ke = Y.call(S, ke, M.keyword, Z, Ee);
      else if (Ke = M.definition.validate, !Ke) return;
      if (Ke === void 0)
        throw new Error('custom keyword "' + M.keyword + '"failed to compile');
      var et = O.length;
      return O[et] = Ke, {
        code: "customRule" + et,
        validate: Ke
      };
    }
  }
  function p(y, v, T) {
    var b = h.call(this, y, v, T);
    return b >= 0 ? { index: b, compiling: !0 } : (b = this._compilations.length, this._compilations[b] = {
      schema: y,
      root: v,
      baseId: T
    }, { index: b, compiling: !1 });
  }
  function m(y, v, T) {
    var b = h.call(this, y, v, T);
    b >= 0 && this._compilations.splice(b, 1);
  }
  function h(y, v, T) {
    for (var b = 0; b < this._compilations.length; b++) {
      var S = this._compilations[b];
      if (S.schema == y && S.root == v && S.baseId == T) return b;
    }
    return -1;
  }
  function l(y, v) {
    return "var pattern" + y + " = new RegExp(" + t.toQuotedString(v[y]) + ");";
  }
  function s(y) {
    return "var default" + y + " = defaults[" + y + "];";
  }
  function c(y, v) {
    return v[y] === void 0 ? "" : "var refVal" + y + " = refVal[" + y + "];";
  }
  function g(y) {
    return "var customRule" + y + " = customRules[" + y + "];";
  }
  function d(y, v) {
    if (!y.length) return "";
    for (var T = "", b = 0; b < y.length; b++)
      T += v(b, y);
    return T;
  }
  return Vn;
}
var Mn = { exports: {} }, kp;
function PS() {
  if (kp) return Mn.exports;
  kp = 1;
  var i = Mn.exports = function() {
    this._cache = {};
  };
  return i.prototype.put = function(o, f) {
    this._cache[o] = f;
  }, i.prototype.get = function(o) {
    return this._cache[o];
  }, i.prototype.del = function(o) {
    delete this._cache[o];
  }, i.prototype.clear = function() {
    this._cache = {};
  }, Mn.exports;
}
var Kn, Bp;
function IS() {
  if (Bp) return Kn;
  Bp = 1;
  var i = wr(), t = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], f = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, r = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, u = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, e = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, a = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, n = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, p = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, m = /^(?:\/(?:[^~/]|~0|~1)*)*$/, h = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, l = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  Kn = s;
  function s(x) {
    return x = x == "full" ? "full" : "fast", i.copy(s[x]);
  }
  s.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": a,
    url: n,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: r,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: C,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: p,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": m,
    "json-pointer-uri-fragment": h,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": l
  }, s.full = {
    date: g,
    time: d,
    "date-time": v,
    uri: b,
    "uri-reference": e,
    "uri-template": a,
    url: n,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: r,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: C,
    uuid: p,
    "json-pointer": m,
    "json-pointer-uri-fragment": h,
    "relative-json-pointer": l
  };
  function c(x) {
    return x % 4 === 0 && (x % 100 !== 0 || x % 400 === 0);
  }
  function g(x) {
    var A = x.match(t);
    if (!A) return !1;
    var R = +A[1], L = +A[2], _ = +A[3];
    return L >= 1 && L <= 12 && _ >= 1 && _ <= (L == 2 && c(R) ? 29 : o[L]);
  }
  function d(x, A) {
    var R = x.match(f);
    if (!R) return !1;
    var L = R[1], _ = R[2], I = R[3], O = R[5];
    return (L <= 23 && _ <= 59 && I <= 59 || L == 23 && _ == 59 && I == 60) && (!A || O);
  }
  var y = /t|\s/i;
  function v(x) {
    var A = x.split(y);
    return A.length == 2 && g(A[0]) && d(A[1], !0);
  }
  var T = /\/|:/;
  function b(x) {
    return T.test(x) && u.test(x);
  }
  var S = /[^\\]\\Z/;
  function C(x) {
    if (S.test(x)) return !1;
    try {
      return new RegExp(x), !0;
    } catch {
      return !1;
    }
  }
  return Kn;
}
var jn, Pp;
function FS() {
  return Pp || (Pp = 1, jn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.errSchemaPath + "/" + o, p = !t.opts.allErrors, m = "data" + (e || ""), h = "valid" + u, l, s;
    if (a == "#" || a == "#/")
      t.isRoot ? (l = t.async, s = "validate") : (l = t.root.schema.$async === !0, s = "root.refVal[0]");
    else {
      var c = t.resolveRef(t.baseId, a, t.isRoot);
      if (c === void 0) {
        var g = t.MissingRefError.message(t.baseId, a);
        if (t.opts.missingRefs == "fail") {
          t.logger.error(g);
          var d = d || [];
          d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '$ref' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(n) + " , params: { ref: '" + t.util.escapeQuotes(a) + "' } ", t.opts.messages !== !1 && (r += " , message: 'can\\'t resolve reference " + t.util.escapeQuotes(a) + "' "), t.opts.verbose && (r += " , schema: " + t.util.toQuotedString(a) + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + m + " "), r += " } ") : r += " {} ";
          var y = r;
          r = d.pop(), !t.compositeRule && p ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", p && (r += " if (false) { ");
        } else if (t.opts.missingRefs == "ignore")
          t.logger.warn(g), p && (r += " if (true) { ");
        else
          throw new t.MissingRefError(t.baseId, a, g);
      } else if (c.inline) {
        var v = t.util.copy(t);
        v.level++;
        var T = "valid" + v.level;
        v.schema = c.schema, v.schemaPath = "", v.errSchemaPath = a;
        var b = t.validate(v).replace(/validate\.schema/g, c.code);
        r += " " + b + " ", p && (r += " if (" + T + ") { ");
      } else
        l = c.$async === !0 || t.async && c.$async !== !1, s = c.code;
    }
    if (s) {
      var d = d || [];
      d.push(r), r = "", t.opts.passContext ? r += " " + s + ".call(this, " : r += " " + s + "( ", r += " " + m + ", (dataPath || '')", t.errorPath != '""' && (r += " + " + t.errorPath);
      var S = e ? "data" + (e - 1 || "") : "parentData", C = e ? t.dataPathArr[e] : "parentDataProperty";
      r += " , " + S + " , " + C + ", rootData)  ";
      var x = r;
      if (r = d.pop(), l) {
        if (!t.async) throw new Error("async schema referenced by sync schema");
        p && (r += " var " + h + "; "), r += " try { await " + x + "; ", p && (r += " " + h + " = true; "), r += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", p && (r += " " + h + " = false; "), r += " } ", p && (r += " if (" + h + ") { ");
      } else
        r += " if (!" + x + ") { if (vErrors === null) vErrors = " + s + ".errors; else vErrors = vErrors.concat(" + s + ".errors); errors = vErrors.length; } ", p && (r += " else { ");
    }
    return r;
  }), jn;
}
var qn, Ip;
function NS() {
  return Ip || (Ip = 1, qn = function(t, o, f) {
    var r = " ", u = t.schema[o], e = t.schemaPath + t.util.getProperty(o), a = t.errSchemaPath + "/" + o, n = !t.opts.allErrors, p = t.util.copy(t), m = "";
    p.level++;
    var h = "valid" + p.level, l = p.baseId, s = !0, c = u;
    if (c)
      for (var g, d = -1, y = c.length - 1; d < y; )
        g = c[d += 1], (t.opts.strictKeywords ? typeof g == "object" && Object.keys(g).length > 0 || g === !1 : t.util.schemaHasRules(g, t.RULES.all)) && (s = !1, p.schema = g, p.schemaPath = e + "[" + d + "]", p.errSchemaPath = a + "/" + d, r += "  " + t.validate(p) + " ", p.baseId = l, n && (r += " if (" + h + ") { ", m += "}"));
    return n && (s ? r += " if (true) { " : r += " " + m.slice(0, -1) + " "), r;
  }), qn;
}
var $n, Fp;
function OS() {
  return Fp || (Fp = 1, $n = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = "errs__" + u, c = t.util.copy(t), g = "";
    c.level++;
    var d = "valid" + c.level, y = a.every(function(A) {
      return t.opts.strictKeywords ? typeof A == "object" && Object.keys(A).length > 0 || A === !1 : t.util.schemaHasRules(A, t.RULES.all);
    });
    if (y) {
      var v = c.baseId;
      r += " var " + s + " = errors; var " + l + " = false;  ";
      var T = t.compositeRule;
      t.compositeRule = c.compositeRule = !0;
      var b = a;
      if (b)
        for (var S, C = -1, x = b.length - 1; C < x; )
          S = b[C += 1], c.schema = S, c.schemaPath = n + "[" + C + "]", c.errSchemaPath = p + "/" + C, r += "  " + t.validate(c) + " ", c.baseId = v, r += " " + l + " = " + l + " || " + d + "; if (!" + l + ") { ", g += "}";
      t.compositeRule = c.compositeRule = T, r += " " + g + " if (!" + l + ") {   var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: 'should match some schema in anyOf' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !t.compositeRule && m && (t.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += " } else {  errors = " + s + "; if (vErrors !== null) { if (" + s + ") vErrors.length = " + s + "; else vErrors = null; } ", t.opts.allErrors && (r += " } ");
    } else
      m && (r += " if (true) { ");
    return r;
  }), $n;
}
var Gn, Np;
function US() {
  return Np || (Np = 1, Gn = function(t, o, f) {
    var r = " ", u = t.schema[o], e = t.errSchemaPath + "/" + o;
    t.opts.allErrors;
    var a = t.util.toQuotedString(u);
    return t.opts.$comment === !0 ? r += " console.log(" + a + ");" : typeof t.opts.$comment == "function" && (r += " self._opts.$comment(" + a + ", " + t.util.toQuotedString(e) + ", validate.root.schema);"), r;
  }), Gn;
}
var Wn, Op;
function VS() {
  return Op || (Op = 1, Wn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = t.opts.$data && a && a.$data;
    s && (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; "), s || (r += " var schema" + u + " = validate.schema" + n + ";"), r += "var " + l + " = equal(" + h + ", schema" + u + "); if (!" + l + ") {   ";
    var c = c || [];
    c.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'const' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { allowedValue: schema" + u + " } ", t.opts.messages !== !1 && (r += " , message: 'should be equal to constant' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var g = r;
    return r = c.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + g + "]); " : r += " validate.errors = [" + g + "]; return false; " : r += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " }", m && (r += " else { "), r;
  }), Wn;
}
var Xn, Up;
function MS() {
  return Up || (Up = 1, Xn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = "errs__" + u, c = t.util.copy(t), g = "";
    c.level++;
    var d = "valid" + c.level, y = "i" + u, v = c.dataLevel = t.dataLevel + 1, T = "data" + v, b = t.baseId, S = t.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : t.util.schemaHasRules(a, t.RULES.all);
    if (r += "var " + s + " = errors;var " + l + ";", S) {
      var C = t.compositeRule;
      t.compositeRule = c.compositeRule = !0, c.schema = a, c.schemaPath = n, c.errSchemaPath = p, r += " var " + d + " = false; for (var " + y + " = 0; " + y + " < " + h + ".length; " + y + "++) { ", c.errorPath = t.util.getPathExpr(t.errorPath, y, t.opts.jsonPointers, !0);
      var x = h + "[" + y + "]";
      c.dataPathArr[v] = y;
      var A = t.validate(c);
      c.baseId = b, t.util.varOccurences(A, T) < 2 ? r += " " + t.util.varReplace(A, T, x) + " " : r += " var " + T + " = " + x + "; " + A + " ", r += " if (" + d + ") break; }  ", t.compositeRule = c.compositeRule = C, r += " " + g + " if (!" + d + ") {";
    } else
      r += " if (" + h + ".length == 0) {";
    var R = R || [];
    R.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'contains' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: 'should contain a valid item' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var L = r;
    return r = R.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + L + "]); " : r += " validate.errors = [" + L + "]; return false; " : r += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ", S && (r += "  errors = " + s + "; if (vErrors !== null) { if (" + s + ") vErrors.length = " + s + "; else vErrors = null; } "), t.opts.allErrors && (r += " } "), r;
  }), Xn;
}
var zn, Vp;
function KS() {
  return Vp || (Vp = 1, zn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "errs__" + u, s = t.util.copy(t), c = "";
    s.level++;
    var g = "valid" + s.level, d = {}, y = {}, v = t.opts.ownProperties;
    for (C in a)
      if (C != "__proto__") {
        var T = a[C], b = Array.isArray(T) ? y : d;
        b[C] = T;
      }
    r += "var " + l + " = errors;";
    var S = t.errorPath;
    r += "var missing" + u + ";";
    for (var C in y)
      if (b = y[C], b.length) {
        if (r += " if ( " + h + t.util.getProperty(C) + " !== undefined ", v && (r += " && Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(C) + "') "), m) {
          r += " && ( ";
          var x = b;
          if (x)
            for (var A, R = -1, L = x.length - 1; R < L; ) {
              A = x[R += 1], R && (r += " || ");
              var _ = t.util.getProperty(A), I = h + _;
              r += " ( ( " + I + " === undefined ", v && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(A) + "') "), r += ") && (missing" + u + " = " + t.util.toQuotedString(t.opts.jsonPointers ? A : _) + ") ) ";
            }
          r += ")) {  ";
          var O = "missing" + u, k = "' + " + O + " + '";
          t.opts._errorDataPathProperty && (t.errorPath = t.opts.jsonPointers ? t.util.getPathExpr(S, O, !0) : S + " + " + O);
          var w = w || [];
          w.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { property: '" + t.util.escapeQuotes(C) + "', missingProperty: '" + k + "', depsCount: " + b.length + ", deps: '" + t.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) + "' } ", t.opts.messages !== !1 && (r += " , message: 'should have ", b.length == 1 ? r += "property " + t.util.escapeQuotes(b[0]) : r += "properties " + t.util.escapeQuotes(b.join(", ")), r += " when property " + t.util.escapeQuotes(C) + " is present' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
          var U = r;
          r = w.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + U + "]); " : r += " validate.errors = [" + U + "]; return false; " : r += " var err = " + U + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        } else {
          r += " ) { ";
          var q = b;
          if (q)
            for (var A, F = -1, $ = q.length - 1; F < $; ) {
              A = q[F += 1];
              var _ = t.util.getProperty(A), k = t.util.escapeQuotes(A), I = h + _;
              t.opts._errorDataPathProperty && (t.errorPath = t.util.getPath(S, A, t.opts.jsonPointers)), r += " if ( " + I + " === undefined ", v && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(A) + "') "), r += ") {  var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { property: '" + t.util.escapeQuotes(C) + "', missingProperty: '" + k + "', depsCount: " + b.length + ", deps: '" + t.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) + "' } ", t.opts.messages !== !1 && (r += " , message: 'should have ", b.length == 1 ? r += "property " + t.util.escapeQuotes(b[0]) : r += "properties " + t.util.escapeQuotes(b.join(", ")), r += " when property " + t.util.escapeQuotes(C) + " is present' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
        }
        r += " }   ", m && (c += "}", r += " else { ");
      }
    t.errorPath = S;
    var P = s.baseId;
    for (var C in d) {
      var T = d[C];
      (t.opts.strictKeywords ? typeof T == "object" && Object.keys(T).length > 0 || T === !1 : t.util.schemaHasRules(T, t.RULES.all)) && (r += " " + g + " = true; if ( " + h + t.util.getProperty(C) + " !== undefined ", v && (r += " && Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(C) + "') "), r += ") { ", s.schema = T, s.schemaPath = n + t.util.getProperty(C), s.errSchemaPath = p + "/" + t.util.escapeFragment(C), r += "  " + t.validate(s) + " ", s.baseId = P, r += " }  ", m && (r += " if (" + g + ") { ", c += "}"));
    }
    return m && (r += "   " + c + " if (" + l + " == errors) {"), r;
  }), zn;
}
var Hn, Mp;
function jS() {
  return Mp || (Mp = 1, Hn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = t.opts.$data && a && a.$data;
    s && (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ");
    var c = "i" + u, g = "schema" + u;
    s || (r += " var " + g + " = validate.schema" + n + ";"), r += "var " + l + ";", s && (r += " if (schema" + u + " === undefined) " + l + " = true; else if (!Array.isArray(schema" + u + ")) " + l + " = false; else {"), r += "" + l + " = false;for (var " + c + "=0; " + c + "<" + g + ".length; " + c + "++) if (equal(" + h + ", " + g + "[" + c + "])) { " + l + " = true; break; }", s && (r += "  }  "), r += " if (!" + l + ") {   ";
    var d = d || [];
    d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'enum' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { allowedValues: schema" + u + " } ", t.opts.messages !== !1 && (r += " , message: 'should be equal to one of the allowed values' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var y = r;
    return r = d.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " }", m && (r += " else { "), r;
  }), Hn;
}
var Jn, Kp;
function qS() {
  return Kp || (Kp = 1, Jn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || "");
    if (t.opts.format === !1)
      return m && (r += " if (true) { "), r;
    var l = t.opts.$data && a && a.$data, s;
    l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a;
    var c = t.opts.unknownFormats, g = Array.isArray(c);
    if (l) {
      var d = "format" + u, y = "isObject" + u, v = "formatType" + u;
      r += " var " + d + " = formats[" + s + "]; var " + y + " = typeof " + d + " == 'object' && !(" + d + " instanceof RegExp) && " + d + ".validate; var " + v + " = " + y + " && " + d + ".type || 'string'; if (" + y + ") { ", t.async && (r += " var async" + u + " = " + d + ".async; "), r += " " + d + " = " + d + ".validate; } if (  ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'string') || "), r += " (", c != "ignore" && (r += " (" + s + " && !" + d + " ", g && (r += " && self._opts.unknownFormats.indexOf(" + s + ") == -1 "), r += ") || "), r += " (" + d + " && " + v + " == '" + f + "' && !(typeof " + d + " == 'function' ? ", t.async ? r += " (async" + u + " ? await " + d + "(" + h + ") : " + d + "(" + h + ")) " : r += " " + d + "(" + h + ") ", r += " : " + d + ".test(" + h + "))))) {";
    } else {
      var d = t.formats[a];
      if (!d) {
        if (c == "ignore")
          return t.logger.warn('unknown format "' + a + '" ignored in schema at path "' + t.errSchemaPath + '"'), m && (r += " if (true) { "), r;
        if (g && c.indexOf(a) >= 0)
          return m && (r += " if (true) { "), r;
        throw new Error('unknown format "' + a + '" is used in schema at path "' + t.errSchemaPath + '"');
      }
      var y = typeof d == "object" && !(d instanceof RegExp) && d.validate, v = y && d.type || "string";
      if (y) {
        var T = d.async === !0;
        d = d.validate;
      }
      if (v != f)
        return m && (r += " if (true) { "), r;
      if (T) {
        if (!t.async) throw new Error("async format in sync schema");
        var b = "formats" + t.util.getProperty(a) + ".validate";
        r += " if (!(await " + b + "(" + h + "))) { ";
      } else {
        r += " if (! ";
        var b = "formats" + t.util.getProperty(a);
        y && (b += ".validate"), typeof d == "function" ? r += " " + b + "(" + h + ") " : r += " " + b + ".test(" + h + ") ", r += ") { ";
      }
    }
    var S = S || [];
    S.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'format' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { format:  ", l ? r += "" + s : r += "" + t.util.toQuotedString(a), r += "  } ", t.opts.messages !== !1 && (r += ` , message: 'should match format "`, l ? r += "' + " + s + " + '" : r += "" + t.util.escapeQuotes(a), r += `"' `), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + t.util.toQuotedString(a), r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var C = r;
    return r = S.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + C + "]); " : r += " validate.errors = [" + C + "]; return false; " : r += " var err = " + C + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", m && (r += " else { "), r;
  }), Jn;
}
var Qn, jp;
function $S() {
  return jp || (jp = 1, Qn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = "errs__" + u, c = t.util.copy(t);
    c.level++;
    var g = "valid" + c.level, d = t.schema.then, y = t.schema.else, v = d !== void 0 && (t.opts.strictKeywords ? typeof d == "object" && Object.keys(d).length > 0 || d === !1 : t.util.schemaHasRules(d, t.RULES.all)), T = y !== void 0 && (t.opts.strictKeywords ? typeof y == "object" && Object.keys(y).length > 0 || y === !1 : t.util.schemaHasRules(y, t.RULES.all)), b = c.baseId;
    if (v || T) {
      var S;
      c.createErrors = !1, c.schema = a, c.schemaPath = n, c.errSchemaPath = p, r += " var " + s + " = errors; var " + l + " = true;  ";
      var C = t.compositeRule;
      t.compositeRule = c.compositeRule = !0, r += "  " + t.validate(c) + " ", c.baseId = b, c.createErrors = !0, r += "  errors = " + s + "; if (vErrors !== null) { if (" + s + ") vErrors.length = " + s + "; else vErrors = null; }  ", t.compositeRule = c.compositeRule = C, v ? (r += " if (" + g + ") {  ", c.schema = t.schema.then, c.schemaPath = t.schemaPath + ".then", c.errSchemaPath = t.errSchemaPath + "/then", r += "  " + t.validate(c) + " ", c.baseId = b, r += " " + l + " = " + g + "; ", v && T ? (S = "ifClause" + u, r += " var " + S + " = 'then'; ") : S = "'then'", r += " } ", T && (r += " else { ")) : r += " if (!" + g + ") { ", T && (c.schema = t.schema.else, c.schemaPath = t.schemaPath + ".else", c.errSchemaPath = t.errSchemaPath + "/else", r += "  " + t.validate(c) + " ", c.baseId = b, r += " " + l + " = " + g + "; ", v && T ? (S = "ifClause" + u, r += " var " + S + " = 'else'; ") : S = "'else'", r += " } "), r += " if (!" + l + ") {   var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'if' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { failingKeyword: " + S + " } ", t.opts.messages !== !1 && (r += ` , message: 'should match "' + ` + S + ` + '" schema' `), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !t.compositeRule && m && (t.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += " }   ", m && (r += " else { ");
    } else
      m && (r += " if (true) { ");
    return r;
  }), Qn;
}
var Yn, qp;
function GS() {
  return qp || (qp = 1, Yn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = "errs__" + u, c = t.util.copy(t), g = "";
    c.level++;
    var d = "valid" + c.level, y = "i" + u, v = c.dataLevel = t.dataLevel + 1, T = "data" + v, b = t.baseId;
    if (r += "var " + s + " = errors;var " + l + ";", Array.isArray(a)) {
      var S = t.schema.additionalItems;
      if (S === !1) {
        r += " " + l + " = " + h + ".length <= " + a.length + "; ";
        var C = p;
        p = t.errSchemaPath + "/additionalItems", r += "  if (!" + l + ") {   ";
        var x = x || [];
        x.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { limit: " + a.length + " } ", t.opts.messages !== !1 && (r += " , message: 'should NOT have more than " + a.length + " items' "), t.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
        var A = r;
        r = x.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + A + "]); " : r += " validate.errors = [" + A + "]; return false; " : r += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", p = C, m && (g += "}", r += " else { ");
      }
      var R = a;
      if (R) {
        for (var L, _ = -1, I = R.length - 1; _ < I; )
          if (L = R[_ += 1], t.opts.strictKeywords ? typeof L == "object" && Object.keys(L).length > 0 || L === !1 : t.util.schemaHasRules(L, t.RULES.all)) {
            r += " " + d + " = true; if (" + h + ".length > " + _ + ") { ";
            var O = h + "[" + _ + "]";
            c.schema = L, c.schemaPath = n + "[" + _ + "]", c.errSchemaPath = p + "/" + _, c.errorPath = t.util.getPathExpr(t.errorPath, _, t.opts.jsonPointers, !0), c.dataPathArr[v] = _;
            var k = t.validate(c);
            c.baseId = b, t.util.varOccurences(k, T) < 2 ? r += " " + t.util.varReplace(k, T, O) + " " : r += " var " + T + " = " + O + "; " + k + " ", r += " }  ", m && (r += " if (" + d + ") { ", g += "}");
          }
      }
      if (typeof S == "object" && (t.opts.strictKeywords ? typeof S == "object" && Object.keys(S).length > 0 || S === !1 : t.util.schemaHasRules(S, t.RULES.all))) {
        c.schema = S, c.schemaPath = t.schemaPath + ".additionalItems", c.errSchemaPath = t.errSchemaPath + "/additionalItems", r += " " + d + " = true; if (" + h + ".length > " + a.length + ") {  for (var " + y + " = " + a.length + "; " + y + " < " + h + ".length; " + y + "++) { ", c.errorPath = t.util.getPathExpr(t.errorPath, y, t.opts.jsonPointers, !0);
        var O = h + "[" + y + "]";
        c.dataPathArr[v] = y;
        var k = t.validate(c);
        c.baseId = b, t.util.varOccurences(k, T) < 2 ? r += " " + t.util.varReplace(k, T, O) + " " : r += " var " + T + " = " + O + "; " + k + " ", m && (r += " if (!" + d + ") break; "), r += " } }  ", m && (r += " if (" + d + ") { ", g += "}");
      }
    } else if (t.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : t.util.schemaHasRules(a, t.RULES.all)) {
      c.schema = a, c.schemaPath = n, c.errSchemaPath = p, r += "  for (var " + y + " = 0; " + y + " < " + h + ".length; " + y + "++) { ", c.errorPath = t.util.getPathExpr(t.errorPath, y, t.opts.jsonPointers, !0);
      var O = h + "[" + y + "]";
      c.dataPathArr[v] = y;
      var k = t.validate(c);
      c.baseId = b, t.util.varOccurences(k, T) < 2 ? r += " " + t.util.varReplace(k, T, O) + " " : r += " var " + T + " = " + O + "; " + k + " ", m && (r += " if (!" + d + ") break; "), r += " }";
    }
    return m && (r += " " + g + " if (" + s + " == errors) {"), r;
  }), Yn;
}
var Zn, $p;
function Gp() {
  return $p || ($p = 1, Zn = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, b, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a;
    var c = o == "maximum", g = c ? "exclusiveMaximum" : "exclusiveMinimum", d = t.schema[g], y = t.opts.$data && d && d.$data, v = c ? "<" : ">", T = c ? ">" : "<", b = void 0;
    if (!(l || typeof a == "number" || a === void 0))
      throw new Error(o + " must be number");
    if (!(y || d === void 0 || typeof d == "number" || typeof d == "boolean"))
      throw new Error(g + " must be number or boolean");
    if (y) {
      var S = t.util.getData(d.$data, e, t.dataPathArr), C = "exclusive" + u, x = "exclType" + u, A = "exclIsNumber" + u, R = "op" + u, L = "' + " + R + " + '";
      r += " var schemaExcl" + u + " = " + S + "; ", S = "schemaExcl" + u, r += " var " + C + "; var " + x + " = typeof " + S + "; if (" + x + " != 'boolean' && " + x + " != 'undefined' && " + x + " != 'number') { ";
      var b = g, _ = _ || [];
      _.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (b || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: '" + g + " should be boolean' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
      var I = r;
      r = _.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + I + "]); " : r += " validate.errors = [" + I + "]; return false; " : r += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), r += " " + x + " == 'number' ? ( (" + C + " = " + s + " === undefined || " + S + " " + v + "= " + s + ") ? " + h + " " + T + "= " + S + " : " + h + " " + T + " " + s + " ) : ( (" + C + " = " + S + " === true) ? " + h + " " + T + "= " + s + " : " + h + " " + T + " " + s + " ) || " + h + " !== " + h + ") { var op" + u + " = " + C + " ? '" + v + "' : '" + v + "='; ", a === void 0 && (b = g, p = t.errSchemaPath + "/" + g, s = S, l = y);
    } else {
      var A = typeof d == "number", L = v;
      if (A && l) {
        var R = "'" + L + "'";
        r += " if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), r += " ( " + s + " === undefined || " + d + " " + v + "= " + s + " ? " + h + " " + T + "= " + d + " : " + h + " " + T + " " + s + " ) || " + h + " !== " + h + ") { ";
      } else {
        A && a === void 0 ? (C = !0, b = g, p = t.errSchemaPath + "/" + g, s = d, T += "=") : (A && (s = Math[c ? "min" : "max"](d, a)), d === (A ? s : !0) ? (C = !0, b = g, p = t.errSchemaPath + "/" + g, T += "=") : (C = !1, L += "="));
        var R = "'" + L + "'";
        r += " if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), r += " " + h + " " + T + " " + s + " || " + h + " !== " + h + ") { ";
      }
    }
    b = b || o;
    var _ = _ || [];
    _.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (b || "_limit") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { comparison: " + R + ", limit: " + s + ", exclusive: " + C + " } ", t.opts.messages !== !1 && (r += " , message: 'should be " + L + " ", l ? r += "' + " + s : r += "" + s + "'"), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var I = r;
    return r = _.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + I + "]); " : r += " validate.errors = [" + I + "]; return false; " : r += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", m && (r += " else { "), r;
  }), Zn;
}
var es, Wp;
function Xp() {
  return Wp || (Wp = 1, es = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, g, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    if (l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a, !(l || typeof a == "number"))
      throw new Error(o + " must be number");
    var c = o == "maxItems" ? ">" : "<";
    r += "if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), r += " " + h + ".length " + c + " " + s + ") { ";
    var g = o, d = d || [];
    d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitItems") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { limit: " + s + " } ", t.opts.messages !== !1 && (r += " , message: 'should NOT have ", o == "maxItems" ? r += "more" : r += "fewer", r += " than ", l ? r += "' + " + s + " + '" : r += "" + a, r += " items' "), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var y = r;
    return r = d.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", m && (r += " else { "), r;
  }), es;
}
var ts, zp;
function Hp() {
  return zp || (zp = 1, ts = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, g, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    if (l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a, !(l || typeof a == "number"))
      throw new Error(o + " must be number");
    var c = o == "maxLength" ? ">" : "<";
    r += "if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), t.opts.unicode === !1 ? r += " " + h + ".length " : r += " ucs2length(" + h + ") ", r += " " + c + " " + s + ") { ";
    var g = o, d = d || [];
    d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitLength") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { limit: " + s + " } ", t.opts.messages !== !1 && (r += " , message: 'should NOT be ", o == "maxLength" ? r += "longer" : r += "shorter", r += " than ", l ? r += "' + " + s + " + '" : r += "" + a, r += " characters' "), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var y = r;
    return r = d.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", m && (r += " else { "), r;
  }), ts;
}
var rs, Jp;
function Qp() {
  return Jp || (Jp = 1, rs = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, g, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    if (l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a, !(l || typeof a == "number"))
      throw new Error(o + " must be number");
    var c = o == "maxProperties" ? ">" : "<";
    r += "if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'number') || "), r += " Object.keys(" + h + ").length " + c + " " + s + ") { ";
    var g = o, d = d || [];
    d.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitProperties") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { limit: " + s + " } ", t.opts.messages !== !1 && (r += " , message: 'should NOT have ", o == "maxProperties" ? r += "more" : r += "fewer", r += " than ", l ? r += "' + " + s + " + '" : r += "" + a, r += " properties' "), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var y = r;
    return r = d.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + y + "]); " : r += " validate.errors = [" + y + "]; return false; " : r += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", m && (r += " else { "), r;
  }), rs;
}
var ns, Yp;
function WS() {
  return Yp || (Yp = 1, ns = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    if (l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a, !(l || typeof a == "number"))
      throw new Error(o + " must be number");
    r += "var division" + u + ";if (", l && (r += " " + s + " !== undefined && ( typeof " + s + " != 'number' || "), r += " (division" + u + " = " + h + " / " + s + ", ", t.opts.multipleOfPrecision ? r += " Math.abs(Math.round(division" + u + ") - division" + u + ") > 1e-" + t.opts.multipleOfPrecision + " " : r += " division" + u + " !== parseInt(division" + u + ") ", r += " ) ", l && (r += "  )  "), r += " ) {   ";
    var c = c || [];
    c.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { multipleOf: " + s + " } ", t.opts.messages !== !1 && (r += " , message: 'should be multiple of ", l ? r += "' + " + s : r += "" + s + "'"), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var g = r;
    return r = c.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + g + "]); " : r += " validate.errors = [" + g + "]; return false; " : r += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", m && (r += " else { "), r;
  }), ns;
}
var ss, Zp;
function XS() {
  return Zp || (Zp = 1, ss = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "errs__" + u, s = t.util.copy(t);
    s.level++;
    var c = "valid" + s.level;
    if (t.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : t.util.schemaHasRules(a, t.RULES.all)) {
      s.schema = a, s.schemaPath = n, s.errSchemaPath = p, r += " var " + l + " = errors;  ";
      var g = t.compositeRule;
      t.compositeRule = s.compositeRule = !0, s.createErrors = !1;
      var d;
      s.opts.allErrors && (d = s.opts.allErrors, s.opts.allErrors = !1), r += " " + t.validate(s) + " ", s.createErrors = !0, d && (s.opts.allErrors = d), t.compositeRule = s.compositeRule = g, r += " if (" + c + ") {   ";
      var y = y || [];
      y.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'not' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: 'should NOT be valid' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
      var v = r;
      r = y.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + v + "]); " : r += " validate.errors = [" + v + "]; return false; " : r += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else {  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; } ", t.opts.allErrors && (r += " } ");
    } else
      r += "  var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'not' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: {} ", t.opts.messages !== !1 && (r += " , message: 'should NOT be valid' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", m && (r += " if (false) { ");
    return r;
  }), ss;
}
var is, eh;
function zS() {
  return eh || (eh = 1, is = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = "errs__" + u, c = t.util.copy(t), g = "";
    c.level++;
    var d = "valid" + c.level, y = c.baseId, v = "prevValid" + u, T = "passingSchemas" + u;
    r += "var " + s + " = errors , " + v + " = false , " + l + " = false , " + T + " = null; ";
    var b = t.compositeRule;
    t.compositeRule = c.compositeRule = !0;
    var S = a;
    if (S)
      for (var C, x = -1, A = S.length - 1; x < A; )
        C = S[x += 1], (t.opts.strictKeywords ? typeof C == "object" && Object.keys(C).length > 0 || C === !1 : t.util.schemaHasRules(C, t.RULES.all)) ? (c.schema = C, c.schemaPath = n + "[" + x + "]", c.errSchemaPath = p + "/" + x, r += "  " + t.validate(c) + " ", c.baseId = y) : r += " var " + d + " = true; ", x && (r += " if (" + d + " && " + v + ") { " + l + " = false; " + T + " = [" + T + ", " + x + "]; } else { ", g += "}"), r += " if (" + d + ") { " + l + " = " + v + " = true; " + T + " = " + x + "; }";
    return t.compositeRule = c.compositeRule = b, r += "" + g + "if (!" + l + ") {   var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { passingSchemas: " + T + " } ", t.opts.messages !== !1 && (r += " , message: 'should match exactly one schema in oneOf' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !t.compositeRule && m && (t.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += "} else {  errors = " + s + "; if (vErrors !== null) { if (" + s + ") vErrors.length = " + s + "; else vErrors = null; }", t.opts.allErrors && (r += " } "), r;
  }), is;
}
var as, th;
function HS() {
  return th || (th = 1, as = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = t.opts.$data && a && a.$data, s;
    l ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", s = "schema" + u) : s = a;
    var c = l ? "(new RegExp(" + s + "))" : t.usePattern(a);
    r += "if ( ", l && (r += " (" + s + " !== undefined && typeof " + s + " != 'string') || "), r += " !" + c + ".test(" + h + ") ) {   ";
    var g = g || [];
    g.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { pattern:  ", l ? r += "" + s : r += "" + t.util.toQuotedString(a), r += "  } ", t.opts.messages !== !1 && (r += ` , message: 'should match pattern "`, l ? r += "' + " + s + " + '" : r += "" + t.util.escapeQuotes(a), r += `"' `), t.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + n : r += "" + t.util.toQuotedString(a), r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
    var d = r;
    return r = g.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + d + "]); " : r += " validate.errors = [" + d + "]; return false; " : r += " var err = " + d + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", m && (r += " else { "), r;
  }), as;
}
var os, rh;
function JS() {
  return rh || (rh = 1, os = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "errs__" + u, s = t.util.copy(t), c = "";
    s.level++;
    var g = "valid" + s.level, d = "key" + u, y = "idx" + u, v = s.dataLevel = t.dataLevel + 1, T = "data" + v, b = "dataProperties" + u, S = Object.keys(a || {}).filter(F), C = t.schema.patternProperties || {}, x = Object.keys(C).filter(F), A = t.schema.additionalProperties, R = S.length || x.length, L = A === !1, _ = typeof A == "object" && Object.keys(A).length, I = t.opts.removeAdditional, O = L || _ || I, k = t.opts.ownProperties, w = t.baseId, U = t.schema.required;
    if (U && !(t.opts.$data && U.$data) && U.length < t.opts.loopRequired)
      var q = t.util.toHash(U);
    function F(dt) {
      return dt !== "__proto__";
    }
    if (r += "var " + l + " = errors;var " + g + " = true;", k && (r += " var " + b + " = undefined;"), O) {
      if (k ? r += " " + b + " = " + b + " || Object.keys(" + h + "); for (var " + y + "=0; " + y + "<" + b + ".length; " + y + "++) { var " + d + " = " + b + "[" + y + "]; " : r += " for (var " + d + " in " + h + ") { ", R) {
        if (r += " var isAdditional" + u + " = !(false ", S.length)
          if (S.length > 8)
            r += " || validate.schema" + n + ".hasOwnProperty(" + d + ") ";
          else {
            var $ = S;
            if ($)
              for (var P, X = -1, Q = $.length - 1; X < Q; )
                P = $[X += 1], r += " || " + d + " == " + t.util.toQuotedString(P) + " ";
          }
        if (x.length) {
          var ue = x;
          if (ue)
            for (var le, Ce = -1, j = ue.length - 1; Ce < j; )
              le = ue[Ce += 1], r += " || " + t.usePattern(le) + ".test(" + d + ") ";
        }
        r += " ); if (isAdditional" + u + ") { ";
      }
      if (I == "all")
        r += " delete " + h + "[" + d + "]; ";
      else {
        var H = t.errorPath, N = "' + " + d + " + '";
        if (t.opts._errorDataPathProperty && (t.errorPath = t.util.getPathExpr(t.errorPath, d, t.opts.jsonPointers)), L)
          if (I)
            r += " delete " + h + "[" + d + "]; ";
          else {
            r += " " + g + " = false; ";
            var G = p;
            p = t.errSchemaPath + "/additionalProperties";
            var M = M || [];
            M.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { additionalProperty: '" + N + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is an invalid additional property" : r += "should NOT have additional properties", r += "' "), t.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
            var Z = r;
            r = M.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + Z + "]); " : r += " validate.errors = [" + Z + "]; return false; " : r += " var err = " + Z + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", p = G, m && (r += " break; ");
          }
        else if (_)
          if (I == "failing") {
            r += " var " + l + " = errors;  ";
            var Ee = t.compositeRule;
            t.compositeRule = s.compositeRule = !0, s.schema = A, s.schemaPath = t.schemaPath + ".additionalProperties", s.errSchemaPath = t.errSchemaPath + "/additionalProperties", s.errorPath = t.opts._errorDataPathProperty ? t.errorPath : t.util.getPathExpr(t.errorPath, d, t.opts.jsonPointers);
            var ke = h + "[" + d + "]";
            s.dataPathArr[v] = d;
            var Ie = t.validate(s);
            s.baseId = w, t.util.varOccurences(Ie, T) < 2 ? r += " " + t.util.varReplace(Ie, T, ke) + " " : r += " var " + T + " = " + ke + "; " + Ie + " ", r += " if (!" + g + ") { errors = " + l + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + h + "[" + d + "]; }  ", t.compositeRule = s.compositeRule = Ee;
          } else {
            s.schema = A, s.schemaPath = t.schemaPath + ".additionalProperties", s.errSchemaPath = t.errSchemaPath + "/additionalProperties", s.errorPath = t.opts._errorDataPathProperty ? t.errorPath : t.util.getPathExpr(t.errorPath, d, t.opts.jsonPointers);
            var ke = h + "[" + d + "]";
            s.dataPathArr[v] = d;
            var Ie = t.validate(s);
            s.baseId = w, t.util.varOccurences(Ie, T) < 2 ? r += " " + t.util.varReplace(Ie, T, ke) + " " : r += " var " + T + " = " + ke + "; " + Ie + " ", m && (r += " if (!" + g + ") break; ");
          }
        t.errorPath = H;
      }
      R && (r += " } "), r += " }  ", m && (r += " if (" + g + ") { ", c += "}");
    }
    var Je = t.opts.useDefaults && !t.compositeRule;
    if (S.length) {
      var at = S;
      if (at)
        for (var P, lt = -1, mt = at.length - 1; lt < mt; ) {
          P = at[lt += 1];
          var Y = a[P];
          if (t.opts.strictKeywords ? typeof Y == "object" && Object.keys(Y).length > 0 || Y === !1 : t.util.schemaHasRules(Y, t.RULES.all)) {
            var Te = t.util.getProperty(P), ke = h + Te, Ke = Je && Y.default !== void 0;
            s.schema = Y, s.schemaPath = n + Te, s.errSchemaPath = p + "/" + t.util.escapeFragment(P), s.errorPath = t.util.getPath(t.errorPath, P, t.opts.jsonPointers), s.dataPathArr[v] = t.util.toQuotedString(P);
            var Ie = t.validate(s);
            if (s.baseId = w, t.util.varOccurences(Ie, T) < 2) {
              Ie = t.util.varReplace(Ie, T, ke);
              var et = ke;
            } else {
              var et = T;
              r += " var " + T + " = " + ke + "; ";
            }
            if (Ke)
              r += " " + Ie + " ";
            else {
              if (q && q[P]) {
                r += " if ( " + et + " === undefined ", k && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(P) + "') "), r += ") { " + g + " = false; ";
                var H = t.errorPath, G = p, nt = t.util.escapeQuotes(P);
                t.opts._errorDataPathProperty && (t.errorPath = t.util.getPath(H, P, t.opts.jsonPointers)), p = t.errSchemaPath + "/required";
                var M = M || [];
                M.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + nt + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + nt + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
                var Z = r;
                r = M.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + Z + "]); " : r += " validate.errors = [" + Z + "]; return false; " : r += " var err = " + Z + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", p = G, t.errorPath = H, r += " } else { ";
              } else
                m ? (r += " if ( " + et + " === undefined ", k && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(P) + "') "), r += ") { " + g + " = true; } else { ") : (r += " if (" + et + " !== undefined ", k && (r += " &&   Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(P) + "') "), r += " ) { ");
              r += " " + Ie + " } ";
            }
          }
          m && (r += " if (" + g + ") { ", c += "}");
        }
    }
    if (x.length) {
      var rt = x;
      if (rt)
        for (var le, ot = -1, Ct = rt.length - 1; ot < Ct; ) {
          le = rt[ot += 1];
          var Y = C[le];
          if (t.opts.strictKeywords ? typeof Y == "object" && Object.keys(Y).length > 0 || Y === !1 : t.util.schemaHasRules(Y, t.RULES.all)) {
            s.schema = Y, s.schemaPath = t.schemaPath + ".patternProperties" + t.util.getProperty(le), s.errSchemaPath = t.errSchemaPath + "/patternProperties/" + t.util.escapeFragment(le), k ? r += " " + b + " = " + b + " || Object.keys(" + h + "); for (var " + y + "=0; " + y + "<" + b + ".length; " + y + "++) { var " + d + " = " + b + "[" + y + "]; " : r += " for (var " + d + " in " + h + ") { ", r += " if (" + t.usePattern(le) + ".test(" + d + ")) { ", s.errorPath = t.util.getPathExpr(t.errorPath, d, t.opts.jsonPointers);
            var ke = h + "[" + d + "]";
            s.dataPathArr[v] = d;
            var Ie = t.validate(s);
            s.baseId = w, t.util.varOccurences(Ie, T) < 2 ? r += " " + t.util.varReplace(Ie, T, ke) + " " : r += " var " + T + " = " + ke + "; " + Ie + " ", m && (r += " if (!" + g + ") break; "), r += " } ", m && (r += " else " + g + " = true; "), r += " }  ", m && (r += " if (" + g + ") { ", c += "}");
          }
        }
    }
    return m && (r += " " + c + " if (" + l + " == errors) {"), r;
  }), os;
}
var ls, nh;
function QS() {
  return nh || (nh = 1, ls = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "errs__" + u, s = t.util.copy(t), c = "";
    s.level++;
    var g = "valid" + s.level;
    if (r += "var " + l + " = errors;", t.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : t.util.schemaHasRules(a, t.RULES.all)) {
      s.schema = a, s.schemaPath = n, s.errSchemaPath = p;
      var d = "key" + u, y = "idx" + u, v = "i" + u, T = "' + " + d + " + '", b = s.dataLevel = t.dataLevel + 1, S = "data" + b, C = "dataProperties" + u, x = t.opts.ownProperties, A = t.baseId;
      x && (r += " var " + C + " = undefined; "), x ? r += " " + C + " = " + C + " || Object.keys(" + h + "); for (var " + y + "=0; " + y + "<" + C + ".length; " + y + "++) { var " + d + " = " + C + "[" + y + "]; " : r += " for (var " + d + " in " + h + ") { ", r += " var startErrs" + u + " = errors; ";
      var R = d, L = t.compositeRule;
      t.compositeRule = s.compositeRule = !0;
      var _ = t.validate(s);
      s.baseId = A, t.util.varOccurences(_, S) < 2 ? r += " " + t.util.varReplace(_, S, R) + " " : r += " var " + S + " = " + R + "; " + _ + " ", t.compositeRule = s.compositeRule = L, r += " if (!" + g + ") { for (var " + v + "=startErrs" + u + "; " + v + "<errors; " + v + "++) { vErrors[" + v + "].propertyName = " + d + "; }   var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { propertyName: '" + T + "' } ", t.opts.messages !== !1 && (r += " , message: 'property name \\'" + T + "\\' is invalid' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !t.compositeRule && m && (t.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), m && (r += " break; "), r += " } }";
    }
    return m && (r += " " + c + " if (" + l + " == errors) {"), r;
  }), ls;
}
var us, sh;
function YS() {
  return sh || (sh = 1, us = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = t.opts.$data && a && a.$data;
    s && (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ");
    var c = "schema" + u;
    if (!s)
      if (a.length < t.opts.loopRequired && t.schema.properties && Object.keys(t.schema.properties).length) {
        var g = [], d = a;
        if (d)
          for (var y, v = -1, T = d.length - 1; v < T; ) {
            y = d[v += 1];
            var b = t.schema.properties[y];
            b && (t.opts.strictKeywords ? typeof b == "object" && Object.keys(b).length > 0 || b === !1 : t.util.schemaHasRules(b, t.RULES.all)) || (g[g.length] = y);
          }
      } else
        var g = a;
    if (s || g.length) {
      var S = t.errorPath, C = s || g.length >= t.opts.loopRequired, x = t.opts.ownProperties;
      if (m)
        if (r += " var missing" + u + "; ", C) {
          s || (r += " var " + c + " = validate.schema" + n + "; ");
          var A = "i" + u, R = "schema" + u + "[" + A + "]", L = "' + " + R + " + '";
          t.opts._errorDataPathProperty && (t.errorPath = t.util.getPathExpr(S, R, t.opts.jsonPointers)), r += " var " + l + " = true; ", s && (r += " if (schema" + u + " === undefined) " + l + " = true; else if (!Array.isArray(schema" + u + ")) " + l + " = false; else {"), r += " for (var " + A + " = 0; " + A + " < " + c + ".length; " + A + "++) { " + l + " = " + h + "[" + c + "[" + A + "]] !== undefined ", x && (r += " &&   Object.prototype.hasOwnProperty.call(" + h + ", " + c + "[" + A + "]) "), r += "; if (!" + l + ") break; } ", s && (r += "  }  "), r += "  if (!" + l + ") {   ";
          var _ = _ || [];
          _.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + L + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + L + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
          var I = r;
          r = _.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + I + "]); " : r += " validate.errors = [" + I + "]; return false; " : r += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ";
        } else {
          r += " if ( ";
          var O = g;
          if (O)
            for (var k, A = -1, w = O.length - 1; A < w; ) {
              k = O[A += 1], A && (r += " || ");
              var U = t.util.getProperty(k), q = h + U;
              r += " ( ( " + q + " === undefined ", x && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(k) + "') "), r += ") && (missing" + u + " = " + t.util.toQuotedString(t.opts.jsonPointers ? k : U) + ") ) ";
            }
          r += ") {  ";
          var R = "missing" + u, L = "' + " + R + " + '";
          t.opts._errorDataPathProperty && (t.errorPath = t.opts.jsonPointers ? t.util.getPathExpr(S, R, !0) : S + " + " + R);
          var _ = _ || [];
          _.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + L + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + L + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
          var I = r;
          r = _.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + I + "]); " : r += " validate.errors = [" + I + "]; return false; " : r += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ";
        }
      else if (C) {
        s || (r += " var " + c + " = validate.schema" + n + "; ");
        var A = "i" + u, R = "schema" + u + "[" + A + "]", L = "' + " + R + " + '";
        t.opts._errorDataPathProperty && (t.errorPath = t.util.getPathExpr(S, R, t.opts.jsonPointers)), s && (r += " if (" + c + " && !Array.isArray(" + c + ")) {  var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + L + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + L + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + c + " !== undefined) { "), r += " for (var " + A + " = 0; " + A + " < " + c + ".length; " + A + "++) { if (" + h + "[" + c + "[" + A + "]] === undefined ", x && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", " + c + "[" + A + "]) "), r += ") {  var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + L + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + L + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", s && (r += "  }  ");
      } else {
        var F = g;
        if (F)
          for (var k, $ = -1, P = F.length - 1; $ < P; ) {
            k = F[$ += 1];
            var U = t.util.getProperty(k), L = t.util.escapeQuotes(k), q = h + U;
            t.opts._errorDataPathProperty && (t.errorPath = t.util.getPath(S, k, t.opts.jsonPointers)), r += " if ( " + q + " === undefined ", x && (r += " || ! Object.prototype.hasOwnProperty.call(" + h + ", '" + t.util.escapeQuotes(k) + "') "), r += ") {  var err =   ", t.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { missingProperty: '" + L + "' } ", t.opts.messages !== !1 && (r += " , message: '", t.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + L + "\\'", r += "' "), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
      }
      t.errorPath = S;
    } else m && (r += " if (true) {");
    return r;
  }), us;
}
var cs, ih;
function ZS() {
  return ih || (ih = 1, cs = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h = "data" + (e || ""), l = "valid" + u, s = t.opts.$data && a && a.$data, c;
    if (s ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", c = "schema" + u) : c = a, (a || s) && t.opts.uniqueItems !== !1) {
      s && (r += " var " + l + "; if (" + c + " === false || " + c + " === undefined) " + l + " = true; else if (typeof " + c + " != 'boolean') " + l + " = false; else { "), r += " var i = " + h + ".length , " + l + " = true , j; if (i > 1) { ";
      var g = t.schema.items && t.schema.items.type, d = Array.isArray(g);
      if (!g || g == "object" || g == "array" || d && (g.indexOf("object") >= 0 || g.indexOf("array") >= 0))
        r += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + h + "[i], " + h + "[j])) { " + l + " = false; break outer; } } } ";
      else {
        r += " var itemIndices = {}, item; for (;i--;) { var item = " + h + "[i]; ";
        var y = "checkDataType" + (d ? "s" : "");
        r += " if (" + t.util[y](g, "item", t.opts.strictNumbers, !0) + ") continue; ", d && (r += ` if (typeof item == 'string') item = '"' + item; `), r += " if (typeof itemIndices[item] == 'number') { " + l + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      r += " } ", s && (r += "  }  "), r += " if (!" + l + ") {   ";
      var v = v || [];
      v.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { i: i, j: j } ", t.opts.messages !== !1 && (r += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), t.opts.verbose && (r += " , schema:  ", s ? r += "validate.schema" + n : r += "" + a, r += "         , parentSchema: validate.schema" + t.schemaPath + " , data: " + h + " "), r += " } ") : r += " {} ";
      var T = r;
      r = v.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + T + "]); " : r += " validate.errors = [" + T + "]; return false; " : r += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", m && (r += " else { ");
    } else
      m && (r += " if (true) { ");
    return r;
  }), cs;
}
var fs, ah;
function e1() {
  return ah || (ah = 1, fs = {
    $ref: FS(),
    allOf: NS(),
    anyOf: OS(),
    $comment: US(),
    const: VS(),
    contains: MS(),
    dependencies: KS(),
    enum: jS(),
    format: qS(),
    if: $S(),
    items: GS(),
    maximum: Gp(),
    minimum: Gp(),
    maxItems: Xp(),
    minItems: Xp(),
    maxLength: Hp(),
    minLength: Hp(),
    maxProperties: Qp(),
    minProperties: Qp(),
    multipleOf: WS(),
    not: XS(),
    oneOf: zS(),
    pattern: HS(),
    properties: JS(),
    propertyNames: QS(),
    required: YS(),
    uniqueItems: ZS(),
    validate: fv()
  }), fs;
}
var ps, oh;
function t1() {
  if (oh) return ps;
  oh = 1;
  var i = e1(), t = wr().toHash;
  return ps = function() {
    var f = [
      {
        type: "number",
        rules: [
          { maximum: ["exclusiveMaximum"] },
          { minimum: ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { properties: ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ], r = ["type", "$comment"], u = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ], e = ["number", "integer", "string", "array", "object", "boolean", "null"];
    return f.all = t(r), f.types = t(e), f.forEach(function(a) {
      a.rules = a.rules.map(function(n) {
        var p;
        if (typeof n == "object") {
          var m = Object.keys(n)[0];
          p = n[m], n = m, p.forEach(function(l) {
            r.push(l), f.all[l] = !0;
          });
        }
        r.push(n);
        var h = f.all[n] = {
          keyword: n,
          code: i[n],
          implements: p
        };
        return h;
      }), f.all.$comment = {
        keyword: "$comment",
        code: i.$comment
      }, a.type && (f.types[a.type] = a);
    }), f.keywords = t(r.concat(u)), f.custom = {}, f;
  }, ps;
}
var hs, lh;
function r1() {
  if (lh) return hs;
  lh = 1;
  var i = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  return hs = function(t, o) {
    for (var f = 0; f < o.length; f++) {
      t = JSON.parse(JSON.stringify(t));
      var r = o[f].split("/"), u = t, e;
      for (e = 1; e < r.length; e++)
        u = u[r[e]];
      for (e = 0; e < i.length; e++) {
        var a = i[e], n = u[a];
        n && (u[a] = {
          anyOf: [
            n,
            { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        });
      }
    }
    return t;
  }, hs;
}
var ms, uh;
function n1() {
  if (uh) return ms;
  uh = 1;
  var i = Kf().MissingRef;
  ms = t;
  function t(o, f, r) {
    var u = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    typeof f == "function" && (r = f, f = void 0);
    var e = a(o).then(function() {
      var p = u._addSchema(o, void 0, f);
      return p.validate || n(p);
    });
    return r && e.then(
      function(p) {
        r(null, p);
      },
      r
    ), e;
    function a(p) {
      var m = p.$schema;
      return m && !u.getSchema(m) ? t.call(u, { $ref: m }, !0) : Promise.resolve();
    }
    function n(p) {
      try {
        return u._compile(p);
      } catch (h) {
        if (h instanceof i) return m(h);
        throw h;
      }
      function m(h) {
        var l = h.missingSchema;
        if (g(l)) throw new Error("Schema " + l + " is loaded but " + h.missingRef + " cannot be resolved");
        var s = u._loadingSchemas[l];
        return s || (s = u._loadingSchemas[l] = u._opts.loadSchema(l), s.then(c, c)), s.then(function(d) {
          if (!g(l))
            return a(d).then(function() {
              g(l) || u.addSchema(d, l, void 0, f);
            });
        }).then(function() {
          return n(p);
        });
        function c() {
          delete u._loadingSchemas[l];
        }
        function g(d) {
          return u._refs[d] || u._schemas[d];
        }
      }
    }
  }
  return ms;
}
var gs, ch;
function s1() {
  return ch || (ch = 1, gs = function(t, o, f) {
    var r = " ", u = t.level, e = t.dataLevel, a = t.schema[o], n = t.schemaPath + t.util.getProperty(o), p = t.errSchemaPath + "/" + o, m = !t.opts.allErrors, h, l = "data" + (e || ""), s = "valid" + u, c = "errs__" + u, g = t.opts.$data && a && a.$data, d;
    g ? (r += " var schema" + u + " = " + t.util.getData(a.$data, e, t.dataPathArr) + "; ", d = "schema" + u) : d = a;
    var y = this, v = "definition" + u, T = y.definition, b = "", S, C, x, A, R;
    if (g && T.$data) {
      R = "keywordValidate" + u;
      var L = T.validateSchema;
      r += " var " + v + " = RULES.custom['" + o + "'].definition; var " + R + " = " + v + ".validate;";
    } else {
      if (A = t.useCustomRule(y, a, t.schema, t), !A) return;
      d = "validate.schema" + n, R = A.code, S = T.compile, C = T.inline, x = T.macro;
    }
    var _ = R + ".errors", I = "i" + u, O = "ruleErr" + u, k = T.async;
    if (k && !t.async) throw new Error("async keyword in sync schema");
    if (C || x || (r += "" + _ + " = null;"), r += "var " + c + " = errors;var " + s + ";", g && T.$data && (b += "}", r += " if (" + d + " === undefined) { " + s + " = true; } else { ", L && (b += "}", r += " " + s + " = " + v + ".validateSchema(" + d + "); if (" + s + ") { ")), C)
      T.statements ? r += " " + A.validate + " " : r += " " + s + " = " + A.validate + "; ";
    else if (x) {
      var w = t.util.copy(t), b = "";
      w.level++;
      var U = "valid" + w.level;
      w.schema = A.validate, w.schemaPath = "";
      var q = t.compositeRule;
      t.compositeRule = w.compositeRule = !0;
      var F = t.validate(w).replace(/validate\.schema/g, R);
      t.compositeRule = w.compositeRule = q, r += " " + F;
    } else {
      var $ = $ || [];
      $.push(r), r = "", r += "  " + R + ".call( ", t.opts.passContext ? r += "this" : r += "self", S || T.schema === !1 ? r += " , " + l + " " : r += " , " + d + " , " + l + " , validate.schema" + t.schemaPath + " ", r += " , (dataPath || '')", t.errorPath != '""' && (r += " + " + t.errorPath);
      var P = e ? "data" + (e - 1 || "") : "parentData", X = e ? t.dataPathArr[e] : "parentDataProperty";
      r += " , " + P + " , " + X + " , rootData )  ";
      var Q = r;
      r = $.pop(), T.errors === !1 ? (r += " " + s + " = ", k && (r += "await "), r += "" + Q + "; ") : k ? (_ = "customErrors" + u, r += " var " + _ + " = null; try { " + s + " = await " + Q + "; } catch (e) { " + s + " = false; if (e instanceof ValidationError) " + _ + " = e.errors; else throw e; } ") : r += " " + _ + " = null; " + s + " = " + Q + "; ";
    }
    if (T.modifying && (r += " if (" + P + ") " + l + " = " + P + "[" + X + "];"), r += "" + b, T.valid)
      m && (r += " if (true) { ");
    else {
      r += " if ( ", T.valid === void 0 ? (r += " !", x ? r += "" + U : r += "" + s) : r += " " + !T.valid + " ", r += ") { ", h = y.keyword;
      var $ = $ || [];
      $.push(r), r = "";
      var $ = $ || [];
      $.push(r), r = "", t.createErrors !== !1 ? (r += " { keyword: '" + (h || "custom") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { keyword: '" + y.keyword + "' } ", t.opts.messages !== !1 && (r += ` , message: 'should pass "` + y.keyword + `" keyword validation' `), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + l + " "), r += " } ") : r += " {} ";
      var ue = r;
      r = $.pop(), !t.compositeRule && m ? t.async ? r += " throw new ValidationError([" + ue + "]); " : r += " validate.errors = [" + ue + "]; return false; " : r += " var err = " + ue + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      var le = r;
      r = $.pop(), C ? T.errors ? T.errors != "full" && (r += "  for (var " + I + "=" + c + "; " + I + "<errors; " + I + "++) { var " + O + " = vErrors[" + I + "]; if (" + O + ".dataPath === undefined) " + O + ".dataPath = (dataPath || '') + " + t.errorPath + "; if (" + O + ".schemaPath === undefined) { " + O + '.schemaPath = "' + p + '"; } ', t.opts.verbose && (r += " " + O + ".schema = " + d + "; " + O + ".data = " + l + "; "), r += " } ") : T.errors === !1 ? r += " " + le + " " : (r += " if (" + c + " == errors) { " + le + " } else {  for (var " + I + "=" + c + "; " + I + "<errors; " + I + "++) { var " + O + " = vErrors[" + I + "]; if (" + O + ".dataPath === undefined) " + O + ".dataPath = (dataPath || '') + " + t.errorPath + "; if (" + O + ".schemaPath === undefined) { " + O + '.schemaPath = "' + p + '"; } ', t.opts.verbose && (r += " " + O + ".schema = " + d + "; " + O + ".data = " + l + "; "), r += " } } ") : x ? (r += "   var err =   ", t.createErrors !== !1 ? (r += " { keyword: '" + (h || "custom") + "' , dataPath: (dataPath || '') + " + t.errorPath + " , schemaPath: " + t.util.toQuotedString(p) + " , params: { keyword: '" + y.keyword + "' } ", t.opts.messages !== !1 && (r += ` , message: 'should pass "` + y.keyword + `" keyword validation' `), t.opts.verbose && (r += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + t.schemaPath + " , data: " + l + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !t.compositeRule && m && (t.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; ")) : T.errors === !1 ? r += " " + le + " " : (r += " if (Array.isArray(" + _ + ")) { if (vErrors === null) vErrors = " + _ + "; else vErrors = vErrors.concat(" + _ + "); errors = vErrors.length;  for (var " + I + "=" + c + "; " + I + "<errors; " + I + "++) { var " + O + " = vErrors[" + I + "]; if (" + O + ".dataPath === undefined) " + O + ".dataPath = (dataPath || '') + " + t.errorPath + ";  " + O + '.schemaPath = "' + p + '";  ', t.opts.verbose && (r += " " + O + ".schema = " + d + "; " + O + ".data = " + l + "; "), r += " } } else { " + le + " } "), r += " } ", m && (r += " else { ");
    }
    return r;
  }), gs;
}
var i1 = "http://json-schema.org/draft-07/schema#", a1 = "http://json-schema.org/draft-07/schema#", o1 = "Core schema meta-schema", l1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, u1 = [
  "object",
  "boolean"
], c1 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, pv = {
  $schema: i1,
  $id: a1,
  title: o1,
  definitions: l1,
  type: u1,
  properties: c1,
  default: !0
}, ds, fh;
function f1() {
  if (fh) return ds;
  fh = 1;
  var i = pv;
  return ds = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: i.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: i.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  }, ds;
}
var Es, ph;
function p1() {
  if (ph) return Es;
  ph = 1;
  var i = /^[a-z_$][a-z0-9_$-]*$/i, t = s1(), o = f1();
  Es = {
    add: f,
    get: r,
    remove: u,
    validate: e
  };
  function f(a, n) {
    var p = this.RULES;
    if (p.keywords[a])
      throw new Error("Keyword " + a + " is already defined");
    if (!i.test(a))
      throw new Error("Keyword " + a + " is not a valid identifier");
    if (n) {
      this.validateKeyword(n, !0);
      var m = n.type;
      if (Array.isArray(m))
        for (var h = 0; h < m.length; h++)
          s(a, m[h], n);
      else
        s(a, m, n);
      var l = n.metaSchema;
      l && (n.$data && this._opts.$data && (l = {
        anyOf: [
          l,
          { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
        ]
      }), n.validateSchema = this.compile(l, !0));
    }
    p.keywords[a] = p.all[a] = !0;
    function s(c, g, d) {
      for (var y, v = 0; v < p.length; v++) {
        var T = p[v];
        if (T.type == g) {
          y = T;
          break;
        }
      }
      y || (y = { type: g, rules: [] }, p.push(y));
      var b = {
        keyword: c,
        definition: d,
        custom: !0,
        code: t,
        implements: d.implements
      };
      y.rules.push(b), p.custom[c] = b;
    }
    return this;
  }
  function r(a) {
    var n = this.RULES.custom[a];
    return n ? n.definition : this.RULES.keywords[a] || !1;
  }
  function u(a) {
    var n = this.RULES;
    delete n.keywords[a], delete n.all[a], delete n.custom[a];
    for (var p = 0; p < n.length; p++)
      for (var m = n[p].rules, h = 0; h < m.length; h++)
        if (m[h].keyword == a) {
          m.splice(h, 1);
          break;
        }
    return this;
  }
  function e(a, n) {
    e.errors = null;
    var p = this._validateKeyword = this._validateKeyword || this.compile(o, !0);
    if (p(a)) return !0;
    if (e.errors = p.errors, n)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(p.errors));
    return !1;
  }
  return Es;
}
var h1 = "http://json-schema.org/draft-07/schema#", m1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", g1 = "Meta-schema for $data reference (JSON Schema extension proposal)", d1 = "object", E1 = [
  "$data"
], y1 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, C1 = !1, v1 = {
  $schema: h1,
  $id: m1,
  description: g1,
  type: d1,
  required: E1,
  properties: y1,
  additionalProperties: C1
}, ys, hh;
function hv() {
  if (hh) return ys;
  hh = 1;
  var i = BS(), t = Mf(), o = PS(), f = uv(), r = cv(), u = IS(), e = t1(), a = r1(), n = wr();
  ys = c, c.prototype.validate = g, c.prototype.compile = d, c.prototype.addSchema = y, c.prototype.addMetaSchema = v, c.prototype.validateSchema = T, c.prototype.getSchema = S, c.prototype.removeSchema = A, c.prototype.addFormat = q, c.prototype.errorsText = U, c.prototype._addSchema = L, c.prototype._compile = _, c.prototype.compileAsync = n1();
  var p = p1();
  c.prototype.addKeyword = p.add, c.prototype.getKeyword = p.get, c.prototype.removeKeyword = p.remove, c.prototype.validateKeyword = p.validate;
  var m = Kf();
  c.ValidationError = m.Validation, c.MissingRefError = m.MissingRef, c.$dataMetaSchema = a;
  var h = "http://json-schema.org/draft-07/schema", l = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], s = ["/properties"];
  function c(j) {
    if (!(this instanceof c)) return new c(j);
    j = this._opts = n.copy(j) || {}, le(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = u(j.format), this._cache = j.cache || new o(), this._loadingSchemas = {}, this._compilations = [], this.RULES = e(), this._getId = I(j), j.loopRequired = j.loopRequired || 1 / 0, j.errorDataPath == "property" && (j._errorDataPathProperty = !0), j.serialize === void 0 && (j.serialize = r), this._metaOpts = ue(this), j.formats && P(this), j.keywords && X(this), F(this), typeof j.meta == "object" && this.addMetaSchema(j.meta), j.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), $(this);
  }
  function g(j, H) {
    var N;
    if (typeof j == "string") {
      if (N = this.getSchema(j), !N) throw new Error('no schema with key or ref "' + j + '"');
    } else {
      var G = this._addSchema(j);
      N = G.validate || this._compile(G);
    }
    var M = N(H);
    return N.$async !== !0 && (this.errors = N.errors), M;
  }
  function d(j, H) {
    var N = this._addSchema(j, void 0, H);
    return N.validate || this._compile(N);
  }
  function y(j, H, N, G) {
    if (Array.isArray(j)) {
      for (var M = 0; M < j.length; M++) this.addSchema(j[M], void 0, N, G);
      return this;
    }
    var Z = this._getId(j);
    if (Z !== void 0 && typeof Z != "string")
      throw new Error("schema id must be string");
    return H = t.normalizeId(H || Z), Q(this, H), this._schemas[H] = this._addSchema(j, N, G, !0), this;
  }
  function v(j, H, N) {
    return this.addSchema(j, H, N, !0), this;
  }
  function T(j, H) {
    var N = j.$schema;
    if (N !== void 0 && typeof N != "string")
      throw new Error("$schema must be a string");
    if (N = N || this._opts.defaultMeta || b(this), !N)
      return this.logger.warn("meta-schema not available"), this.errors = null, !0;
    var G = this.validate(N, j);
    if (!G && H) {
      var M = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(M);
      else throw new Error(M);
    }
    return G;
  }
  function b(j) {
    var H = j._opts.meta;
    return j._opts.defaultMeta = typeof H == "object" ? j._getId(H) || H : j.getSchema(h) ? h : void 0, j._opts.defaultMeta;
  }
  function S(j) {
    var H = x(this, j);
    switch (typeof H) {
      case "object":
        return H.validate || this._compile(H);
      case "string":
        return this.getSchema(H);
      case "undefined":
        return C(this, j);
    }
  }
  function C(j, H) {
    var N = t.schema.call(j, { schema: {} }, H);
    if (N) {
      var G = N.schema, M = N.root, Z = N.baseId, Ee = i.call(j, G, M, void 0, Z);
      return j._fragments[H] = new f({
        ref: H,
        fragment: !0,
        schema: G,
        root: M,
        baseId: Z,
        validate: Ee
      }), Ee;
    }
  }
  function x(j, H) {
    return H = t.normalizeId(H), j._schemas[H] || j._refs[H] || j._fragments[H];
  }
  function A(j) {
    if (j instanceof RegExp)
      return R(this, this._schemas, j), R(this, this._refs, j), this;
    switch (typeof j) {
      case "undefined":
        return R(this, this._schemas), R(this, this._refs), this._cache.clear(), this;
      case "string":
        var H = x(this, j);
        return H && this._cache.del(H.cacheKey), delete this._schemas[j], delete this._refs[j], this;
      case "object":
        var N = this._opts.serialize, G = N ? N(j) : j;
        this._cache.del(G);
        var M = this._getId(j);
        M && (M = t.normalizeId(M), delete this._schemas[M], delete this._refs[M]);
    }
    return this;
  }
  function R(j, H, N) {
    for (var G in H) {
      var M = H[G];
      !M.meta && (!N || N.test(G)) && (j._cache.del(M.cacheKey), delete H[G]);
    }
  }
  function L(j, H, N, G) {
    if (typeof j != "object" && typeof j != "boolean")
      throw new Error("schema should be object or boolean");
    var M = this._opts.serialize, Z = M ? M(j) : j, Ee = this._cache.get(Z);
    if (Ee) return Ee;
    G = G || this._opts.addUsedSchema !== !1;
    var ke = t.normalizeId(this._getId(j));
    ke && G && Q(this, ke);
    var Ie = this._opts.validateSchema !== !1 && !H, Je;
    Ie && !(Je = ke && ke == t.normalizeId(j.$schema)) && this.validateSchema(j, !0);
    var at = t.ids.call(this, j), lt = new f({
      id: ke,
      schema: j,
      localRefs: at,
      cacheKey: Z,
      meta: N
    });
    return ke[0] != "#" && G && (this._refs[ke] = lt), this._cache.put(Z, lt), Ie && Je && this.validateSchema(j, !0), lt;
  }
  function _(j, H) {
    if (j.compiling)
      return j.validate = M, M.schema = j.schema, M.errors = null, M.root = H || M, j.schema.$async === !0 && (M.$async = !0), M;
    j.compiling = !0;
    var N;
    j.meta && (N = this._opts, this._opts = this._metaOpts);
    var G;
    try {
      G = i.call(this, j.schema, H, j.localRefs);
    } catch (Z) {
      throw delete j.validate, Z;
    } finally {
      j.compiling = !1, j.meta && (this._opts = N);
    }
    return j.validate = G, j.refs = G.refs, j.refVal = G.refVal, j.root = G.root, G;
    function M() {
      var Z = j.validate, Ee = Z.apply(this, arguments);
      return M.errors = Z.errors, Ee;
    }
  }
  function I(j) {
    switch (j.schemaId) {
      case "auto":
        return w;
      case "id":
        return O;
      default:
        return k;
    }
  }
  function O(j) {
    return j.$id && this.logger.warn("schema $id ignored", j.$id), j.id;
  }
  function k(j) {
    return j.id && this.logger.warn("schema id ignored", j.id), j.$id;
  }
  function w(j) {
    if (j.$id && j.id && j.$id != j.id)
      throw new Error("schema $id is different from id");
    return j.$id || j.id;
  }
  function U(j, H) {
    if (j = j || this.errors, !j) return "No errors";
    H = H || {};
    for (var N = H.separator === void 0 ? ", " : H.separator, G = H.dataVar === void 0 ? "data" : H.dataVar, M = "", Z = 0; Z < j.length; Z++) {
      var Ee = j[Z];
      Ee && (M += G + Ee.dataPath + " " + Ee.message + N);
    }
    return M.slice(0, -N.length);
  }
  function q(j, H) {
    return typeof H == "string" && (H = new RegExp(H)), this._formats[j] = H, this;
  }
  function F(j) {
    var H;
    if (j._opts.$data && (H = v1, j.addMetaSchema(H, H.$id, !0)), j._opts.meta !== !1) {
      var N = pv;
      j._opts.$data && (N = a(N, s)), j.addMetaSchema(N, h, !0), j._refs["http://json-schema.org/schema"] = h;
    }
  }
  function $(j) {
    var H = j._opts.schemas;
    if (H)
      if (Array.isArray(H)) j.addSchema(H);
      else for (var N in H) j.addSchema(H[N], N);
  }
  function P(j) {
    for (var H in j._opts.formats) {
      var N = j._opts.formats[H];
      j.addFormat(H, N);
    }
  }
  function X(j) {
    for (var H in j._opts.keywords) {
      var N = j._opts.keywords[H];
      j.addKeyword(H, N);
    }
  }
  function Q(j, H) {
    if (j._schemas[H] || j._refs[H])
      throw new Error('schema with key or id "' + H + '" already exists');
  }
  function ue(j) {
    for (var H = n.copy(j._opts), N = 0; N < l.length; N++)
      delete H[l[N]];
    return H;
  }
  function le(j) {
    var H = j._opts.logger;
    if (H === !1)
      j.logger = { log: Ce, warn: Ce, error: Ce };
    else {
      if (H === void 0 && (H = console), !(typeof H == "object" && H.log && H.warn && H.error))
        throw new Error("logger must implement log, warn and error methods");
      j.logger = H;
    }
  }
  function Ce() {
  }
  return ys;
}
var S1 = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, A1 = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, T1 = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, b1 = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, x1 = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, R1 = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, D1 = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  AudioWorkletGlobalScope: !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  ClipboardItem: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  CompressionStream: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMatrixComponent: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSPerspective: !1,
  CSSRotate: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSScale: !1,
  CSSSkew: !1,
  CSSSkewX: !1,
  CSSSkewY: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CSSTransformValue: !1,
  CSSTranslate: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  DecompressionStream: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectList: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  FormDataEvent: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaMetadata: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamConstraints: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NavigatorUAData: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  OffscreenCanvasRenderingContext2D: !1,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  OverconstrainedError: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableByteStreamController: !1,
  ReadableStream: !1,
  ReadableStreamBYOBReader: !1,
  ReadableStreamBYOBRequest: !1,
  ReadableStreamDefaultController: !1,
  ReadableStreamDefaultReader: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  structuredClone: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubmitEvent: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextDecoderStream: !1,
  TextEncoder: !1,
  TextEncoderStream: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  ToggleEvent: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransformStream: !1,
  TransformStreamDefaultController: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  WritableStreamDefaultController: !1,
  WritableStreamDefaultWriter: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, L1 = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  CompressionStream: !1,
  console: !1,
  CountQueuingStrategy: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CustomEvent: !1,
  DecompressionStream: !1,
  ErrorEvent: !1,
  Event: !1,
  fetch: !1,
  File: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  ReadableByteStreamController: !1,
  ReadableStream: !1,
  ReadableStreamBYOBReader: !1,
  ReadableStreamBYOBRequest: !1,
  ReadableStreamDefaultController: !1,
  ReadableStreamDefaultReader: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  SubtleCrypto: !1,
  TextDecoder: !1,
  TextDecoderStream: !1,
  TextEncoder: !1,
  TextEncoderStream: !1,
  TransformStream: !1,
  TransformStreamDefaultController: !1,
  URL: !1,
  URLSearchParams: !1,
  WebAssembly: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  WritableStream: !1,
  WritableStreamDefaultController: !1,
  WritableStreamDefaultWriter: !1,
  XMLHttpRequest: !1
}, _1 = {
  __dirname: !1,
  __filename: !1,
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Buffer: !1,
  ByteLengthQueuingStrategy: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  CompressionStream: !1,
  console: !1,
  CountQueuingStrategy: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CustomEvent: !1,
  DecompressionStream: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  exports: !0,
  fetch: !1,
  File: !1,
  FormData: !1,
  global: !1,
  Headers: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  module: !1,
  performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformanceResourceTiming: !1,
  process: !1,
  queueMicrotask: !1,
  ReadableByteStreamController: !1,
  ReadableStream: !1,
  ReadableStreamBYOBReader: !1,
  ReadableStreamBYOBRequest: !1,
  ReadableStreamDefaultController: !1,
  ReadableStreamDefaultReader: !1,
  Request: !1,
  require: !1,
  Response: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  SubtleCrypto: !1,
  TextDecoder: !1,
  TextDecoderStream: !1,
  TextEncoder: !1,
  TextEncoderStream: !1,
  TransformStream: !1,
  TransformStreamDefaultController: !1,
  URL: !1,
  URLSearchParams: !1,
  WebAssembly: !1,
  WritableStream: !1,
  WritableStreamDefaultController: !1,
  WritableStreamDefaultWriter: !1
}, w1 = {
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Buffer: !1,
  ByteLengthQueuingStrategy: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  CompressionStream: !1,
  console: !1,
  CountQueuingStrategy: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CustomEvent: !1,
  DecompressionStream: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  fetch: !1,
  File: !1,
  FormData: !1,
  global: !1,
  Headers: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformanceResourceTiming: !1,
  process: !1,
  queueMicrotask: !1,
  ReadableByteStreamController: !1,
  ReadableStream: !1,
  ReadableStreamBYOBReader: !1,
  ReadableStreamBYOBRequest: !1,
  ReadableStreamDefaultController: !1,
  ReadableStreamDefaultReader: !1,
  Request: !1,
  Response: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  SubtleCrypto: !1,
  TextDecoder: !1,
  TextDecoderStream: !1,
  TextEncoder: !1,
  TextEncoderStream: !1,
  TransformStream: !1,
  TransformStreamDefaultController: !1,
  URL: !1,
  URLSearchParams: !1,
  WebAssembly: !1,
  WritableStream: !1,
  WritableStreamDefaultController: !1,
  WritableStreamDefaultWriter: !1
}, k1 = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, B1 = {
  define: !1,
  require: !1
}, P1 = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, I1 = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  expectAsync: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnAllFunctions: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, F1 = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, N1 = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, O1 = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, U1 = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, V1 = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, M1 = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, K1 = {
  ActiveXObject: !1,
  CollectGarbage: !1,
  Debug: !1,
  Enumerator: !1,
  GetObject: !1,
  RuntimeObject: !1,
  ScriptEngine: !1,
  ScriptEngineBuildVersion: !1,
  ScriptEngineMajorVersion: !1,
  ScriptEngineMinorVersion: !1,
  VBArray: !1,
  WScript: !1,
  WSH: !1
}, j1 = {
  $: !1,
  jQuery: !1
}, q1 = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, $1 = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, G1 = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, W1 = {
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, X1 = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, z1 = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, H1 = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  CompressionStream: !1,
  console: !1,
  CountQueuingStrategy: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CustomEvent: !1,
  DecompressionStream: !1,
  ErrorEvent: !1,
  Event: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  File: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  ReadableByteStreamController: !1,
  ReadableStream: !1,
  ReadableStreamBYOBReader: !1,
  ReadableStreamBYOBRequest: !1,
  ReadableStreamDefaultController: !1,
  ReadableStreamDefaultReader: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  SubtleCrypto: !1,
  TextDecoder: !1,
  TextDecoderStream: !1,
  TextEncoder: !1,
  TextEncoderStream: !1,
  TransformStream: !1,
  TransformStreamDefaultController: !1,
  URL: !1,
  URLSearchParams: !1,
  WebAssembly: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  WritableStream: !1,
  WritableStreamDefaultController: !1,
  WritableStreamDefaultWriter: !1,
  XMLHttpRequest: !1
}, J1 = {
  advanceClock: !1,
  atom: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, Q1 = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, Y1 = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, Z1 = {
  browser: !1,
  chrome: !1,
  opr: !1
}, eA = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addElement: !1,
  GM_addStyle: !1,
  GM_addValueChangeListener: !1,
  GM_deleteValue: !1,
  GM_download: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getTab: !1,
  GM_getTabs: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_notification: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_removeValueChangeListener: !1,
  GM_saveTab: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_unregisterMenuCommand: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, tA = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, rA = {
  builtin: S1,
  es5: A1,
  es2015: T1,
  es2017: b1,
  es2020: x1,
  es2021: R1,
  browser: D1,
  worker: L1,
  node: _1,
  nodeBuiltin: w1,
  commonjs: k1,
  amd: B1,
  mocha: P1,
  jasmine: I1,
  jest: F1,
  qunit: N1,
  phantomjs: O1,
  couch: U1,
  rhino: V1,
  nashorn: M1,
  wsh: K1,
  jquery: j1,
  yui: q1,
  shelljs: $1,
  prototypejs: G1,
  meteor: W1,
  mongo: X1,
  applescript: z1,
  serviceworker: H1,
  atomtest: J1,
  embertest: Q1,
  protractor: Y1,
  "shared-node-browser": {
    AbortController: !1,
    AbortSignal: !1,
    atob: !1,
    Blob: !1,
    BroadcastChannel: !1,
    btoa: !1,
    ByteLengthQueuingStrategy: !1,
    clearInterval: !1,
    clearTimeout: !1,
    CompressionStream: !1,
    console: !1,
    CountQueuingStrategy: !1,
    crypto: !1,
    Crypto: !1,
    CryptoKey: !1,
    CustomEvent: !1,
    DecompressionStream: !1,
    DOMException: !1,
    Event: !1,
    EventTarget: !1,
    fetch: !1,
    File: !1,
    FormData: !1,
    Headers: !1,
    Intl: !1,
    MessageChannel: !1,
    MessageEvent: !1,
    MessagePort: !1,
    performance: !1,
    PerformanceEntry: !1,
    PerformanceMark: !1,
    PerformanceMeasure: !1,
    PerformanceObserver: !1,
    PerformanceObserverEntryList: !1,
    PerformanceResourceTiming: !1,
    queueMicrotask: !1,
    ReadableByteStreamController: !1,
    ReadableStream: !1,
    ReadableStreamBYOBReader: !1,
    ReadableStreamBYOBRequest: !1,
    ReadableStreamDefaultController: !1,
    ReadableStreamDefaultReader: !1,
    Request: !1,
    Response: !1,
    setInterval: !1,
    setTimeout: !1,
    structuredClone: !1,
    SubtleCrypto: !1,
    TextDecoder: !1,
    TextDecoderStream: !1,
    TextEncoder: !1,
    TextEncoderStream: !1,
    TransformStream: !1,
    TransformStreamDefaultController: !1,
    URL: !1,
    URLSearchParams: !1,
    WebAssembly: !1,
    WritableStream: !1,
    WritableStreamDefaultController: !1,
    WritableStreamDefaultWriter: !1
  },
  webextensions: Z1,
  greasemonkey: eA,
  devtools: tA
}, Cs, mh;
function jf() {
  return mh || (mh = 1, Cs = rA), Cs;
}
var gh;
function mv() {
  if (gh) return Hr;
  gh = 1, Object.defineProperty(Hr, "__esModule", { value: !0 });
  var i = HC, t = cn, o = hv(), f = jf();
  function r(G) {
    return G && typeof G == "object" && "default" in G ? G : { default: G };
  }
  var u = /* @__PURE__ */ r(i), e = /* @__PURE__ */ r(t), a = /* @__PURE__ */ r(o), n = /* @__PURE__ */ r(f);
  const p = ["off", "warn", "error"], m = p.reduce((G, M, Z) => (G[M] = Z, G), {}), h = [0, 1, 2, "off", "warn", "error"];
  function l(G) {
    const M = Array.isArray(G) ? G[0] : G;
    return M === 0 || M === 1 || M === 2 ? M : typeof M == "string" && m[M.toLowerCase()] || 0;
  }
  function s(G) {
    G.rules && Object.keys(G.rules).forEach((M) => {
      const Z = G.rules[M];
      typeof Z == "number" ? G.rules[M] = p[Z] || p[0] : Array.isArray(Z) && typeof Z[0] == "number" && (Z[0] = p[Z[0]] || p[0]);
    });
  }
  function c(G) {
    return l(G) === 2;
  }
  function g(G) {
    let M = Array.isArray(G) ? G[0] : G;
    return typeof M == "string" && (M = M.toLowerCase()), h.indexOf(M) !== -1;
  }
  function d(G) {
    return Object.keys(G).every((M) => g(G[M]));
  }
  function y(G) {
    switch (G) {
      case "off":
        return "off";
      case !0:
      case "true":
      case "writeable":
      case "writable":
        return "writable";
      case null:
      case !1:
      case "false":
      case "readable":
      case "readonly":
        return "readonly";
      default:
        throw new Error(`'${G}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
    }
  }
  var v = {
    __proto__: null,
    getRuleSeverity: l,
    normalizeToStrings: s,
    isErrorSeverity: c,
    isValidSeverity: g,
    isEverySeverityValid: d,
    normalizeConfigGlobal: y
  };
  const T = {
    ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
    ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
    ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
  }, b = /* @__PURE__ */ new Set();
  function S(G, M) {
    const Z = JSON.stringify({ source: G, errorCode: M });
    if (b.has(Z))
      return;
    b.add(Z);
    const Ee = e.default.relative(process.cwd(), G), ke = T[M];
    process.emitWarning(
      `${ke} (found in "${Ee}")`,
      "DeprecationWarning",
      M
    );
  }
  const C = {
    id: "http://json-schema.org/draft-04/schema#",
    $schema: "http://json-schema.org/draft-04/schema#",
    description: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      positiveInteger: {
        type: "integer",
        minimum: 0
      },
      positiveIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        minItems: 1,
        uniqueItems: !0
      }
    },
    type: "object",
    properties: {
      id: {
        type: "string"
      },
      $schema: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: {},
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: !0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: !1
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: !1
      },
      maxLength: { $ref: "#/definitions/positiveInteger" },
      minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {
        anyOf: [
          { type: "boolean" },
          { $ref: "#" }
        ],
        default: {}
      },
      items: {
        anyOf: [
          { $ref: "#" },
          { $ref: "#/definitions/schemaArray" }
        ],
        default: {}
      },
      maxItems: { $ref: "#/definitions/positiveInteger" },
      minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: !1
      },
      maxProperties: { $ref: "#/definitions/positiveInteger" },
      minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: {
        anyOf: [
          { type: "boolean" },
          { $ref: "#" }
        ],
        default: {}
      },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/stringArray" }
          ]
        }
      },
      enum: {
        type: "array",
        minItems: 1,
        uniqueItems: !0
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: !0
          }
        ]
      },
      format: { type: "string" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    dependencies: {
      exclusiveMaximum: ["maximum"],
      exclusiveMinimum: ["minimum"]
    },
    default: {}
  };
  var x = (G = {}) => {
    const M = new a.default({
      meta: !1,
      useDefaults: !0,
      validateSchema: !1,
      missingRefs: "ignore",
      verbose: !0,
      schemaId: "auto",
      ...G
    });
    return M.addMetaSchema(C), M._opts.defaultMeta = C.id, M;
  };
  const A = {
    $schema: { type: "string" },
    env: { type: "object" },
    extends: { $ref: "#/definitions/stringOrStrings" },
    globals: { type: "object" },
    overrides: {
      type: "array",
      items: { $ref: "#/definitions/overrideConfig" },
      additionalItems: !1
    },
    parser: { type: ["string", "null"] },
    parserOptions: { type: "object" },
    plugins: { type: "array" },
    processor: { type: "string" },
    rules: { type: "object" },
    settings: { type: "object" },
    noInlineConfig: { type: "boolean" },
    reportUnusedDisableDirectives: { type: "boolean" },
    ecmaFeatures: { type: "object" }
    // deprecated; logs a warning when used
  }, R = {
    definitions: {
      stringOrStrings: {
        oneOf: [
          { type: "string" },
          {
            type: "array",
            items: { type: "string" },
            additionalItems: !1
          }
        ]
      },
      stringOrStringsRequired: {
        oneOf: [
          { type: "string" },
          {
            type: "array",
            items: { type: "string" },
            additionalItems: !1,
            minItems: 1
          }
        ]
      },
      // Config at top-level.
      objectConfig: {
        type: "object",
        properties: {
          root: { type: "boolean" },
          ignorePatterns: { $ref: "#/definitions/stringOrStrings" },
          ...A
        },
        additionalProperties: !1
      },
      // Config in `overrides`.
      overrideConfig: {
        type: "object",
        properties: {
          excludedFiles: { $ref: "#/definitions/stringOrStrings" },
          files: { $ref: "#/definitions/stringOrStringsRequired" },
          ...A
        },
        required: ["files"],
        additionalProperties: !1
      }
    },
    $ref: "#/definitions/objectConfig"
  };
  function L(G, M) {
    const Z = {};
    for (const [Ee, ke] of Object.entries(G))
      Object.hasOwnProperty.call(M, Ee) || (Z[Ee] = ke);
    return Z;
  }
  const _ = L(n.default.es2015, n.default.es5), I = {
    Atomics: !1,
    SharedArrayBuffer: !1
  }, O = {
    BigInt: !1,
    BigInt64Array: !1,
    BigUint64Array: !1,
    globalThis: !1
  }, k = {
    AggregateError: !1,
    FinalizationRegistry: !1,
    WeakRef: !1
  };
  var w = new Map(Object.entries({
    // Language
    builtin: {
      globals: n.default.es5
    },
    es6: {
      globals: _,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2015: {
      globals: _,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2016: {
      globals: _,
      parserOptions: {
        ecmaVersion: 7
      }
    },
    es2017: {
      globals: { ..._, ...I },
      parserOptions: {
        ecmaVersion: 8
      }
    },
    es2018: {
      globals: { ..._, ...I },
      parserOptions: {
        ecmaVersion: 9
      }
    },
    es2019: {
      globals: { ..._, ...I },
      parserOptions: {
        ecmaVersion: 10
      }
    },
    es2020: {
      globals: { ..._, ...I, ...O },
      parserOptions: {
        ecmaVersion: 11
      }
    },
    es2021: {
      globals: { ..._, ...I, ...O, ...k },
      parserOptions: {
        ecmaVersion: 12
      }
    },
    es2022: {
      globals: { ..._, ...I, ...O, ...k },
      parserOptions: {
        ecmaVersion: 13
      }
    },
    es2023: {
      globals: { ..._, ...I, ...O, ...k },
      parserOptions: {
        ecmaVersion: 14
      }
    },
    es2024: {
      globals: { ..._, ...I, ...O, ...k },
      parserOptions: {
        ecmaVersion: 15
      }
    },
    // Platforms
    browser: {
      globals: n.default.browser
    },
    node: {
      globals: n.default.node,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: !0
        }
      }
    },
    "shared-node-browser": {
      globals: n.default["shared-node-browser"]
    },
    worker: {
      globals: n.default.worker
    },
    serviceworker: {
      globals: n.default.serviceworker
    },
    // Frameworks
    commonjs: {
      globals: n.default.commonjs,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: !0
        }
      }
    },
    amd: {
      globals: n.default.amd
    },
    mocha: {
      globals: n.default.mocha
    },
    jasmine: {
      globals: n.default.jasmine
    },
    jest: {
      globals: n.default.jest
    },
    phantomjs: {
      globals: n.default.phantomjs
    },
    jquery: {
      globals: n.default.jquery
    },
    qunit: {
      globals: n.default.qunit
    },
    prototypejs: {
      globals: n.default.prototypejs
    },
    shelljs: {
      globals: n.default.shelljs
    },
    meteor: {
      globals: n.default.meteor
    },
    mongo: {
      globals: n.default.mongo
    },
    protractor: {
      globals: n.default.protractor
    },
    applescript: {
      globals: n.default.applescript
    },
    nashorn: {
      globals: n.default.nashorn
    },
    atomtest: {
      globals: n.default.atomtest
    },
    embertest: {
      globals: n.default.embertest
    },
    webextensions: {
      globals: n.default.webextensions
    },
    greasemonkey: {
      globals: n.default.greasemonkey
    }
  }));
  const U = x(), q = /* @__PURE__ */ new WeakMap(), F = Function.prototype;
  let $;
  const P = {
    error: 2,
    warn: 1,
    off: 0
  }, X = /* @__PURE__ */ new WeakSet();
  class Q {
    constructor({ builtInRules: M = /* @__PURE__ */ new Map() } = {}) {
      this.builtInRules = M;
    }
    /**
     * Gets a complete options schema for a rule.
     * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
     * @returns {Object} JSON Schema for the rule's options.
     */
    getRuleOptionsSchema(M) {
      if (!M)
        return null;
      const Z = M.schema || M.meta && M.meta.schema;
      return Array.isArray(Z) ? Z.length ? {
        type: "array",
        items: Z,
        minItems: 0,
        maxItems: Z.length
      } : {
        type: "array",
        minItems: 0,
        maxItems: 0
      } : Z || null;
    }
    /**
     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
     * @param {options} options The given options for the rule.
     * @returns {number|string} The rule's severity value
     */
    validateRuleSeverity(M) {
      const Z = Array.isArray(M) ? M[0] : M, Ee = typeof Z == "string" ? P[Z.toLowerCase()] : Z;
      if (Ee === 0 || Ee === 1 || Ee === 2)
        return Ee;
      throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${u.default.inspect(Z).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
    }
    /**
     * Validates the non-severity options passed to a rule, based on its schema.
     * @param {{create: Function}} rule The rule to validate
     * @param {Array} localOptions The options for the rule, excluding severity
     * @returns {void}
     */
    validateRuleSchema(M, Z) {
      if (!q.has(M)) {
        const ke = this.getRuleOptionsSchema(M);
        ke && q.set(M, U.compile(ke));
      }
      const Ee = q.get(M);
      if (Ee && (Ee(Z), Ee.errors))
        throw new Error(Ee.errors.map(
          (ke) => `	Value ${JSON.stringify(ke.data)} ${ke.message}.
`
        ).join(""));
    }
    /**
     * Validates a rule's options against its schema.
     * @param {{create: Function}|null} rule The rule that the config is being validated for
     * @param {string} ruleId The rule's unique name.
     * @param {Array|number} options The given options for the rule.
     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
     * no source is prepended to the message.
     * @returns {void}
     */
    validateRuleOptions(M, Z, Ee, ke = null) {
      try {
        this.validateRuleSeverity(Ee) !== 0 && this.validateRuleSchema(M, Array.isArray(Ee) ? Ee.slice(1) : []);
      } catch (Ie) {
        const Je = `Configuration for rule "${Z}" is invalid:
${Ie.message}`;
        throw typeof ke == "string" ? new Error(`${ke}:
	${Je}`) : new Error(Je);
      }
    }
    /**
     * Validates an environment object
     * @param {Object} environment The environment config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
     * @returns {void}
     */
    validateEnvironment(M, Z, Ee = F) {
      M && Object.keys(M).forEach((ke) => {
        if (!(Ee(ke) || w.get(ke) || null)) {
          const Je = `${Z}:
	Environment key "${ke}" is unknown
`;
          throw new Error(Je);
        }
      });
    }
    /**
     * Validates a rules config object
     * @param {Object} rulesConfig The rules config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
     * @returns {void}
     */
    validateRules(M, Z, Ee = F) {
      M && Object.keys(M).forEach((ke) => {
        const Ie = Ee(ke) || this.builtInRules.get(ke) || null;
        this.validateRuleOptions(Ie, ke, M[ke], Z);
      });
    }
    /**
     * Validates a `globals` section of a config file
     * @param {Object} globalsConfig The `globals` section
     * @param {string|null} source The name of the configuration source to report in the event of an error.
     * @returns {void}
     */
    validateGlobals(M, Z = null) {
      M && Object.entries(M).forEach(([Ee, ke]) => {
        try {
          y(ke);
        } catch (Ie) {
          throw new Error(`ESLint configuration of global '${Ee}' in ${Z} is invalid:
${Ie.message}`);
        }
      });
    }
    /**
     * Validate `processor` configuration.
     * @param {string|undefined} processorName The processor name.
     * @param {string} source The name of config file.
     * @param {function(id:string): Processor} getProcessor The getter of defined processors.
     * @returns {void}
     */
    validateProcessor(M, Z, Ee) {
      if (M && !Ee(M))
        throw new Error(`ESLint configuration of processor in '${Z}' is invalid: '${M}' was not found.`);
    }
    /**
     * Formats an array of schema validation errors.
     * @param {Array} errors An array of error messages to format.
     * @returns {string} Formatted error message
     */
    formatErrors(M) {
      return M.map((Z) => {
        if (Z.keyword === "additionalProperties")
          return `Unexpected top-level property "${Z.dataPath.length ? `${Z.dataPath.slice(1)}.${Z.params.additionalProperty}` : Z.params.additionalProperty}"`;
        if (Z.keyword === "type") {
          const ke = Z.dataPath.slice(1), Ie = Array.isArray(Z.schema) ? Z.schema.join("/") : Z.schema, Je = JSON.stringify(Z.data);
          return `Property "${ke}" is the wrong type (expected ${Ie} but got \`${Je}\`)`;
        }
        return `"${Z.dataPath[0] === "." ? Z.dataPath.slice(1) : Z.dataPath}" ${Z.message}. Value: ${JSON.stringify(Z.data)}`;
      }).map((Z) => `	- ${Z}.
`).join("");
    }
    /**
     * Validates the top level properties of the config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @returns {void}
     */
    validateConfigSchema(M, Z = null) {
      if ($ = $ || U.compile(R), !$(M))
        throw new Error(`ESLint configuration in ${Z} is invalid:
${this.formatErrors($.errors)}`);
      Object.hasOwnProperty.call(M, "ecmaFeatures") && S(Z, "ESLINT_LEGACY_ECMAFEATURES");
    }
    /**
     * Validates an entire config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
     * @returns {void}
     */
    validate(M, Z, Ee, ke) {
      this.validateConfigSchema(M, Z), this.validateRules(M.rules, Z, Ee), this.validateEnvironment(M.env, Z, ke), this.validateGlobals(M.globals, Z);
      for (const Ie of M.overrides || [])
        this.validateRules(Ie.rules, Z, Ee), this.validateEnvironment(Ie.env, Z, ke), this.validateGlobals(M.globals, Z);
    }
    /**
     * Validate config array object.
     * @param {ConfigArray} configArray The config array to validate.
     * @returns {void}
     */
    validateConfigArray(M) {
      const Z = Map.prototype.get.bind(M.pluginEnvironments), Ee = Map.prototype.get.bind(M.pluginProcessors), ke = Map.prototype.get.bind(M.pluginRules);
      for (const Ie of M)
        X.has(Ie) || (X.add(Ie), this.validateEnvironment(Ie.env, Ie.name, Z), this.validateGlobals(Ie.globals, Ie.name), this.validateProcessor(Ie.processor, Ie.name, Ee), this.validateRules(Ie.rules, Ie.name, ke));
    }
  }
  const ue = /^@.*\//iu;
  function le(G, M) {
    let Z = G;
    if (Z.includes("\\") && (Z = Z.replace(/\\/gu, "/")), Z.charAt(0) === "@") {
      const Ee = new RegExp(`^(@[^/]+)(?:/(?:${M})?)?$`, "u"), ke = new RegExp(`^${M}(-|$)`, "u");
      Ee.test(Z) ? Z = Z.replace(Ee, `$1/${M}`) : ke.test(Z.split("/")[1]) || (Z = Z.replace(/^@([^/]+)\/(.*)$/u, `@$1/${M}-$2`));
    } else Z.startsWith(`${M}-`) || (Z = `${M}-${Z}`);
    return Z;
  }
  function Ce(G, M) {
    if (G[0] === "@") {
      let Z = new RegExp(`^(@[^/]+)/${M}$`, "u").exec(G);
      if (Z)
        return Z[1];
      if (Z = new RegExp(`^(@[^/]+)/${M}-(.+)$`, "u").exec(G), Z)
        return `${Z[1]}/${Z[2]}`;
    } else if (G.startsWith(`${M}-`))
      return G.slice(M.length + 1);
    return G;
  }
  function j(G) {
    const M = G.match(ue);
    return M ? M[0] : "";
  }
  var H = {
    __proto__: null,
    normalizePackageName: le,
    getShorthandName: Ce,
    getNamespaceFromTerm: j
  };
  const N = {
    environments: w,
    // shared
    ConfigOps: v,
    ConfigValidator: Q,
    naming: H
  };
  return Hr.Legacy = N, Hr;
}
var Qr = { exports: {} }, Yr = { exports: {} }, vs, dh;
function nA() {
  if (dh) return vs;
  dh = 1;
  var i = 1e3, t = i * 60, o = t * 60, f = o * 24, r = f * 7, u = f * 365.25;
  vs = function(m, h) {
    h = h || {};
    var l = typeof m;
    if (l === "string" && m.length > 0)
      return e(m);
    if (l === "number" && isFinite(m))
      return h.long ? n(m) : a(m);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(m)
    );
  };
  function e(m) {
    if (m = String(m), !(m.length > 100)) {
      var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        m
      );
      if (h) {
        var l = parseFloat(h[1]), s = (h[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return l * u;
          case "weeks":
          case "week":
          case "w":
            return l * r;
          case "days":
          case "day":
          case "d":
            return l * f;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return l * o;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return l * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return l * i;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return l;
          default:
            return;
        }
      }
    }
  }
  function a(m) {
    var h = Math.abs(m);
    return h >= f ? Math.round(m / f) + "d" : h >= o ? Math.round(m / o) + "h" : h >= t ? Math.round(m / t) + "m" : h >= i ? Math.round(m / i) + "s" : m + "ms";
  }
  function n(m) {
    var h = Math.abs(m);
    return h >= f ? p(m, h, f, "day") : h >= o ? p(m, h, o, "hour") : h >= t ? p(m, h, t, "minute") : h >= i ? p(m, h, i, "second") : m + " ms";
  }
  function p(m, h, l, s) {
    var c = h >= l * 1.5;
    return Math.round(m / l) + " " + s + (c ? "s" : "");
  }
  return vs;
}
var Ss, Eh;
function gv() {
  if (Eh) return Ss;
  Eh = 1;
  function i(t) {
    f.debug = f, f.default = f, f.coerce = p, f.disable = e, f.enable = u, f.enabled = a, f.humanize = nA(), f.destroy = m, Object.keys(t).forEach((h) => {
      f[h] = t[h];
    }), f.names = [], f.skips = [], f.formatters = {};
    function o(h) {
      let l = 0;
      for (let s = 0; s < h.length; s++)
        l = (l << 5) - l + h.charCodeAt(s), l |= 0;
      return f.colors[Math.abs(l) % f.colors.length];
    }
    f.selectColor = o;
    function f(h) {
      let l, s = null, c, g;
      function d(...y) {
        if (!d.enabled)
          return;
        const v = d, T = Number(/* @__PURE__ */ new Date()), b = T - (l || T);
        v.diff = b, v.prev = l, v.curr = T, l = T, y[0] = f.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
        let S = 0;
        y[0] = y[0].replace(/%([a-zA-Z%])/g, (x, A) => {
          if (x === "%%")
            return "%";
          S++;
          const R = f.formatters[A];
          if (typeof R == "function") {
            const L = y[S];
            x = R.call(v, L), y.splice(S, 1), S--;
          }
          return x;
        }), f.formatArgs.call(v, y), (v.log || f.log).apply(v, y);
      }
      return d.namespace = h, d.useColors = f.useColors(), d.color = f.selectColor(h), d.extend = r, d.destroy = f.destroy, Object.defineProperty(d, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => s !== null ? s : (c !== f.namespaces && (c = f.namespaces, g = f.enabled(h)), g),
        set: (y) => {
          s = y;
        }
      }), typeof f.init == "function" && f.init(d), d;
    }
    function r(h, l) {
      const s = f(this.namespace + (typeof l > "u" ? ":" : l) + h);
      return s.log = this.log, s;
    }
    function u(h) {
      f.save(h), f.namespaces = h, f.names = [], f.skips = [];
      let l;
      const s = (typeof h == "string" ? h : "").split(/[\s,]+/), c = s.length;
      for (l = 0; l < c; l++)
        s[l] && (h = s[l].replace(/\*/g, ".*?"), h[0] === "-" ? f.skips.push(new RegExp("^" + h.slice(1) + "$")) : f.names.push(new RegExp("^" + h + "$")));
    }
    function e() {
      const h = [
        ...f.names.map(n),
        ...f.skips.map(n).map((l) => "-" + l)
      ].join(",");
      return f.enable(""), h;
    }
    function a(h) {
      if (h[h.length - 1] === "*")
        return !0;
      let l, s;
      for (l = 0, s = f.skips.length; l < s; l++)
        if (f.skips[l].test(h))
          return !1;
      for (l = 0, s = f.names.length; l < s; l++)
        if (f.names[l].test(h))
          return !0;
      return !1;
    }
    function n(h) {
      return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function p(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }
    function m() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return f.enable(f.load()), f;
  }
  return Ss = i, Ss;
}
var yh;
function sA() {
  return yh || (yh = 1, function(i, t) {
    t.formatArgs = f, t.save = r, t.load = u, t.useColors = o, t.storage = e(), t.destroy = /* @__PURE__ */ (() => {
      let n = !1;
      return () => {
        n || (n = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function o() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function f(n) {
      if (n[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + n[0] + (this.useColors ? "%c " : " ") + "+" + i.exports.humanize(this.diff), !this.useColors)
        return;
      const p = "color: " + this.color;
      n.splice(1, 0, p, "color: inherit");
      let m = 0, h = 0;
      n[0].replace(/%[a-zA-Z%]/g, (l) => {
        l !== "%%" && (m++, l === "%c" && (h = m));
      }), n.splice(h, 0, p);
    }
    t.log = console.debug || console.log || (() => {
    });
    function r(n) {
      try {
        n ? t.storage.setItem("debug", n) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function u() {
      let n;
      try {
        n = t.storage.getItem("debug");
      } catch {
      }
      return !n && typeof process < "u" && "env" in process && (n = process.env.DEBUG), n;
    }
    function e() {
      try {
        return localStorage;
      } catch {
      }
    }
    i.exports = gv()(t);
    const { formatters: a } = i.exports;
    a.j = function(n) {
      try {
        return JSON.stringify(n);
      } catch (p) {
        return "[UnexpectedJSONParseError]: " + p.message;
      }
    };
  }(Yr, Yr.exports)), Yr.exports;
}
var Zr = { exports: {} };
function iA() {
  return !1;
}
function aA() {
  throw new Error("tty.ReadStream is not implemented");
}
function oA() {
  throw new Error("tty.ReadStream is not implemented");
}
var lA = {
  isatty: iA,
  ReadStream: aA,
  WriteStream: oA
}, Ch;
function uA() {
  return Ch || (Ch = 1, function(i, t) {
    const o = lA, f = HC;
    t.init = m, t.log = a, t.formatArgs = u, t.save = n, t.load = p, t.useColors = r, t.destroy = f.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
      const l = require("supports-color");
      l && (l.stderr || l).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((l) => /^debug_/i.test(l)).reduce((l, s) => {
      const c = s.substring(6).toLowerCase().replace(/_([a-z])/g, (d, y) => y.toUpperCase());
      let g = process.env[s];
      return /^(yes|on|true|enabled)$/i.test(g) ? g = !0 : /^(no|off|false|disabled)$/i.test(g) ? g = !1 : g === "null" ? g = null : g = Number(g), l[c] = g, l;
    }, {});
    function r() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : o.isatty(process.stderr.fd);
    }
    function u(l) {
      const { namespace: s, useColors: c } = this;
      if (c) {
        const g = this.color, d = "\x1B[3" + (g < 8 ? g : "8;5;" + g), y = `  ${d};1m${s} \x1B[0m`;
        l[0] = y + l[0].split(`
`).join(`
` + y), l.push(d + "m+" + i.exports.humanize(this.diff) + "\x1B[0m");
      } else
        l[0] = e() + s + " " + l[0];
    }
    function e() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function a(...l) {
      return process.stderr.write(f.format(...l) + `
`);
    }
    function n(l) {
      l ? process.env.DEBUG = l : delete process.env.DEBUG;
    }
    function p() {
      return process.env.DEBUG;
    }
    function m(l) {
      l.inspectOpts = {};
      const s = Object.keys(t.inspectOpts);
      for (let c = 0; c < s.length; c++)
        l.inspectOpts[s[c]] = t.inspectOpts[s[c]];
    }
    i.exports = gv()(t);
    const { formatters: h } = i.exports;
    h.o = function(l) {
      return this.inspectOpts.colors = this.useColors, f.inspect(l, this.inspectOpts).split(`
`).map((s) => s.trim()).join(" ");
    }, h.O = function(l) {
      return this.inspectOpts.colors = this.useColors, f.inspect(l, this.inspectOpts);
    };
  }(Zr, Zr.exports)), Zr.exports;
}
var vh;
function vr() {
  return vh || (vh = 1, typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? Qr.exports = sA() : Qr.exports = uA()), Qr.exports;
}
var As, Sh;
function qf() {
  if (Sh) return As;
  Sh = 1;
  const i = qr(), t = vr()("eslint:traverser");
  function o() {
  }
  function f(e) {
    return e !== null && typeof e == "object" && typeof e.type == "string";
  }
  function r(e, a) {
    let n = e[a.type];
    return n || (n = i.getKeys(a), t('Unknown node type "%s": Estimated visitor keys %j', a.type, n)), n;
  }
  class u {
    constructor() {
      this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = null, this._enter = null, this._leave = null;
    }
    /**
     * Gives current node.
     * @returns {ASTNode} The current node.
     */
    current() {
      return this._current;
    }
    /**
     * Gives a copy of the ancestor nodes.
     * @returns {ASTNode[]} The ancestor nodes.
     */
    parents() {
      return this._parents.slice(0);
    }
    /**
     * Break the current traversal.
     * @returns {void}
     */
    break() {
      this._broken = !0;
    }
    /**
     * Skip child nodes for the current traversal.
     * @returns {void}
     */
    skip() {
      this._skipped = !0;
    }
    /**
     * Traverse the given AST tree.
     * @param {ASTNode} node The root node to traverse.
     * @param {Object} options The option object.
     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
     * @returns {void}
     */
    traverse(a, n) {
      this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = n.visitorKeys || i.KEYS, this._enter = n.enter || o, this._leave = n.leave || o, this._traverse(a, null);
    }
    /**
     * Traverse the given AST tree recursively.
     * @param {ASTNode} node The current node.
     * @param {ASTNode|null} parent The parent node.
     * @returns {void}
     * @private
     */
    _traverse(a, n) {
      if (f(a)) {
        if (this._current = a, this._skipped = !1, this._enter(a, n), !this._skipped && !this._broken) {
          const p = r(this._visitorKeys, a);
          if (p.length >= 1) {
            this._parents.push(a);
            for (let m = 0; m < p.length && !this._broken; ++m) {
              const h = a[p[m]];
              if (Array.isArray(h))
                for (let l = 0; l < h.length && !this._broken; ++l)
                  this._traverse(h[l], a);
              else
                this._traverse(h, a);
            }
            this._parents.pop();
          }
        }
        this._broken || this._leave(a, n), this._current = n;
      }
    }
    /**
     * Calculates the keys to use for traversal.
     * @param {ASTNode} node The node to read keys from.
     * @returns {string[]} An array of keys to visit on the node.
     * @private
     */
    static getKeys(a) {
      return i.getKeys(a);
    }
    /**
     * Traverse the given AST tree.
     * @param {ASTNode} node The root node to traverse.
     * @param {Object} options The option object.
     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
     * @returns {void}
     */
    static traverse(a, n) {
      new u().traverse(a, n);
    }
    /**
     * The default visitor keys.
     * @type {Object}
     */
    static get DEFAULT_VISITOR_KEYS() {
      return i.KEYS;
    }
  }
  return As = u, As;
}
var Ts = {}, Ah;
function Ft() {
  return Ah || (Ah = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 });
    var t = qr();
    function o(re, ne) {
      const ae = ne.range[0];
      let fe = re, de = !1;
      do {
        de = !1;
        for (const ee of fe.childScopes) {
          const te = ee.block.range;
          if (te[0] <= ae && ae < te[1]) {
            fe = ee, de = !0;
            break;
          }
        }
      } while (de);
      return fe;
    }
    function f(re, ne) {
      let ae = "", fe = re;
      for (typeof ne == "string" ? ae = ne : (ae = ne.name, fe = o(fe, ne)); fe != null; ) {
        const de = fe.set.get(ae);
        if (de != null)
          return de;
        fe = fe.upper;
      }
      return null;
    }
    function r(re) {
      return !this(re);
    }
    function u(re) {
      return r.bind(re);
    }
    function e(re, ne) {
      return re.type === "Punctuator" && re.value === ne;
    }
    function a(re) {
      return e(re, "=>");
    }
    function n(re) {
      return e(re, ",");
    }
    function p(re) {
      return e(re, ";");
    }
    function m(re) {
      return e(re, ":");
    }
    function h(re) {
      return e(re, "(");
    }
    function l(re) {
      return e(re, ")");
    }
    function s(re) {
      return e(re, "[");
    }
    function c(re) {
      return e(re, "]");
    }
    function g(re) {
      return e(re, "{");
    }
    function d(re) {
      return e(re, "}");
    }
    function y(re) {
      return ["Block", "Line", "Shebang"].includes(re.type);
    }
    const v = u(a), T = u(n), b = u(p), S = u(m), C = u(h), x = u(l), A = u(s), R = u(c), L = u(g), _ = u(d), I = u(y);
    function O(re, ne) {
      return re.id ? ne.getTokenAfter(re.id, h) : ne.getFirstToken(re, h);
    }
    function k(re, ne) {
      const ae = re.parent;
      let fe = null, de = null;
      if (re.type === "ArrowFunctionExpression") {
        const ee = ne.getTokenBefore(re.body, a);
        fe = ee.loc.start, de = ee.loc.end;
      } else ae.type === "Property" || ae.type === "MethodDefinition" || ae.type === "PropertyDefinition" ? (fe = ae.loc.start, de = O(re, ne).loc.start) : (fe = re.loc.start, de = O(re, ne).loc.start);
      return {
        start: { ...fe },
        end: { ...de }
      };
    }
    const w = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof Mt < "u" ? Mt : {}, U = Object.freeze(
      /* @__PURE__ */ new Set([
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "Float32Array",
        "Float64Array",
        "Function",
        "Infinity",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "isFinite",
        "isNaN",
        "isPrototypeOf",
        "JSON",
        "Map",
        "Math",
        "NaN",
        "Number",
        "Object",
        "parseFloat",
        "parseInt",
        "Promise",
        "Proxy",
        "Reflect",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "undefined",
        "unescape",
        "WeakMap",
        "WeakSet"
      ])
    ), q = new Set(
      [
        Array.isArray,
        typeof BigInt == "function" ? BigInt : void 0,
        Boolean,
        Date,
        Date.parse,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        isFinite,
        isNaN,
        isPrototypeOf,
        ...Object.getOwnPropertyNames(Math).map((re) => Math[re]).filter((re) => typeof re == "function"),
        Number,
        Number.isFinite,
        Number.isNaN,
        Number.parseFloat,
        Number.parseInt,
        Object,
        Object.entries,
        Object.is,
        Object.isExtensible,
        Object.isFrozen,
        Object.isSealed,
        Object.keys,
        Object.values,
        parseFloat,
        parseInt,
        RegExp,
        String,
        String.fromCharCode,
        String.fromCodePoint,
        String.raw,
        Symbol.for,
        Symbol.keyFor,
        unescape
      ].filter((re) => typeof re == "function")
    ), F = /* @__PURE__ */ new Set([
      Object.freeze,
      Object.preventExtensions,
      Object.seal
    ]);
    function $(re, ne) {
      let ae = re;
      for (; (typeof ae == "object" || typeof ae == "function") && ae !== null; ) {
        const fe = Object.getOwnPropertyDescriptor(ae, ne);
        if (fe)
          return fe;
        ae = Object.getPrototypeOf(ae);
      }
      return null;
    }
    function P(re, ne) {
      const ae = $(re, ne);
      return ae != null && ae.get != null;
    }
    function X(re, ne) {
      const ae = [];
      for (let fe = 0; fe < re.length; ++fe) {
        const de = re[fe];
        if (de == null)
          ae.length = fe + 1;
        else if (de.type === "SpreadElement") {
          const ee = ue(de.argument, ne);
          if (ee == null)
            return null;
          ae.push(...ee.value);
        } else {
          const ee = ue(de, ne);
          if (ee == null)
            return null;
          ae.push(ee.value);
        }
      }
      return ae;
    }
    const Q = Object.freeze({
      ArrayExpression(re, ne) {
        const ae = X(re.elements, ne);
        return ae != null ? { value: ae } : null;
      },
      AssignmentExpression(re, ne) {
        return re.operator === "=" ? ue(re.right, ne) : null;
      },
      //eslint-disable-next-line complexity
      BinaryExpression(re, ne) {
        if (re.operator === "in" || re.operator === "instanceof")
          return null;
        const ae = ue(re.left, ne), fe = ue(re.right, ne);
        if (ae != null && fe != null)
          switch (re.operator) {
            case "==":
              return { value: ae.value == fe.value };
            case "!=":
              return { value: ae.value != fe.value };
            case "===":
              return { value: ae.value === fe.value };
            case "!==":
              return { value: ae.value !== fe.value };
            case "<":
              return { value: ae.value < fe.value };
            case "<=":
              return { value: ae.value <= fe.value };
            case ">":
              return { value: ae.value > fe.value };
            case ">=":
              return { value: ae.value >= fe.value };
            case "<<":
              return { value: ae.value << fe.value };
            case ">>":
              return { value: ae.value >> fe.value };
            case ">>>":
              return { value: ae.value >>> fe.value };
            case "+":
              return { value: ae.value + fe.value };
            case "-":
              return { value: ae.value - fe.value };
            case "*":
              return { value: ae.value * fe.value };
            case "/":
              return { value: ae.value / fe.value };
            case "%":
              return { value: ae.value % fe.value };
            case "**":
              return { value: ae.value ** fe.value };
            case "|":
              return { value: ae.value | fe.value };
            case "^":
              return { value: ae.value ^ fe.value };
            case "&":
              return { value: ae.value & fe.value };
          }
        return null;
      },
      CallExpression(re, ne) {
        const ae = re.callee, fe = X(re.arguments, ne);
        if (fe != null)
          if (ae.type === "MemberExpression") {
            if (ae.property.type === "PrivateIdentifier")
              return null;
            const de = ue(ae.object, ne);
            if (de != null) {
              if (de.value == null && (de.optional || re.optional))
                return { value: void 0, optional: !0 };
              const ee = le(
                ae,
                ne
              );
              if (ee != null) {
                const te = de.value, B = ee.value;
                if (q.has(te[B]))
                  return { value: te[B](...fe) };
                if (F.has(te[B]))
                  return { value: fe[0] };
              }
            }
          } else {
            const de = ue(ae, ne);
            if (de != null) {
              if (de.value == null && re.optional)
                return { value: void 0, optional: !0 };
              const ee = de.value;
              if (q.has(ee))
                return { value: ee(...fe) };
              if (F.has(ee))
                return { value: fe[0] };
            }
          }
        return null;
      },
      ConditionalExpression(re, ne) {
        const ae = ue(re.test, ne);
        return ae != null ? ae.value ? ue(re.consequent, ne) : ue(re.alternate, ne) : null;
      },
      ExpressionStatement(re, ne) {
        return ue(re.expression, ne);
      },
      Identifier(re, ne) {
        if (ne != null) {
          const ae = f(ne, re);
          if (ae != null && ae.defs.length === 0 && U.has(ae.name) && ae.name in w)
            return { value: w[ae.name] };
          if (ae != null && ae.defs.length === 1) {
            const fe = ae.defs[0];
            if (fe.parent && fe.parent.kind === "const" && // TODO(mysticatea): don't support destructuring here.
            fe.node.id.type === "Identifier")
              return ue(fe.node.init, ne);
          }
        }
        return null;
      },
      Literal(re) {
        return (re.regex != null || re.bigint != null) && re.value == null ? null : { value: re.value };
      },
      LogicalExpression(re, ne) {
        const ae = ue(re.left, ne);
        if (ae != null) {
          if (re.operator === "||" && ae.value || re.operator === "&&" && !ae.value || re.operator === "??" && ae.value != null)
            return ae;
          const fe = ue(re.right, ne);
          if (fe != null)
            return fe;
        }
        return null;
      },
      MemberExpression(re, ne) {
        if (re.property.type === "PrivateIdentifier")
          return null;
        const ae = ue(re.object, ne);
        if (ae != null) {
          if (ae.value == null && (ae.optional || re.optional))
            return { value: void 0, optional: !0 };
          const fe = le(re, ne);
          if (fe != null && !P(ae.value, fe.value))
            return { value: ae.value[fe.value] };
        }
        return null;
      },
      ChainExpression(re, ne) {
        const ae = ue(re.expression, ne);
        return ae != null ? { value: ae.value } : null;
      },
      NewExpression(re, ne) {
        const ae = ue(re.callee, ne), fe = X(re.arguments, ne);
        if (ae != null && fe != null) {
          const de = ae.value;
          if (q.has(de))
            return { value: new de(...fe) };
        }
        return null;
      },
      ObjectExpression(re, ne) {
        const ae = {};
        for (const fe of re.properties)
          if (fe.type === "Property") {
            if (fe.kind !== "init")
              return null;
            const de = le(
              fe,
              ne
            ), ee = ue(fe.value, ne);
            if (de == null || ee == null)
              return null;
            ae[de.value] = ee.value;
          } else if (fe.type === "SpreadElement" || fe.type === "ExperimentalSpreadProperty") {
            const de = ue(
              fe.argument,
              ne
            );
            if (de == null)
              return null;
            Object.assign(ae, de.value);
          } else
            return null;
        return { value: ae };
      },
      SequenceExpression(re, ne) {
        const ae = re.expressions[re.expressions.length - 1];
        return ue(ae, ne);
      },
      TaggedTemplateExpression(re, ne) {
        const ae = ue(re.tag, ne), fe = X(
          re.quasi.expressions,
          ne
        );
        if (ae != null && fe != null) {
          const de = ae.value, ee = re.quasi.quasis.map((te) => te.value.cooked);
          if (ee.raw = re.quasi.quasis.map((te) => te.value.raw), de === String.raw)
            return { value: de(ee, ...fe) };
        }
        return null;
      },
      TemplateLiteral(re, ne) {
        const ae = X(re.expressions, ne);
        if (ae != null) {
          let fe = re.quasis[0].value.cooked;
          for (let de = 0; de < ae.length; ++de)
            fe += ae[de], fe += re.quasis[de + 1].value.cooked;
          return { value: fe };
        }
        return null;
      },
      UnaryExpression(re, ne) {
        if (re.operator === "delete")
          return null;
        if (re.operator === "void")
          return { value: void 0 };
        const ae = ue(re.argument, ne);
        if (ae != null)
          switch (re.operator) {
            case "-":
              return { value: -ae.value };
            case "+":
              return { value: +ae.value };
            case "!":
              return { value: !ae.value };
            case "~":
              return { value: ~ae.value };
            case "typeof":
              return { value: typeof ae.value };
          }
        return null;
      }
    });
    function ue(re, ne) {
      return re != null && Object.hasOwnProperty.call(Q, re.type) ? Q[re.type](re, ne) : null;
    }
    function le(re, ne) {
      const ae = re.type === "Property" ? re.key : re.property;
      return re.computed ? ue(ae, ne) : ae.type === "Identifier" ? { value: ae.name } : ae.type === "Literal" ? ae.bigint ? { value: ae.bigint } : { value: String(ae.value) } : null;
    }
    function Ce(re, ne = null) {
      try {
        return ue(re, ne);
      } catch {
        return null;
      }
    }
    function j(re, ne = null) {
      if (re && re.type === "Literal" && re.value === null) {
        if (re.regex)
          return `/${re.regex.pattern}/${re.regex.flags}`;
        if (re.bigint)
          return re.bigint;
      }
      const ae = Ce(re, ne);
      return ae && String(ae.value);
    }
    function H(re, ne) {
      switch (re.type) {
        case "MemberExpression":
          return re.computed ? j(re.property, ne) : re.property.type === "PrivateIdentifier" ? null : re.property.name;
        case "Property":
        case "MethodDefinition":
        case "PropertyDefinition":
          return re.computed ? j(re.key, ne) : re.key.type === "Literal" ? String(re.key.value) : re.key.type === "PrivateIdentifier" ? null : re.key.name;
      }
      return null;
    }
    function N(re, ne) {
      const ae = re.parent, fe = [], de = ae.type === "Property" && ae.value === re, ee = ae.type === "MethodDefinition" && ae.value === re, te = ae.type === "PropertyDefinition" && ae.value === re;
      if ((ee || te) && (ae.static && fe.push("static"), ae.key.type === "PrivateIdentifier" && fe.push("private")), re.async && fe.push("async"), re.generator && fe.push("generator"), de || ee) {
        if (ae.kind === "constructor")
          return "constructor";
        ae.kind === "get" ? fe.push("getter") : ae.kind === "set" ? fe.push("setter") : fe.push("method");
      } else te ? fe.push("method") : (re.type === "ArrowFunctionExpression" && fe.push("arrow"), fe.push("function"));
      if (de || ee || te)
        if (ae.key.type === "PrivateIdentifier")
          fe.push(`#${ae.key.name}`);
        else {
          const B = H(ae);
          if (B)
            fe.push(`'${B}'`);
          else if (ne) {
            const z = ne.getText(ae.key);
            z.includes(`
`) || fe.push(`[${z}]`);
          }
        }
      else re.id ? fe.push(`'${re.id.name}'`) : ae.type === "VariableDeclarator" && ae.id && ae.id.type === "Identifier" ? fe.push(`'${ae.id.name}'`) : (ae.type === "AssignmentExpression" || ae.type === "AssignmentPattern") && ae.left && ae.left.type === "Identifier" ? fe.push(`'${ae.left.name}'`) : ae.type === "ExportDefaultDeclaration" && ae.declaration === re && fe.push("'default'");
      return fe.join(" ");
    }
    const G = Object.freeze(
      /* @__PURE__ */ new Set([
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "|",
        "^",
        "&",
        "in"
      ])
    ), M = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
    function Z(re) {
      return re !== null && typeof re == "object" && typeof re.type == "string";
    }
    const Ee = Object.freeze(
      Object.assign(/* @__PURE__ */ Object.create(null), {
        $visit(re, ne, ae) {
          const { type: fe } = re;
          return typeof this[fe] == "function" ? this[fe](re, ne, ae) : this.$visitChildren(re, ne, ae);
        },
        $visitChildren(re, ne, ae) {
          const { type: fe } = re;
          for (const de of ae[fe] || t.getKeys(re)) {
            const ee = re[de];
            if (Array.isArray(ee)) {
              for (const te of ee)
                if (Z(te) && this.$visit(te, ne, ae))
                  return !0;
            } else if (Z(ee) && this.$visit(ee, ne, ae))
              return !0;
          }
          return !1;
        },
        ArrowFunctionExpression() {
          return !1;
        },
        AssignmentExpression() {
          return !0;
        },
        AwaitExpression() {
          return !0;
        },
        BinaryExpression(re, ne, ae) {
          return ne.considerImplicitTypeConversion && G.has(re.operator) && (re.left.type !== "Literal" || re.right.type !== "Literal") ? !0 : this.$visitChildren(re, ne, ae);
        },
        CallExpression() {
          return !0;
        },
        FunctionExpression() {
          return !1;
        },
        ImportExpression() {
          return !0;
        },
        MemberExpression(re, ne, ae) {
          return ne.considerGetters || ne.considerImplicitTypeConversion && re.computed && re.property.type !== "Literal" ? !0 : this.$visitChildren(re, ne, ae);
        },
        MethodDefinition(re, ne, ae) {
          return ne.considerImplicitTypeConversion && re.computed && re.key.type !== "Literal" ? !0 : this.$visitChildren(re, ne, ae);
        },
        NewExpression() {
          return !0;
        },
        Property(re, ne, ae) {
          return ne.considerImplicitTypeConversion && re.computed && re.key.type !== "Literal" ? !0 : this.$visitChildren(re, ne, ae);
        },
        PropertyDefinition(re, ne, ae) {
          return ne.considerImplicitTypeConversion && re.computed && re.key.type !== "Literal" ? !0 : this.$visitChildren(re, ne, ae);
        },
        UnaryExpression(re, ne, ae) {
          return re.operator === "delete" || ne.considerImplicitTypeConversion && M.has(re.operator) && re.argument.type !== "Literal" ? !0 : this.$visitChildren(re, ne, ae);
        },
        UpdateExpression() {
          return !0;
        },
        YieldExpression() {
          return !0;
        }
      })
    );
    function ke(re, ne, { considerGetters: ae = !1, considerImplicitTypeConversion: fe = !1 } = {}) {
      return Ee.$visit(
        re,
        { considerGetters: ae, considerImplicitTypeConversion: fe },
        ne.visitorKeys || t.KEYS
      );
    }
    function Ie(re, ne) {
      const ae = re.parent;
      switch (ae.type) {
        case "CallExpression":
        case "NewExpression":
          return ae.arguments.length === 1 && ae.arguments[0] === re ? ne.getTokenAfter(
            ae.callee,
            h
          ) : null;
        case "DoWhileStatement":
          return ae.test === re ? ne.getTokenAfter(
            ae.body,
            h
          ) : null;
        case "IfStatement":
        case "WhileStatement":
          return ae.test === re ? ne.getFirstToken(ae, 1) : null;
        case "ImportExpression":
          return ae.source === re ? ne.getFirstToken(ae, 1) : null;
        case "SwitchStatement":
          return ae.discriminant === re ? ne.getFirstToken(ae, 1) : null;
        case "WithStatement":
          return ae.object === re ? ne.getFirstToken(ae, 1) : null;
        default:
          return null;
      }
    }
    function Je(re, ne, ae) {
      let fe, de, ee, te, B;
      if (typeof re == "number") {
        if (fe = re | 0, de = ne, ee = ae, !(fe >= 1))
          throw new TypeError("'times' should be a positive integer.");
      } else
        fe = 1, de = re, ee = ne;
      if (de == null || // `Program` can't be parenthesized
      de.parent == null || // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`
      de.parent.type === "CatchClause" && de.parent.param === de)
        return !1;
      te = B = de;
      do
        te = ee.getTokenBefore(te), B = ee.getTokenAfter(B);
      while (te != null && B != null && h(te) && l(B) && // Avoid false positive such as `if (a) {}`
      te !== Ie(de, ee) && --fe > 0);
      return fe === 0;
    }
    const at = /\$(?:[$&`']|[1-9][0-9]?)/gu, lt = /* @__PURE__ */ new WeakMap();
    function mt(re, ne) {
      let ae = !1;
      for (let fe = ne - 1; fe >= 0 && re.charCodeAt(fe) === 92; --fe)
        ae = !ae;
      return ae;
    }
    function Y(re, ne, ae) {
      const fe = [];
      let de = 0, ee = null;
      function te(B) {
        switch (B) {
          case "$$":
            return "$";
          case "$&":
            return ee[0];
          case "$`":
            return ne.slice(0, ee.index);
          case "$'":
            return ne.slice(ee.index + ee[0].length);
          default: {
            const z = B.slice(1);
            return z in ee ? ee[z] : B;
          }
        }
      }
      for (ee of re.execAll(ne))
        fe.push(ne.slice(de, ee.index)), fe.push(ae.replace(at, te)), de = ee.index + ee[0].length;
      return fe.push(ne.slice(de)), fe.join("");
    }
    function Te(re, ne, ae) {
      const fe = [];
      let de = 0;
      for (const ee of re.execAll(ne))
        fe.push(ne.slice(de, ee.index)), fe.push(String(ae(...ee, ee.index, ee.input))), de = ee.index + ee[0].length;
      return fe.push(ne.slice(de)), fe.join("");
    }
    class Ke {
      /**
       * Initialize this matcher.
       * @param {RegExp} pattern The pattern to match.
       * @param {{escaped:boolean}} options The options.
       */
      constructor(ne, { escaped: ae = !1 } = {}) {
        if (!(ne instanceof RegExp))
          throw new TypeError("'pattern' should be a RegExp instance.");
        if (!ne.flags.includes("g"))
          throw new Error("'pattern' should contains 'g' flag.");
        lt.set(this, {
          pattern: new RegExp(ne.source, ne.flags),
          escaped: !!ae
        });
      }
      /**
       * Find the pattern in a given string.
       * @param {string} str The string to find.
       * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
       */
      *execAll(ne) {
        const { pattern: ae, escaped: fe } = lt.get(this);
        let de = null, ee = 0;
        for (ae.lastIndex = 0; (de = ae.exec(ne)) != null; )
          (fe || !mt(ne, de.index)) && (ee = ae.lastIndex, yield de, ae.lastIndex = ee);
      }
      /**
       * Check whether the pattern is found in a given string.
       * @param {string} str The string to check.
       * @returns {boolean} `true` if the pattern was found in the string.
       */
      test(ne) {
        return !this.execAll(ne).next().done;
      }
      /**
       * Replace a given string.
       * @param {string} str The string to be replaced.
       * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
       * @returns {string} The replaced string.
       */
      [Symbol.replace](ne, ae) {
        return typeof ae == "function" ? Te(this, String(ne), ae) : Y(this, String(ne), String(ae));
      }
    }
    const et = /^(?:Import|Export(?:All|Default|Named))Declaration$/u, nt = Function.call.bind(Object.hasOwnProperty), rt = Symbol("read"), ot = Symbol("call"), Ct = Symbol("construct"), dt = Symbol("esm"), vt = { require: { [ot]: !0 } };
    function W(re) {
      return re == null || re.defs.length !== 0 || re.references.some((ne) => ne.isWrite());
    }
    function Ye(re) {
      const ne = re.parent;
      switch (ne && ne.type) {
        case "ConditionalExpression":
          return ne.consequent === re || ne.alternate === re;
        case "LogicalExpression":
          return !0;
        case "SequenceExpression":
          return ne.expressions[ne.expressions.length - 1] === re;
        case "ChainExpression":
          return !0;
        default:
          return !1;
      }
    }
    class Ue {
      /**
       * Initialize this tracker.
       * @param {Scope} globalScope The global scope.
       * @param {object} [options] The options.
       * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
       * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
       */
      constructor(ne, {
        mode: ae = "strict",
        globalObjectNames: fe = ["global", "globalThis", "self", "window"]
      } = {}) {
        this.variableStack = [], this.globalScope = ne, this.mode = ae, this.globalObjectNames = fe.slice(0);
      }
      /**
       * Iterate the references of global variables.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateGlobalReferences(ne) {
        for (const ae of Object.keys(ne)) {
          const fe = ne[ae], de = [ae], ee = this.globalScope.set.get(ae);
          W(ee) || (yield* this._iterateVariableReferences(
            ee,
            de,
            fe,
            !0
          ));
        }
        for (const ae of this.globalObjectNames) {
          const fe = [], de = this.globalScope.set.get(ae);
          W(de) || (yield* this._iterateVariableReferences(
            de,
            fe,
            ne,
            !1
          ));
        }
      }
      /**
       * Iterate the references of CommonJS modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateCjsReferences(ne) {
        for (const { node: ae } of this.iterateGlobalReferences(vt)) {
          const fe = j(ae.arguments[0]);
          if (fe == null || !nt(ne, fe))
            continue;
          const de = ne[fe], ee = [fe];
          de[rt] && (yield {
            node: ae,
            path: ee,
            type: rt,
            info: de[rt]
          }), yield* this._iteratePropertyReferences(ae, ee, de);
        }
      }
      /**
       * Iterate the references of ES modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateEsmReferences(ne) {
        const ae = this.globalScope.block;
        for (const fe of ae.body) {
          if (!et.test(fe.type) || fe.source == null)
            continue;
          const de = fe.source.value;
          if (!nt(ne, de))
            continue;
          const ee = ne[de], te = [de];
          if (ee[rt] && (yield { node: fe, path: te, type: rt, info: ee[rt] }), fe.type === "ExportAllDeclaration")
            for (const B of Object.keys(ee)) {
              const z = ee[B];
              z[rt] && (yield {
                node: fe,
                path: te.concat(B),
                type: rt,
                info: z[rt]
              });
            }
          else
            for (const B of fe.specifiers) {
              const z = nt(ee, dt), ce = this._iterateImportReferences(
                B,
                te,
                z ? ee : this.mode === "legacy" ? { default: ee, ...ee } : { default: ee }
              );
              if (z)
                yield* ce;
              else
                for (const ye of ce)
                  ye.path = ye.path.filter(Ve), (ye.path.length >= 2 || ye.type !== rt) && (yield ye);
            }
        }
      }
      /**
       * Iterate the references for a given variable.
       * @param {Variable} variable The variable to iterate that references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @param {boolean} shouldReport = The flag to report those references.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateVariableReferences(ne, ae, fe, de) {
        if (!this.variableStack.includes(ne)) {
          this.variableStack.push(ne);
          try {
            for (const ee of ne.references) {
              if (!ee.isRead())
                continue;
              const te = ee.identifier;
              de && fe[rt] && (yield { node: te, path: ae, type: rt, info: fe[rt] }), yield* this._iteratePropertyReferences(te, ae, fe);
            }
          } finally {
            this.variableStack.pop();
          }
        }
      }
      /**
       * Iterate the references for a given AST node.
       * @param rootNode The AST node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      //eslint-disable-next-line complexity
      *_iteratePropertyReferences(ne, ae, fe) {
        let de = ne;
        for (; Ye(de); )
          de = de.parent;
        const ee = de.parent;
        if (ee.type === "MemberExpression") {
          if (ee.object === de) {
            const te = H(ee);
            if (te == null || !nt(fe, te))
              return;
            ae = ae.concat(te);
            const B = fe[te];
            B[rt] && (yield {
              node: ee,
              path: ae,
              type: rt,
              info: B[rt]
            }), yield* this._iteratePropertyReferences(
              ee,
              ae,
              B
            );
          }
          return;
        }
        if (ee.type === "CallExpression") {
          ee.callee === de && fe[ot] && (yield { node: ee, path: ae, type: ot, info: fe[ot] });
          return;
        }
        if (ee.type === "NewExpression") {
          ee.callee === de && fe[Ct] && (yield {
            node: ee,
            path: ae,
            type: Ct,
            info: fe[Ct]
          });
          return;
        }
        if (ee.type === "AssignmentExpression") {
          ee.right === de && (yield* this._iterateLhsReferences(ee.left, ae, fe), yield* this._iteratePropertyReferences(ee, ae, fe));
          return;
        }
        if (ee.type === "AssignmentPattern") {
          ee.right === de && (yield* this._iterateLhsReferences(ee.left, ae, fe));
          return;
        }
        ee.type === "VariableDeclarator" && ee.init === de && (yield* this._iterateLhsReferences(ee.id, ae, fe));
      }
      /**
       * Iterate the references for a given Pattern node.
       * @param {Node} patternNode The Pattern node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateLhsReferences(ne, ae, fe) {
        if (ne.type === "Identifier") {
          const de = f(this.globalScope, ne);
          de != null && (yield* this._iterateVariableReferences(
            de,
            ae,
            fe,
            !1
          ));
          return;
        }
        if (ne.type === "ObjectPattern") {
          for (const de of ne.properties) {
            const ee = H(de);
            if (ee == null || !nt(fe, ee))
              continue;
            const te = ae.concat(ee), B = fe[ee];
            B[rt] && (yield {
              node: de,
              path: te,
              type: rt,
              info: B[rt]
            }), yield* this._iterateLhsReferences(
              de.value,
              te,
              B
            );
          }
          return;
        }
        ne.type === "AssignmentPattern" && (yield* this._iterateLhsReferences(ne.left, ae, fe));
      }
      /**
       * Iterate the references for a given ModuleSpecifier node.
       * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateImportReferences(ne, ae, fe) {
        const de = ne.type;
        if (de === "ImportSpecifier" || de === "ImportDefaultSpecifier") {
          const ee = de === "ImportDefaultSpecifier" ? "default" : ne.imported.name;
          if (!nt(fe, ee))
            return;
          ae = ae.concat(ee);
          const te = fe[ee];
          te[rt] && (yield {
            node: ne,
            path: ae,
            type: rt,
            info: te[rt]
          }), yield* this._iterateVariableReferences(
            f(this.globalScope, ne.local),
            ae,
            te,
            !1
          );
          return;
        }
        if (de === "ImportNamespaceSpecifier") {
          yield* this._iterateVariableReferences(
            f(this.globalScope, ne.local),
            ae,
            fe,
            !1
          );
          return;
        }
        if (de === "ExportSpecifier") {
          const ee = ne.local.name;
          if (!nt(fe, ee))
            return;
          ae = ae.concat(ee);
          const te = fe[ee];
          te[rt] && (yield {
            node: ne,
            path: ae,
            type: rt,
            info: te[rt]
          });
        }
      }
    }
    Ue.READ = rt, Ue.CALL = ot, Ue.CONSTRUCT = Ct, Ue.ESM = dt;
    function Ve(re, ne) {
      return !(ne === 1 && re === "default");
    }
    var xe = {
      CALL: ot,
      CONSTRUCT: Ct,
      ESM: dt,
      findVariable: f,
      getFunctionHeadLocation: k,
      getFunctionNameWithKind: N,
      getInnermostScope: o,
      getPropertyName: H,
      getStaticValue: Ce,
      getStringIfConstant: j,
      hasSideEffect: ke,
      isArrowToken: a,
      isClosingBraceToken: d,
      isClosingBracketToken: c,
      isClosingParenToken: l,
      isColonToken: m,
      isCommaToken: n,
      isCommentToken: y,
      isNotArrowToken: v,
      isNotClosingBraceToken: _,
      isNotClosingBracketToken: R,
      isNotClosingParenToken: x,
      isNotColonToken: S,
      isNotCommaToken: T,
      isNotCommentToken: I,
      isNotOpeningBraceToken: L,
      isNotOpeningBracketToken: A,
      isNotOpeningParenToken: C,
      isNotSemicolonToken: b,
      isOpeningBraceToken: g,
      isOpeningBracketToken: s,
      isOpeningParenToken: h,
      isParenthesized: Je,
      isSemicolonToken: p,
      PatternMatcher: Ke,
      READ: rt,
      ReferenceTracker: Ue
    };
    i.CALL = ot, i.CONSTRUCT = Ct, i.ESM = dt, i.PatternMatcher = Ke, i.READ = rt, i.ReferenceTracker = Ue, i.default = xe, i.findVariable = f, i.getFunctionHeadLocation = k, i.getFunctionNameWithKind = N, i.getInnermostScope = o, i.getPropertyName = H, i.getStaticValue = Ce, i.getStringIfConstant = j, i.hasSideEffect = ke, i.isArrowToken = a, i.isClosingBraceToken = d, i.isClosingBracketToken = c, i.isClosingParenToken = l, i.isColonToken = m, i.isCommaToken = n, i.isCommentToken = y, i.isNotArrowToken = v, i.isNotClosingBraceToken = _, i.isNotClosingBracketToken = R, i.isNotClosingParenToken = x, i.isNotColonToken = S, i.isNotCommaToken = T, i.isNotCommentToken = I, i.isNotOpeningBraceToken = L, i.isNotOpeningBracketToken = A, i.isNotOpeningParenToken = C, i.isNotSemicolonToken = b, i.isOpeningBraceToken = g, i.isOpeningBracketToken = s, i.isOpeningParenToken = h, i.isParenthesized = Je, i.isSemicolonToken = p;
  }(Ts)), Ts;
}
var en = {}, bs, Th;
function $r() {
  return Th || (Th = 1, bs = class {
    /**
     * Initializes this cursor.
     */
    constructor() {
      this.current = null;
    }
    /**
     * Gets the first token.
     * This consumes this cursor.
     * @returns {Token|Comment} The first token or null.
     */
    getOneToken() {
      return this.moveNext() ? this.current : null;
    }
    /**
     * Gets the first tokens.
     * This consumes this cursor.
     * @returns {(Token|Comment)[]} All tokens.
     */
    getAllTokens() {
      const t = [];
      for (; this.moveNext(); )
        t.push(this.current);
      return t;
    }
    /**
     * Moves this cursor to the next token.
     * @returns {boolean} `true` if the next token exists.
     * @abstract
     */
    /* c8 ignore next */
    moveNext() {
      throw new Error("Not implemented.");
    }
  }), bs;
}
var Fr = {}, bh;
function Gr() {
  return bh || (bh = 1, Fr.search = function(t, o) {
    for (let f = 0, r = t.length - 1; f <= r; ) {
      const u = (f + r) / 2 | 0, a = t[u].range[0];
      if (o <= a) {
        if (u === f)
          return u;
        r = u;
      } else
        f = u + 1;
    }
    return t.length;
  }, Fr.getFirstIndex = function(t, o, f) {
    if (f in o)
      return o[f];
    if (f - 1 in o) {
      const r = o[f - 1], u = t[r];
      return u ? u.range[0] >= f ? r : r + 1 : t.length;
    }
    return 0;
  }, Fr.getLastIndex = function(t, o, f) {
    if (f in o)
      return o[f] - 1;
    if (f - 1 in o) {
      const r = o[f - 1], u = t[r];
      return u ? u.range[1] > f ? r - 1 : r : t.length - 1;
    }
    return t.length - 1;
  }), Fr;
}
var xs, xh;
function cA() {
  if (xh) return xs;
  xh = 1;
  const i = $r(), t = Gr();
  return xs = class extends i {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(f, r, u, e, a) {
      super(), this.tokens = f, this.comments = r, this.tokenIndex = t.getLastIndex(f, u, a), this.commentIndex = t.search(r, a) - 1, this.border = e;
    }
    /** @inheritdoc */
    moveNext() {
      const f = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null, r = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
      return f && (!r || f.range[1] > r.range[1]) ? (this.current = f, this.tokenIndex -= 1) : r ? (this.current = r, this.commentIndex -= 1) : this.current = null, !!this.current && (this.border === -1 || this.current.range[0] >= this.border);
    }
  }, xs;
}
var Rs, Rh;
function fA() {
  if (Rh) return Rs;
  Rh = 1;
  const i = $r(), t = Gr();
  return Rs = class extends i {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(f, r, u, e, a) {
      super(), this.tokens = f, this.index = t.getLastIndex(f, u, a), this.indexEnd = t.getFirstIndex(f, u, e);
    }
    /** @inheritdoc */
    moveNext() {
      return this.index >= this.indexEnd ? (this.current = this.tokens[this.index], this.index -= 1, !0) : !1;
    }
    /*
     *
     * Shorthand for performance.
     *
     */
    /** @inheritdoc */
    getOneToken() {
      return this.index >= this.indexEnd ? this.tokens[this.index] : null;
    }
  }, Rs;
}
var Ds, Dh;
function $f() {
  if (Dh) return Ds;
  Dh = 1;
  const i = $r();
  return Ds = class extends i {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     */
    constructor(o) {
      super(), this.cursor = o;
    }
    /** @inheritdoc */
    moveNext() {
      const o = this.cursor.moveNext();
      return this.current = this.cursor.current, o;
    }
  }, Ds;
}
var Ls, Lh;
function pA() {
  if (Lh) return Ls;
  Lh = 1;
  const i = $f();
  return Ls = class extends i {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {Function} predicate The predicate function to decide tokens this cursor iterates.
     */
    constructor(o, f) {
      super(o), this.predicate = f;
    }
    /** @inheritdoc */
    moveNext() {
      const o = this.predicate;
      for (; super.moveNext(); )
        if (o(this.current))
          return !0;
      return !1;
    }
  }, Ls;
}
var _s, _h;
function hA() {
  if (_h) return _s;
  _h = 1;
  const i = $r(), t = Gr();
  return _s = class extends i {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(f, r, u, e, a) {
      super(), this.tokens = f, this.comments = r, this.tokenIndex = t.getFirstIndex(f, u, e), this.commentIndex = t.search(r, e), this.border = a;
    }
    /** @inheritdoc */
    moveNext() {
      const f = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null, r = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
      return f && (!r || f.range[0] < r.range[0]) ? (this.current = f, this.tokenIndex += 1) : r ? (this.current = r, this.commentIndex += 1) : this.current = null, !!this.current && (this.border === -1 || this.current.range[1] <= this.border);
    }
  }, _s;
}
var ws, wh;
function Gf() {
  if (wh) return ws;
  wh = 1;
  const i = $r(), t = Gr();
  return ws = class extends i {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(f, r, u, e, a) {
      super(), this.tokens = f, this.index = t.getFirstIndex(f, u, e), this.indexEnd = t.getLastIndex(f, u, a);
    }
    /** @inheritdoc */
    moveNext() {
      return this.index <= this.indexEnd ? (this.current = this.tokens[this.index], this.index += 1, !0) : !1;
    }
    /*
     *
     * Shorthand for performance.
     *
     */
    /** @inheritdoc */
    getOneToken() {
      return this.index <= this.indexEnd ? this.tokens[this.index] : null;
    }
    /** @inheritdoc */
    getAllTokens() {
      return this.tokens.slice(this.index, this.indexEnd + 1);
    }
  }, ws;
}
var ks, kh;
function mA() {
  if (kh) return ks;
  kh = 1;
  const i = $f();
  return ks = class extends i {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {number} count The count of tokens this cursor iterates.
     */
    constructor(o, f) {
      super(o), this.count = f;
    }
    /** @inheritdoc */
    moveNext() {
      return this.count > 0 ? (this.count -= 1, super.moveNext()) : !1;
    }
  }, ks;
}
var Bs, Bh;
function gA() {
  if (Bh) return Bs;
  Bh = 1;
  const i = $f();
  return Bs = class extends i {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {number} count The count of tokens this cursor skips.
     */
    constructor(o, f) {
      super(o), this.count = f;
    }
    /** @inheritdoc */
    moveNext() {
      for (; this.count > 0; )
        if (this.count -= 1, !super.moveNext())
          return !1;
      return super.moveNext();
    }
  }, Bs;
}
var Ph;
function dA() {
  if (Ph) return en;
  Ph = 1;
  const i = cA(), t = fA(), o = pA(), f = hA(), r = Gf(), u = mA(), e = gA();
  class a {
    /**
     * Initializes this cursor.
     * @param {Function} TokenCursor The class of the cursor which iterates tokens only.
     * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.
     */
    constructor(p, m) {
      this.TokenCursor = p, this.TokenCommentCursor = m;
    }
    /**
     * Creates a base cursor instance that can be decorated by createCursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {boolean} includeComments The flag to iterate comments as well.
     * @returns {Cursor} The created base cursor.
     */
    createBaseCursor(p, m, h, l, s, c) {
      const g = c ? this.TokenCommentCursor : this.TokenCursor;
      return new g(p, m, h, l, s);
    }
    /**
     * Creates a cursor that iterates tokens with normalized options.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {boolean} includeComments The flag to iterate comments as well.
     * @param {Function|null} filter The predicate function to choose tokens.
     * @param {number} skip The count of tokens the cursor skips.
     * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
     * @returns {Cursor} The created cursor.
     */
    createCursor(p, m, h, l, s, c, g, d, y) {
      let v = this.createBaseCursor(p, m, h, l, s, c);
      return g && (v = new o(v, g)), d >= 1 && (v = new e(v, d)), y >= 0 && (v = new u(v, y)), v;
    }
  }
  return en.forward = new a(r, f), en.backward = new a(t, i), en;
}
var Ps, Ih;
function EA() {
  if (Ih) return Ps;
  Ih = 1;
  const i = Gf();
  return Ps = class extends i {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {number} beforeCount The number of tokens this cursor iterates before start.
     * @param {number} afterCount The number of tokens this cursor iterates after end.
     */
    constructor(o, f, r, u, e, a, n) {
      super(o, f, r, u, e), this.index = Math.max(0, this.index - a), this.indexEnd = Math.min(o.length - 1, this.indexEnd + n);
    }
  }, Ps;
}
var Is, Fh;
function yA() {
  if (Fh) return Is;
  Fh = 1;
  const i = It, { isCommentToken: t } = Ft(), o = dA(), f = Gf(), r = EA(), u = Gr(), e = Symbol("tokens"), a = Symbol("comments"), n = Symbol("indexMap");
  function p(c, g) {
    const d = /* @__PURE__ */ Object.create(null);
    let y = 0, v = 0, T = 0, b = null;
    for (; y < c.length || v < g.length; ) {
      for (T = v < g.length ? g[v].range[0] : Number.MAX_SAFE_INTEGER; y < c.length && (b = c[y].range)[0] < T; )
        d[b[0]] = y, d[b[1] - 1] = y, y += 1;
      for (T = y < c.length ? c[y].range[0] : Number.MAX_SAFE_INTEGER; v < g.length && (b = g[v].range)[0] < T; )
        d[b[0]] = y, d[b[1] - 1] = y, v += 1;
    }
    return d;
  }
  function m(c, g, d, y, v, T, b) {
    let S = !1, C = 0, x = null;
    return typeof b == "number" ? C = b | 0 : typeof b == "function" ? x = b : b && (S = !!b.includeComments, C = b.skip | 0, x = b.filter || null), i(C >= 0, "options.skip should be zero or a positive integer."), i(!x || typeof x == "function", "options.filter should be a function."), c.createCursor(g, d, y, v, T, S, x, C, -1);
  }
  function h(c, g, d, y, v, T, b) {
    let S = !1, C = 0, x = !1, A = null;
    return typeof b == "number" ? (C = b | 0, x = !0) : typeof b == "function" ? A = b : b && (S = !!b.includeComments, C = b.count | 0, x = typeof b.count == "number", A = b.filter || null), i(C >= 0, "options.count should be zero or a positive integer."), i(!A || typeof A == "function", "options.filter should be a function."), c.createCursor(g, d, y, v, T, S, A, 0, x ? C : -1);
  }
  function l(c, g, d, y, v, T, b) {
    return typeof T > "u" && typeof b > "u" ? new f(c, g, d, y, v) : typeof T == "number" || typeof T > "u" ? new r(c, g, d, y, v, T | 0, b | 0) : h(o.forward, c, g, d, y, v, T);
  }
  function s(c) {
    const g = [];
    let d = c.getOneToken();
    for (; d && t(d); )
      g.push(d), d = c.getOneToken();
    return g;
  }
  return Is = class {
    /**
     * Initializes this token store.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     */
    constructor(g, d) {
      this[e] = g, this[a] = d, this[n] = p(g, d);
    }
    //--------------------------------------------------------------------------
    // Gets single token.
    //--------------------------------------------------------------------------
    /**
     * Gets the token starting at the specified index.
     * @param {number} offset Index of the start of the token's range.
     * @param {Object} [options=0] The option object.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @returns {Token|null} The token starting at index, or null if no such token.
     */
    getTokenByRangeStart(g, d) {
      const y = d && d.includeComments, v = o.forward.createBaseCursor(
        this[e],
        this[a],
        this[n],
        g,
        -1,
        y
      ).getOneToken();
      return v && v.range[0] === g ? v : null;
    }
    /**
     * Gets the first token of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.skip=0] The count of tokens the cursor skips.
     * @returns {Token|null} An object representing the token.
     */
    getFirstToken(g, d) {
      return m(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[0],
        g.range[1],
        d
      ).getOneToken();
    }
    /**
     * Gets the last token of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getLastToken(g, d) {
      return m(
        o.backward,
        this[e],
        this[a],
        this[n],
        g.range[0],
        g.range[1],
        d
      ).getOneToken();
    }
    /**
     * Gets the token that precedes a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getTokenBefore(g, d) {
      return m(
        o.backward,
        this[e],
        this[a],
        this[n],
        -1,
        g.range[0],
        d
      ).getOneToken();
    }
    /**
     * Gets the token that follows a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getTokenAfter(g, d) {
      return m(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        -1,
        d
      ).getOneToken();
    }
    /**
     * Gets the first token between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getFirstTokenBetween(g, d, y) {
      return m(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        d.range[0],
        y
      ).getOneToken();
    }
    /**
     * Gets the last token between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getLastTokenBetween(g, d, y) {
      return m(
        o.backward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        d.range[0],
        y
      ).getOneToken();
    }
    /**
     * Gets the token that precedes a given node or token in the token stream.
     * This is defined for backward compatibility. Use `includeComments` option instead.
     * TODO: We have a plan to remove this in a future major version.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number} [skip=0] A number of tokens to skip.
     * @returns {Token|null} An object representing the token.
     * @deprecated
     */
    getTokenOrCommentBefore(g, d) {
      return this.getTokenBefore(g, { includeComments: !0, skip: d });
    }
    /**
     * Gets the token that follows a given node or token in the token stream.
     * This is defined for backward compatibility. Use `includeComments` option instead.
     * TODO: We have a plan to remove this in a future major version.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number} [skip=0] A number of tokens to skip.
     * @returns {Token|null} An object representing the token.
     * @deprecated
     */
    getTokenOrCommentAfter(g, d) {
      return this.getTokenAfter(g, { includeComments: !0, skip: d });
    }
    //--------------------------------------------------------------------------
    // Gets multiple tokens.
    //--------------------------------------------------------------------------
    /**
     * Gets the first `count` tokens of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Tokens.
     */
    getFirstTokens(g, d) {
      return h(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[0],
        g.range[1],
        d
      ).getAllTokens();
    }
    /**
     * Gets the last `count` tokens of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getLastTokens(g, d) {
      return h(
        o.backward,
        this[e],
        this[a],
        this[n],
        g.range[0],
        g.range[1],
        d
      ).getAllTokens().reverse();
    }
    /**
     * Gets the `count` tokens that precedes a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getTokensBefore(g, d) {
      return h(
        o.backward,
        this[e],
        this[a],
        this[n],
        -1,
        g.range[0],
        d
      ).getAllTokens().reverse();
    }
    /**
     * Gets the `count` tokens that follows a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getTokensAfter(g, d) {
      return h(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        -1,
        d
      ).getAllTokens();
    }
    /**
     * Gets the first `count` tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens between left and right.
     */
    getFirstTokensBetween(g, d, y) {
      return h(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        d.range[0],
        y
      ).getAllTokens();
    }
    /**
     * Gets the last `count` tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens between left and right.
     */
    getLastTokensBetween(g, d, y) {
      return h(
        o.backward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        d.range[0],
        y
      ).getAllTokens().reverse();
    }
    /**
     * Gets all tokens that are related to the given node.
     * @param {ASTNode} node The AST node.
     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Array of objects representing tokens.
     */
    /**
     * Gets all tokens that are related to the given node.
     * @param {ASTNode} node The AST node.
     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.
     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.
     * @returns {Token[]} Array of objects representing tokens.
     */
    getTokens(g, d, y) {
      return l(
        this[e],
        this[a],
        this[n],
        g.range[0],
        g.range[1],
        d,
        y
      ).getAllTokens();
    }
    /**
     * Gets all of the tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Tokens between left and right.
     */
    /**
     * Gets all of the tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {int} [padding=0] Number of extra tokens on either side of center.
     * @returns {Token[]} Tokens between left and right.
     */
    getTokensBetween(g, d, y) {
      return l(
        this[e],
        this[a],
        this[n],
        g.range[1],
        d.range[0],
        y,
        y
      ).getAllTokens();
    }
    //--------------------------------------------------------------------------
    // Others.
    //--------------------------------------------------------------------------
    /**
     * Checks whether any comments exist or not between the given 2 nodes.
     * @param {ASTNode} left The node to check.
     * @param {ASTNode} right The node to check.
     * @returns {boolean} `true` if one or more comments exist.
     */
    commentsExistBetween(g, d) {
      const y = u.search(this[a], g.range[1]);
      return y < this[a].length && this[a][y].range[1] <= d.range[0];
    }
    /**
     * Gets all comment tokens directly before the given node or token.
     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsBefore(g) {
      const d = h(
        o.backward,
        this[e],
        this[a],
        this[n],
        -1,
        g.range[0],
        { includeComments: !0 }
      );
      return s(d).reverse();
    }
    /**
     * Gets all comment tokens directly after the given node or token.
     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsAfter(g) {
      const d = h(
        o.forward,
        this[e],
        this[a],
        this[n],
        g.range[1],
        -1,
        { includeComments: !0 }
      );
      return s(d);
    }
    /**
     * Gets all comment tokens inside the given node.
     * @param {ASTNode} node The AST node to get the comments for.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsInside(g) {
      return this.getTokens(g, {
        includeComments: !0,
        filter: t
      });
    }
  }, Is;
}
var Fs, Nh;
function CA() {
  if (Nh) return Fs;
  Nh = 1;
  const i = {
    exports: !0,
    global: !1,
    module: !1,
    require: !1
  }, t = {
    Array: !1,
    Boolean: !1,
    constructor: !1,
    Date: !1,
    decodeURI: !1,
    decodeURIComponent: !1,
    encodeURI: !1,
    encodeURIComponent: !1,
    Error: !1,
    escape: !1,
    eval: !1,
    EvalError: !1,
    Function: !1,
    hasOwnProperty: !1,
    Infinity: !1,
    isFinite: !1,
    isNaN: !1,
    isPrototypeOf: !1,
    Math: !1,
    NaN: !1,
    Number: !1,
    Object: !1,
    parseFloat: !1,
    parseInt: !1,
    propertyIsEnumerable: !1,
    RangeError: !1,
    ReferenceError: !1,
    RegExp: !1,
    String: !1,
    SyntaxError: !1,
    toLocaleString: !1,
    toString: !1,
    TypeError: !1,
    undefined: !1,
    unescape: !1,
    URIError: !1,
    valueOf: !1
  }, o = {
    ...t,
    JSON: !1
  }, f = {
    ...o,
    ArrayBuffer: !1,
    DataView: !1,
    Float32Array: !1,
    Float64Array: !1,
    Int16Array: !1,
    Int32Array: !1,
    Int8Array: !1,
    Map: !1,
    Promise: !1,
    Proxy: !1,
    Reflect: !1,
    Set: !1,
    Symbol: !1,
    Uint16Array: !1,
    Uint32Array: !1,
    Uint8Array: !1,
    Uint8ClampedArray: !1,
    WeakMap: !1,
    WeakSet: !1
  }, r = {
    ...f
  }, u = {
    ...r,
    Atomics: !1,
    SharedArrayBuffer: !1
  }, e = {
    ...u
  }, a = {
    ...e
  }, n = {
    ...a,
    BigInt: !1,
    BigInt64Array: !1,
    BigUint64Array: !1,
    globalThis: !1
  }, p = {
    ...n,
    AggregateError: !1,
    FinalizationRegistry: !1,
    WeakRef: !1
  }, m = {
    ...p
  }, h = {
    ...m
  }, l = {
    ...h
  };
  return Fs = {
    commonjs: i,
    es3: t,
    es5: o,
    es2015: f,
    es2016: r,
    es2017: u,
    es2018: e,
    es2019: a,
    es2020: n,
    es2021: p,
    es2022: m,
    es2023: h,
    es2024: l
  }, Fs;
}
var Ns = { exports: {} }, Os = { exports: {} }, Us, Oh;
function vA() {
  if (Oh) return Us;
  Oh = 1;
  var i, t, o, f, r, u, e = {}.toString;
  i = a(function(n, p) {
    return n.apply(null, p);
  }), t = function(n) {
    return a(n);
  }, o = a(function(n, p, m) {
    return n(m, p);
  }), f = function(n) {
    return /* @__PURE__ */ function(p) {
      return function() {
        return n(p(p)).apply(null, arguments);
      };
    }(function(p) {
      return function() {
        return n(p(p)).apply(null, arguments);
      };
    });
  }, r = a(function(n, p, m, h) {
    return n(p(m), p(h));
  }), u = function(n) {
    var p;
    return p = {}, function() {
      var m, h, l, s, c, g;
      for (h = [], l = 0, s = arguments.length; l < s; ++l)
        h.push(arguments[l]);
      return m = h, c = function() {
        var d, y, v, T = [];
        for (d = 0, v = (y = m).length; d < v; ++d)
          g = y[d], T.push(g + e.call(g).slice(8, -1));
        return T;
      }().join(""), p[c] = c in p ? p[c] : n.apply(null, m);
    };
  }, Us = {
    curry: t,
    flip: o,
    fix: f,
    apply: i,
    over: r,
    memoize: u
  };
  function a(n, p) {
    var m, h = function(l) {
      return n.length > 1 ? function() {
        var s = l ? l.concat() : [];
        return m = this, s.push.apply(s, arguments) < n.length && arguments.length ? h.call(m, s) : n.apply(m, s);
      } : n;
    };
    return h();
  }
  return Us;
}
var Vs, Uh;
function SA() {
  if (Uh) return Vs;
  Uh = 1;
  var i, t, o, f, r, u, e, a, n, p, m, h, l, s, c, g, d, y, v, T, b, S, C, x, A, R, L, _, I, O, k, w, U, q, F, $, P, X, Q, ue, le, Ce, j, H, N, G, M, Z, Ee, ke, Ie, Je, at, lt, mt, Y, Te, Ke, et, nt, rt, ot, Ct, dt, vt, W, Ye, Ue, Ve, xe, re = {}.toString;
  i = ne(function(ee, te) {
    var B, z, ce;
    for (B = 0, z = te.length; B < z; ++B)
      ce = te[B], ee(ce);
    return te;
  }), t = ne(function(ee, te) {
    var B, z, ce, ye = [];
    for (B = 0, z = te.length; B < z; ++B)
      ce = te[B], ye.push(ee(ce));
    return ye;
  }), o = function(ee) {
    var te, B, z, ce = [];
    for (te = 0, B = ee.length; te < B; ++te)
      z = ee[te], z && ce.push(z);
    return ce;
  }, f = ne(function(ee, te) {
    var B, z, ce, ye = [];
    for (B = 0, z = te.length; B < z; ++B)
      ce = te[B], ee(ce) && ye.push(ce);
    return ye;
  }), r = ne(function(ee, te) {
    var B, z, ce, ye = [];
    for (B = 0, z = te.length; B < z; ++B)
      ce = te[B], ee(ce) || ye.push(ce);
    return ye;
  }), u = ne(function(ee, te) {
    var B, z;
    return B = Ye(ee, te), z = te.slice(), B != null && z.splice(B, 1), z;
  }), e = ne(function(ee, te) {
    var B, z, ce, ye, Be;
    for (B = [], z = [], ce = 0, ye = te.length; ce < ye; ++ce)
      Be = te[ce], (ee(Be) ? B : z).push(Be);
    return [B, z];
  }), a = ne(function(ee, te) {
    var B, z, ce;
    for (B = 0, z = te.length; B < z; ++B)
      if (ce = te[B], ee(ce))
        return ce;
  }), n = p = function(ee) {
    return ee[0];
  }, m = function(ee) {
    if (ee.length)
      return ee.slice(1);
  }, h = function(ee) {
    return ee[ee.length - 1];
  }, l = function(ee) {
    if (ee.length)
      return ee.slice(0, -1);
  }, s = function(ee) {
    return !ee.length;
  }, c = function(ee) {
    return ee.concat().reverse();
  }, g = function(ee) {
    var te, B, z, ce;
    for (te = [], B = 0, z = ee.length; B < z; ++B)
      ce = ee[B], ae(ce, te) || te.push(ce);
    return te;
  }, d = ne(function(ee, te) {
    var B, z, ce, ye, Be, we = [];
    for (B = [], z = 0, ce = te.length; z < ce; ++z)
      ye = te[z], Be = ee(ye), !ae(Be, B) && (B.push(Be), we.push(ye));
    return we;
  }), y = v = ne(function(ee, te, B) {
    var z, ce, ye;
    for (z = 0, ce = B.length; z < ce; ++z)
      ye = B[z], te = ee(te, ye);
    return te;
  }), T = b = ne(function(ee, te) {
    return y(ee, te[0], te.slice(1));
  }), S = ne(function(ee, te, B) {
    var z, ce;
    for (z = B.length - 1; z >= 0; --z)
      ce = B[z], te = ee(ce, te);
    return te;
  }), C = ne(function(ee, te) {
    return S(ee, te[te.length - 1], te.slice(0, -1));
  }), x = ne(function(ee, te) {
    var B, z, ce;
    for (B = [], z = te; (ce = ee(z)) != null; )
      B.push(ce[0]), z = ce[1];
    return B;
  }), A = function(ee) {
    return [].concat.apply([], ee);
  }, R = ne(function(ee, te) {
    var B;
    return [].concat.apply([], function() {
      var z, ce, ye, Be = [];
      for (z = 0, ye = (ce = te).length; z < ye; ++z)
        B = ce[z], Be.push(ee(B));
      return Be;
    }());
  }), L = function(ee) {
    var te;
    return [].concat.apply([], function() {
      var B, z, ce, ye = [];
      for (B = 0, ce = (z = ee).length; B < ce; ++B)
        te = z[B], re.call(te).slice(8, -1) === "Array" ? ye.push(L(te)) : ye.push(te);
      return ye;
    }());
  }, _ = function(ee) {
    var te, B, z, ce, ye, Be, we, Pe, st, We;
    for (B = [], z = 1, ce = arguments.length; z < ce; ++z)
      B.push(arguments[z]);
    te = B, ye = [];
    e: for (z = 0, Be = ee.length; z < Be; ++z) {
      for (we = ee[z], Pe = 0, st = te.length; Pe < st; ++Pe)
        if (We = te[Pe], ae(we, We))
          continue e;
      ye.push(we);
    }
    return ye;
  }, I = function(ee) {
    var te, B, z, ce, ye, Be, we, Pe, st, We;
    for (B = [], z = 1, ce = arguments.length; z < ce; ++z)
      B.push(arguments[z]);
    te = B, ye = [];
    e: for (z = 0, Be = ee.length; z < Be; ++z) {
      for (we = ee[z], Pe = 0, st = te.length; Pe < st; ++Pe)
        if (We = te[Pe], !ae(we, We))
          continue e;
      ye.push(we);
    }
    return ye;
  }, O = function() {
    var ee, te, B, z, ce, ye, Be, we, Pe, st;
    for (te = [], B = 0, z = arguments.length; B < z; ++B)
      te.push(arguments[B]);
    for (ee = te, ce = [], B = 0, ye = ee.length; B < ye; ++B)
      for (Be = ee[B], we = 0, Pe = Be.length; we < Pe; ++we)
        st = Be[we], ae(st, ce) || ce.push(st);
    return ce;
  }, k = ne(function(ee, te) {
    var B, z, ce, ye, Be;
    for (B = {}, z = 0, ce = te.length; z < ce; ++z)
      ye = te[z], Be = ee(ye), Be in B ? B[Be] += 1 : B[Be] = 1;
    return B;
  }), w = ne(function(ee, te) {
    var B, z, ce, ye, Be;
    for (B = {}, z = 0, ce = te.length; z < ce; ++z)
      ye = te[z], Be = ee(ye), Be in B ? B[Be].push(ye) : B[Be] = [ye];
    return B;
  }), U = function(ee) {
    var te, B, z;
    for (te = 0, B = ee.length; te < B; ++te)
      if (z = ee[te], !z)
        return !1;
    return !0;
  }, q = function(ee) {
    var te, B, z;
    for (te = 0, B = ee.length; te < B; ++te)
      if (z = ee[te], z)
        return !0;
    return !1;
  }, F = ne(function(ee, te) {
    var B, z, ce;
    for (B = 0, z = te.length; B < z; ++B)
      if (ce = te[B], ee(ce))
        return !0;
    return !1;
  }), $ = ne(function(ee, te) {
    var B, z, ce;
    for (B = 0, z = te.length; B < z; ++B)
      if (ce = te[B], !ee(ce))
        return !1;
    return !0;
  }), P = function(ee) {
    return ee.concat().sort(function(te, B) {
      return te > B ? 1 : te < B ? -1 : 0;
    });
  }, X = ne(function(ee, te) {
    return te.concat().sort(ee);
  }), Q = ne(function(ee, te) {
    return te.concat().sort(function(B, z) {
      return ee(B) > ee(z) ? 1 : ee(B) < ee(z) ? -1 : 0;
    });
  }), ue = function(ee) {
    var te, B, z, ce;
    for (te = 0, B = 0, z = ee.length; B < z; ++B)
      ce = ee[B], te += ce;
    return te;
  }, le = function(ee) {
    var te, B, z, ce;
    for (te = 1, B = 0, z = ee.length; B < z; ++B)
      ce = ee[B], te *= ce;
    return te;
  }, Ce = j = function(ee) {
    var te, B, z, ce;
    for (te = 0, B = 0, z = ee.length; B < z; ++B)
      ce = ee[B], te += ce;
    return te / ee.length;
  }, H = function(ee) {
    var te, B, z, ce, ye;
    for (te = ee[0], B = 0, ce = (z = ee.slice(1)).length; B < ce; ++B)
      ye = z[B], ye > te && (te = ye);
    return te;
  }, N = function(ee) {
    var te, B, z, ce, ye;
    for (te = ee[0], B = 0, ce = (z = ee.slice(1)).length; B < ce; ++B)
      ye = z[B], ye < te && (te = ye);
    return te;
  }, G = ne(function(ee, te) {
    var B, z, ce, ye, Be;
    for (B = te[0], z = 0, ye = (ce = te.slice(1)).length; z < ye; ++z)
      Be = ce[z], ee(Be) > ee(B) && (B = Be);
    return B;
  }), M = ne(function(ee, te) {
    var B, z, ce, ye, Be;
    for (B = te[0], z = 0, ye = (ce = te.slice(1)).length; z < ye; ++z)
      Be = ce[z], ee(Be) < ee(B) && (B = Be);
    return B;
  }), Z = Ee = ne(function(ee, te, B) {
    var z, ce;
    return z = te, [te].concat(function() {
      var ye, Be, we, Pe = [];
      for (ye = 0, we = (Be = B).length; ye < we; ++ye)
        ce = Be[ye], Pe.push(z = ee(z, ce));
      return Pe;
    }());
  }), ke = Ie = ne(function(ee, te) {
    if (te.length)
      return Z(ee, te[0], te.slice(1));
  }), Je = ne(function(ee, te, B) {
    return B = B.concat().reverse(), Z(ee, te, B).reverse();
  }), at = ne(function(ee, te) {
    if (te.length)
      return te = te.concat().reverse(), Z(ee, te[0], te.slice(1)).reverse();
  }), lt = ne(function(ee, te, B) {
    return B.slice(ee, te);
  }), mt = ne(function(ee, te) {
    return ee <= 0 ? te.slice(0, 0) : te.slice(0, ee);
  }), Y = ne(function(ee, te) {
    return ee <= 0 ? te : te.slice(ee);
  }), Te = ne(function(ee, te) {
    return [mt(ee, te), Y(ee, te)];
  }), Ke = ne(function(ee, te) {
    var B, z;
    if (B = te.length, !B)
      return te;
    for (z = 0; z < B && ee(te[z]); )
      z += 1;
    return te.slice(0, z);
  }), et = ne(function(ee, te) {
    var B, z;
    if (B = te.length, !B)
      return te;
    for (z = 0; z < B && ee(te[z]); )
      z += 1;
    return te.slice(z);
  }), nt = ne(function(ee, te) {
    return [Ke(ee, te), et(ee, te)];
  }), rt = ne(function(ee, te) {
    return nt(fe(ee, de), te);
  }), ot = ne(function(ee, te) {
    var B, z, ce, ye, Be, we;
    for (B = [], z = te.length, ce = 0, ye = ee.length; ce < ye && (Be = ce, we = ee[ce], Be !== z); ++ce)
      B.push([we, te[Be]]);
    return B;
  }), Ct = ne(function(ee, te, B) {
    var z, ce, ye, Be, we, Pe;
    for (z = [], ce = B.length, ye = 0, Be = te.length; ye < Be && (we = ye, Pe = te[ye], we !== ce); ++ye)
      z.push(ee(Pe, B[we]));
    return z;
  }), dt = function() {
    var ee, te, B, z, ce, ye, Be, we, Pe, st, We, _e = [];
    for (te = [], B = 0, z = arguments.length; B < z; ++B)
      te.push(arguments[B]);
    for (ee = te, ce = void 0, B = 0, ye = ee.length; B < ye; ++B)
      Be = ee[B], ce <= (we = Be.length) || (ce = we);
    for (B = 0; B < ce; ++B) {
      for (Pe = B, st = [], We = 0, ye = ee.length; We < ye; ++We)
        Be = ee[We], st.push(Be[Pe]);
      _e.push(st);
    }
    return _e;
  }, vt = function(ee) {
    var te, B, z, ce, ye, Be, we, Pe, st, We = [];
    for (B = [], z = 1, ce = arguments.length; z < ce; ++z)
      B.push(arguments[z]);
    for (te = B, ye = void 0, z = 0, Be = te.length; z < Be; ++z)
      we = te[z], ye <= (Pe = we.length) || (ye = Pe);
    for (z = 0; z < ye; ++z)
      st = z, We.push(ee.apply(null, _e()));
    return We;
    function _e() {
      var je, $e, Ae, oe = [];
      for (je = 0, Ae = ($e = te).length; je < Ae; ++je)
        we = $e[je], oe.push(we[st]);
      return oe;
    }
  }, W = ne(function(ee, te) {
    return ee < 0 ? te[te.length + ee] : te[ee];
  }), Ye = ne(function(ee, te) {
    var B, z, ce, ye;
    for (B = 0, z = te.length; B < z; ++B)
      if (ce = B, ye = te[B], ye === ee)
        return ce;
  }), Ue = ne(function(ee, te) {
    var B, z, ce, ye, Be = [];
    for (B = 0, z = te.length; B < z; ++B)
      ce = B, ye = te[B], ye === ee && Be.push(ce);
    return Be;
  }), Ve = ne(function(ee, te) {
    var B, z, ce, ye;
    for (B = 0, z = te.length; B < z; ++B)
      if (ce = B, ye = te[B], ee(ye))
        return ce;
  }), xe = ne(function(ee, te) {
    var B, z, ce, ye, Be = [];
    for (B = 0, z = te.length; B < z; ++B)
      ce = B, ye = te[B], ee(ye) && Be.push(ce);
    return Be;
  }), Vs = {
    each: i,
    map: t,
    filter: f,
    compact: o,
    reject: r,
    remove: u,
    partition: e,
    find: a,
    head: n,
    first: p,
    tail: m,
    last: h,
    initial: l,
    empty: s,
    reverse: c,
    difference: _,
    intersection: I,
    union: O,
    countBy: k,
    groupBy: w,
    fold: y,
    fold1: T,
    foldl: v,
    foldl1: b,
    foldr: S,
    foldr1: C,
    unfoldr: x,
    andList: U,
    orList: q,
    any: F,
    all: $,
    unique: g,
    uniqueBy: d,
    sort: P,
    sortWith: X,
    sortBy: Q,
    sum: ue,
    product: le,
    mean: Ce,
    average: j,
    concat: A,
    concatMap: R,
    flatten: L,
    maximum: H,
    minimum: N,
    maximumBy: G,
    minimumBy: M,
    scan: Z,
    scan1: ke,
    scanl: Ee,
    scanl1: Ie,
    scanr: Je,
    scanr1: at,
    slice: lt,
    take: mt,
    drop: Y,
    splitAt: Te,
    takeWhile: Ke,
    dropWhile: et,
    span: nt,
    breakList: rt,
    zip: ot,
    zipWith: Ct,
    zipAll: dt,
    zipAllWith: vt,
    at: W,
    elemIndex: Ye,
    elemIndices: Ue,
    findIndex: Ve,
    findIndices: xe
  };
  function ne(ee, te) {
    var B, z = function(ce) {
      return ee.length > 1 ? function() {
        var ye = ce ? ce.concat() : [];
        return B = this, ye.push.apply(ye, arguments) < ee.length && arguments.length ? z.call(B, ye) : ee.apply(B, ye);
      } : ee;
    };
    return z();
  }
  function ae(ee, te) {
    for (var B = -1, z = te.length >>> 0; ++B < z; ) if (ee === te[B]) return !0;
    return !1;
  }
  function fe() {
    var ee = arguments;
    return function() {
      var te, B;
      for (B = ee[0].apply(this, arguments), te = 1; te < ee.length; ++te)
        B = ee[te](B);
      return B;
    };
  }
  function de(ee) {
    return !ee;
  }
  return Vs;
}
var Ms, Vh;
function AA() {
  if (Vh) return Ms;
  Vh = 1;
  var i, t, o, f, r, u, e, a, n, p, m, h, l, s;
  i = function(g) {
    var d, y, v = [];
    for (d in g)
      y = g[d], v.push(y);
    return v;
  }, t = function(g) {
    var d, y = [];
    for (d in g)
      y.push(d);
    return y;
  }, o = function(g) {
    var d, y, v, T = {};
    for (d = 0, y = g.length; d < y; ++d)
      v = g[d], T[v[0]] = v[1];
    return T;
  }, f = function(g) {
    var d, y, v = [];
    for (d in g)
      y = g[d], v.push([d, y]);
    return v;
  }, r = c(function(g, d) {
    var y, v, T, b, S = {};
    for (y = 0, v = g.length; y < v; ++y)
      T = y, b = g[y], S[b] = d[T];
    return S;
  }), u = function(g) {
    var d, y, v, T;
    d = [], y = [];
    for (v in g)
      T = g[v], d.push(v), y.push(T);
    return [d, y];
  }, e = function(g) {
    var d;
    for (d in g)
      return !1;
    return !0;
  }, a = c(function(g, d) {
    var y, v;
    for (y in d)
      v = d[y], g(v);
    return d;
  }), n = c(function(g, d) {
    var y, v, T = {};
    for (y in d)
      v = d[y], T[y] = g(v);
    return T;
  }), p = function(g) {
    var d, y, v = {};
    for (d in g)
      y = g[d], y && (v[d] = y);
    return v;
  }, m = c(function(g, d) {
    var y, v, T = {};
    for (y in d)
      v = d[y], g(v) && (T[y] = v);
    return T;
  }), h = c(function(g, d) {
    var y, v, T = {};
    for (y in d)
      v = d[y], g(v) || (T[y] = v);
    return T;
  }), l = c(function(g, d) {
    var y, v, T, b;
    y = {}, v = {};
    for (T in d)
      b = d[T], (g(b) ? y : v)[T] = b;
    return [y, v];
  }), s = c(function(g, d) {
    var y, v;
    for (y in d)
      if (v = d[y], g(v))
        return v;
  }), Ms = {
    values: i,
    keys: t,
    pairsToObj: o,
    objToPairs: f,
    listsToObj: r,
    objToLists: u,
    empty: e,
    each: a,
    map: n,
    filter: m,
    compact: p,
    reject: h,
    partition: l,
    find: s
  };
  function c(g, d) {
    var y, v = function(T) {
      return g.length > 1 ? function() {
        var b = T ? T.concat() : [];
        return y = this, b.push.apply(b, arguments) < g.length && arguments.length ? v.call(y, b) : g.apply(y, b);
      } : g;
    };
    return v();
  }
  return Ms;
}
var Ks, Mh;
function TA() {
  if (Mh) return Ks;
  Mh = 1;
  var i, t, o, f, r, u, e, a, n, p, m, h, l;
  i = s(function(c, g) {
    return g.split(c);
  }), t = s(function(c, g) {
    return g.join(c);
  }), o = function(c) {
    return c.length ? c.split(`
`) : [];
  }, f = function(c) {
    return c.join(`
`);
  }, r = function(c) {
    return c.length ? c.split(/[ ]+/) : [];
  }, u = function(c) {
    return c.join(" ");
  }, e = function(c) {
    return c.split("");
  }, a = function(c) {
    return c.join("");
  }, n = function(c) {
    return c.split("").reverse().join("");
  }, p = s(function(c, g) {
    var d, y;
    for (d = "", y = 0; y < c; ++y)
      d += g;
    return d;
  }), m = function(c) {
    return c.charAt(0).toUpperCase() + c.slice(1);
  }, h = function(c) {
    return c.replace(/[-_]+(.)?/g, function(g, d) {
      return (d ?? "").toUpperCase();
    });
  }, l = function(c) {
    return c.replace(/([^-A-Z])([A-Z]+)/g, function(g, d, y) {
      return d + "-" + (y.length > 1 ? y : y.toLowerCase());
    }).replace(/^([A-Z]+)/, function(g, d) {
      return d.length > 1 ? d + "-" : d.toLowerCase();
    });
  }, Ks = {
    split: i,
    join: t,
    lines: o,
    unlines: f,
    words: r,
    unwords: u,
    chars: e,
    unchars: a,
    reverse: n,
    repeat: p,
    capitalize: m,
    camelize: h,
    dasherize: l
  };
  function s(c, g) {
    var d, y = function(v) {
      return c.length > 1 ? function() {
        var T = v ? v.concat() : [];
        return d = this, T.push.apply(T, arguments) < c.length && arguments.length ? y.call(d, T) : c.apply(d, T);
      } : c;
    };
    return y();
  }
  return Ks;
}
var js, Kh;
function bA() {
  if (Kh) return js;
  Kh = 1;
  var i, t, o, f, r, u, e, a, n, p, m, h, l, s, c, g, d, y, v, T, b, S, C, x, A, R, L, _, I, O, k, w;
  i = U(function(q, F) {
    return q > F ? q : F;
  }), t = U(function(q, F) {
    return q < F ? q : F;
  }), o = function(q) {
    return -q;
  }, f = Math.abs, r = function(q) {
    return q < 0 ? -1 : q > 0 ? 1 : 0;
  }, u = U(function(q, F) {
    return ~~(q / F);
  }), e = U(function(q, F) {
    return q % F;
  }), a = U(function(q, F) {
    return Math.floor(q / F);
  }), n = U(function(q, F) {
    var $;
    return (q % ($ = F) + $) % $;
  }), p = function(q) {
    return 1 / q;
  }, m = Math.PI, h = m * 2, l = Math.exp, s = Math.sqrt, c = Math.log, g = U(function(q, F) {
    return Math.pow(q, F);
  }), d = Math.sin, y = Math.tan, v = Math.cos, T = Math.asin, b = Math.acos, S = Math.atan, C = U(function(q, F) {
    return Math.atan2(q, F);
  }), x = function(q) {
    return ~~q;
  }, A = Math.round, R = Math.ceil, L = Math.floor, _ = function(q) {
    return q !== q;
  }, I = function(q) {
    return q % 2 === 0;
  }, O = function(q) {
    return q % 2 !== 0;
  }, k = U(function(q, F) {
    var $;
    for (q = Math.abs(q), F = Math.abs(F); F !== 0; )
      $ = q % F, q = F, F = $;
    return q;
  }), w = U(function(q, F) {
    return Math.abs(Math.floor(q / k(q, F) * F));
  }), js = {
    max: i,
    min: t,
    negate: o,
    abs: f,
    signum: r,
    quot: u,
    rem: e,
    div: a,
    mod: n,
    recip: p,
    pi: m,
    tau: h,
    exp: l,
    sqrt: s,
    ln: c,
    pow: g,
    sin: d,
    tan: y,
    cos: v,
    acos: b,
    asin: T,
    atan: S,
    atan2: C,
    truncate: x,
    round: A,
    ceiling: R,
    floor: L,
    isItNaN: _,
    even: I,
    odd: O,
    gcd: k,
    lcm: w
  };
  function U(q, F) {
    var $, P = function(X) {
      return q.length > 1 ? function() {
        var Q = X ? X.concat() : [];
        return $ = this, Q.push.apply(Q, arguments) < q.length && arguments.length ? P.call($, Q) : q.apply($, Q);
      } : q;
    };
    return P();
  }
  return js;
}
var qs, jh;
function dv() {
  if (jh) return qs;
  jh = 1;
  var i, t, o, f, r, u, e, a, n, p = {}.toString;
  i = vA(), t = SA(), o = AA(), f = TA(), r = bA(), u = function(h) {
    return h;
  }, e = m(function(h, l) {
    return p.call(l).slice(8, -1) === h;
  }), a = m(function(h, l) {
    var s, c = [];
    for (s = 0; s < h; ++s)
      c.push(l);
    return c;
  }), f.empty = t.empty, f.slice = t.slice, f.take = t.take, f.drop = t.drop, f.splitAt = t.splitAt, f.takeWhile = t.takeWhile, f.dropWhile = t.dropWhile, f.span = t.span, f.breakStr = t.breakList, n = {
    Func: i,
    List: t,
    Obj: o,
    Str: f,
    Num: r,
    id: u,
    isType: e,
    replicate: a
  }, n.each = t.each, n.map = t.map, n.filter = t.filter, n.compact = t.compact, n.reject = t.reject, n.partition = t.partition, n.find = t.find, n.head = t.head, n.first = t.first, n.tail = t.tail, n.last = t.last, n.initial = t.initial, n.empty = t.empty, n.reverse = t.reverse, n.difference = t.difference, n.intersection = t.intersection, n.union = t.union, n.countBy = t.countBy, n.groupBy = t.groupBy, n.fold = t.fold, n.foldl = t.foldl, n.fold1 = t.fold1, n.foldl1 = t.foldl1, n.foldr = t.foldr, n.foldr1 = t.foldr1, n.unfoldr = t.unfoldr, n.andList = t.andList, n.orList = t.orList, n.any = t.any, n.all = t.all, n.unique = t.unique, n.uniqueBy = t.uniqueBy, n.sort = t.sort, n.sortWith = t.sortWith, n.sortBy = t.sortBy, n.sum = t.sum, n.product = t.product, n.mean = t.mean, n.average = t.average, n.concat = t.concat, n.concatMap = t.concatMap, n.flatten = t.flatten, n.maximum = t.maximum, n.minimum = t.minimum, n.maximumBy = t.maximumBy, n.minimumBy = t.minimumBy, n.scan = t.scan, n.scanl = t.scanl, n.scan1 = t.scan1, n.scanl1 = t.scanl1, n.scanr = t.scanr, n.scanr1 = t.scanr1, n.slice = t.slice, n.take = t.take, n.drop = t.drop, n.splitAt = t.splitAt, n.takeWhile = t.takeWhile, n.dropWhile = t.dropWhile, n.span = t.span, n.breakList = t.breakList, n.zip = t.zip, n.zipWith = t.zipWith, n.zipAll = t.zipAll, n.zipAllWith = t.zipAllWith, n.at = t.at, n.elemIndex = t.elemIndex, n.elemIndices = t.elemIndices, n.findIndex = t.findIndex, n.findIndices = t.findIndices, n.apply = i.apply, n.curry = i.curry, n.flip = i.flip, n.fix = i.fix, n.over = i.over, n.split = f.split, n.join = f.join, n.lines = f.lines, n.unlines = f.unlines, n.words = f.words, n.unwords = f.unwords, n.chars = f.chars, n.unchars = f.unchars, n.repeat = f.repeat, n.capitalize = f.capitalize, n.camelize = f.camelize, n.dasherize = f.dasherize, n.values = o.values, n.keys = o.keys, n.pairsToObj = o.pairsToObj, n.objToPairs = o.objToPairs, n.listsToObj = o.listsToObj, n.objToLists = o.objToLists, n.max = r.max, n.min = r.min, n.negate = r.negate, n.abs = r.abs, n.signum = r.signum, n.quot = r.quot, n.rem = r.rem, n.div = r.div, n.mod = r.mod, n.recip = r.recip, n.pi = r.pi, n.tau = r.tau, n.exp = r.exp, n.sqrt = r.sqrt, n.ln = r.ln, n.pow = r.pow, n.sin = r.sin, n.tan = r.tan, n.cos = r.cos, n.acos = r.acos, n.asin = r.asin, n.atan = r.atan, n.atan2 = r.atan2, n.truncate = r.truncate, n.round = r.round, n.ceiling = r.ceiling, n.floor = r.floor, n.isItNaN = r.isItNaN, n.even = r.even, n.odd = r.odd, n.gcd = r.gcd, n.lcm = r.lcm, n.VERSION = "1.2.1", qs = n;
  function m(h, l) {
    var s, c = function(g) {
      return h.length > 1 ? function() {
        var d = g ? g.concat() : [];
        return s = this, d.push.apply(d, arguments) < h.length && arguments.length ? c.call(s, d) : h.apply(s, d);
      } : h;
    };
    return c();
  }
  return qs;
}
var qh;
function xA() {
  return qh || (qh = 1, (function() {
    var i, t, o;
    i = dv().reject;
    function f(s, c) {
      if (s[0] === c)
        return s.shift();
      throw new Error("Expected '" + c + "', but got '" + s[0] + "' instead in " + JSON.stringify(s) + ".");
    }
    function r(s, c) {
      if (s[0] === c)
        return s.shift();
    }
    function u(s, c, g) {
      var d, y, v, T;
      for (d = c[0], y = c[1], g && f(s, d), v = [], T = "," + (g ? y : ""); s.length && g && s[0] !== y; )
        v.push(m(s, T)), r(s, ",");
      return g && f(s, y), v;
    }
    function e(s, c) {
      return u(s, ["[", "]"], c);
    }
    function a(s, c) {
      return u(s, ["(", ")"], c);
    }
    function n(s, c) {
      var g, d, y;
      for (c && f(s, "{"), g = {}, d = "," + (c ? "}" : ""); s.length && (!c || s[0] !== "}"); )
        y = p(s, ":"), f(s, ":"), g[y] = m(s, d), r(s, ",");
      return c && f(s, "}"), g;
    }
    function p(s, c) {
      var g;
      for (c == null && (c = ""), g = ""; s.length && c.indexOf(s[0]) === -1; )
        g += s.shift();
      return g;
    }
    function m(s, c) {
      switch (s[0]) {
        case "[":
          return e(s, !0);
        case "(":
          return a(s, !0);
        case "{":
          return n(s, !0);
        default:
          return p(s, c);
      }
    }
    function h(s, c, g) {
      var d, y, v, T, b, S, C, x;
      return d = c[0], y = d.type, v = d.structure, T = s.concat(), !g.explicit && c.length === 1 && (!y && v || y === "Array" || y === "Object") ? (b = v === "array" || y === "Array" ? e(s, s[0] === "[") : v === "tuple" ? a(s, s[0] === "(") : n(s, s[0] === "{"), S = s.length ? m(v === "array" || y === "Array" ? (C = T, C.unshift("["), C.push("]"), C) : (x = T, x.unshift("("), x.push(")"), x)) : b) : S = m(s), S;
    }
    t = /\[\]\(\)}{:,/.source, o = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + t + "])|([^\\s" + t + "](?:\\s*[^\\s" + t + "]+)*)|\\s*"), Os.exports = function(s, c, g) {
      var d, y;
      if (g == null && (g = {}), !g.explicit && s.length === 1 && s[0].type === "String")
        return c;
      if (d = i(l, c.split(o)), y = h(d, s, g), !y)
        throw new Error("Error parsing '" + c + "'.");
      return y;
    };
    function l(s) {
      return !s;
    }
  }).call(this)), Os.exports;
}
var $s = { exports: {} }, Gs = { exports: {} }, Ws = { exports: {} }, $h;
function RA() {
  return $h || ($h = 1, (function() {
    var i, t;
    i = /[\$\w]+/;
    function o(c) {
      var g;
      if (g = c[0], g == null)
        throw new Error("Unexpected end of input.");
      return g;
    }
    function f(c) {
      var g;
      if (g = o(c), !i.test(g))
        throw new Error("Expected text, got '" + g + "' instead.");
      return c.shift();
    }
    function r(c, g) {
      var d;
      if (d = o(c), d !== g)
        throw new Error("Expected '" + g + "', got '" + d + "' instead.");
      return c.shift();
    }
    function u(c, g) {
      var d;
      return d = c[0], d === g ? c.shift() : null;
    }
    function e(c) {
      var g;
      if (r(c, "["), o(c) === "]")
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      return g = l(c), r(c, "]"), {
        structure: "array",
        of: g
      };
    }
    function a(c) {
      var g;
      if (g = [], r(c, "("), o(c) === ")")
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      for (; g.push(l(c)), u(c, ","), o(c) !== ")"; )
        ;
      return r(c, ")"), {
        structure: "tuple",
        of: g
      };
    }
    function n(c) {
      var g, d, y, v, T;
      for (g = {}, r(c, "{"), d = !1; ; ) {
        if (u(c, "...")) {
          d = !0;
          break;
        }
        if (y = p(c), v = y[0], T = y[1], g[v] = T, u(c, ","), o(c) === "}")
          break;
      }
      return r(c, "}"), {
        structure: "fields",
        of: g,
        subset: d
      };
    }
    function p(c) {
      var g, d;
      return g = f(c), r(c, ":"), d = l(c), [g, d];
    }
    function m(c) {
      switch (c[0]) {
        case "[":
          return e(c);
        case "(":
          return a(c);
        case "{":
          return n(c);
      }
    }
    function h(c) {
      var g, d, y, v;
      if (g = o(c), d = g === "*", d || i.test(g))
        return y = d ? r(c, "*") : f(c), v = m(c), v ? (v.type = y, v) : {
          type: y
        };
      if (v = m(c), !v)
        throw new Error("Unexpected character: " + g);
      return v;
    }
    function l(c) {
      var g, d, y, v, T, b;
      if (o(c) === "::")
        throw new Error("No comment before comment separator '::' found.");
      for (g = c[1], g != null && g === "::" && (c.shift(), c.shift()), d = [], y = {}, o(c) === "Maybe" && (c.shift(), d = [
        {
          type: "Undefined"
        },
        {
          type: "Null"
        }
      ], y = {
        Undefined: !0,
        Null: !0
      }); v = h(c), T = v.type, b = v.structure, y[T] || d.push(v), b == null && (y[T] = !0), !!u(c, "|"); )
        ;
      return d;
    }
    t = RegExp("\\.\\.\\.|::|->|" + i.source + "|\\S", "g"), Ws.exports = function(c) {
      var g, d;
      if (!c.length)
        throw new Error("No type specified.");
      if (g = c.match(t) || [], s("->", g))
        throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
      try {
        return l(g);
      } catch (y) {
        throw d = y, new Error(d.message + " - Remaining tokens: " + JSON.stringify(g) + " - Initial input: '" + c + "'");
      }
    };
    function s(c, g) {
      for (var d = -1, y = g.length >>> 0; ++d < y; ) if (c === g[d]) return !0;
      return !1;
    }
  }).call(this)), Ws.exports;
}
var Xs = { exports: {} }, Gh;
function DA() {
  return Gh || (Gh = 1, (function() {
    var i, t, o, f, r, u, e = {}.toString;
    i = dv(), t = i.any, o = i.all, f = i.isItNaN, r = {
      Number: {
        typeOf: "Number",
        validate: function(s) {
          return !f(s);
        }
      },
      NaN: {
        typeOf: "Number",
        validate: f
      },
      Int: {
        typeOf: "Number",
        validate: function(s) {
          return !f(s) && s % 1 === 0;
        }
      },
      Float: {
        typeOf: "Number",
        validate: function(s) {
          return !f(s);
        }
      },
      Date: {
        typeOf: "Date",
        validate: function(s) {
          return !f(s.getTime());
        }
      }
    }, u = {
      array: "Array",
      tuple: "Array"
    };
    function a(s, c, g) {
      return o(function(d) {
        return l(d, c.of, g);
      }, s);
    }
    function n(s, c, g) {
      var d, y, v, T, b;
      for (d = 0, y = 0, T = (v = c.of).length; y < T; ++y) {
        if (b = v[y], !l(s[d], b, g))
          return !1;
        d++;
      }
      return s.length <= d;
    }
    function p(s, c, g) {
      var d, y, v, T, b, S, C;
      d = {}, y = 0;
      for (v in s)
        d[v] = !0, y++;
      T = 0;
      for (b in S = c.of) {
        if (C = S[b], !l(s[b], C, g))
          return !1;
        d[b] && T++;
      }
      return c.subset || y === T;
    }
    function m(s, c, g) {
      if (!(s instanceof Object))
        return !1;
      switch (c.structure) {
        case "fields":
          return p(s, c, g);
        case "array":
          return a(s, c, g);
        case "tuple":
          return n(s, c, g);
      }
    }
    function h(s, c, g) {
      var d, y, v, T;
      if (d = c.type, y = c.structure, d)
        return d === "*" ? !0 : (v = g.customTypes[d] || r[d], v ? (v.typeOf === void 0 || v.typeOf === e.call(s).slice(8, -1)) && v.validate(s) : d === e.call(s).slice(8, -1) && (!y || m(s, c, g)));
      if (y)
        return (T = u[y]) && T !== e.call(s).slice(8, -1) ? !1 : m(s, c, g);
      throw new Error("No type defined. Input: " + s + ".");
    }
    function l(s, c, g) {
      if (e.call(c).slice(8, -1) !== "Array")
        throw new Error("Types must be in an array. Input: " + s + ".");
      return t(function(d) {
        return h(s, d, g);
      }, c);
    }
    Xs.exports = function(s, c, g) {
      return g == null && (g = {}), g.customTypes == null && (g.customTypes = {}), l(c, s, g);
    };
  }).call(this)), Xs.exports;
}
var Wh;
function Ev() {
  return Wh || (Wh = 1, (function() {
    var i, t, o, f;
    i = "0.4.0", t = RA(), o = DA(), f = function(r, u, e) {
      return o(t(r), u, e);
    }, Gs.exports = {
      VERSION: i,
      typeCheck: f,
      parsedTypeCheck: o,
      parseType: t
    };
  }).call(this)), Gs.exports;
}
var Xh;
function LA() {
  return Xh || (Xh = 1, (function() {
    var i, t, o = {}.toString;
    i = Ev().parsedTypeCheck, t = {
      "*": function(n, p) {
        switch (o.call(n).slice(8, -1)) {
          case "Array":
            return e(n, {
              type: "Array"
            }, p);
          case "Object":
            return e(n, {
              type: "Object"
            }, p);
          default:
            return {
              type: "Just",
              value: a(n, [
                {
                  type: "Undefined"
                },
                {
                  type: "Null"
                },
                {
                  type: "NaN"
                },
                {
                  type: "Boolean"
                },
                {
                  type: "Number"
                },
                {
                  type: "Date"
                },
                {
                  type: "RegExp"
                },
                {
                  type: "Array"
                },
                {
                  type: "Object"
                },
                {
                  type: "String"
                }
              ], (p.explicit = !0, p))
            };
        }
      },
      Undefined: function(n) {
        return n === "undefined" || n === void 0 ? {
          type: "Just",
          value: void 0
        } : {
          type: "Nothing"
        };
      },
      Null: function(n) {
        return n === "null" ? {
          type: "Just",
          value: null
        } : {
          type: "Nothing"
        };
      },
      NaN: function(n) {
        return n === "NaN" ? {
          type: "Just",
          value: NaN
        } : {
          type: "Nothing"
        };
      },
      Boolean: function(n) {
        return n === "true" ? {
          type: "Just",
          value: !0
        } : n === "false" ? {
          type: "Just",
          value: !1
        } : {
          type: "Nothing"
        };
      },
      Number: function(n) {
        return {
          type: "Just",
          value: +n
        };
      },
      Int: function(n) {
        return {
          type: "Just",
          value: +n
        };
      },
      Float: function(n) {
        return {
          type: "Just",
          value: +n
        };
      },
      Date: function(n, p) {
        var m;
        return (m = /^\#([\s\S]*)\#$/.exec(n)) ? {
          type: "Just",
          value: new Date(+m[1] || m[1])
        } : p.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new Date(+n || n)
        };
      },
      RegExp: function(n, p) {
        var m;
        return (m = /^\/([\s\S]*)\/([gimy]*)$/.exec(n)) ? {
          type: "Just",
          value: new RegExp(m[1], m[2])
        } : p.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new RegExp(n)
        };
      },
      Array: function(n, p) {
        return f(n, {
          of: [{
            type: "*"
          }]
        }, p);
      },
      Object: function(n, p) {
        return u(n, {
          of: {}
        }, p);
      },
      String: function(n) {
        var p, m;
        return o.call(n).slice(8, -1) !== "String" ? {
          type: "Nothing"
        } : (p = function(h, l) {
          return h.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(s, c) {
            switch (c[0]) {
              case l:
                return l;
              case "\\":
                return "\\";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return `
`;
              case "r":
                return "\r";
              case "t":
                return "	";
              case "u":
                return JSON.parse('"' + s + '"');
              default:
                return c;
            }
          });
        }, (m = n.match(/^'([\s\S]*)'$/)) ? {
          type: "Just",
          value: p(m[1], "'")
        } : (m = n.match(/^"([\s\S]*)"$/)) ? {
          type: "Just",
          value: p(m[1], '"')
        } : {
          type: "Just",
          value: n
        });
      }
    };
    function f(n, p, m) {
      var h, l;
      return o.call(n).slice(8, -1) !== "Array" ? {
        type: "Nothing"
      } : (h = p.of, {
        type: "Just",
        value: function() {
          var s, c, g, d = [];
          for (s = 0, g = (c = n).length; s < g; ++s)
            l = c[s], d.push(a(l, h, m));
          return d;
        }()
      });
    }
    function r(n, p, m) {
      var h, l, s, c, g, d, y;
      if (o.call(n).slice(8, -1) !== "Array")
        return {
          type: "Nothing"
        };
      for (h = [], l = 0, s = 0, g = (c = p.of).length; s < g; ++s)
        d = c[s], y = a(n[l], d, m), o.call(y).slice(8, -1) !== "Undefined" && h.push(y), l++;
      return n.length <= l ? {
        type: "Just",
        value: h
      } : {
        type: "Nothing"
      };
    }
    function u(n, p, m) {
      var h, l, s;
      return o.call(n).slice(8, -1) !== "Object" ? {
        type: "Nothing"
      } : (h = p.of, {
        type: "Just",
        value: function() {
          var c, g = {};
          for (l in c = n)
            s = c[l], g[a(l, [{
              type: "String"
            }], m)] = a(s, h[l] || [{
              type: "*"
            }], m);
          return g;
        }()
      });
    }
    function e(n, p, m) {
      var h, l, s, c;
      if (h = p.type, l = p.structure, h) {
        if (s = ((c = m.customTypes[h]) != null ? c.cast : void 0) || t[h], !s)
          throw new Error("Type not defined: " + h + ".");
        return s(n, m, a);
      } else
        switch (l) {
          case "array":
            return f(n, p, m);
          case "tuple":
            return r(n, p, m);
          case "fields":
            return u(n, p, m);
        }
    }
    function a(n, p, m) {
      var h, l, s, c, g, d;
      for (h = 0, l = p.length; h < l; ++h)
        if (s = p[h], c = e(n, s, m), g = c.type, d = c.value, g !== "Nothing" && i([s], d, {
          customTypes: m.customTypes
        }))
          return d;
      throw new Error("Value " + JSON.stringify(n) + " does not type check against " + JSON.stringify(p) + ".");
    }
    $s.exports = function(n, p, m) {
      return !m.explicit && p.length === 1 && p[0].type === "String" ? n : a(n, p, m);
    };
  }).call(this)), $s.exports;
}
var zh;
function _A() {
  return zh || (zh = 1, (function() {
    var i, t, o, f, r, u;
    i = xA(), t = LA(), o = Ev().parseType, f = "0.4.1", r = function(e, a, n) {
      return n == null && (n = {}), n.explicit == null && (n.explicit = !1), n.customTypes == null && (n.customTypes = {}), t(i(e, a, n), e, n);
    }, u = function(e, a, n) {
      return r(o(e), a, n);
    }, Ns.exports = {
      VERSION: f,
      parse: u,
      parsedTypeParse: r
    };
  }).call(this)), Ns.exports;
}
var zs, Hh;
function yv() {
  if (Hh) return zs;
  Hh = 1;
  const i = _A(), {
    Legacy: {
      ConfigOps: t
    }
  } = mv(), {
    directivesPattern: o
  } = gn(), f = vr()("eslint:config-comment-parser");
  return zs = class {
    /**
     * Parses a list of "name:string_value" or/and "name" options divided by comma or
     * whitespace. Used for "global" and "exported" comments.
     * @param {string} string The string to parse.
     * @param {Comment} comment The comment node which has the string.
     * @returns {Object} Result map object of names and string values, or null values if no value was provided
     */
    parseStringConfig(u, e) {
      f("Parsing String config");
      const a = {};
      return u.replace(/\s*([:,])\s*/gu, "$1").split(/\s|,+/u).forEach((p) => {
        if (!p)
          return;
        const [m, h = null] = p.split(":");
        a[m] = { value: h, comment: e };
      }), a;
    }
    /**
     * Parses a JSON-like config.
     * @param {string} string The string to parse.
     * @param {Object} location Start line and column of comments for potential error message.
     * @returns {({success: true, config: Object}|{success: false, error: LintMessage})} Result map object
     */
    parseJsonConfig(u, e) {
      f("Parsing JSON config");
      let a = {};
      try {
        if (a = i.parse("Object", u) || {}, t.isEverySeverityValid(a))
          return {
            success: !0,
            config: a
          };
      } catch {
        f("Levn parsing failed; falling back to manual parsing.");
      }
      a = {};
      const n = u.replace(/([-a-zA-Z0-9/]+):/gu, '"$1":').replace(/(\]|[0-9])\s+(?=")/u, "$1,");
      try {
        a = JSON.parse(`{${n}}`);
      } catch (p) {
        return f("Manual parsing failed."), {
          success: !1,
          error: {
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: `Failed to parse JSON from '${n}': ${p.message}`,
            line: e.start.line,
            column: e.start.column + 1,
            nodeType: null
          }
        };
      }
      return {
        success: !0,
        config: a
      };
    }
    /**
     * Parses a config of values separated by comma.
     * @param {string} string The string to parse.
     * @returns {Object} Result map of values and true values
     */
    parseListConfig(u) {
      f("Parsing list config");
      const e = {};
      return u.split(",").forEach((a) => {
        const n = a.trim().replace(/^(?<quote>['"]?)(?<ruleId>.*)\k<quote>$/us, "$<ruleId>");
        n && (e[n] = !0);
      }), e;
    }
    /**
     * Extract the directive and the justification from a given directive comment and trim them.
     * @param {string} value The comment text to extract.
     * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.
     */
    extractDirectiveComment(u) {
      const e = /\s-{2,}\s/u.exec(u);
      if (!e)
        return { directivePart: u.trim(), justificationPart: "" };
      const a = u.slice(0, e.index).trim(), n = u.slice(e.index + e[0].length).trim();
      return { directivePart: a, justificationPart: n };
    }
    /**
     * Parses a directive comment into directive text and value.
     * @param {Comment} comment The comment node with the directive to be parsed.
     * @returns {{directiveText: string, directiveValue: string}} The directive text and value.
     */
    parseDirective(u) {
      const { directivePart: e } = this.extractDirectiveComment(u.value), a = o.exec(e), n = a[1], p = e.slice(a.index + n.length);
      return { directiveText: n, directiveValue: p };
    }
  }, zs;
}
var Hs, Jh;
function wA() {
  if (Jh) return Hs;
  Jh = 1;
  const { isCommentToken: i } = Ft(), t = yA(), o = mn(), f = qf(), r = CA(), {
    directivesPattern: u
  } = gn(), e = yv(), a = lv(), n = new e();
  function p(b) {
    if (!b.tokens)
      throw new Error("AST is missing the tokens array.");
    if (!b.comments)
      throw new Error("AST is missing the comments array.");
    if (!b.loc)
      throw new Error("AST is missing location information.");
    if (!b.range)
      throw new Error("AST is missing range information");
  }
  function m(b) {
    switch (b) {
      case 3:
        return r.es3;
      case 5:
        return r.es5;
      default:
        return b < 2015 ? r[`es${b + 2009}`] : r[`es${b}`];
    }
  }
  function h(b) {
    return b.type === "ExportDefaultDeclaration" || b.type === "ExportNamedDeclaration" || b.type === "ExportAllDeclaration" || b.type === "ExportSpecifier";
  }
  function l(b, S) {
    const C = [];
    let x = 0, A = 0;
    for (; x < b.length || A < S.length; )
      A >= S.length || x < b.length && b[x].range[0] < S[A].range[0] ? C.push(b[x++]) : C.push(S[A++]);
    return C;
  }
  function s(b) {
    switch (b) {
      case "off":
        return "off";
      case !0:
      case "true":
      case "writeable":
      case "writable":
        return "writable";
      case null:
      case !1:
      case "false":
      case "readable":
      case "readonly":
        return "readonly";
      default:
        throw new Error(`'${b}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
    }
  }
  function c(b, S) {
    return b.range[0] <= S.range[0] && b.range[1] >= S.range[0] || S.range[0] <= b.range[0] && S.range[1] >= b.range[0];
  }
  function g(b, S, C, x) {
    if (c(S, C))
      return !1;
    const [A, R] = S.range[1] <= C.range[0] ? [S, C] : [C, S], L = b.getLastToken(A) || A, _ = b.getFirstToken(R) || R;
    let I = L;
    for (; I !== _; ) {
      const O = b.getTokenAfter(I, { includeComments: !0 });
      if (I.range[1] !== O.range[0] || /*
      * For backward compatibility, check spaces in JSXText.
      * https://github.com/eslint/eslint/issues/12614
      */
      x && O !== _ && O.type === "JSXText" && /\s/u.test(O.value))
        return !0;
      I = O;
    }
    return !1;
  }
  function d(b, S = {}, C = {}) {
    for (const x of /* @__PURE__ */ new Set([...Object.keys(S), ...Object.keys(C)])) {
      const A = S[x] === void 0 ? void 0 : s(S[x]), L = C[x] && C[x].value || A, _ = C[x] && C[x].comments;
      if (L === "off")
        continue;
      let I = b.set.get(x);
      I || (I = new a.Variable(x, b), b.variables.push(I), b.set.set(x, I)), I.eslintImplicitGlobalSetting = A, I.eslintExplicitGlobal = _ !== void 0, I.eslintExplicitGlobalComments = _, I.writeable = L === "writable";
    }
    b.through = b.through.filter((x) => {
      const A = x.identifier.name, R = b.set.get(A);
      return R ? (x.resolved = R, R.references.push(x), !1) : !0;
    });
  }
  function y(b, S) {
    Object.keys(S).forEach((C) => {
      const x = b.set.get(C);
      x && (x.eslintUsed = !0, x.eslintExported = !0);
    });
  }
  const v = Symbol("caches");
  class T extends t {
    /**
     * @param {string|Object} textOrConfig The source code text or config object.
     * @param {string} textOrConfig.text The source code text.
     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     * @param {Object|null} textOrConfig.parserServices The parser services.
     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.
     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.
     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     */
    constructor(S, C) {
      let x, A, R, L, _;
      typeof S == "string" ? (x = S, A = C) : typeof S == "object" && S !== null && (x = S.text, A = S.ast, R = S.parserServices, L = S.scopeManager, _ = S.visitorKeys), p(A), super(A.tokens, A.comments), this[v] = /* @__PURE__ */ new Map([
        ["scopes", /* @__PURE__ */ new WeakMap()],
        ["vars", /* @__PURE__ */ new Map()],
        ["configNodes", void 0]
      ]), this.hasBOM = x.charCodeAt(0) === 65279, this.text = this.hasBOM ? x.slice(1) : x, this.ast = A, this.parserServices = R || {}, this.scopeManager = L || null, this.visitorKeys = _ || f.DEFAULT_VISITOR_KEYS;
      const I = this.text.match(o.shebangPattern);
      I && A.comments.length && A.comments[0].value === I[1] && (A.comments[0].type = "Shebang"), this.tokensAndComments = l(A.tokens, A.comments), this.lines = [], this.lineStartIndices = [0];
      const k = o.createGlobalLinebreakMatcher();
      let w;
      for (; w = k.exec(this.text); )
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], w.index)), this.lineStartIndices.push(w.index + w[0].length);
      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1])), this._commentCache = /* @__PURE__ */ new WeakMap(), Object.freeze(this), Object.freeze(this.lines);
    }
    /**
     * Split the source code into multiple lines based on the line delimiters.
     * @param {string} text Source code as a string.
     * @returns {string[]} Array of source code lines.
     * @public
     */
    static splitLines(S) {
      return S.split(o.createGlobalLinebreakMatcher());
    }
    /**
     * Gets the source code for the given node.
     * @param {ASTNode} [node] The AST node to get the text for.
     * @param {int} [beforeCount] The number of characters before the node to retrieve.
     * @param {int} [afterCount] The number of characters after the node to retrieve.
     * @returns {string} The text representing the AST node.
     * @public
     */
    getText(S, C, x) {
      return S ? this.text.slice(
        Math.max(S.range[0] - (C || 0), 0),
        S.range[1] + (x || 0)
      ) : this.text;
    }
    /**
     * Gets the entire source text split into an array of lines.
     * @returns {Array} The source text as an array of lines.
     * @public
     */
    getLines() {
      return this.lines;
    }
    /**
     * Retrieves an array containing all comments in the source code.
     * @returns {ASTNode[]} An array of comment nodes.
     * @public
     */
    getAllComments() {
      return this.ast.comments;
    }
    /**
     * Gets all comments for the given node.
     * @param {ASTNode} node The AST node to get the comments for.
     * @returns {Object} An object containing a leading and trailing array
     *      of comments indexed by their position.
     * @public
     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().
     */
    getComments(S) {
      if (this._commentCache.has(S))
        return this._commentCache.get(S);
      const C = {
        leading: [],
        trailing: []
      };
      if (S.type === "Program")
        S.body.length === 0 && (C.leading = S.comments);
      else {
        ((S.type === "BlockStatement" || S.type === "ClassBody") && S.body.length === 0 || S.type === "ObjectExpression" && S.properties.length === 0 || S.type === "ArrayExpression" && S.elements.length === 0 || S.type === "SwitchStatement" && S.cases.length === 0) && (C.trailing = this.getTokens(S, {
          includeComments: !0,
          filter: i
        }));
        let x = this.getTokenBefore(S, { includeComments: !0 });
        for (; x && i(x) && !(S.parent && S.parent.type !== "Program" && x.start < S.parent.start); )
          C.leading.push(x), x = this.getTokenBefore(x, { includeComments: !0 });
        for (C.leading.reverse(), x = this.getTokenAfter(S, { includeComments: !0 }); x && i(x) && !(S.parent && S.parent.type !== "Program" && x.end > S.parent.end); )
          C.trailing.push(x), x = this.getTokenAfter(x, { includeComments: !0 });
      }
      return this._commentCache.set(S, C), C;
    }
    /**
     * Retrieves the JSDoc comment for a given node.
     * @param {ASTNode} node The AST node to get the comment for.
     * @returns {Token|null} The Block comment token containing the JSDoc comment
     *      for the given node or null if not found.
     * @public
     * @deprecated
     */
    getJSDocComment(S) {
      const C = (A) => {
        const R = this.getTokenBefore(A, { includeComments: !0 });
        return R && i(R) && R.type === "Block" && R.value.charAt(0) === "*" && A.loc.start.line - R.loc.end.line <= 1 ? R : null;
      };
      let x = S.parent;
      switch (S.type) {
        case "ClassDeclaration":
        case "FunctionDeclaration":
          return C(h(x) ? x : S);
        case "ClassExpression":
          return C(x.parent);
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          if (x.type !== "CallExpression" && x.type !== "NewExpression") {
            for (; !this.getCommentsBefore(x).length && !/Function/u.test(x.type) && x.type !== "MethodDefinition" && x.type !== "Property" && (x = x.parent, !!x); )
              ;
            if (x && x.type !== "FunctionDeclaration" && x.type !== "Program")
              return C(x);
          }
          return C(S);
        default:
          return null;
      }
    }
    /**
     * Gets the deepest node containing a range index.
     * @param {int} index Range index of the desired node.
     * @returns {ASTNode} The node if found or null if not found.
     * @public
     */
    getNodeByRangeIndex(S) {
      let C = null;
      return f.traverse(this.ast, {
        visitorKeys: this.visitorKeys,
        enter(x) {
          x.range[0] <= S && S < x.range[1] ? C = x : this.skip();
        },
        leave(x) {
          x === C && this.break();
        }
      }), C;
    }
    /**
     * Determines if two nodes or tokens have at least one whitespace character
     * between them. Order does not matter. Returns false if the given nodes or
     * tokens overlap.
     * @param {ASTNode|Token} first The first node or token to check between.
     * @param {ASTNode|Token} second The second node or token to check between.
     * @returns {boolean} True if there is a whitespace character between
     * any of the tokens found between the two given nodes or tokens.
     * @public
     */
    isSpaceBetween(S, C) {
      return g(this, S, C, !1);
    }
    /**
     * Determines if two nodes or tokens have at least one whitespace character
     * between them. Order does not matter. Returns false if the given nodes or
     * tokens overlap.
     * For backward compatibility, this method returns true if there are
     * `JSXText` tokens that contain whitespaces between the two.
     * @param {ASTNode|Token} first The first node or token to check between.
     * @param {ASTNode|Token} second The second node or token to check between.
     * @returns {boolean} True if there is a whitespace character between
     * any of the tokens found between the two given nodes or tokens.
     * @deprecated in favor of isSpaceBetween().
     * @public
     */
    isSpaceBetweenTokens(S, C) {
      return g(this, S, C, !0);
    }
    /**
     * Converts a source text index into a (line, column) pair.
     * @param {number} index The index of a character in a file
     * @throws {TypeError} If non-numeric index or index out of range.
     * @returns {Object} A {line, column} location object with a 0-indexed column
     * @public
     */
    getLocFromIndex(S) {
      if (typeof S != "number")
        throw new TypeError("Expected `index` to be a number.");
      if (S < 0 || S > this.text.length)
        throw new RangeError(`Index out of range (requested index ${S}, but source text has length ${this.text.length}).`);
      if (S === this.text.length)
        return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
      const C = S >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex((x) => S < x);
      return { line: C, column: S - this.lineStartIndices[C - 1] };
    }
    /**
     * Converts a (line, column) pair into a range index.
     * @param {Object} loc A line/column location
     * @param {number} loc.line The line number of the location (1-indexed)
     * @param {number} loc.column The column number of the location (0-indexed)
     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric
     *   `line` and `column`, if the `line` is less than or equal to zero or
     *   the line or column is out of the expected range.
     * @returns {number} The range index of the location in the file.
     * @public
     */
    getIndexFromLoc(S) {
      if (typeof S != "object" || typeof S.line != "number" || typeof S.column != "number")
        throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
      if (S.line <= 0)
        throw new RangeError(`Line number out of range (line ${S.line} requested). Line numbers should be 1-based.`);
      if (S.line > this.lineStartIndices.length)
        throw new RangeError(`Line number out of range (line ${S.line} requested, but only ${this.lineStartIndices.length} lines present).`);
      const C = this.lineStartIndices[S.line - 1], x = S.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[S.line], A = C + S.column;
      if (S.line === this.lineStartIndices.length && A > x || S.line < this.lineStartIndices.length && A >= x)
        throw new RangeError(`Column number out of range (column ${S.column} requested, but the length of line ${S.line} is ${x - C}).`);
      return A;
    }
    /**
     * Gets the scope for the given node
     * @param {ASTNode} currentNode The node to get the scope of
     * @returns {eslint-scope.Scope} The scope information for this node
     * @throws {TypeError} If the `currentNode` argument is missing.
     */
    getScope(S) {
      if (!S)
        throw new TypeError("Missing required argument: node.");
      const C = this[v].get("scopes"), x = C.get(S);
      if (x)
        return x;
      const A = S.type !== "Program";
      for (let R = S; R; R = R.parent) {
        const L = this.scopeManager.acquire(R, A);
        if (L)
          return L.type === "function-expression-name" ? (C.set(S, L.childScopes[0]), L.childScopes[0]) : (C.set(S, L), L);
      }
      return C.set(S, this.scopeManager.scopes[0]), this.scopeManager.scopes[0];
    }
    /**
     * Get the variables that `node` defines.
     * This is a convenience method that passes through
     * to the same method on the `scopeManager`.
     * @param {ASTNode} node The node for which the variables are obtained.
     * @returns {Array<Variable>} An array of variable nodes representing
     *      the variables that `node` defines.
     */
    getDeclaredVariables(S) {
      return this.scopeManager.getDeclaredVariables(S);
    }
    /* eslint-disable class-methods-use-this -- node is owned by SourceCode */
    /**
     * Gets all the ancestors of a given node
     * @param {ASTNode} node The node
     * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting
     * from the root node at index 0 and going inwards to the parent node.
     * @throws {TypeError} When `node` is missing.
     */
    getAncestors(S) {
      if (!S)
        throw new TypeError("Missing required argument: node.");
      const C = [];
      for (let x = S.parent; x; x = x.parent)
        C.push(x);
      return C.reverse();
    }
    /* eslint-enable class-methods-use-this -- node is owned by SourceCode */
    /**
     * Marks a variable as used in the current scope
     * @param {string} name The name of the variable to mark as used.
     * @param {ASTNode} [refNode] The closest node to the variable reference.
     * @returns {boolean} True if the variable was found and marked as used, false if not.
     */
    markVariableAsUsed(S, C = this.ast) {
      const x = this.getScope(C);
      let A = x;
      x.type === "global" && x.childScopes.length > 0 && // top-level scopes refer to a `Program` node
      x.childScopes[0].block === this.ast && (A = x.childScopes[0]);
      for (let R = A; R; R = R.upper) {
        const L = R.variables.find((_) => _.name === S);
        if (L)
          return L.eslintUsed = !0, !0;
      }
      return !1;
    }
    /**
     * Returns an array of all inline configuration nodes found in the
     * source code.
     * @returns {Array<Token>} An array of all inline configuration nodes.
     */
    getInlineConfigNodes() {
      let S = this[v].get("configNodes");
      return S || (S = this.ast.comments.filter((C) => {
        if (C.type === "Shebang")
          return !1;
        const { directivePart: x } = n.extractDirectiveComment(C.value), A = u.exec(x);
        return A ? C.type !== "Line" || !!/^eslint-disable-(next-)?line$/u.test(A[1]) : !1;
      }), this[v].set("configNodes", S), S);
    }
    /**
     * Applies language options sent in from the core.
     * @param {Object} languageOptions The language options for this run.
     * @returns {void}
     */
    applyLanguageOptions(S) {
      const C = Object.assign(
        {},
        m(S.ecmaVersion),
        S.sourceType === "commonjs" ? r.commonjs : void 0,
        S.globals
      );
      this[v].get("vars").set("configGlobals", C);
    }
    /**
     * Applies configuration found inside of the source code. This method is only
     * called when ESLint is running with inline configuration allowed.
     * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,node:ASTNode}}} Information
     *      that ESLint needs to further process the inline configuration.
     */
    applyInlineConfig() {
      const S = [], C = [], x = {}, A = /* @__PURE__ */ Object.create(null);
      this.getInlineConfigNodes().forEach((L) => {
        const { directiveText: _, directiveValue: I } = n.parseDirective(L);
        switch (_) {
          case "exported":
            Object.assign(x, n.parseStringConfig(I, L));
            break;
          case "globals":
          case "global":
            for (const [O, { value: k }] of Object.entries(n.parseStringConfig(I, L))) {
              let w;
              try {
                w = s(k);
              } catch (U) {
                S.push({
                  ruleId: null,
                  loc: L.loc,
                  message: U.message
                });
                continue;
              }
              A[O] ? (A[O].comments.push(L), A[O].value = w) : A[O] = {
                comments: [L],
                value: w
              };
            }
            break;
          case "eslint": {
            const O = n.parseJsonConfig(I, L.loc);
            O.success ? C.push({
              config: {
                rules: O.config
              },
              node: L
            }) : S.push(O.error);
            break;
          }
        }
      });
      const R = this[v].get("vars");
      return R.set("inlineGlobals", A), R.set("exportedVariables", x), {
        configs: C,
        problems: S
      };
    }
    /**
     * Called by ESLint core to indicate that it has finished providing
     * information. We now add in all the missing variables and ensure that
     * state-changing methods cannot be called by rules.
     * @returns {void}
     */
    finalize() {
      const S = this[v].get("vars"), C = this.scopeManager.scopes[0], x = S.get("configGlobals"), A = S.get("inlineGlobals"), R = S.get("exportedVariables");
      d(C, x, A), R && y(C, R);
    }
  }
  return Hs = T, Hs;
}
var Js, Qh;
function kA() {
  return Qh || (Qh = 1, Js = {
    SourceCode: wA()
  }), Js;
}
var Qs, Yh;
function Cv() {
  if (Yh) return Qs;
  Yh = 1;
  const i = vr()("eslint:code-path");
  function t(f) {
    return f.id + (f.reachable ? "" : "!");
  }
  function o(f, r) {
    const u = r ? `:${r}` : "";
    switch (f.type) {
      case "Identifier":
        return `${f.type}${u} (${f.name})`;
      case "Literal":
        return `${f.type}${u} (${f.value})`;
      default:
        return `${f.type}${u}`;
    }
  }
  return Qs = {
    /**
     * A flag that debug dumping is enabled or not.
     * @type {boolean}
     */
    enabled: i.enabled,
    /**
     * Dumps given objects.
     * @param {...any} args objects to dump.
     * @returns {void}
     */
    dump: i,
    /**
     * Dumps the current analyzing state.
     * @param {ASTNode} node A node to dump.
     * @param {CodePathState} state A state to dump.
     * @param {boolean} leaving A flag whether or not it's leaving
     * @returns {void}
     */
    dumpState: i.enabled ? (
      /* c8 ignore next */
      function(f, r, u) {
        for (let e = 0; e < r.currentSegments.length; ++e) {
          const a = r.currentSegments[e].internal;
          if (u) {
            const n = a.nodes.length - 1;
            n >= 0 && a.nodes[n] === o(f, "enter") ? a.nodes[n] = o(f, void 0) : a.nodes.push(o(f, "exit"));
          } else
            a.nodes.push(o(f, "enter"));
        }
        i([
          `${r.currentSegments.map(t).join(",")})`,
          `${f.type}${u ? ":exit" : ""}`
        ].join(" "));
      }
    ) : i,
    /**
     * Dumps a DOT code of a given code path.
     * The DOT code can be visualized with Graphvis.
     * @param {CodePath} codePath A code path to dump.
     * @returns {void}
     * @see http://www.graphviz.org
     * @see http://www.webgraphviz.com
     */
    dumpDot: i.enabled ? (
      /* c8 ignore next */
      function(f) {
        let r = `
digraph {
node[shape=box,style="rounded,filled",fillcolor=white];
initial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];
`;
        f.returnedSegments.length > 0 && (r += `final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];
`), f.thrownSegments.length > 0 && (r += `thrown[label="✘",shape=circle,width=0.3,height=0.3,fixedsize=true];
`);
        const u = /* @__PURE__ */ Object.create(null), e = this.makeDotArrows(f, u);
        for (const a in u) {
          const n = u[a];
          r += `${a}[`, n.reachable ? r += 'label="' : r += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n', n.internal.nodes.length > 0 ? r += n.internal.nodes.join("\\n") : r += "????", r += `"];
`;
        }
        r += `${e}
`, r += "}", i("DOT", r);
      }
    ) : i,
    /**
     * Makes a DOT code of a given code path.
     * The DOT code can be visualized with Graphvis.
     * @param {CodePath} codePath A code path to make DOT.
     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.
     * @returns {string} A DOT code of the code path.
     */
    makeDotArrows(f, r) {
      const u = [[f.initialSegment, 0]], e = r || /* @__PURE__ */ Object.create(null);
      let a = f.initialSegment.id, n = `initial->${f.initialSegment.id}`;
      for (; u.length > 0; ) {
        const p = u.pop(), m = p[0], h = p[1];
        if (e[m.id] && h === 0)
          continue;
        e[m.id] = m;
        const l = m.allNextSegments[h];
        l && (a === m.id ? n += `->${l.id}` : n += `;
${m.id}->${l.id}`, a = l.id, u.unshift([m, 1 + h]), u.push([l, 0]));
      }
      return f.returnedSegments.forEach((p) => {
        a === p.id ? n += "->final" : n += `;
${p.id}->final`, a = null;
      }), f.thrownSegments.forEach((p) => {
        a === p.id ? n += "->thrown" : n += `;
${p.id}->thrown`, a = null;
      }), `${n};`;
    }
  }, Qs;
}
var Ys, Zh;
function Wf() {
  if (Zh) return Ys;
  Zh = 1;
  const i = Cv();
  function t(f) {
    return f.reachable;
  }
  class o {
    /**
     * Creates a new instance.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     *   This array includes unreachable segments.
     * @param {boolean} reachable A flag which shows this is reachable.
     */
    constructor(r, u, e) {
      this.id = r, this.nextSegments = [], this.prevSegments = u.filter(t), this.allNextSegments = [], this.allPrevSegments = u, this.reachable = e, Object.defineProperty(this, "internal", {
        value: {
          // determines if the segment has been attached to the code path
          used: !1,
          // array of previous segments coming from the end of a loop
          loopedPrevSegments: []
        }
      }), i.enabled && (this.internal.nodes = []);
    }
    /**
     * Checks a given previous segment is coming from the end of a loop.
     * @param {CodePathSegment} segment A previous segment to check.
     * @returns {boolean} `true` if the segment is coming from the end of a loop.
     */
    isLoopedPrevSegment(r) {
      return this.internal.loopedPrevSegments.includes(r);
    }
    /**
     * Creates the root segment.
     * @param {string} id An identifier.
     * @returns {CodePathSegment} The created segment.
     */
    static newRoot(r) {
      return new o(r, [], !0);
    }
    /**
     * Creates a new segment and appends it after the given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments
     *      to append to.
     * @returns {CodePathSegment} The created segment.
     */
    static newNext(r, u) {
      return new o(
        r,
        o.flattenUnusedSegments(u),
        u.some(t)
      );
    }
    /**
     * Creates an unreachable segment and appends it after the given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newUnreachable(r, u) {
      const e = new o(r, o.flattenUnusedSegments(u), !1);
      return o.markUsed(e), e;
    }
    /**
     * Creates a segment that follows given segments.
     * This factory method does not connect with `allPrevSegments`.
     * But this inherits `reachable` flag.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newDisconnected(r, u) {
      return new o(r, [], u.some(t));
    }
    /**
     * Marks a given segment as used.
     *
     * And this function registers the segment into the previous segments as a next.
     * @param {CodePathSegment} segment A segment to mark.
     * @returns {void}
     */
    static markUsed(r) {
      if (r.internal.used)
        return;
      r.internal.used = !0;
      let u;
      if (r.reachable)
        for (u = 0; u < r.allPrevSegments.length; ++u) {
          const e = r.allPrevSegments[u];
          e.allNextSegments.push(r), e.nextSegments.push(r);
        }
      else
        for (u = 0; u < r.allPrevSegments.length; ++u)
          r.allPrevSegments[u].allNextSegments.push(r);
    }
    /**
     * Marks a previous segment as looped.
     * @param {CodePathSegment} segment A segment.
     * @param {CodePathSegment} prevSegment A previous segment to mark.
     * @returns {void}
     */
    static markPrevSegmentAsLooped(r, u) {
      r.internal.loopedPrevSegments.push(u);
    }
    /**
     * Creates a new array based on an array of segments. If any segment in the
     * array is unused, then it is replaced by all of its previous segments.
     * All used segments are returned as-is without replacement.
     * @param {CodePathSegment[]} segments The array of segments to flatten.
     * @returns {CodePathSegment[]} The flattened array.
     */
    static flattenUnusedSegments(r) {
      const u = /* @__PURE__ */ new Set();
      for (let e = 0; e < r.length; ++e) {
        const a = r[e];
        if (!u.has(a))
          if (a.internal.used)
            u.add(a);
          else
            for (let n = 0; n < a.allPrevSegments.length; ++n) {
              const p = a.allPrevSegments[n];
              u.has(p) || u.add(p);
            }
      }
      return [...u];
    }
  }
  return Ys = o, Ys;
}
var Zs, em;
function BA() {
  if (em) return Zs;
  em = 1;
  const i = It, t = Wf();
  function o(e) {
    return e.reachable;
  }
  function f(e, a, n, p) {
    const m = e.segmentsList, h = a >= 0 ? a : m.length + a, l = n >= 0 ? n : m.length + n, s = [];
    for (let c = 0; c < e.count; ++c) {
      const g = [];
      for (let d = h; d <= l; ++d)
        g.push(m[d][c]);
      s.push(p(e.idGenerator.next(), g));
    }
    return s;
  }
  function r(e, a) {
    let n = a;
    for (; n.length > e.count; ) {
      const p = [];
      for (let m = 0, h = Math.floor(n.length / 2); m < h; ++m)
        p.push(t.newNext(
          e.idGenerator.next(),
          [n[m], n[m + h]]
        ));
      n = p;
    }
    return n;
  }
  class u {
    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An identifier generator for segments.
     * @param {ForkContext|null} upper The preceding fork context.
     * @param {number} count The number of parallel segments in each element
     *      of `segmentsList`.
     */
    constructor(a, n, p) {
      this.idGenerator = a, this.upper = n, this.count = p, this.segmentsList = [];
    }
    /**
     * The segments that begin this fork context.
     * @type {Array<CodePathSegment>}
     */
    get head() {
      const a = this.segmentsList;
      return a.length === 0 ? [] : a[a.length - 1];
    }
    /**
     * Indicates if the context contains no segments.
     * @type {boolean}
     */
    get empty() {
      return this.segmentsList.length === 0;
    }
    /**
     * Indicates if there are any segments that are reachable.
     * @type {boolean}
     */
    get reachable() {
      const a = this.head;
      return a.length > 0 && a.some(o);
    }
    /**
     * Creates new segments in this context and appends them to the end of the
     * already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeNext(a, n) {
      return f(this, a, n, t.newNext);
    }
    /**
     * Creates new unreachable segments in this context and appends them to the end of the
     * already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeUnreachable(a, n) {
      return f(this, a, n, t.newUnreachable);
    }
    /**
     * Creates new segments in this context and does not append them to the end
     *  of the already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`. The `startIndex` and `endIndex` are only used to determine if
     * the new segments should be reachable. If any of the segments in this range
     * are reachable then the new segments are also reachable; otherwise, the new
     * segments are unreachable.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be considered for reachability.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be considered for reachability.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeDisconnected(a, n) {
      return f(this, a, n, t.newDisconnected);
    }
    /**
     * Adds segments to the head of this context.
     * @param {Array<CodePathSegment>} segments The segments to add.
     * @returns {void}
     */
    add(a) {
      i(a.length >= this.count, `${a.length} >= ${this.count}`), this.segmentsList.push(r(this, a));
    }
    /**
     * Replaces the head segments with the given segments.
     * The current head segments are removed.
     * @param {Array<CodePathSegment>} replacementHeadSegments The new head segments.
     * @returns {void}
     */
    replaceHead(a) {
      i(
        a.length >= this.count,
        `${a.length} >= ${this.count}`
      ), this.segmentsList.splice(-1, 1, r(this, a));
    }
    /**
     * Adds all segments of a given fork context into this context.
     * @param {ForkContext} otherForkContext The fork context to add from.
     * @returns {void}
     */
    addAll(a) {
      i(a.count === this.count), this.segmentsList.push(...a.segmentsList);
    }
    /**
     * Clears all segments in this context.
     * @returns {void}
     */
    clear() {
      this.segmentsList = [];
    }
    /**
     * Creates a new root context, meaning that there are no parent
     * fork contexts.
     * @param {IdGenerator} idGenerator An identifier generator for segments.
     * @returns {ForkContext} New fork context.
     */
    static newRoot(a) {
      const n = new u(a, null, 1);
      return n.add([t.newRoot(a.next())]), n;
    }
    /**
     * Creates an empty fork context preceded by a given context.
     * @param {ForkContext} parentContext The parent fork context.
     * @param {boolean} shouldForkLeavingPath Indicates that we are inside of
     *      a `finally` block and should therefore fork the path that leaves
     *      `finally`.
     * @returns {ForkContext} New fork context.
     */
    static newEmpty(a, n) {
      return new u(
        a.idGenerator,
        a,
        (n ? 2 : 1) * a.count
      );
    }
  }
  return Zs = u, Zs;
}
var ei, tm;
function PA() {
  if (tm) return ei;
  tm = 1;
  const i = Wf(), t = BA();
  class o {
    /**
     * Creates a new instance.
     * @param {BreakContext} upperContext The previous `BreakContext`.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label for the statement.
     * @param {ForkContext} forkContext The current fork context.
     */
    constructor(A, R, L, _) {
      this.upper = A, this.breakable = R, this.label = L, this.brokenForkContext = t.newEmpty(_);
    }
  }
  class f {
    /**
     * Creates a new instance.
     * @param {ChainContext} upperContext The previous `ChainContext`.
     */
    constructor(A) {
      this.upper = A, this.choiceContextCount = 0;
    }
  }
  class r {
    /**
     * Creates a new instance.
     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.
     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this
     *      is `"&&"` or `"||"` or `"??"`; if it's an `if` statement or
     *      conditional expression, this is `"test"`; otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @param {ForkContext} forkContext The containing `ForkContext`.
     */
    constructor(A, R, L, _) {
      this.upper = A, this.kind = R, this.isForkingAsResult = L, this.trueForkContext = t.newEmpty(_), this.falseForkContext = t.newEmpty(_), this.nullishForkContext = t.newEmpty(_), this.processed = !1;
    }
  }
  class u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string} type The AST node's `type` for the loop.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(A, R, L, _) {
      this.upper = A, this.type = R, this.label = L, this.brokenForkContext = _.brokenForkContext;
    }
  }
  class e extends u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(A, R, L) {
      super(A, "WhileStatement", R, L), this.test = void 0, this.continueDestSegments = null;
    }
  }
  class a extends u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(A, R, L, _) {
      super(A, "DoWhileStatement", R, L), this.test = void 0, this.entrySegments = null, this.continueForkContext = t.newEmpty(_);
    }
  }
  class n extends u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(A, R, L) {
      super(A, "ForStatement", R, L), this.test = void 0, this.endOfInitSegments = null, this.testSegments = null, this.endOfTestSegments = null, this.updateSegments = null, this.endOfUpdateSegments = null, this.continueDestSegments = null;
    }
  }
  class p extends u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(A, R, L) {
      super(A, "ForInStatement", R, L), this.prevSegments = null, this.leftSegments = null, this.endOfLeftSegments = null, this.continueDestSegments = null;
    }
  }
  class m extends u {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(A, R, L) {
      super(A, "ForOfStatement", R, L), this.prevSegments = null, this.leftSegments = null, this.endOfLeftSegments = null, this.continueDestSegments = null;
    }
  }
  class h {
    /**
     * Creates a new instance.
     * @param {SwitchContext} upperContext The previous context.
     * @param {boolean} hasCase Indicates if there is at least one `case` statement.
     *      `default` doesn't count.
     */
    constructor(A, R) {
      this.upper = A, this.hasCase = R, this.defaultSegments = null, this.defaultBodySegments = null, this.foundEmptyDefault = !1, this.lastIsDefault = !1, this.forkCount = 0;
    }
  }
  class l {
    /**
     * Creates a new instance.
     * @param {TryContext} upperContext The previous context.
     * @param {boolean} hasFinalizer Indicates if the `try` statement has a
     *      `finally` block.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(A, R, L) {
      this.upper = A, this.hasFinalizer = R, this.position = "try", this.returnedForkContext = R ? t.newEmpty(L) : null, this.thrownForkContext = t.newEmpty(L), this.lastOfTryIsReachable = !1, this.lastOfCatchIsReachable = !1;
    }
  }
  function s(x, A, R, L) {
    for (let _ = 0; _ < L.length; ++_) {
      const I = L[_];
      x.push(I), A.includes(I) || R.push(I);
    }
  }
  function c(x, A) {
    if (!A)
      return x.loopContext;
    let R = x.loopContext;
    for (; R; ) {
      if (R.label === A)
        return R;
      R = R.upper;
    }
    return null;
  }
  function g(x, A) {
    let R = x.breakContext;
    for (; R; ) {
      if (A ? R.label === A : R.breakable)
        return R;
      R = R.upper;
    }
    return null;
  }
  function d(x) {
    let A = x.tryContext;
    for (; A; ) {
      if (A.hasFinalizer && A.position !== "finally")
        return A;
      A = A.upper;
    }
    return x;
  }
  function y(x) {
    let A = x.tryContext;
    for (; A; ) {
      if (A.position === "try" || A.hasFinalizer && A.position === "catch")
        return A;
      A = A.upper;
    }
    return x;
  }
  function v(x, A) {
    x.splice(x.indexOf(A), 1);
  }
  function T(x, A) {
    for (let R = 0; R < x.length; ++R) {
      const L = x[R], _ = A[R];
      v(L.nextSegments, _), v(L.allNextSegments, _), v(_.prevSegments, L), v(_.allPrevSegments, L);
    }
  }
  function b(x, A, R) {
    const L = i.flattenUnusedSegments(A), _ = i.flattenUnusedSegments(R), I = Math.min(L.length, _.length);
    for (let O = 0; O < I; ++O) {
      const k = L[O], w = _[O];
      w.reachable && k.nextSegments.push(w), k.reachable && w.prevSegments.push(k), k.allNextSegments.push(w), w.allPrevSegments.push(k), w.allPrevSegments.length >= 2 && i.markPrevSegmentAsLooped(w, k), x.notifyLooped(k, w);
    }
  }
  function S(x, A, R) {
    A.processed || (A.trueForkContext.add(R), A.falseForkContext.add(R), A.nullishForkContext.add(R)), x.test !== !0 && x.brokenForkContext.addAll(A.falseForkContext), x.endOfTestSegments = A.trueForkContext.makeNext(0, -1);
  }
  class C {
    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An id generator to generate id for code
     *   path segments.
     * @param {Function} onLooped A callback function to notify looping.
     */
    constructor(A, R) {
      this.idGenerator = A, this.notifyLooped = R, this.forkContext = t.newRoot(A), this.choiceContext = null, this.switchContext = null, this.tryContext = null, this.loopContext = null, this.breakContext = null, this.chainContext = null, this.currentSegments = [], this.initialSegment = this.forkContext.head[0], this.finalSegments = [], this.returnedForkContext = [], this.thrownForkContext = [];
      const L = this.finalSegments, _ = this.returnedForkContext, I = this.thrownForkContext;
      _.add = s.bind(null, _, I, L), I.add = s.bind(null, I, _, L);
    }
    /**
     * A passthrough property exposing the current pointer as part of the API.
     * @type {CodePathSegment[]}
     */
    get headSegments() {
      return this.forkContext.head;
    }
    /**
     * The parent forking context.
     * This is used for the root of new forks.
     * @type {ForkContext}
     */
    get parentForkContext() {
      const A = this.forkContext;
      return A && A.upper;
    }
    /**
     * Creates and stacks new forking context.
     * @param {boolean} forkLeavingPath A flag which shows being in a
     *   "finally" block.
     * @returns {ForkContext} The created context.
     */
    pushForkContext(A) {
      return this.forkContext = t.newEmpty(
        this.forkContext,
        A
      ), this.forkContext;
    }
    /**
     * Pops and merges the last forking context.
     * @returns {ForkContext} The last context.
     */
    popForkContext() {
      const A = this.forkContext;
      return this.forkContext = A.upper, this.forkContext.replaceHead(A.makeNext(0, -1)), A;
    }
    /**
     * Creates a new path.
     * @returns {void}
     */
    forkPath() {
      this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }
    /**
     * Creates a bypass path.
     * This is used for such as IfStatement which does not have "else" chunk.
     * @returns {void}
     */
    forkBypassPath() {
      this.forkContext.add(this.parentForkContext.head);
    }
    //--------------------------------------------------------------------------
    // ConditionalExpression, LogicalExpression, IfStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),
     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
     *
     * LogicalExpressions have cases that it goes different paths between the
     * `true` case and the `false` case.
     *
     * For Example:
     *
     *     if (a || b) {
     *         foo();
     *     } else {
     *         bar();
     *     }
     *
     * In this case, `b` is evaluated always in the code path of the `else`
     * block, but it's not so in the code path of the `if` block.
     * So there are 3 paths.
     *
     *     a -> foo();
     *     a -> b -> foo();
     *     a -> b -> bar();
     * @param {string} kind A kind string.
     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `"&&"` or `"||"` or `"??"`.
     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
     *   Otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @returns {void}
     */
    pushChoiceContext(A, R) {
      this.choiceContext = new r(this.choiceContext, A, R, this.forkContext);
    }
    /**
     * Pops the last choice context and finalizes it.
     * This is called upon leaving a node that represents a choice.
     * @throws {Error} (Unreachable.)
     * @returns {ChoiceContext} The popped context.
     */
    popChoiceContext() {
      const A = this.choiceContext, R = this.forkContext, L = R.head;
      switch (this.choiceContext = A.upper, A.kind) {
        case "&&":
        case "||":
        case "??":
          if (A.processed || (A.trueForkContext.add(L), A.falseForkContext.add(L), A.nullishForkContext.add(L)), A.isForkingAsResult) {
            const I = this.choiceContext;
            return I.trueForkContext.addAll(A.trueForkContext), I.falseForkContext.addAll(A.falseForkContext), I.nullishForkContext.addAll(A.nullishForkContext), I.processed = !0, A;
          }
          break;
        case "test":
          A.processed ? (A.falseForkContext.clear(), A.falseForkContext.add(L)) : (A.trueForkContext.clear(), A.trueForkContext.add(L));
          break;
        case "loop":
          return A;
        default:
          throw new Error("unreachable");
      }
      const _ = A.trueForkContext;
      return _.addAll(A.falseForkContext), R.replaceHead(_.makeNext(0, -1)), A;
    }
    /**
     * Creates a code path segment to represent right-hand operand of a logical
     * expression.
     * This is called in the preprocessing phase when entering a node.
     * @throws {Error} (Unreachable.)
     * @returns {void}
     */
    makeLogicalRight() {
      const A = this.choiceContext, R = this.forkContext;
      if (A.processed) {
        let L;
        switch (A.kind) {
          case "&&":
            L = A.trueForkContext;
            break;
          case "||":
            L = A.falseForkContext;
            break;
          case "??":
            L = A.nullishForkContext;
            break;
          default:
            throw new Error("unreachable");
        }
        R.replaceHead(L.makeNext(0, -1)), L.clear(), A.processed = !1;
      } else {
        switch (A.kind) {
          case "&&":
            A.falseForkContext.add(R.head), A.nullishForkContext.add(R.head);
            break;
          case "||":
            A.trueForkContext.add(R.head);
            break;
          case "??":
            A.trueForkContext.add(R.head), A.falseForkContext.add(R.head);
            break;
          default:
            throw new Error("unreachable");
        }
        R.replaceHead(R.makeNext(-1, -1));
      }
    }
    /**
     * Makes a code path segment of the `if` block.
     * @returns {void}
     */
    makeIfConsequent() {
      const A = this.choiceContext, R = this.forkContext;
      A.processed || (A.trueForkContext.add(R.head), A.falseForkContext.add(R.head), A.nullishForkContext.add(R.head)), A.processed = !1, R.replaceHead(
        A.trueForkContext.makeNext(0, -1)
      );
    }
    /**
     * Makes a code path segment of the `else` block.
     * @returns {void}
     */
    makeIfAlternate() {
      const A = this.choiceContext, R = this.forkContext;
      A.trueForkContext.clear(), A.trueForkContext.add(R.head), A.processed = !0, R.replaceHead(
        A.falseForkContext.makeNext(0, -1)
      );
    }
    //--------------------------------------------------------------------------
    // ChainExpression
    //--------------------------------------------------------------------------
    /**
     * Pushes a new `ChainExpression` context to the stack. This method is
     * called when entering a `ChainExpression` node. A chain context is used to
     * count forking in the optional chain then merge them on the exiting from the
     * `ChainExpression` node.
     * @returns {void}
     */
    pushChainContext() {
      this.chainContext = new f(this.chainContext);
    }
    /**
     * Pop a `ChainExpression` context from the stack. This method is called on
     * exiting from each `ChainExpression` node. This merges all forks of the
     * last optional chaining.
     * @returns {void}
     */
    popChainContext() {
      const A = this.chainContext;
      this.chainContext = A.upper;
      for (let R = A.choiceContextCount; R > 0; --R)
        this.popChoiceContext();
    }
    /**
     * Create a choice context for optional access.
     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.
     * This creates a choice context as similar to `LogicalExpression[operator="??"]` node.
     * @returns {void}
     */
    makeOptionalNode() {
      this.chainContext && (this.chainContext.choiceContextCount += 1, this.pushChoiceContext("??", !1));
    }
    /**
     * Create a fork.
     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.
     * @returns {void}
     */
    makeOptionalRight() {
      this.chainContext && this.makeLogicalRight();
    }
    //--------------------------------------------------------------------------
    // SwitchStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of SwitchStatement and stacks it.
     * @param {boolean} hasCase `true` if the switch statement has one or more
     *   case parts.
     * @param {string|null} label The label text.
     * @returns {void}
     */
    pushSwitchContext(A, R) {
      this.switchContext = new h(this.switchContext, A), this.pushBreakContext(!0, R);
    }
    /**
     * Pops the last context of SwitchStatement and finalizes it.
     *
     * - Disposes all forking stack for `case` and `default`.
     * - Creates the next code path segment from `context.brokenForkContext`.
     * - If the last `SwitchCase` node is not a `default` part, creates a path
     *   to the `default` body.
     * @returns {void}
     */
    popSwitchContext() {
      const A = this.switchContext;
      this.switchContext = A.upper;
      const R = this.forkContext, L = this.popBreakContext().brokenForkContext;
      if (A.forkCount === 0) {
        L.empty || (L.add(R.makeNext(-1, -1)), R.replaceHead(L.makeNext(0, -1)));
        return;
      }
      const _ = R.head;
      this.forkBypassPath();
      const I = R.head;
      L.add(_), A.lastIsDefault || (A.defaultBodySegments ? (T(A.defaultSegments, A.defaultBodySegments), b(this, I, A.defaultBodySegments)) : L.add(I));
      for (let O = 0; O < A.forkCount; ++O)
        this.forkContext = this.forkContext.upper;
      this.forkContext.replaceHead(L.makeNext(0, -1));
    }
    /**
     * Makes a code path segment for a `SwitchCase` node.
     * @param {boolean} isCaseBodyEmpty `true` if the body is empty.
     * @param {boolean} isDefaultCase `true` if the body is the default case.
     * @returns {void}
     */
    makeSwitchCaseBody(A, R) {
      const L = this.switchContext;
      if (!L.hasCase)
        return;
      const _ = this.forkContext, I = this.pushForkContext();
      I.add(_.makeNext(0, -1)), R ? (L.defaultSegments = _.head, A ? L.foundEmptyDefault = !0 : L.defaultBodySegments = I.head) : !A && L.foundEmptyDefault && (L.foundEmptyDefault = !1, L.defaultBodySegments = I.head), L.lastIsDefault = R, L.forkCount += 1;
    }
    //--------------------------------------------------------------------------
    // TryStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of TryStatement and stacks it.
     * @param {boolean} hasFinalizer `true` if the try statement has a
     *   `finally` block.
     * @returns {void}
     */
    pushTryContext(A) {
      this.tryContext = new l(this.tryContext, A, this.forkContext);
    }
    /**
     * Pops the last context of TryStatement and finalizes it.
     * @returns {void}
     */
    popTryContext() {
      const A = this.tryContext;
      if (this.tryContext = A.upper, A.position === "catch") {
        this.popForkContext();
        return;
      }
      const R = A.returnedForkContext, L = A.thrownForkContext;
      if (R.empty && L.empty)
        return;
      const _ = this.forkContext.head;
      this.forkContext = this.forkContext.upper;
      const I = _.slice(0, _.length / 2 | 0), O = _.slice(_.length / 2 | 0);
      R.empty || d(this).returnedForkContext.add(O), L.empty || y(this).thrownForkContext.add(O), this.forkContext.replaceHead(I), !A.lastOfTryIsReachable && !A.lastOfCatchIsReachable && this.forkContext.makeUnreachable();
    }
    /**
     * Makes a code path segment for a `catch` block.
     * @returns {void}
     */
    makeCatchBlock() {
      const A = this.tryContext, R = this.forkContext, L = A.thrownForkContext;
      A.position = "catch", A.thrownForkContext = t.newEmpty(R), A.lastOfTryIsReachable = R.reachable, L.add(R.head);
      const _ = L.makeNext(0, -1);
      this.pushForkContext(), this.forkBypassPath(), this.forkContext.add(_);
    }
    /**
     * Makes a code path segment for a `finally` block.
     *
     * In the `finally` block, parallel paths are created. The parallel paths
     * are used as leaving-paths. The leaving-paths are paths from `return`
     * statements and `throw` statements in a `try` block or a `catch` block.
     * @returns {void}
     */
    makeFinallyBlock() {
      const A = this.tryContext;
      let R = this.forkContext;
      const L = A.returnedForkContext, _ = A.thrownForkContext, I = R.head;
      if (A.position === "catch" ? (this.popForkContext(), R = this.forkContext, A.lastOfCatchIsReachable = R.reachable) : A.lastOfTryIsReachable = R.reachable, A.position = "finally", L.empty && _.empty)
        return;
      const O = R.makeNext(-1, -1);
      for (let k = 0; k < R.count; ++k) {
        const w = [I[k]];
        for (let U = 0; U < L.segmentsList.length; ++U)
          w.push(L.segmentsList[U][k]);
        for (let U = 0; U < _.segmentsList.length; ++U)
          w.push(_.segmentsList[U][k]);
        O.push(
          i.newNext(
            this.idGenerator.next(),
            w
          )
        );
      }
      this.pushForkContext(!0), this.forkContext.add(O);
    }
    /**
     * Makes a code path segment from the first throwable node to the `catch`
     * block or the `finally` block.
     * @returns {void}
     */
    makeFirstThrowablePathInTryBlock() {
      const A = this.forkContext;
      if (!A.reachable)
        return;
      const R = y(this);
      R === this || R.position !== "try" || !R.thrownForkContext.empty || (R.thrownForkContext.add(A.head), A.replaceHead(A.makeNext(-1, -1)));
    }
    //--------------------------------------------------------------------------
    // Loop Statements
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of a loop statement and stacks it.
     * @param {string} type The type of the node which was triggered. One of
     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
     *   and `ForStatement`.
     * @param {string|null} label A label of the node which was triggered.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    pushLoopContext(A, R) {
      const L = this.forkContext, _ = this.pushBreakContext(!0, R);
      switch (A) {
        case "WhileStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = new e(this.loopContext, R, _);
          break;
        case "DoWhileStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = new a(this.loopContext, R, _, L);
          break;
        case "ForStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = new n(this.loopContext, R, _);
          break;
        case "ForInStatement":
          this.loopContext = new p(this.loopContext, R, _);
          break;
        case "ForOfStatement":
          this.loopContext = new m(this.loopContext, R, _);
          break;
        default:
          throw new Error(`unknown type: "${A}"`);
      }
    }
    /**
     * Pops the last context of a loop statement and finalizes it.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    popLoopContext() {
      const A = this.loopContext;
      this.loopContext = A.upper;
      const R = this.forkContext, L = this.popBreakContext().brokenForkContext;
      switch (A.type) {
        case "WhileStatement":
        case "ForStatement":
          this.popChoiceContext(), b(
            this,
            R.head,
            A.continueDestSegments
          );
          break;
        case "DoWhileStatement": {
          const _ = this.popChoiceContext();
          _.processed || (_.trueForkContext.add(R.head), _.falseForkContext.add(R.head)), A.test !== !0 && L.addAll(_.falseForkContext);
          const I = _.trueForkContext.segmentsList;
          for (let O = 0; O < I.length; ++O)
            b(
              this,
              I[O],
              A.entrySegments
            );
          break;
        }
        case "ForInStatement":
        case "ForOfStatement":
          L.add(R.head), b(
            this,
            R.head,
            A.leftSegments
          );
          break;
        default:
          throw new Error("unreachable");
      }
      L.empty ? R.replaceHead(R.makeUnreachable(-1, -1)) : R.replaceHead(L.makeNext(0, -1));
    }
    /**
     * Makes a code path segment for the test part of a WhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeWhileTest(A) {
      const R = this.loopContext, L = this.forkContext, _ = L.makeNext(0, -1);
      R.test = A, R.continueDestSegments = _, L.replaceHead(_);
    }
    /**
     * Makes a code path segment for the body part of a WhileStatement.
     * @returns {void}
     */
    makeWhileBody() {
      const A = this.loopContext, R = this.choiceContext, L = this.forkContext;
      R.processed || (R.trueForkContext.add(L.head), R.falseForkContext.add(L.head)), A.test !== !0 && A.brokenForkContext.addAll(R.falseForkContext), L.replaceHead(R.trueForkContext.makeNext(0, -1));
    }
    /**
     * Makes a code path segment for the body part of a DoWhileStatement.
     * @returns {void}
     */
    makeDoWhileBody() {
      const A = this.loopContext, R = this.forkContext, L = R.makeNext(-1, -1);
      A.entrySegments = L, R.replaceHead(L);
    }
    /**
     * Makes a code path segment for the test part of a DoWhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeDoWhileTest(A) {
      const R = this.loopContext, L = this.forkContext;
      if (R.test = A, !R.continueForkContext.empty) {
        R.continueForkContext.add(L.head);
        const _ = R.continueForkContext.makeNext(0, -1);
        L.replaceHead(_);
      }
    }
    /**
     * Makes a code path segment for the test part of a ForStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeForTest(A) {
      const R = this.loopContext, L = this.forkContext, _ = L.head, I = L.makeNext(-1, -1);
      R.test = A, R.endOfInitSegments = _, R.continueDestSegments = R.testSegments = I, L.replaceHead(I);
    }
    /**
     * Makes a code path segment for the update part of a ForStatement.
     * @returns {void}
     */
    makeForUpdate() {
      const A = this.loopContext, R = this.choiceContext, L = this.forkContext;
      A.testSegments ? S(
        A,
        R,
        L.head
      ) : A.endOfInitSegments = L.head;
      const _ = L.makeDisconnected(-1, -1);
      A.continueDestSegments = A.updateSegments = _, L.replaceHead(_);
    }
    /**
     * Makes a code path segment for the body part of a ForStatement.
     * @returns {void}
     */
    makeForBody() {
      const A = this.loopContext, R = this.choiceContext, L = this.forkContext;
      A.updateSegments ? (A.endOfUpdateSegments = L.head, A.testSegments && b(
        this,
        A.endOfUpdateSegments,
        A.testSegments
      )) : A.testSegments ? S(
        A,
        R,
        L.head
      ) : A.endOfInitSegments = L.head;
      let _ = A.endOfTestSegments;
      if (!_) {
        const I = t.newEmpty(L);
        I.add(A.endOfInitSegments), A.endOfUpdateSegments && I.add(A.endOfUpdateSegments), _ = I.makeNext(0, -1);
      }
      A.continueDestSegments = A.continueDestSegments || _, L.replaceHead(_);
    }
    /**
     * Makes a code path segment for the left part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfLeft() {
      const A = this.loopContext, R = this.forkContext, L = R.makeDisconnected(-1, -1);
      A.prevSegments = R.head, A.leftSegments = A.continueDestSegments = L, R.replaceHead(L);
    }
    /**
     * Makes a code path segment for the right part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfRight() {
      const A = this.loopContext, R = this.forkContext, L = t.newEmpty(R);
      L.add(A.prevSegments);
      const _ = L.makeNext(-1, -1);
      A.endOfLeftSegments = R.head, R.replaceHead(_);
    }
    /**
     * Makes a code path segment for the body part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfBody() {
      const A = this.loopContext, R = this.forkContext, L = t.newEmpty(R);
      L.add(A.endOfLeftSegments);
      const _ = L.makeNext(-1, -1);
      b(this, R.head, A.leftSegments), A.brokenForkContext.add(R.head), R.replaceHead(_);
    }
    //--------------------------------------------------------------------------
    // Control Statements
    //--------------------------------------------------------------------------
    /**
     * Creates new context in which a `break` statement can be used. This occurs inside of a loop,
     * labeled statement, or switch statement.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label associated with the statement.
     * @returns {BreakContext} The new context.
     */
    pushBreakContext(A, R) {
      return this.breakContext = new o(this.breakContext, A, R, this.forkContext), this.breakContext;
    }
    /**
     * Removes the top item of the break context stack.
     * @returns {Object} The removed context.
     */
    popBreakContext() {
      const A = this.breakContext, R = this.forkContext;
      if (this.breakContext = A.upper, !A.breakable) {
        const L = A.brokenForkContext;
        L.empty || (L.add(R.head), R.replaceHead(L.makeNext(0, -1)));
      }
      return A;
    }
    /**
     * Makes a path for a `break` statement.
     *
     * It registers the head segment to a context of `break`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the break statement.
     * @returns {void}
     */
    makeBreak(A) {
      const R = this.forkContext;
      if (!R.reachable)
        return;
      const L = g(this, A);
      L && L.brokenForkContext.add(R.head), R.replaceHead(R.makeUnreachable(-1, -1));
    }
    /**
     * Makes a path for a `continue` statement.
     *
     * It makes a looping path.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the continue statement.
     * @returns {void}
     */
    makeContinue(A) {
      const R = this.forkContext;
      if (!R.reachable)
        return;
      const L = c(this, A);
      L && (L.continueDestSegments ? (b(this, R.head, L.continueDestSegments), (L.type === "ForInStatement" || L.type === "ForOfStatement") && L.brokenForkContext.add(R.head)) : L.continueForkContext.add(R.head)), R.replaceHead(R.makeUnreachable(-1, -1));
    }
    /**
     * Makes a path for a `return` statement.
     *
     * It registers the head segment to a context of `return`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeReturn() {
      const A = this.forkContext;
      A.reachable && (d(this).returnedForkContext.add(A.head), A.replaceHead(A.makeUnreachable(-1, -1)));
    }
    /**
     * Makes a path for a `throw` statement.
     *
     * It registers the head segment to a context of `throw`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeThrow() {
      const A = this.forkContext;
      A.reachable && (y(this).thrownForkContext.add(A.head), A.replaceHead(A.makeUnreachable(-1, -1)));
    }
    /**
     * Makes the final path.
     * @returns {void}
     */
    makeFinal() {
      const A = this.currentSegments;
      A.length > 0 && A[0].reachable && this.returnedForkContext.add(A);
    }
  }
  return ei = C, ei;
}
var ti, rm;
function vv() {
  if (rm) return ti;
  rm = 1;
  class i {
    /**
     * @param {string} prefix Optional. A prefix of generated ids.
     */
    constructor(o) {
      this.prefix = String(o), this.n = 0;
    }
    /**
     * Generates id.
     * @returns {string} A generated id.
     */
    next() {
      return this.n = 1 + this.n | 0, this.n < 0 && (this.n = 1), this.prefix + this.n;
    }
  }
  return ti = i, ti;
}
var ri, nm;
function IA() {
  if (nm) return ri;
  nm = 1;
  const i = PA(), t = vv();
  class o {
    /**
     * Creates a new instance.
     * @param {Object} options Options for the function (see below).
     * @param {string} options.id An identifier.
     * @param {string} options.origin The type of code path origin.
     * @param {CodePath|null} options.upper The code path of the upper function scope.
     * @param {Function} options.onLooped A callback function to notify looping.
     */
    constructor({ id: r, origin: u, upper: e, onLooped: a }) {
      this.id = r, this.origin = u, this.upper = e, this.childCodePaths = [], Object.defineProperty(
        this,
        "internal",
        { value: new i(new t(`${r}_`), a) }
      ), e && e.childCodePaths.push(this);
    }
    /**
     * Gets the state of a given code path.
     * @param {CodePath} codePath A code path to get.
     * @returns {CodePathState} The state of the code path.
     */
    static getState(r) {
      return r.internal;
    }
    /**
     * The initial code path segment. This is the segment that is at the head
     * of the code path.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment}
     */
    get initialSegment() {
      return this.internal.initialSegment;
    }
    /**
     * Final code path segments. These are the terminal (tail) segments in the
     * code path, which is the combination of `returnedSegments` and `thrownSegments`.
     * All segments in this array are reachable.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment[]}
     */
    get finalSegments() {
      return this.internal.finalSegments;
    }
    /**
     * Final code path segments that represent normal completion of the code path.
     * For functions, this means both explicit `return` statements and implicit returns,
     * such as the last reachable segment in a function that does not have an
     * explicit `return` as this implicitly returns `undefined`. For scripts,
     * modules, class field initializers, and class static blocks, this means
     * all lines of code have been executed.
     * These segments are also present in `finalSegments`.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment[]}
     */
    get returnedSegments() {
      return this.internal.returnedForkContext;
    }
    /**
     * Final code path segments that represent `throw` statements.
     * This is a passthrough to the underlying `CodePathState`.
     * These segments are also present in `finalSegments`.
     * @type {CodePathSegment[]}
     */
    get thrownSegments() {
      return this.internal.thrownForkContext;
    }
    /**
     * Tracks the traversal of the code path through each segment. This array
     * starts empty and segments are added or removed as the code path is
     * traversed. This array always ends up empty at the end of a code path
     * traversal. The `CodePathState` uses this to track its progress through
     * the code path.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment[]}
     * @deprecated
     */
    get currentSegments() {
      return this.internal.currentSegments;
    }
    /**
     * Traverses all segments in this code path.
     *
     *     codePath.traverseSegments((segment, controller) => {
     *         // do something.
     *     });
     *
     * This method enumerates segments in order from the head.
     *
     * The `controller` argument has two methods:
     *
     * - `skip()` - skips the following segments in this branch
     * - `break()` - skips all following segments in the traversal
     *
     * A note on the parameters: the `options` argument is optional. This means
     * the first argument might be an options object or the callback function.
     * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.
     * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.
     * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.
     * @param {Function} callback A callback function.
     * @returns {void}
     */
    traverseSegments(r, u) {
      let e, a;
      typeof r == "function" ? (a = r, e = {}) : (e = r || {}, a = u);
      const n = e.first || this.internal.initialSegment, p = e.last;
      let m = null, h = 0, l = 0, s = null;
      const c = /* @__PURE__ */ new Set(), g = [[n, 0]];
      let d = null, y = !1;
      const v = {
        /**
         * Skip the following segments in this branch.
         * @returns {void}
         */
        skip() {
          g.length <= 1 ? y = !0 : d = g[g.length - 2][0];
        },
        /**
         * Stop traversal completely - do not traverse to any
         * other segments.
         * @returns {void}
         */
        break() {
          y = !0;
        }
      };
      function T(b) {
        return c.has(b) || s.isLoopedPrevSegment(b);
      }
      for (; g.length > 0; ) {
        if (m = g[g.length - 1], s = m[0], h = m[1], h === 0) {
          if (c.has(s)) {
            g.pop();
            continue;
          }
          if (s !== n && s.prevSegments.length > 0 && !s.prevSegments.every(T)) {
            g.pop();
            continue;
          }
          if (d && s.prevSegments.includes(d) && (d = null), c.add(s), !d && (a.call(this, s, v), s === p && v.skip(), y))
            break;
        }
        l = s.nextSegments.length - 1, h < l ? (m[1] += 1, g.push([s.nextSegments[h], 0])) : h === l ? (m[0] = s.nextSegments[h], m[1] = 0) : g.pop();
      }
    }
  }
  return ri = o, ri;
}
var ni, sm;
function FA() {
  if (sm) return ni;
  sm = 1;
  const i = It, { breakableTypePattern: t } = mn(), o = IA(), f = Wf(), r = vv(), u = Cv();
  function e(S) {
    return !!S.test;
  }
  function a(S) {
    const C = S.parent;
    return C && C.type === "PropertyDefinition" && C.value === S;
  }
  function n(S) {
    return S === "&&" || S === "||" || S === "??";
  }
  function p(S) {
    return S === "&&=" || S === "||=" || S === "??=";
  }
  function m(S) {
    return S.parent.type === "LabeledStatement" ? S.parent.label.name : null;
  }
  function h(S) {
    const C = S.parent;
    switch (C.type) {
      case "ConditionalExpression":
      case "IfStatement":
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
        return C.test === S;
      case "LogicalExpression":
        return n(C.operator);
      case "AssignmentExpression":
        return p(C.operator);
      default:
        return !1;
    }
  }
  function l(S) {
    if (S.type === "Literal")
      return !!S.value;
  }
  function s(S) {
    const C = S.parent;
    switch (C.type) {
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "ArrayPattern":
      case "RestElement":
      case "ImportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "CatchClause":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "ClassDeclaration":
      case "ClassExpression":
      case "VariableDeclarator":
        return C.id !== S;
      case "Property":
      case "PropertyDefinition":
      case "MethodDefinition":
        return C.key !== S || C.computed || C.shorthand;
      case "AssignmentPattern":
        return C.key !== S;
      default:
        return !0;
    }
  }
  function c(S, C) {
    const x = S.codePath, A = o.getState(x), R = A.currentSegments, L = A.headSegments, _ = Math.max(R.length, L.length);
    let I, O, k;
    for (I = 0; I < _; ++I)
      if (O = R[I], k = L[I], O !== k && O) {
        const w = O.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
        u.dump(`${w} ${O.id}`), S.emitter.emit(
          w,
          O,
          C
        );
      }
    for (A.currentSegments = L, I = 0; I < _; ++I)
      if (O = R[I], k = L[I], O !== k && k) {
        const w = k.reachable ? "onCodePathSegmentStart" : "onUnreachableCodePathSegmentStart";
        u.dump(`${w} ${k.id}`), f.markUsed(k), S.emitter.emit(
          w,
          k,
          C
        );
      }
  }
  function g(S, C) {
    const x = o.getState(S.codePath), A = x.currentSegments;
    for (let R = 0; R < A.length; ++R) {
      const L = A[R], _ = L.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
      u.dump(`${_} ${L.id}`), S.emitter.emit(
        _,
        L,
        C
      );
    }
    x.currentSegments = [];
  }
  function d(S, C) {
    const x = S.codePath, A = o.getState(x), R = C.parent;
    switch (R.type) {
      case "CallExpression":
        R.optional === !0 && R.arguments.length >= 1 && R.arguments[0] === C && A.makeOptionalRight();
        break;
      case "MemberExpression":
        R.optional === !0 && R.property === C && A.makeOptionalRight();
        break;
      case "LogicalExpression":
        R.right === C && n(R.operator) && A.makeLogicalRight();
        break;
      case "AssignmentExpression":
        R.right === C && p(R.operator) && A.makeLogicalRight();
        break;
      case "ConditionalExpression":
      case "IfStatement":
        R.consequent === C ? A.makeIfConsequent() : R.alternate === C && A.makeIfAlternate();
        break;
      case "SwitchCase":
        R.consequent[0] === C && A.makeSwitchCaseBody(!1, !R.test);
        break;
      case "TryStatement":
        R.handler === C ? A.makeCatchBlock() : R.finalizer === C && A.makeFinallyBlock();
        break;
      case "WhileStatement":
        R.test === C ? A.makeWhileTest(l(C)) : (i(R.body === C), A.makeWhileBody());
        break;
      case "DoWhileStatement":
        R.body === C ? A.makeDoWhileBody() : (i(R.test === C), A.makeDoWhileTest(l(C)));
        break;
      case "ForStatement":
        R.test === C ? A.makeForTest(l(C)) : R.update === C ? A.makeForUpdate() : R.body === C && A.makeForBody();
        break;
      case "ForInStatement":
      case "ForOfStatement":
        R.left === C ? A.makeForInOfLeft() : R.right === C ? A.makeForInOfRight() : (i(R.body === C), A.makeForInOfBody());
        break;
      case "AssignmentPattern":
        R.right === C && (A.pushForkContext(), A.forkBypassPath(), A.forkPath());
        break;
    }
  }
  function y(S, C) {
    let x = S.codePath, A = x && o.getState(x);
    const R = C.parent;
    function L(_) {
      x && (c(S, C), u.dumpState(C, A, !1)), x = S.codePath = new o({
        id: S.idGenerator.next(),
        origin: _,
        upper: x,
        onLooped: S.onLooped
      }), A = o.getState(x), u.dump(`onCodePathStart ${x.id}`), S.emitter.emit("onCodePathStart", x, C);
    }
    switch (a(C) && L("class-field-initializer"), C.type) {
      case "Program":
        L("program");
        break;
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
        L("function");
        break;
      case "StaticBlock":
        L("class-static-block");
        break;
      case "ChainExpression":
        A.pushChainContext();
        break;
      case "CallExpression":
        C.optional === !0 && A.makeOptionalNode();
        break;
      case "MemberExpression":
        C.optional === !0 && A.makeOptionalNode();
        break;
      case "LogicalExpression":
        n(C.operator) && A.pushChoiceContext(
          C.operator,
          h(C)
        );
        break;
      case "AssignmentExpression":
        p(C.operator) && A.pushChoiceContext(
          C.operator.slice(0, -1),
          // removes `=` from the end
          h(C)
        );
        break;
      case "ConditionalExpression":
      case "IfStatement":
        A.pushChoiceContext("test", !1);
        break;
      case "SwitchStatement":
        A.pushSwitchContext(
          C.cases.some(e),
          m(C)
        );
        break;
      case "TryStatement":
        A.pushTryContext(!!C.finalizer);
        break;
      case "SwitchCase":
        R.discriminant !== C && R.cases[0] !== C && A.forkPath();
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        A.pushLoopContext(C.type, m(C));
        break;
      case "LabeledStatement":
        t.test(C.body.type) || A.pushBreakContext(!1, C.label.name);
        break;
    }
    c(S, C), u.dumpState(C, A, !1);
  }
  function v(S, C) {
    const x = S.codePath, A = o.getState(x);
    let R = !1;
    switch (C.type) {
      case "ChainExpression":
        A.popChainContext();
        break;
      case "IfStatement":
      case "ConditionalExpression":
        A.popChoiceContext();
        break;
      case "LogicalExpression":
        n(C.operator) && A.popChoiceContext();
        break;
      case "AssignmentExpression":
        p(C.operator) && A.popChoiceContext();
        break;
      case "SwitchStatement":
        A.popSwitchContext();
        break;
      case "SwitchCase":
        C.consequent.length === 0 && A.makeSwitchCaseBody(!0, !C.test), A.forkContext.reachable && (R = !0);
        break;
      case "TryStatement":
        A.popTryContext();
        break;
      case "BreakStatement":
        c(S, C), A.makeBreak(C.label && C.label.name), R = !0;
        break;
      case "ContinueStatement":
        c(S, C), A.makeContinue(C.label && C.label.name), R = !0;
        break;
      case "ReturnStatement":
        c(S, C), A.makeReturn(), R = !0;
        break;
      case "ThrowStatement":
        c(S, C), A.makeThrow(), R = !0;
        break;
      case "Identifier":
        s(C) && (A.makeFirstThrowablePathInTryBlock(), R = !0);
        break;
      case "CallExpression":
      case "ImportExpression":
      case "MemberExpression":
      case "NewExpression":
      case "YieldExpression":
        A.makeFirstThrowablePathInTryBlock();
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        A.popLoopContext();
        break;
      case "AssignmentPattern":
        A.popForkContext();
        break;
      case "LabeledStatement":
        t.test(C.body.type) || A.popBreakContext();
        break;
    }
    R || c(S, C), u.dumpState(C, A, !0);
  }
  function T(S, C) {
    function x() {
      let A = S.codePath;
      o.getState(A).makeFinal(), g(S, C), u.dump(`onCodePathEnd ${A.id}`), S.emitter.emit("onCodePathEnd", A, C), u.dumpDot(A), A = S.codePath = S.codePath.upper, A && u.dumpState(C, o.getState(A), !0);
    }
    switch (C.type) {
      case "Program":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "StaticBlock": {
        x();
        break;
      }
      case "CallExpression":
        C.optional === !0 && C.arguments.length === 0 && o.getState(S.codePath).makeOptionalRight();
        break;
    }
    a(C) && x();
  }
  class b {
    /**
     * @param {EventGenerator} eventGenerator An event generator to wrap.
     */
    constructor(C) {
      this.original = C, this.emitter = C.emitter, this.codePath = null, this.idGenerator = new r("s"), this.currentNode = null, this.onLooped = this.onLooped.bind(this);
    }
    /**
     * Does the process to enter a given AST node.
     * This updates state of analysis and calls `enterNode` of the wrapped.
     * @param {ASTNode} node A node which is entering.
     * @returns {void}
     */
    enterNode(C) {
      this.currentNode = C, C.parent && d(this, C), y(this, C), this.original.enterNode(C), this.currentNode = null;
    }
    /**
     * Does the process to leave a given AST node.
     * This updates state of analysis and calls `leaveNode` of the wrapped.
     * @param {ASTNode} node A node which is leaving.
     * @returns {void}
     */
    leaveNode(C) {
      this.currentNode = C, v(this, C), this.original.leaveNode(C), T(this, C), this.currentNode = null;
    }
    /**
     * This is called on a code path looped.
     * Then this raises a looped event.
     * @param {CodePathSegment} fromSegment A segment of prev.
     * @param {CodePathSegment} toSegment A segment of next.
     * @returns {void}
     */
    onLooped(C, x) {
      C.reachable && x.reachable && (u.dump(`onCodePathSegmentLoop ${C.id} -> ${x.id}`), this.emitter.emit(
        "onCodePathSegmentLoop",
        C,
        x,
        this.currentNode
      ));
    }
  }
  return ni = b, ni;
}
var si, im;
function dn() {
  return im || (im = 1, si = (i) => {
    if (typeof i != "string")
      throw new TypeError("Expected a string");
    return i.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }), si;
}
var ii, am;
function NA() {
  if (am) return ii;
  am = 1;
  const i = dn();
  function t(n, p) {
    return n.line - p.line || n.column - p.column;
  }
  function o(n) {
    const p = /* @__PURE__ */ new Map();
    for (const m of n) {
      const { unprocessedDirective: { parentComment: h } } = m;
      p.has(h) ? p.get(h).push(m) : p.set(h, [m]);
    }
    return [...p.values()];
  }
  function f(n, p) {
    const m = p.range[0] + 2, h = /^\s*\S+\s+/u.exec(p.value)[0].length, l = p.value.slice(h).split(/\s-{2,}\s/u)[0].trimEnd();
    return n.map((s) => {
      const { ruleId: c } = s, d = new RegExp(String.raw`(?:^|\s*,\s*)(?<quote>['"]?)${i(c)}\k<quote>(?:\s*,\s*|$)`, "u").exec(l), y = d[0], v = h + d.index, T = v + y.length, b = y.indexOf(","), S = y.lastIndexOf(",");
      let C, x;
      return b !== S ? (C = v + b, x = v + S) : (C = v, x = T), {
        description: `'${c}'`,
        fix: {
          range: [
            m + C,
            m + x
          ],
          text: ""
        },
        unprocessedDirective: s.unprocessedDirective
      };
    });
  }
  function r(n, p) {
    const { range: m } = p, h = n.filter((l) => l.ruleId).map((l) => `'${l.ruleId}'`);
    return {
      description: h.length <= 2 ? h.join(" or ") : `${h.slice(0, h.length - 1).join(", ")}, or ${h[h.length - 1]}`,
      fix: {
        range: m,
        text: " "
      },
      unprocessedDirective: n[0].unprocessedDirective
    };
  }
  function u(n) {
    return o(n).flatMap(
      (m) => {
        const { parentComment: h } = m[0].unprocessedDirective, l = new Set(h.ruleIds);
        for (const s of m)
          l.delete(s.ruleId);
        return l.size ? f(m, h.commentToken) : [r(m, h.commentToken)];
      }
    );
  }
  function e(n) {
    const p = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Set();
    for (let h = n.length - 1; h >= 0; h--) {
      const l = n[h];
      if (l.type === "disable") {
        if (p.size === 0)
          continue;
        if (l.ruleId === null) {
          for (const s of p.values())
            m.add(s);
          p.clear();
        } else {
          const s = p.get(l.ruleId);
          if (s)
            m.add(s);
          else {
            const c = p.get(null);
            c && m.add(c);
          }
        }
      } else l.type === "enable" && (l.ruleId === null ? (p.clear(), p.set(null, l)) : p.set(l.ruleId, l));
    }
    return m;
  }
  function a(n) {
    const p = [], m = /* @__PURE__ */ new Set();
    for (const g of n.problems) {
      let d = [], y = 0;
      for (; y < n.directives.length && t(n.directives[y], g) <= 0; ) {
        const v = n.directives[y++];
        if (v.ruleId === null || v.ruleId === g.ruleId)
          switch (v.type) {
            case "disable":
              d.push(v);
              break;
            case "enable":
              d = [];
              break;
          }
      }
      if (d.length > 0) {
        const v = d.map((T) => ({
          kind: "directive",
          justification: T.unprocessedDirective.justification
        }));
        g.suppressions ? g.suppressions = g.suppressions.concat(v) : (g.suppressions = v, m.add(d[d.length - 1]));
      }
      p.push(g);
    }
    const h = n.directives.filter((g) => g.type === "disable" && !m.has(g)), l = new Set(
      n.directives.filter((g) => g.unprocessedDirective.type === "enable")
    );
    if (l.size > 0)
      for (const g of e(n.directives))
        l.delete(g);
    const c = u(h).concat(u(l)).map(({ description: g, fix: d, unprocessedDirective: y }) => {
      const { parentComment: v, type: T, line: b, column: S } = y;
      let C;
      return T === "enable" ? C = g ? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${g}).` : "Unused eslint-enable directive (no matching eslint-disable directives were found)." : C = g ? `Unused eslint-disable directive (no problems were reported from ${g}).` : "Unused eslint-disable directive (no problems were reported).", {
        ruleId: null,
        message: C,
        line: T === "disable-next-line" ? v.commentToken.loc.start.line : b,
        column: T === "disable-next-line" ? v.commentToken.loc.start.column + 1 : S,
        severity: n.reportUnusedDisableDirectives === "warn" ? 1 : 2,
        nodeType: null,
        ...n.disableFixes ? {} : { fix: d }
      };
    });
    return { problems: p, unusedDirectives: c };
  }
  return ii = ({ directives: n, disableFixes: p, problems: m, reportUnusedDisableDirectives: h = "off" }) => {
    const l = n.filter((d) => d.type === "disable" || d.type === "enable").map((d) => Object.assign({}, d, { unprocessedDirective: d })).sort(t), s = n.flatMap((d) => {
      switch (d.type) {
        case "disable":
        case "enable":
          return [];
        case "disable-line":
          return [
            { type: "disable", line: d.line, column: 1, ruleId: d.ruleId, unprocessedDirective: d },
            { type: "enable", line: d.line + 1, column: 0, ruleId: d.ruleId, unprocessedDirective: d }
          ];
        case "disable-next-line":
          return [
            { type: "disable", line: d.line + 1, column: 1, ruleId: d.ruleId, unprocessedDirective: d },
            { type: "enable", line: d.line + 2, column: 0, ruleId: d.ruleId, unprocessedDirective: d }
          ];
        default:
          throw new TypeError(`Unrecognized directive type '${d.type}'`);
      }
    }).sort(t), c = a({
      problems: m,
      directives: l,
      disableFixes: p,
      reportUnusedDisableDirectives: h
    }), g = a({
      problems: c.problems,
      directives: s,
      disableFixes: p,
      reportUnusedDisableDirectives: h
    });
    return h !== "off" ? g.problems.concat(c.unusedDirectives).concat(g.unusedDirectives).sort(t) : g.problems;
  }, ii;
}
function jr(i) {
  return (jr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  })(i);
}
function Xf(i, t) {
  return function(o) {
    if (Array.isArray(o)) return o;
  }(i) || function(o, f) {
    var r = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
    if (r != null) {
      var u, e, a, n, p = [], m = !0, h = !1;
      try {
        if (a = (r = r.call(o)).next, f !== 0) for (; !(m = (u = a.call(r)).done) && (p.push(u.value), p.length !== f); m = !0) ;
      } catch (l) {
        h = !0, e = l;
      } finally {
        try {
          if (!m && r.return != null && (n = r.return(), Object(n) !== n)) return;
        } finally {
          if (h) throw e;
        }
      }
      return p;
    }
  }(i, t) || Sv(i, t) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function OA(i) {
  return function(t) {
    if (Array.isArray(t)) return wf(t);
  }(i) || function(t) {
    if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
  }(i) || Sv(i) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function Sv(i, t) {
  if (i) {
    if (typeof i == "string") return wf(i, t);
    var o = Object.prototype.toString.call(i).slice(8, -1);
    return o === "Object" && i.constructor && (o = i.constructor.name), o === "Map" || o === "Set" ? Array.from(i) : o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? wf(i, t) : void 0;
  }
}
function wf(i, t) {
  (t == null || t > i.length) && (t = i.length);
  for (var o = 0, f = new Array(t); o < t; o++) f[o] = i[o];
  return f;
}
function Av(i, t) {
  return i(t = { exports: {} }, t.exports), t.exports;
}
var un = Av(function(i, t) {
  (function o(f) {
    var r, u, e, a, n, p;
    function m(T) {
      var b, S, C = {};
      for (b in T) T.hasOwnProperty(b) && (S = T[b], C[b] = typeof S == "object" && S !== null ? m(S) : S);
      return C;
    }
    function h(T, b) {
      this.parent = T, this.key = b;
    }
    function l(T, b, S, C) {
      this.node = T, this.path = b, this.wrap = S, this.ref = C;
    }
    function s() {
    }
    function c(T) {
      return T != null && typeof T == "object" && typeof T.type == "string";
    }
    function g(T, b) {
      return (T === r.ObjectExpression || T === r.ObjectPattern) && b === "properties";
    }
    function d(T, b) {
      for (var S = T.length - 1; S >= 0; --S) if (T[S].node === b) return !0;
      return !1;
    }
    function y(T, b) {
      return new s().traverse(T, b);
    }
    function v(T, b) {
      var S;
      return S = function(C, x) {
        var A, R, L, _;
        for (R = C.length, L = 0; R; ) x(C[_ = L + (A = R >>> 1)]) ? R = A : (L = _ + 1, R -= A + 1);
        return L;
      }(b, function(C) {
        return C.range[0] > T.range[0];
      }), T.extendedRange = [T.range[0], T.range[1]], S !== b.length && (T.extendedRange[1] = b[S].range[0]), (S -= 1) >= 0 && (T.extendedRange[0] = b[S].range[1]), T;
    }
    return r = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", PrivateIdentifier: "PrivateIdentifier", Program: "Program", Property: "Property", PropertyDefinition: "PropertyDefinition", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" }, e = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, u = { Break: a = {}, Skip: n = {}, Remove: p = {} }, h.prototype.replace = function(T) {
      this.parent[this.key] = T;
    }, h.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    }, s.prototype.path = function() {
      var T, b, S, C, x;
      function A(R, L) {
        if (Array.isArray(L)) for (S = 0, C = L.length; S < C; ++S) R.push(L[S]);
        else R.push(L);
      }
      if (!this.__current.path) return null;
      for (x = [], T = 2, b = this.__leavelist.length; T < b; ++T) A(x, this.__leavelist[T].path);
      return A(x, this.__current.path), x;
    }, s.prototype.type = function() {
      return this.current().type || this.__current.wrap;
    }, s.prototype.parents = function() {
      var T, b, S;
      for (S = [], T = 1, b = this.__leavelist.length; T < b; ++T) S.push(this.__leavelist[T].node);
      return S;
    }, s.prototype.current = function() {
      return this.__current.node;
    }, s.prototype.__execute = function(T, b) {
      var S, C;
      return C = void 0, S = this.__current, this.__current = b, this.__state = null, T && (C = T.call(this, b.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = S, C;
    }, s.prototype.notify = function(T) {
      this.__state = T;
    }, s.prototype.skip = function() {
      this.notify(n);
    }, s.prototype.break = function() {
      this.notify(a);
    }, s.prototype.remove = function() {
      this.notify(p);
    }, s.prototype.__initialize = function(T, b) {
      this.visitor = b, this.root = T, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, b.fallback === "iteration" ? this.__fallback = Object.keys : typeof b.fallback == "function" && (this.__fallback = b.fallback), this.__keys = e, b.keys && (this.__keys = Object.assign(Object.create(this.__keys), b.keys));
    }, s.prototype.traverse = function(T, b) {
      var S, C, x, A, R, L, _, I, O, k, w, U;
      for (this.__initialize(T, b), U = {}, S = this.__worklist, C = this.__leavelist, S.push(new l(T, null, null, null)), C.push(new l(null, null, null, null)); S.length; ) if ((x = S.pop()) !== U) {
        if (x.node) {
          if (L = this.__execute(b.enter, x), this.__state === a || L === a) return;
          if (S.push(U), C.push(x), this.__state === n || L === n) continue;
          if (R = (A = x.node).type || x.wrap, !(k = this.__keys[R])) {
            if (!this.__fallback) throw new Error("Unknown node type " + R + ".");
            k = this.__fallback(A);
          }
          for (I = k.length; (I -= 1) >= 0; ) if (w = A[_ = k[I]]) {
            if (Array.isArray(w)) {
              for (O = w.length; (O -= 1) >= 0; ) if (w[O] && !d(C, w[O])) {
                if (g(R, k[I])) x = new l(w[O], [_, O], "Property", null);
                else {
                  if (!c(w[O])) continue;
                  x = new l(w[O], [_, O], null, null);
                }
                S.push(x);
              }
            } else if (c(w)) {
              if (d(C, w)) continue;
              S.push(new l(w, _, null, null));
            }
          }
        }
      } else if (x = C.pop(), L = this.__execute(b.leave, x), this.__state === a || L === a) return;
    }, s.prototype.replace = function(T, b) {
      var S, C, x, A, R, L, _, I, O, k, w, U, q;
      function F($) {
        var P, X, Q, ue;
        if ($.ref.remove()) {
          for (X = $.ref.key, ue = $.ref.parent, P = S.length; P--; ) if ((Q = S[P]).ref && Q.ref.parent === ue) {
            if (Q.ref.key < X) break;
            --Q.ref.key;
          }
        }
      }
      for (this.__initialize(T, b), w = {}, S = this.__worklist, C = this.__leavelist, L = new l(T, null, null, new h(U = { root: T }, "root")), S.push(L), C.push(L); S.length; ) if ((L = S.pop()) !== w) {
        if ((R = this.__execute(b.enter, L)) !== void 0 && R !== a && R !== n && R !== p && (L.ref.replace(R), L.node = R), this.__state !== p && R !== p || (F(L), L.node = null), this.__state === a || R === a) return U.root;
        if ((x = L.node) && (S.push(w), C.push(L), this.__state !== n && R !== n)) {
          if (A = x.type || L.wrap, !(O = this.__keys[A])) {
            if (!this.__fallback) throw new Error("Unknown node type " + A + ".");
            O = this.__fallback(x);
          }
          for (_ = O.length; (_ -= 1) >= 0; ) if (k = x[q = O[_]]) if (Array.isArray(k)) {
            for (I = k.length; (I -= 1) >= 0; ) if (k[I]) {
              if (g(A, O[_])) L = new l(k[I], [q, I], "Property", new h(k, I));
              else {
                if (!c(k[I])) continue;
                L = new l(k[I], [q, I], null, new h(k, I));
              }
              S.push(L);
            }
          } else c(k) && S.push(new l(k, q, null, new h(x, q)));
        }
      } else if (L = C.pop(), (R = this.__execute(b.leave, L)) !== void 0 && R !== a && R !== n && R !== p && L.ref.replace(R), this.__state !== p && R !== p || F(L), this.__state === a || R === a) return U.root;
      return U.root;
    }, f.Syntax = r, f.traverse = y, f.replace = function(T, b) {
      return new s().replace(T, b);
    }, f.attachComments = function(T, b, S) {
      var C, x, A, R, L = [];
      if (!T.range) throw new Error("attachComments needs range information");
      if (!S.length) {
        if (b.length) {
          for (A = 0, x = b.length; A < x; A += 1) (C = m(b[A])).extendedRange = [0, T.range[0]], L.push(C);
          T.leadingComments = L;
        }
        return T;
      }
      for (A = 0, x = b.length; A < x; A += 1) L.push(v(m(b[A]), S));
      return R = 0, y(T, { enter: function(_) {
        for (var I; R < L.length && !((I = L[R]).extendedRange[1] > _.range[0]); ) I.extendedRange[1] === _.range[0] ? (_.leadingComments || (_.leadingComments = []), _.leadingComments.push(I), L.splice(R, 1)) : R += 1;
        return R === L.length ? u.Break : L[R].extendedRange[0] > _.range[1] ? u.Skip : void 0;
      } }), R = 0, y(T, { leave: function(_) {
        for (var I; R < L.length && (I = L[R], !(_.range[1] < I.extendedRange[0])); ) _.range[1] === I.extendedRange[0] ? (_.trailingComments || (_.trailingComments = []), _.trailingComments.push(I), L.splice(R, 1)) : R += 1;
        return R === L.length ? u.Break : L[R].extendedRange[0] > _.range[1] ? u.Skip : void 0;
      } }), T;
    }, f.VisitorKeys = e, f.VisitorOption = u, f.Controller = s, f.cloneEnvironment = function() {
      return o({});
    }, f;
  })(t);
}), UA = Av(function(i) {
  i.exports && (i.exports = function() {
    function t(o, f, r, u) {
      this.message = o, this.expected = f, this.found = r, this.location = u, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, t);
    }
    return function(o, f) {
      function r() {
        this.constructor = o;
      }
      r.prototype = f.prototype, o.prototype = new r();
    }(t, Error), t.buildMessage = function(o, f) {
      var r = { literal: function(n) {
        return '"' + e(n.text) + '"';
      }, class: function(n) {
        var p, m = "";
        for (p = 0; p < n.parts.length; p++) m += n.parts[p] instanceof Array ? a(n.parts[p][0]) + "-" + a(n.parts[p][1]) : a(n.parts[p]);
        return "[" + (n.inverted ? "^" : "") + m + "]";
      }, any: function(n) {
        return "any character";
      }, end: function(n) {
        return "end of input";
      }, other: function(n) {
        return n.description;
      } };
      function u(n) {
        return n.charCodeAt(0).toString(16).toUpperCase();
      }
      function e(n) {
        return n.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(p) {
          return "\\x0" + u(p);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(p) {
          return "\\x" + u(p);
        });
      }
      function a(n) {
        return n.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(p) {
          return "\\x0" + u(p);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(p) {
          return "\\x" + u(p);
        });
      }
      return "Expected " + function(n) {
        var p, m, h, l = new Array(n.length);
        for (p = 0; p < n.length; p++) l[p] = (h = n[p], r[h.type](h));
        if (l.sort(), l.length > 0) {
          for (p = 1, m = 1; p < l.length; p++) l[p - 1] !== l[p] && (l[m] = l[p], m++);
          l.length = m;
        }
        switch (l.length) {
          case 1:
            return l[0];
          case 2:
            return l[0] + " or " + l[1];
          default:
            return l.slice(0, -1).join(", ") + ", or " + l[l.length - 1];
        }
      }(o) + " but " + function(n) {
        return n ? '"' + e(n) + '"' : "end of input";
      }(f) + " found.";
    }, { SyntaxError: t, parse: function(o, f) {
      f = f !== void 0 ? f : {};
      var r, u, e, a, n = {}, p = { start: ee }, m = ee, h = re(" ", !1), l = /^[^ [\],():#!=><~+.]/, s = ne([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], !0, !1), c = re(">", !1), g = re("~", !1), d = re("+", !1), y = re(",", !1), v = re("!", !1), T = re("*", !1), b = re("#", !1), S = re("[", !1), C = re("]", !1), x = /^[><!]/, A = ne([">", "<", "!"], !1, !1), R = re("=", !1), L = function(_e) {
        return (_e || "") + "=";
      }, _ = /^[><]/, I = ne([">", "<"], !1, !1), O = re(".", !1), k = function(_e, je, $e) {
        return { type: "attribute", name: _e, operator: je, value: $e };
      }, w = re('"', !1), U = /^[^\\"]/, q = ne(["\\", '"'], !0, !1), F = re("\\", !1), $ = { type: "any" }, P = function(_e, je) {
        return _e + je;
      }, X = function(_e) {
        return { type: "literal", value: (je = _e.join(""), je.replace(/\\(.)/g, function($e, Ae) {
          switch (Ae) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return `
`;
            case "r":
              return "\r";
            case "t":
              return "	";
            case "v":
              return "\v";
            default:
              return Ae;
          }
        })) };
        var je;
      }, Q = re("'", !1), ue = /^[^\\']/, le = ne(["\\", "'"], !0, !1), Ce = /^[0-9]/, j = ne([["0", "9"]], !1, !1), H = re("type(", !1), N = /^[^ )]/, G = ne([" ", ")"], !0, !1), M = re(")", !1), Z = /^[imsu]/, Ee = ne(["i", "m", "s", "u"], !1, !1), ke = re("/", !1), Ie = /^[^\/]/, Je = ne(["/"], !0, !1), at = re(":not(", !1), lt = re(":matches(", !1), mt = re(":has(", !1), Y = re(":first-child", !1), Te = re(":last-child", !1), Ke = re(":nth-child(", !1), et = re(":nth-last-child(", !1), nt = re(":", !1), rt = re("statement", !0), ot = re("expression", !0), Ct = re("declaration", !0), dt = re("function", !0), vt = re("pattern", !0), W = 0, Ye = [{ line: 1, column: 1 }], Ue = 0, Ve = [], xe = {};
      if ("startRule" in f) {
        if (!(f.startRule in p)) throw new Error(`Can't start parsing from rule "` + f.startRule + '".');
        m = p[f.startRule];
      }
      function re(_e, je) {
        return { type: "literal", text: _e, ignoreCase: je };
      }
      function ne(_e, je, $e) {
        return { type: "class", parts: _e, inverted: je, ignoreCase: $e };
      }
      function ae(_e) {
        var je, $e = Ye[_e];
        if ($e) return $e;
        for (je = _e - 1; !Ye[je]; ) je--;
        for ($e = { line: ($e = Ye[je]).line, column: $e.column }; je < _e; ) o.charCodeAt(je) === 10 ? ($e.line++, $e.column = 1) : $e.column++, je++;
        return Ye[_e] = $e, $e;
      }
      function fe(_e, je) {
        var $e = ae(_e), Ae = ae(je);
        return { start: { offset: _e, line: $e.line, column: $e.column }, end: { offset: je, line: Ae.line, column: Ae.column } };
      }
      function de(_e) {
        W < Ue || (W > Ue && (Ue = W, Ve = []), Ve.push(_e));
      }
      function ee() {
        var _e, je, $e, Ae, oe = 30 * W + 0, se = xe[oe];
        return se ? (W = se.nextPos, se.result) : (_e = W, (je = te()) !== n && ($e = ce()) !== n && te() !== n ? _e = je = (Ae = $e).length === 1 ? Ae[0] : { type: "matches", selectors: Ae } : (W = _e, _e = n), _e === n && (_e = W, (je = te()) !== n && (je = void 0), _e = je), xe[oe] = { nextPos: W, result: _e }, _e);
      }
      function te() {
        var _e, je, $e = 30 * W + 1, Ae = xe[$e];
        if (Ae) return W = Ae.nextPos, Ae.result;
        for (_e = [], o.charCodeAt(W) === 32 ? (je = " ", W++) : (je = n, de(h)); je !== n; ) _e.push(je), o.charCodeAt(W) === 32 ? (je = " ", W++) : (je = n, de(h));
        return xe[$e] = { nextPos: W, result: _e }, _e;
      }
      function B() {
        var _e, je, $e, Ae = 30 * W + 2, oe = xe[Ae];
        if (oe) return W = oe.nextPos, oe.result;
        if (je = [], l.test(o.charAt(W)) ? ($e = o.charAt(W), W++) : ($e = n, de(s)), $e !== n) for (; $e !== n; ) je.push($e), l.test(o.charAt(W)) ? ($e = o.charAt(W), W++) : ($e = n, de(s));
        else je = n;
        return je !== n && (je = je.join("")), _e = je, xe[Ae] = { nextPos: W, result: _e }, _e;
      }
      function z() {
        var _e, je, $e, Ae = 30 * W + 3, oe = xe[Ae];
        return oe ? (W = oe.nextPos, oe.result) : (_e = W, (je = te()) !== n ? (o.charCodeAt(W) === 62 ? ($e = ">", W++) : ($e = n, de(c)), $e !== n && te() !== n ? _e = je = "child" : (W = _e, _e = n)) : (W = _e, _e = n), _e === n && (_e = W, (je = te()) !== n ? (o.charCodeAt(W) === 126 ? ($e = "~", W++) : ($e = n, de(g)), $e !== n && te() !== n ? _e = je = "sibling" : (W = _e, _e = n)) : (W = _e, _e = n), _e === n && (_e = W, (je = te()) !== n ? (o.charCodeAt(W) === 43 ? ($e = "+", W++) : ($e = n, de(d)), $e !== n && te() !== n ? _e = je = "adjacent" : (W = _e, _e = n)) : (W = _e, _e = n), _e === n && (_e = W, o.charCodeAt(W) === 32 ? (je = " ", W++) : (je = n, de(h)), je !== n && ($e = te()) !== n ? _e = je = "descendant" : (W = _e, _e = n)))), xe[Ae] = { nextPos: W, result: _e }, _e);
      }
      function ce() {
        var _e, je, $e, Ae, oe, se, pe, ve, Se = 30 * W + 4, Ge = xe[Se];
        if (Ge) return W = Ge.nextPos, Ge.result;
        if (_e = W, (je = ye()) !== n) {
          for ($e = [], Ae = W, (oe = te()) !== n ? (o.charCodeAt(W) === 44 ? (se = ",", W++) : (se = n, de(y)), se !== n && (pe = te()) !== n && (ve = ye()) !== n ? Ae = oe = [oe, se, pe, ve] : (W = Ae, Ae = n)) : (W = Ae, Ae = n); Ae !== n; ) $e.push(Ae), Ae = W, (oe = te()) !== n ? (o.charCodeAt(W) === 44 ? (se = ",", W++) : (se = n, de(y)), se !== n && (pe = te()) !== n && (ve = ye()) !== n ? Ae = oe = [oe, se, pe, ve] : (W = Ae, Ae = n)) : (W = Ae, Ae = n);
          $e !== n ? _e = je = [je].concat($e.map(function(Ze) {
            return Ze[3];
          })) : (W = _e, _e = n);
        } else W = _e, _e = n;
        return xe[Se] = { nextPos: W, result: _e }, _e;
      }
      function ye() {
        var _e, je, $e, Ae, oe, se, pe, ve = 30 * W + 5, Se = xe[ve];
        if (Se) return W = Se.nextPos, Se.result;
        if (_e = W, (je = Be()) !== n) {
          for ($e = [], Ae = W, (oe = z()) !== n && (se = Be()) !== n ? Ae = oe = [oe, se] : (W = Ae, Ae = n); Ae !== n; ) $e.push(Ae), Ae = W, (oe = z()) !== n && (se = Be()) !== n ? Ae = oe = [oe, se] : (W = Ae, Ae = n);
          $e !== n ? (pe = je, _e = je = $e.reduce(function(Ge, Ze) {
            return { type: Ze[0], left: Ge, right: Ze[1] };
          }, pe)) : (W = _e, _e = n);
        } else W = _e, _e = n;
        return xe[ve] = { nextPos: W, result: _e }, _e;
      }
      function Be() {
        var _e, je, $e, Ae, oe, se, pe, ve = 30 * W + 6, Se = xe[ve];
        if (Se) return W = Se.nextPos, Se.result;
        if (_e = W, o.charCodeAt(W) === 33 ? (je = "!", W++) : (je = n, de(v)), je === n && (je = null), je !== n) {
          if ($e = [], (Ae = we()) !== n) for (; Ae !== n; ) $e.push(Ae), Ae = we();
          else $e = n;
          $e !== n ? (oe = je, pe = (se = $e).length === 1 ? se[0] : { type: "compound", selectors: se }, oe && (pe.subject = !0), _e = je = pe) : (W = _e, _e = n);
        } else W = _e, _e = n;
        return xe[ve] = { nextPos: W, result: _e }, _e;
      }
      function we() {
        var _e, je = 30 * W + 7, $e = xe[je];
        return $e ? (W = $e.nextPos, $e.result) : ((_e = function() {
          var Ae, oe, se = 30 * W + 8, pe = xe[se];
          return pe ? (W = pe.nextPos, pe.result) : (o.charCodeAt(W) === 42 ? (oe = "*", W++) : (oe = n, de(T)), oe !== n && (oe = { type: "wildcard", value: oe }), Ae = oe, xe[se] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe = 30 * W + 9, ve = xe[pe];
          return ve ? (W = ve.nextPos, ve.result) : (Ae = W, o.charCodeAt(W) === 35 ? (oe = "#", W++) : (oe = n, de(b)), oe === n && (oe = null), oe !== n && (se = B()) !== n ? Ae = oe = { type: "identifier", value: se } : (W = Ae, Ae = n), xe[pe] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve = 30 * W + 10, Se = xe[ve];
          return Se ? (W = Se.nextPos, Se.result) : (Ae = W, o.charCodeAt(W) === 91 ? (oe = "[", W++) : (oe = n, de(S)), oe !== n && te() !== n && (se = function() {
            var Ge, Ze, ft, gt, At = 30 * W + 14, ht = xe[At];
            return ht ? (W = ht.nextPos, ht.result) : (Ge = W, (Ze = Pe()) !== n && te() !== n && (ft = function() {
              var qe, He, Xe, Me = 30 * W + 12, it = xe[Me];
              return it ? (W = it.nextPos, it.result) : (qe = W, o.charCodeAt(W) === 33 ? (He = "!", W++) : (He = n, de(v)), He === n && (He = null), He !== n ? (o.charCodeAt(W) === 61 ? (Xe = "=", W++) : (Xe = n, de(R)), Xe !== n ? (He = L(He), qe = He) : (W = qe, qe = n)) : (W = qe, qe = n), xe[Me] = { nextPos: W, result: qe }, qe);
            }()) !== n && te() !== n ? ((gt = function() {
              var qe, He, Xe, Me, it, ut = 30 * W + 18, Tt = xe[ut];
              if (Tt) return W = Tt.nextPos, Tt.result;
              if (qe = W, o.substr(W, 5) === "type(" ? (He = "type(", W += 5) : (He = n, de(H)), He !== n) if (te() !== n) {
                if (Xe = [], N.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(G)), Me !== n) for (; Me !== n; ) Xe.push(Me), N.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(G));
                else Xe = n;
                Xe !== n && (Me = te()) !== n ? (o.charCodeAt(W) === 41 ? (it = ")", W++) : (it = n, de(M)), it !== n ? (He = { type: "type", value: Xe.join("") }, qe = He) : (W = qe, qe = n)) : (W = qe, qe = n);
              } else W = qe, qe = n;
              else W = qe, qe = n;
              return xe[ut] = { nextPos: W, result: qe }, qe;
            }()) === n && (gt = function() {
              var qe, He, Xe, Me, it, ut, Tt = 30 * W + 20, Rt = xe[Tt];
              if (Rt) return W = Rt.nextPos, Rt.result;
              if (qe = W, o.charCodeAt(W) === 47 ? (He = "/", W++) : (He = n, de(ke)), He !== n) {
                if (Xe = [], Ie.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(Je)), Me !== n) for (; Me !== n; ) Xe.push(Me), Ie.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(Je));
                else Xe = n;
                Xe !== n ? (o.charCodeAt(W) === 47 ? (Me = "/", W++) : (Me = n, de(ke)), Me !== n ? ((it = function() {
                  var xt, tt, Lt = 30 * W + 19, Bt = xe[Lt];
                  if (Bt) return W = Bt.nextPos, Bt.result;
                  if (xt = [], Z.test(o.charAt(W)) ? (tt = o.charAt(W), W++) : (tt = n, de(Ee)), tt !== n) for (; tt !== n; ) xt.push(tt), Z.test(o.charAt(W)) ? (tt = o.charAt(W), W++) : (tt = n, de(Ee));
                  else xt = n;
                  return xe[Lt] = { nextPos: W, result: xt }, xt;
                }()) === n && (it = null), it !== n ? (ut = it, He = { type: "regexp", value: new RegExp(Xe.join(""), ut ? ut.join("") : "") }, qe = He) : (W = qe, qe = n)) : (W = qe, qe = n)) : (W = qe, qe = n);
              } else W = qe, qe = n;
              return xe[Tt] = { nextPos: W, result: qe }, qe;
            }()), gt !== n ? (Ze = k(Ze, ft, gt), Ge = Ze) : (W = Ge, Ge = n)) : (W = Ge, Ge = n), Ge === n && (Ge = W, (Ze = Pe()) !== n && te() !== n && (ft = function() {
              var qe, He, Xe, Me = 30 * W + 11, it = xe[Me];
              return it ? (W = it.nextPos, it.result) : (qe = W, x.test(o.charAt(W)) ? (He = o.charAt(W), W++) : (He = n, de(A)), He === n && (He = null), He !== n ? (o.charCodeAt(W) === 61 ? (Xe = "=", W++) : (Xe = n, de(R)), Xe !== n ? (He = L(He), qe = He) : (W = qe, qe = n)) : (W = qe, qe = n), qe === n && (_.test(o.charAt(W)) ? (qe = o.charAt(W), W++) : (qe = n, de(I))), xe[Me] = { nextPos: W, result: qe }, qe);
            }()) !== n && te() !== n ? ((gt = function() {
              var qe, He, Xe, Me, it, ut, Tt = 30 * W + 15, Rt = xe[Tt];
              if (Rt) return W = Rt.nextPos, Rt.result;
              if (qe = W, o.charCodeAt(W) === 34 ? (He = '"', W++) : (He = n, de(w)), He !== n) {
                for (Xe = [], U.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(q)), Me === n && (Me = W, o.charCodeAt(W) === 92 ? (it = "\\", W++) : (it = n, de(F)), it !== n ? (o.length > W ? (ut = o.charAt(W), W++) : (ut = n, de($)), ut !== n ? (it = P(it, ut), Me = it) : (W = Me, Me = n)) : (W = Me, Me = n)); Me !== n; ) Xe.push(Me), U.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(q)), Me === n && (Me = W, o.charCodeAt(W) === 92 ? (it = "\\", W++) : (it = n, de(F)), it !== n ? (o.length > W ? (ut = o.charAt(W), W++) : (ut = n, de($)), ut !== n ? (it = P(it, ut), Me = it) : (W = Me, Me = n)) : (W = Me, Me = n));
                Xe !== n ? (o.charCodeAt(W) === 34 ? (Me = '"', W++) : (Me = n, de(w)), Me !== n ? (He = X(Xe), qe = He) : (W = qe, qe = n)) : (W = qe, qe = n);
              } else W = qe, qe = n;
              if (qe === n) if (qe = W, o.charCodeAt(W) === 39 ? (He = "'", W++) : (He = n, de(Q)), He !== n) {
                for (Xe = [], ue.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(le)), Me === n && (Me = W, o.charCodeAt(W) === 92 ? (it = "\\", W++) : (it = n, de(F)), it !== n ? (o.length > W ? (ut = o.charAt(W), W++) : (ut = n, de($)), ut !== n ? (it = P(it, ut), Me = it) : (W = Me, Me = n)) : (W = Me, Me = n)); Me !== n; ) Xe.push(Me), ue.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(le)), Me === n && (Me = W, o.charCodeAt(W) === 92 ? (it = "\\", W++) : (it = n, de(F)), it !== n ? (o.length > W ? (ut = o.charAt(W), W++) : (ut = n, de($)), ut !== n ? (it = P(it, ut), Me = it) : (W = Me, Me = n)) : (W = Me, Me = n));
                Xe !== n ? (o.charCodeAt(W) === 39 ? (Me = "'", W++) : (Me = n, de(Q)), Me !== n ? (He = X(Xe), qe = He) : (W = qe, qe = n)) : (W = qe, qe = n);
              } else W = qe, qe = n;
              return xe[Tt] = { nextPos: W, result: qe }, qe;
            }()) === n && (gt = function() {
              var qe, He, Xe, Me, it, ut, Tt, Rt = 30 * W + 16, xt = xe[Rt];
              if (xt) return W = xt.nextPos, xt.result;
              for (qe = W, He = W, Xe = [], Ce.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(j)); Me !== n; ) Xe.push(Me), Ce.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(j));
              if (Xe !== n ? (o.charCodeAt(W) === 46 ? (Me = ".", W++) : (Me = n, de(O)), Me !== n ? He = Xe = [Xe, Me] : (W = He, He = n)) : (W = He, He = n), He === n && (He = null), He !== n) {
                if (Xe = [], Ce.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(j)), Me !== n) for (; Me !== n; ) Xe.push(Me), Ce.test(o.charAt(W)) ? (Me = o.charAt(W), W++) : (Me = n, de(j));
                else Xe = n;
                Xe !== n ? (ut = Xe, Tt = (it = He) ? [].concat.apply([], it).join("") : "", He = { type: "literal", value: parseFloat(Tt + ut.join("")) }, qe = He) : (W = qe, qe = n);
              } else W = qe, qe = n;
              return xe[Rt] = { nextPos: W, result: qe }, qe;
            }()) === n && (gt = function() {
              var qe, He, Xe = 30 * W + 17, Me = xe[Xe];
              return Me ? (W = Me.nextPos, Me.result) : ((He = B()) !== n && (He = { type: "literal", value: He }), qe = He, xe[Xe] = { nextPos: W, result: qe }, qe);
            }()), gt !== n ? (Ze = k(Ze, ft, gt), Ge = Ze) : (W = Ge, Ge = n)) : (W = Ge, Ge = n), Ge === n && (Ge = W, (Ze = Pe()) !== n && (Ze = { type: "attribute", name: Ze }), Ge = Ze)), xe[At] = { nextPos: W, result: Ge }, Ge);
          }()) !== n && te() !== n ? (o.charCodeAt(W) === 93 ? (pe = "]", W++) : (pe = n, de(C)), pe !== n ? Ae = oe = se : (W = Ae, Ae = n)) : (W = Ae, Ae = n), xe[ve] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve, Se, Ge, Ze, ft = 30 * W + 21, gt = xe[ft];
          if (gt) return W = gt.nextPos, gt.result;
          if (Ae = W, o.charCodeAt(W) === 46 ? (oe = ".", W++) : (oe = n, de(O)), oe !== n) if ((se = B()) !== n) {
            for (pe = [], ve = W, o.charCodeAt(W) === 46 ? (Se = ".", W++) : (Se = n, de(O)), Se !== n && (Ge = B()) !== n ? ve = Se = [Se, Ge] : (W = ve, ve = n); ve !== n; ) pe.push(ve), ve = W, o.charCodeAt(W) === 46 ? (Se = ".", W++) : (Se = n, de(O)), Se !== n && (Ge = B()) !== n ? ve = Se = [Se, Ge] : (W = ve, ve = n);
            pe !== n ? (Ze = se, oe = { type: "field", name: pe.reduce(function(At, ht) {
              return At + ht[0] + ht[1];
            }, Ze) }, Ae = oe) : (W = Ae, Ae = n);
          } else W = Ae, Ae = n;
          else W = Ae, Ae = n;
          return xe[ft] = { nextPos: W, result: Ae }, Ae;
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve = 30 * W + 22, Se = xe[ve];
          return Se ? (W = Se.nextPos, Se.result) : (Ae = W, o.substr(W, 5) === ":not(" ? (oe = ":not(", W += 5) : (oe = n, de(at)), oe !== n && te() !== n && (se = ce()) !== n && te() !== n ? (o.charCodeAt(W) === 41 ? (pe = ")", W++) : (pe = n, de(M)), pe !== n ? Ae = oe = { type: "not", selectors: se } : (W = Ae, Ae = n)) : (W = Ae, Ae = n), xe[ve] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve = 30 * W + 23, Se = xe[ve];
          return Se ? (W = Se.nextPos, Se.result) : (Ae = W, o.substr(W, 9) === ":matches(" ? (oe = ":matches(", W += 9) : (oe = n, de(lt)), oe !== n && te() !== n && (se = ce()) !== n && te() !== n ? (o.charCodeAt(W) === 41 ? (pe = ")", W++) : (pe = n, de(M)), pe !== n ? Ae = oe = { type: "matches", selectors: se } : (W = Ae, Ae = n)) : (W = Ae, Ae = n), xe[ve] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve = 30 * W + 24, Se = xe[ve];
          return Se ? (W = Se.nextPos, Se.result) : (Ae = W, o.substr(W, 5) === ":has(" ? (oe = ":has(", W += 5) : (oe = n, de(mt)), oe !== n && te() !== n && (se = ce()) !== n && te() !== n ? (o.charCodeAt(W) === 41 ? (pe = ")", W++) : (pe = n, de(M)), pe !== n ? Ae = oe = { type: "has", selectors: se } : (W = Ae, Ae = n)) : (W = Ae, Ae = n), xe[ve] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se = 30 * W + 25, pe = xe[se];
          return pe ? (W = pe.nextPos, pe.result) : (o.substr(W, 12) === ":first-child" ? (oe = ":first-child", W += 12) : (oe = n, de(Y)), oe !== n && (oe = st(1)), Ae = oe, xe[se] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se = 30 * W + 26, pe = xe[se];
          return pe ? (W = pe.nextPos, pe.result) : (o.substr(W, 11) === ":last-child" ? (oe = ":last-child", W += 11) : (oe = n, de(Te)), oe !== n && (oe = We(1)), Ae = oe, xe[se] = { nextPos: W, result: Ae }, Ae);
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve, Se = 30 * W + 27, Ge = xe[Se];
          if (Ge) return W = Ge.nextPos, Ge.result;
          if (Ae = W, o.substr(W, 11) === ":nth-child(" ? (oe = ":nth-child(", W += 11) : (oe = n, de(Ke)), oe !== n) if (te() !== n) {
            if (se = [], Ce.test(o.charAt(W)) ? (pe = o.charAt(W), W++) : (pe = n, de(j)), pe !== n) for (; pe !== n; ) se.push(pe), Ce.test(o.charAt(W)) ? (pe = o.charAt(W), W++) : (pe = n, de(j));
            else se = n;
            se !== n && (pe = te()) !== n ? (o.charCodeAt(W) === 41 ? (ve = ")", W++) : (ve = n, de(M)), ve !== n ? (oe = st(parseInt(se.join(""), 10)), Ae = oe) : (W = Ae, Ae = n)) : (W = Ae, Ae = n);
          } else W = Ae, Ae = n;
          else W = Ae, Ae = n;
          return xe[Se] = { nextPos: W, result: Ae }, Ae;
        }()) === n && (_e = function() {
          var Ae, oe, se, pe, ve, Se = 30 * W + 28, Ge = xe[Se];
          if (Ge) return W = Ge.nextPos, Ge.result;
          if (Ae = W, o.substr(W, 16) === ":nth-last-child(" ? (oe = ":nth-last-child(", W += 16) : (oe = n, de(et)), oe !== n) if (te() !== n) {
            if (se = [], Ce.test(o.charAt(W)) ? (pe = o.charAt(W), W++) : (pe = n, de(j)), pe !== n) for (; pe !== n; ) se.push(pe), Ce.test(o.charAt(W)) ? (pe = o.charAt(W), W++) : (pe = n, de(j));
            else se = n;
            se !== n && (pe = te()) !== n ? (o.charCodeAt(W) === 41 ? (ve = ")", W++) : (ve = n, de(M)), ve !== n ? (oe = We(parseInt(se.join(""), 10)), Ae = oe) : (W = Ae, Ae = n)) : (W = Ae, Ae = n);
          } else W = Ae, Ae = n;
          else W = Ae, Ae = n;
          return xe[Se] = { nextPos: W, result: Ae }, Ae;
        }()) === n && (_e = function() {
          var Ae, oe, se, pe = 30 * W + 29, ve = xe[pe];
          return ve ? (W = ve.nextPos, ve.result) : (Ae = W, o.charCodeAt(W) === 58 ? (oe = ":", W++) : (oe = n, de(nt)), oe !== n ? (o.substr(W, 9).toLowerCase() === "statement" ? (se = o.substr(W, 9), W += 9) : (se = n, de(rt)), se === n && (o.substr(W, 10).toLowerCase() === "expression" ? (se = o.substr(W, 10), W += 10) : (se = n, de(ot)), se === n && (o.substr(W, 11).toLowerCase() === "declaration" ? (se = o.substr(W, 11), W += 11) : (se = n, de(Ct)), se === n && (o.substr(W, 8).toLowerCase() === "function" ? (se = o.substr(W, 8), W += 8) : (se = n, de(dt)), se === n && (o.substr(W, 7).toLowerCase() === "pattern" ? (se = o.substr(W, 7), W += 7) : (se = n, de(vt)))))), se !== n ? Ae = oe = { type: "class", name: se } : (W = Ae, Ae = n)) : (W = Ae, Ae = n), xe[pe] = { nextPos: W, result: Ae }, Ae);
        }()), xe[je] = { nextPos: W, result: _e }, _e);
      }
      function Pe() {
        var _e, je, $e, Ae, oe, se, pe, ve, Se = 30 * W + 13, Ge = xe[Se];
        if (Ge) return W = Ge.nextPos, Ge.result;
        if (_e = W, (je = B()) !== n) {
          for ($e = [], Ae = W, o.charCodeAt(W) === 46 ? (oe = ".", W++) : (oe = n, de(O)), oe !== n && (se = B()) !== n ? Ae = oe = [oe, se] : (W = Ae, Ae = n); Ae !== n; ) $e.push(Ae), Ae = W, o.charCodeAt(W) === 46 ? (oe = ".", W++) : (oe = n, de(O)), oe !== n && (se = B()) !== n ? Ae = oe = [oe, se] : (W = Ae, Ae = n);
          $e !== n ? (pe = je, ve = $e, _e = je = [].concat.apply([pe], ve).join("")) : (W = _e, _e = n);
        } else W = _e, _e = n;
        return xe[Se] = { nextPos: W, result: _e }, _e;
      }
      function st(_e) {
        return { type: "nth-child", index: { type: "literal", value: _e } };
      }
      function We(_e) {
        return { type: "nth-last-child", index: { type: "literal", value: _e } };
      }
      if ((r = m()) !== n && W === o.length) return r;
      throw r !== n && W < o.length && de({ type: "end" }), u = Ve, e = Ue < o.length ? o.charAt(Ue) : null, a = Ue < o.length ? fe(Ue, Ue + 1) : fe(Ue, Ue), new t(t.buildMessage(u, e), u, e, a);
    } };
  }());
});
function Qt(i, t) {
  for (var o = 0; o < t.length; ++o) {
    if (i == null) return i;
    i = i[t[o]];
  }
  return i;
}
var ai = typeof WeakMap == "function" ? /* @__PURE__ */ new WeakMap() : null;
function Ot(i) {
  if (i == null) return function() {
    return !0;
  };
  if (ai != null) {
    var t = ai.get(i);
    return t != null || (t = om(i), ai.set(i, t)), t;
  }
  return om(i);
}
function om(i) {
  switch (i.type) {
    case "wildcard":
      return function() {
        return !0;
      };
    case "identifier":
      var t = i.value.toLowerCase();
      return function(x) {
        return t === x.type.toLowerCase();
      };
    case "field":
      var o = i.name.split(".");
      return function(x, A) {
        return function R(L, _, I, O) {
          for (var k = _, w = O; w < I.length; ++w) {
            if (k == null) return !1;
            var U = k[I[w]];
            if (Array.isArray(U)) {
              for (var q = 0; q < U.length; ++q) if (R(L, U[q], I, w + 1)) return !0;
              return !1;
            }
            k = U;
          }
          return L === k;
        }(x, A[o.length - 1], o, 0);
      };
    case "matches":
      var f = i.selectors.map(Ot);
      return function(x, A, R) {
        for (var L = 0; L < f.length; ++L) if (f[L](x, A, R)) return !0;
        return !1;
      };
    case "compound":
      var r = i.selectors.map(Ot);
      return function(x, A, R) {
        for (var L = 0; L < r.length; ++L) if (!r[L](x, A, R)) return !1;
        return !0;
      };
    case "not":
      var u = i.selectors.map(Ot);
      return function(x, A, R) {
        for (var L = 0; L < u.length; ++L) if (u[L](x, A, R)) return !1;
        return !0;
      };
    case "has":
      var e = i.selectors.map(Ot);
      return function(x, A, R) {
        var L = !1, _ = [];
        return un.traverse(x, { enter: function(I, O) {
          O != null && _.unshift(O);
          for (var k = 0; k < e.length; ++k) if (e[k](I, _, R)) return L = !0, void this.break();
        }, leave: function() {
          _.shift();
        }, keys: R && R.visitorKeys, fallback: R && R.fallback || "iteration" }), L;
      };
    case "child":
      var a = Ot(i.left), n = Ot(i.right);
      return function(x, A, R) {
        return !!(A.length > 0 && n(x, A, R)) && a(A[0], A.slice(1), R);
      };
    case "descendant":
      var p = Ot(i.left), m = Ot(i.right);
      return function(x, A, R) {
        if (m(x, A, R)) {
          for (var L = 0, _ = A.length; L < _; ++L) if (p(A[L], A.slice(L + 1), R)) return !0;
        }
        return !1;
      };
    case "attribute":
      var h = i.name.split(".");
      switch (i.operator) {
        case void 0:
          return function(x) {
            return Qt(x, h) != null;
          };
        case "=":
          switch (i.value.type) {
            case "regexp":
              return function(x) {
                var A = Qt(x, h);
                return typeof A == "string" && i.value.value.test(A);
              };
            case "literal":
              var l = "".concat(i.value.value);
              return function(x) {
                return l === "".concat(Qt(x, h));
              };
            case "type":
              return function(x) {
                return i.value.value === jr(Qt(x, h));
              };
          }
          throw new Error("Unknown selector value type: ".concat(i.value.type));
        case "!=":
          switch (i.value.type) {
            case "regexp":
              return function(x) {
                return !i.value.value.test(Qt(x, h));
              };
            case "literal":
              var s = "".concat(i.value.value);
              return function(x) {
                return s !== "".concat(Qt(x, h));
              };
            case "type":
              return function(x) {
                return i.value.value !== jr(Qt(x, h));
              };
          }
          throw new Error("Unknown selector value type: ".concat(i.value.type));
        case "<=":
          return function(x) {
            return Qt(x, h) <= i.value.value;
          };
        case "<":
          return function(x) {
            return Qt(x, h) < i.value.value;
          };
        case ">":
          return function(x) {
            return Qt(x, h) > i.value.value;
          };
        case ">=":
          return function(x) {
            return Qt(x, h) >= i.value.value;
          };
      }
      throw new Error("Unknown operator: ".concat(i.operator));
    case "sibling":
      var c = Ot(i.left), g = Ot(i.right);
      return function(x, A, R) {
        return g(x, A, R) && lm(x, c, A, "LEFT_SIDE", R) || i.left.subject && c(x, A, R) && lm(x, g, A, "RIGHT_SIDE", R);
      };
    case "adjacent":
      var d = Ot(i.left), y = Ot(i.right);
      return function(x, A, R) {
        return y(x, A, R) && um(x, d, A, "LEFT_SIDE", R) || i.right.subject && d(x, A, R) && um(x, y, A, "RIGHT_SIDE", R);
      };
    case "nth-child":
      var v = i.index.value, T = Ot(i.right);
      return function(x, A, R) {
        return T(x, A, R) && cm(x, A, v, R);
      };
    case "nth-last-child":
      var b = -i.index.value, S = Ot(i.right);
      return function(x, A, R) {
        return S(x, A, R) && cm(x, A, b, R);
      };
    case "class":
      var C = i.name.toLowerCase();
      return function(x, A) {
        switch (C) {
          case "statement":
            if (x.type.slice(-9) === "Statement") return !0;
          case "declaration":
            return x.type.slice(-11) === "Declaration";
          case "pattern":
            if (x.type.slice(-7) === "Pattern") return !0;
          case "expression":
            return x.type.slice(-10) === "Expression" || x.type.slice(-7) === "Literal" || x.type === "Identifier" && (A.length === 0 || A[0].type !== "MetaProperty") || x.type === "MetaProperty";
          case "function":
            return x.type === "FunctionDeclaration" || x.type === "FunctionExpression" || x.type === "ArrowFunctionExpression";
        }
        throw new Error("Unknown class name: ".concat(i.name));
      };
  }
  throw new Error("Unknown selector type: ".concat(i.type));
}
function zf(i, t) {
  var o = i.type;
  return t && t.visitorKeys && t.visitorKeys[o] ? t.visitorKeys[o] : un.VisitorKeys[o] ? un.VisitorKeys[o] : t && typeof t.fallback == "function" ? t.fallback(i) : Object.keys(i).filter(function(f) {
    return f !== "type";
  });
}
function kf(i) {
  return i !== null && jr(i) === "object" && typeof i.type == "string";
}
function lm(i, t, o, f, r) {
  var u = Xf(o, 1)[0];
  if (!u) return !1;
  for (var e = zf(u, r), a = 0; a < e.length; ++a) {
    var n = u[e[a]];
    if (Array.isArray(n)) {
      var p = n.indexOf(i);
      if (p < 0) continue;
      var m = void 0, h = void 0;
      f === "LEFT_SIDE" ? (m = 0, h = p) : (m = p + 1, h = n.length);
      for (var l = m; l < h; ++l) if (kf(n[l]) && t(n[l], o, r)) return !0;
    }
  }
  return !1;
}
function um(i, t, o, f, r) {
  var u = Xf(o, 1)[0];
  if (!u) return !1;
  for (var e = zf(u, r), a = 0; a < e.length; ++a) {
    var n = u[e[a]];
    if (Array.isArray(n)) {
      var p = n.indexOf(i);
      if (p < 0) continue;
      if (f === "LEFT_SIDE" && p > 0 && kf(n[p - 1]) && t(n[p - 1], o, r) || f === "RIGHT_SIDE" && p < n.length - 1 && kf(n[p + 1]) && t(n[p + 1], o, r)) return !0;
    }
  }
  return !1;
}
function cm(i, t, o, f) {
  if (o === 0) return !1;
  var r = Xf(t, 1)[0];
  if (!r) return !1;
  for (var u = zf(r, f), e = 0; e < u.length; ++e) {
    var a = r[u[e]];
    if (Array.isArray(a)) {
      var n = o < 0 ? a.length + o : o - 1;
      if (n >= 0 && n < a.length && a[n] === i) return !0;
    }
  }
  return !1;
}
function Tv(i, t, o, f) {
  if (t) {
    var r = [], u = Ot(t), e = function a(n, p) {
      if (n == null || jr(n) != "object") return [];
      p == null && (p = n);
      for (var m = n.subject ? [p] : [], h = Object.keys(n), l = 0; l < h.length; ++l) {
        var s = h[l], c = n[s];
        m.push.apply(m, OA(a(c, s === "left" ? c : p)));
      }
      return m;
    }(t).map(Ot);
    un.traverse(i, { enter: function(a, n) {
      if (n != null && r.unshift(n), u(a, r, f)) if (e.length) for (var p = 0, m = e.length; p < m; ++p) {
        e[p](a, r, f) && o(a, n, r);
        for (var h = 0, l = r.length; h < l; ++h) {
          var s = r.slice(h + 1);
          e[p](r[h], s, f) && o(r[h], n, s);
        }
      }
      else o(a, n, r);
    }, leave: function() {
      r.shift();
    }, keys: f && f.visitorKeys, fallback: f && f.fallback || "iteration" });
  }
}
function bv(i, t, o) {
  var f = [];
  return Tv(i, t, function(r) {
    f.push(r);
  }, o), f;
}
function xv(i) {
  return UA.parse(i);
}
function Cr(i, t, o) {
  return bv(i, xv(t), o);
}
Cr.parse = xv, Cr.match = bv, Cr.traverse = Tv, Cr.matches = function(i, t, o, f) {
  return !t || !!i && (o || (o = []), Ot(t)(i, o, f));
}, Cr.query = Cr;
var oi, fm;
function VA() {
  if (fm) return oi;
  fm = 1;
  const i = Cr;
  function t(...h) {
    return [...new Set(h.flat())];
  }
  function o(...h) {
    if (h.length === 0)
      return [];
    let l = [...new Set(h[0])];
    for (const s of h.slice(1))
      l = l.filter((c) => s.includes(c));
    return l;
  }
  function f(h) {
    switch (h.type) {
      case "identifier":
        return [h.value];
      case "matches": {
        const l = h.selectors.map(f);
        return l.every(Boolean) ? t(...l) : null;
      }
      case "compound": {
        const l = h.selectors.map(f).filter((s) => s);
        return l.length ? o(...l) : null;
      }
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return f(h.right);
      case "class":
        return h.name === "function" ? ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"] : null;
      default:
        return null;
    }
  }
  function r(h) {
    switch (h.type) {
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return r(h.left) + r(h.right);
      case "compound":
      case "not":
      case "matches":
        return h.selectors.reduce((l, s) => l + r(s), 0);
      case "attribute":
      case "field":
      case "nth-child":
      case "nth-last-child":
        return 1;
      default:
        return 0;
    }
  }
  function u(h) {
    switch (h.type) {
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return u(h.left) + u(h.right);
      case "compound":
      case "not":
      case "matches":
        return h.selectors.reduce((l, s) => l + u(s), 0);
      case "identifier":
        return 1;
      default:
        return 0;
    }
  }
  function e(h, l) {
    return h.attributeCount - l.attributeCount || h.identifierCount - l.identifierCount || (h.rawSelector <= l.rawSelector ? -1 : 1);
  }
  function a(h) {
    try {
      return i.parse(h.replace(/:exit$/u, ""));
    } catch (l) {
      throw l.location && l.location.start && typeof l.location.start.offset == "number" ? new SyntaxError(`Syntax error in selector "${h}" at position ${l.location.start.offset}: ${l.message}`) : l;
    }
  }
  const n = /* @__PURE__ */ new Map();
  function p(h) {
    if (n.has(h))
      return n.get(h);
    const l = a(h), s = {
      rawSelector: h,
      isExit: h.endsWith(":exit"),
      parsedSelector: l,
      listenerTypes: f(l),
      attributeCount: r(l),
      identifierCount: u(l)
    };
    return n.set(h, s), s;
  }
  class m {
    /**
     * @param {SafeEmitter} emitter
     * An SafeEmitter which is the destination of events. This emitter must already
     * have registered listeners for all of the events that it needs to listen for.
     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)
     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.
     * @returns {NodeEventGenerator} new instance
     */
    constructor(l, s) {
      this.emitter = l, this.esqueryOptions = s, this.currentAncestry = [], this.enterSelectorsByNodeType = /* @__PURE__ */ new Map(), this.exitSelectorsByNodeType = /* @__PURE__ */ new Map(), this.anyTypeEnterSelectors = [], this.anyTypeExitSelectors = [], l.eventNames().forEach((c) => {
        const g = p(c);
        if (g.listenerTypes) {
          const y = g.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
          g.listenerTypes.forEach((v) => {
            y.has(v) || y.set(v, []), y.get(v).push(g);
          });
          return;
        }
        (g.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(g);
      }), this.anyTypeEnterSelectors.sort(e), this.anyTypeExitSelectors.sort(e), this.enterSelectorsByNodeType.forEach((c) => c.sort(e)), this.exitSelectorsByNodeType.forEach((c) => c.sort(e));
    }
    /**
     * Checks a selector against a node, and emits it if it matches
     * @param {ASTNode} node The node to check
     * @param {ASTSelector} selector An AST selector descriptor
     * @returns {void}
     */
    applySelector(l, s) {
      i.matches(l, s.parsedSelector, this.currentAncestry, this.esqueryOptions) && this.emitter.emit(s.rawSelector, l);
    }
    /**
     * Applies all appropriate selectors to a node, in specificity order
     * @param {ASTNode} node The node to check
     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited
     * @returns {void}
     */
    applySelectors(l, s) {
      const c = (s ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(l.type) || [], g = s ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
      let d = 0, y = 0;
      for (; d < c.length || y < g.length; )
        d >= c.length || y < g.length && e(g[y], c[d]) < 0 ? this.applySelector(l, g[y++]) : this.applySelector(l, c[d++]);
    }
    /**
     * Emits an event of entering AST node.
     * @param {ASTNode} node A node which was entered.
     * @returns {void}
     */
    enterNode(l) {
      l.parent && this.currentAncestry.unshift(l.parent), this.applySelectors(l, !1);
    }
    /**
     * Emits an event of leaving AST node.
     * @param {ASTNode} node A node which was left.
     * @returns {void}
     */
    leaveNode(l) {
      this.applySelectors(l, !0), this.currentAncestry.shift();
    }
  }
  return oi = m, oi;
}
var li, pm;
function MA() {
  if (pm) return li;
  pm = 1;
  function i(o, f) {
    return {
      range: [o, o],
      text: f
    };
  }
  return li = Object.freeze({
    /**
     * Creates a fix command that inserts text after the given node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextAfter(o, f) {
      return this.insertTextAfterRange(o.range, f);
    },
    /**
     * Creates a fix command that inserts text after the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {int[]} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextAfterRange(o, f) {
      return i(o[1], f);
    },
    /**
     * Creates a fix command that inserts text before the given node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextBefore(o, f) {
      return this.insertTextBeforeRange(o.range, f);
    },
    /**
     * Creates a fix command that inserts text before the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {int[]} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextBeforeRange(o, f) {
      return i(o[0], f);
    },
    /**
     * Creates a fix command that replaces text at the node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    replaceText(o, f) {
      return this.replaceTextRange(o.range, f);
    },
    /**
     * Creates a fix command that replaces text at the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {int[]} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    replaceTextRange(o, f) {
      return {
        range: o,
        text: f
      };
    },
    /**
     * Creates a fix command that removes the node or token from the source.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @returns {Object} The fix command.
     */
    remove(o) {
      return this.removeRange(o.range);
    },
    /**
     * Creates a fix command that removes the specified range of text from the source.
     * The fix is not applied until applyFixes() is called.
     * @param {int[]} range The range to remove, first item is start of range, second
     *      is end of range.
     * @returns {Object} The fix command.
     */
    removeRange(o) {
      return {
        range: o,
        text: ""
      };
    }
  }), li;
}
var ui, hm;
function KA() {
  return hm || (hm = 1, ui = (i, t) => t ? i.replace(/\{\{([^{}]+?)\}\}/gu, (o, f) => {
    const r = f.trim();
    return r in t ? t[r] : o;
  }) : i), ui;
}
var ci, mm;
function jA() {
  if (mm) return ci;
  mm = 1;
  const i = It, t = MA(), o = KA();
  function f(...c) {
    return c.length === 1 ? Object.assign({}, c[0]) : typeof c[1] == "string" ? {
      node: c[0],
      message: c[1],
      data: c[2],
      fix: c[3]
    } : {
      node: c[0],
      loc: c[1],
      message: c[2],
      data: c[3],
      fix: c[4]
    };
  }
  function r(c) {
    c.node ? i(typeof c.node == "object", "Node must be an object") : i(c.loc, "Node must be provided when reporting error if location is not provided");
  }
  function u(c) {
    return c.loc ? c.loc.start ? c.loc : { start: c.loc, end: null } : c.node.loc;
  }
  function e(c) {
    return c ? {
      range: [c.range[0], c.range[1]],
      text: c.text
    } : null;
  }
  function a(c) {
    c && i(c.range && typeof c.range[0] == "number" && typeof c.range[1] == "number", `Fix has invalid range: ${JSON.stringify(c, null, 2)}`);
  }
  function n(c, g) {
    return c.range[0] - g.range[0] || c.range[1] - g.range[1];
  }
  function p(c, g) {
    for (const S of c)
      a(S);
    if (c.length === 0)
      return null;
    if (c.length === 1)
      return e(c[0]);
    c.sort(n);
    const d = g.text, y = c[0].range[0], v = c[c.length - 1].range[1];
    let T = "", b = Number.MIN_SAFE_INTEGER;
    for (const S of c)
      i(S.range[0] >= b, "Fix objects must not be overlapped in a report."), S.range[0] >= 0 && (T += d.slice(Math.max(0, y, b), S.range[0])), T += S.text, b = S.range[1];
    return T += d.slice(Math.max(0, y, b), v), { range: [y, v], text: T };
  }
  function m(c, g) {
    if (typeof c.fix != "function")
      return null;
    const d = c.fix(t);
    return d && Symbol.iterator in d ? p(Array.from(d), g) : (a(d), e(d));
  }
  function h(c, g, d) {
    return !c.suggest || !Array.isArray(c.suggest) ? [] : c.suggest.map((y) => {
      const v = y.desc || d[y.messageId];
      return {
        ...y,
        desc: o(v, y.data),
        fix: m(y, g)
      };
    }).filter(({ fix: y }) => y);
  }
  function l(c) {
    const g = {
      ruleId: c.ruleId,
      severity: c.severity,
      message: c.message,
      line: c.loc.start.line,
      column: c.loc.start.column + 1,
      nodeType: c.node && c.node.type || null
    };
    return c.messageId && (g.messageId = c.messageId), c.loc.end && (g.endLine = c.loc.end.line, g.endColumn = c.loc.end.column + 1), c.fix && (g.fix = c.fix), c.suggestions && c.suggestions.length > 0 && (g.suggestions = c.suggestions), g;
  }
  function s(c, g) {
    c && Array.isArray(c) && c.forEach((d) => {
      if (d.messageId) {
        const { messageId: y } = d;
        if (!g)
          throw new TypeError(`context.report() called with a suggest option with a messageId '${y}', but no messages were present in the rule metadata.`);
        if (!g[y])
          throw new TypeError(`context.report() called with a suggest option with a messageId '${y}' which is not present in the 'messages' config: ${JSON.stringify(g, null, 2)}`);
        if (d.desc)
          throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
      } else if (!d.desc)
        throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
      if (typeof d.fix != "function")
        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${d}`);
    });
  }
  return ci = function(g) {
    return (...d) => {
      const y = f(...d), v = g.messageIds;
      r(y);
      let T;
      if (y.messageId) {
        if (!v)
          throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
        const b = y.messageId;
        if (y.message)
          throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
        if (!v || !Object.prototype.hasOwnProperty.call(v, b))
          throw new TypeError(`context.report() called with a messageId of '${b}' which is not present in the 'messages' config: ${JSON.stringify(v, null, 2)}`);
        T = v[b];
      } else if (y.message)
        T = y.message;
      else
        throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
      return s(y.suggest, v), l({
        ruleId: g.ruleId,
        severity: g.severity,
        node: y.node,
        message: o(T, y.data),
        messageId: y.messageId,
        loc: u(y),
        fix: g.disableFixes ? null : m(y, g.sourceCode),
        suggestions: g.disableFixes ? [] : h(y, g.sourceCode, v)
      });
    };
  }, ci;
}
function qA(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var fi, gm;
function $A() {
  if (gm) return fi;
  gm = 1;
  const i = vr()("eslint:rules");
  class t extends Map {
    /**
     * Initialize this map.
     * @param {Array<[string, function(): Rule]>} loaders The rule loaders.
     */
    constructor(f) {
      let r = f.length;
      super(
        i.enabled ? f.map(([u, e]) => {
          let a = null;
          return [
            u,
            () => (a || (i("Loading rule %o (remaining=%d)", u, --r), a = e()), a)
          ];
        }) : f
      ), Object.defineProperty(t.prototype, "set", {
        configurable: !0,
        value: void 0
      });
    }
    /**
     * Get a rule.
     * Each rule will be loaded on the first access.
     * @param {string} ruleId The rule ID to get.
     * @returns {Rule|undefined} The rule.
     */
    get(f) {
      const r = super.get(f);
      return r && r();
    }
    /**
     * Iterate rules.
     * @returns {IterableIterator<Rule>} Rules.
     */
    *values() {
      for (const f of super.values())
        yield f();
    }
    /**
     * Iterate rules.
     * @returns {IterableIterator<[string, Rule]>} Rules.
     */
    *entries() {
      for (const [f, r] of super.entries())
        yield [f, r()];
    }
    /**
     * Call a function with each rule.
     * @param {Function} callbackFn The callback function.
     * @param {any} [thisArg] The object to pass to `this` of the callback function.
     * @returns {void}
     */
    forEach(f, r) {
      for (const [u, e] of super.entries())
        f.call(r, e(), u, this);
    }
  }
  return Object.defineProperties(t.prototype, {
    clear: { configurable: !0, value: void 0 },
    delete: { configurable: !0, value: void 0 },
    [Symbol.iterator]: {
      configurable: !0,
      writable: !0,
      value: t.prototype.entries
    }
  }), fi = { LazyLoadingRuleMap: t }, fi;
}
var pi = { exports: {} }, Nr = {}, hi = { exports: {} }, dm;
function GA() {
  return dm || (dm = 1, function() {
    function i(e) {
      if (e == null)
        return !1;
      switch (e.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return !0;
      }
      return !1;
    }
    function t(e) {
      if (e == null)
        return !1;
      switch (e.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return !0;
      }
      return !1;
    }
    function o(e) {
      if (e == null)
        return !1;
      switch (e.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return !0;
      }
      return !1;
    }
    function f(e) {
      return o(e) || e != null && e.type === "FunctionDeclaration";
    }
    function r(e) {
      switch (e.type) {
        case "IfStatement":
          return e.alternate != null ? e.alternate : e.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e.body;
      }
      return null;
    }
    function u(e) {
      var a;
      if (e.type !== "IfStatement" || e.alternate == null)
        return !1;
      a = e.consequent;
      do {
        if (a.type === "IfStatement" && a.alternate == null)
          return !0;
        a = r(a);
      } while (a);
      return !1;
    }
    hi.exports = {
      isExpression: i,
      isStatement: o,
      isIterationStatement: t,
      isSourceElement: f,
      isProblematicIfStatement: u,
      trailingStatement: r
    };
  }()), hi.exports;
}
var mi = { exports: {} }, Em;
function Rv() {
  return Em || (Em = 1, function() {
    var i, t, o, f, r, u;
    t = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, i = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function e(d) {
      return 48 <= d && d <= 57;
    }
    function a(d) {
      return 48 <= d && d <= 57 || // 0..9
      97 <= d && d <= 102 || // a..f
      65 <= d && d <= 70;
    }
    function n(d) {
      return d >= 48 && d <= 55;
    }
    o = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function p(d) {
      return d === 32 || d === 9 || d === 11 || d === 12 || d === 160 || d >= 5760 && o.indexOf(d) >= 0;
    }
    function m(d) {
      return d === 10 || d === 13 || d === 8232 || d === 8233;
    }
    function h(d) {
      if (d <= 65535)
        return String.fromCharCode(d);
      var y = String.fromCharCode(Math.floor((d - 65536) / 1024) + 55296), v = String.fromCharCode((d - 65536) % 1024 + 56320);
      return y + v;
    }
    for (f = new Array(128), u = 0; u < 128; ++u)
      f[u] = u >= 97 && u <= 122 || // a..z
      u >= 65 && u <= 90 || // A..Z
      u === 36 || u === 95;
    for (r = new Array(128), u = 0; u < 128; ++u)
      r[u] = u >= 97 && u <= 122 || // a..z
      u >= 65 && u <= 90 || // A..Z
      u >= 48 && u <= 57 || // 0..9
      u === 36 || u === 95;
    function l(d) {
      return d < 128 ? f[d] : t.NonAsciiIdentifierStart.test(h(d));
    }
    function s(d) {
      return d < 128 ? r[d] : t.NonAsciiIdentifierPart.test(h(d));
    }
    function c(d) {
      return d < 128 ? f[d] : i.NonAsciiIdentifierStart.test(h(d));
    }
    function g(d) {
      return d < 128 ? r[d] : i.NonAsciiIdentifierPart.test(h(d));
    }
    mi.exports = {
      isDecimalDigit: e,
      isHexDigit: a,
      isOctalDigit: n,
      isWhiteSpace: p,
      isLineTerminator: m,
      isIdentifierStartES5: l,
      isIdentifierPartES5: s,
      isIdentifierStartES6: c,
      isIdentifierPartES6: g
    };
  }()), mi.exports;
}
var gi = { exports: {} }, ym;
function WA() {
  return ym || (ym = 1, function() {
    var i = Rv();
    function t(l) {
      switch (l) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return !0;
        default:
          return !1;
      }
    }
    function o(l, s) {
      return !s && l === "yield" ? !1 : f(l, s);
    }
    function f(l, s) {
      if (s && t(l))
        return !0;
      switch (l.length) {
        case 2:
          return l === "if" || l === "in" || l === "do";
        case 3:
          return l === "var" || l === "for" || l === "new" || l === "try";
        case 4:
          return l === "this" || l === "else" || l === "case" || l === "void" || l === "with" || l === "enum";
        case 5:
          return l === "while" || l === "break" || l === "catch" || l === "throw" || l === "const" || l === "yield" || l === "class" || l === "super";
        case 6:
          return l === "return" || l === "typeof" || l === "delete" || l === "switch" || l === "export" || l === "import";
        case 7:
          return l === "default" || l === "finally" || l === "extends";
        case 8:
          return l === "function" || l === "continue" || l === "debugger";
        case 10:
          return l === "instanceof";
        default:
          return !1;
      }
    }
    function r(l, s) {
      return l === "null" || l === "true" || l === "false" || o(l, s);
    }
    function u(l, s) {
      return l === "null" || l === "true" || l === "false" || f(l, s);
    }
    function e(l) {
      return l === "eval" || l === "arguments";
    }
    function a(l) {
      var s, c, g;
      if (l.length === 0 || (g = l.charCodeAt(0), !i.isIdentifierStartES5(g)))
        return !1;
      for (s = 1, c = l.length; s < c; ++s)
        if (g = l.charCodeAt(s), !i.isIdentifierPartES5(g))
          return !1;
      return !0;
    }
    function n(l, s) {
      return (l - 55296) * 1024 + (s - 56320) + 65536;
    }
    function p(l) {
      var s, c, g, d, y;
      if (l.length === 0)
        return !1;
      for (y = i.isIdentifierStartES6, s = 0, c = l.length; s < c; ++s) {
        if (g = l.charCodeAt(s), 55296 <= g && g <= 56319) {
          if (++s, s >= c || (d = l.charCodeAt(s), !(56320 <= d && d <= 57343)))
            return !1;
          g = n(g, d);
        }
        if (!y(g))
          return !1;
        y = i.isIdentifierPartES6;
      }
      return !0;
    }
    function m(l, s) {
      return a(l) && !r(l, s);
    }
    function h(l, s) {
      return p(l) && !u(l, s);
    }
    gi.exports = {
      isKeywordES5: o,
      isKeywordES6: f,
      isReservedWordES5: r,
      isReservedWordES6: u,
      isRestrictedWord: e,
      isIdentifierNameES5: a,
      isIdentifierNameES6: p,
      isIdentifierES5: m,
      isIdentifierES6: h
    };
  }()), gi.exports;
}
var Cm;
function En() {
  return Cm || (Cm = 1, function() {
    Nr.ast = GA(), Nr.code = Rv(), Nr.keyword = WA();
  }()), Nr;
}
var vm;
function Re() {
  return vm || (vm = 1, function(i) {
    const { KEYS: t } = qr(), o = En(), f = hn(), r = dn(), {
      breakableTypePattern: u,
      createGlobalLinebreakMatcher: e,
      lineBreakPattern: a,
      shebangPattern: n
    } = mn(), p = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u, m = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u, h = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|some)$/u, l = /Array$/u, s = /^(?:bind|call|apply)$/u, c = /^[\s*]*@this/mu, g = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u, d = /^(?:eslint[- ]|(?:globals?|exported) )/u, y = /* @__PURE__ */ new Set([`\r
`, "\r", `
`, "\u2028", "\u2029"]), v = /* @__PURE__ */ new Set(["Program", "BlockStatement", "StaticBlock", "SwitchCase"]), T = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u, b = /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su, S = /* @__PURE__ */ new Set(["&&=", "||=", "??="]);
    function C(B, z, ce) {
      const ye = B.identifier, Be = z === 0 || ce[z - 1].identifier !== ye;
      return ye && B.init === !1 && B.isWrite() && Be;
    }
    function x(B) {
      return B[0] !== B[0].toLocaleLowerCase();
    }
    function A(B) {
      return B.id && x(B.id.name);
    }
    function R(B) {
      for (let z = B; z; z = z.parent)
        if (p.test(z.type))
          return z;
      return null;
    }
    function L(B) {
      return !!(B && p.test(B.type));
    }
    function _(B) {
      return !!(B && m.test(B.type));
    }
    function I(B) {
      for (let z = B; z && !L(z); z = z.parent)
        if (_(z))
          return !0;
      return !1;
    }
    function O(B) {
      return B.type === "Literal" && B.value === null && !B.regex && !B.bigint;
    }
    function k(B) {
      return O(B) || B.type === "Identifier" && B.name === "undefined" || B.type === "UnaryExpression" && B.operator === "void";
    }
    function w(B) {
      return B.parent.type === "CallExpression" && B.parent.callee === B;
    }
    function U(B) {
      switch (B.type) {
        case "Literal":
          if (B.value === null) {
            if (O(B))
              return String(B.value);
            if (B.regex)
              return `/${B.regex.pattern}/${B.regex.flags}`;
            if (B.bigint)
              return B.bigint;
          } else
            return String(B.value);
          break;
        case "TemplateLiteral":
          if (B.expressions.length === 0 && B.quasis.length === 1)
            return B.quasis[0].value.cooked;
          break;
      }
      return null;
    }
    function q(B) {
      let z;
      switch (B && B.type) {
        case "ChainExpression":
          return q(B.expression);
        case "Property":
        case "PropertyDefinition":
        case "MethodDefinition":
          z = B.key;
          break;
        case "MemberExpression":
          z = B.property;
          break;
      }
      return z ? z.type === "Identifier" && !B.computed ? z.name : U(z) : null;
    }
    function F(B) {
      return B && B.type === "ChainExpression" ? B.expression : B;
    }
    function $(B, z) {
      return typeof z == "string" ? B === z : z.test(B);
    }
    function P(B, z) {
      return B.type === "Identifier" && $(B.name, z);
    }
    function X(B, z, ce) {
      const ye = F(B);
      if (ye.type !== "MemberExpression" || z && !P(ye.object, z))
        return !1;
      if (ce) {
        const Be = q(ye);
        if (typeof Be != "string" || !$(Be, ce))
          return !1;
      }
      return !0;
    }
    function Q(B, z) {
      return B.regex || z.regex ? !!(B.regex && z.regex && B.regex.pattern === z.regex.pattern && B.regex.flags === z.regex.flags) : B.bigint || z.bigint ? B.bigint === z.bigint : B.value === z.value;
    }
    function ue(B, z, ce = !1) {
      if (B.type !== z.type)
        return B.type === "ChainExpression" ? ue(B.expression, z, ce) : z.type === "ChainExpression" ? ue(B, z.expression, ce) : !1;
      switch (B.type) {
        case "Super":
        case "ThisExpression":
          return !0;
        case "Identifier":
        case "PrivateIdentifier":
          return B.name === z.name;
        case "Literal":
          return Q(B, z);
        case "ChainExpression":
          return ue(B.expression, z.expression, ce);
        case "MemberExpression": {
          if (!ce) {
            const ye = q(B);
            if (ye !== null)
              return ue(B.object, z.object, ce) && ye === q(z);
          }
          return B.computed === z.computed && ue(B.object, z.object, ce) && ue(B.property, z.property, ce);
        }
        default:
          return !1;
      }
    }
    function le(B) {
      return X(B, "Reflect", "apply");
    }
    function Ce(B) {
      return X(B, l, "from");
    }
    function j(B) {
      return X(B, null, h);
    }
    function H(B) {
      return (z) => !B(z);
    }
    function N(B, z) {
      const ce = z.getJSDocComment(B);
      return ce && c.test(ce.value) ? !0 : z.getCommentsBefore(B).some((ye) => c.test(ye.value));
    }
    function G(B, z) {
      const ce = B.getTokenBefore(z), ye = B.getTokenAfter(z);
      return !!(ce && ye) && ce.value === "(" && ce.range[1] <= z.range[0] && ye.value === ")" && ye.range[0] >= z.range[1];
    }
    function M(B) {
      return B.value === "=" && B.type === "Punctuator";
    }
    function Z(B) {
      return B.value === "=>" && B.type === "Punctuator";
    }
    function Ee(B) {
      return B.value === "," && B.type === "Punctuator";
    }
    function ke(B) {
      return B.value === "." && B.type === "Punctuator";
    }
    function Ie(B) {
      return B.value === "?." && B.type === "Punctuator";
    }
    function Je(B) {
      return B.value === ";" && B.type === "Punctuator";
    }
    function at(B) {
      return B.value === ":" && B.type === "Punctuator";
    }
    function lt(B) {
      return B.value === "(" && B.type === "Punctuator";
    }
    function mt(B) {
      return B.value === ")" && B.type === "Punctuator";
    }
    function Y(B) {
      return B.value === "[" && B.type === "Punctuator";
    }
    function Te(B) {
      return B.value === "]" && B.type === "Punctuator";
    }
    function Ke(B) {
      return B.value === "{" && B.type === "Punctuator";
    }
    function et(B) {
      return B.value === "}" && B.type === "Punctuator";
    }
    function nt(B) {
      return B.type === "Line" || B.type === "Block" || B.type === "Shebang";
    }
    function rt(B) {
      return B.type === "Keyword";
    }
    function ot(B, z) {
      if (B.type === "ArrowFunctionExpression" && B.params.length === 1) {
        const ce = z.getFirstToken(B.params[0]), ye = z.getTokenBefore(ce);
        return lt(ye) ? ye : ce;
      }
      return B.id ? z.getTokenAfter(B.id, lt) : z.getFirstToken(B, lt);
    }
    function Ct(B, z, ce) {
      const ye = ce.getTokens(B), Be = ce.getTokens(z);
      if (ye.length !== Be.length)
        return !1;
      for (let we = 0; we < ye.length; ++we)
        if (ye[we].type !== Be[we].type || ye[we].value !== Be[we].value)
          return !1;
      return !0;
    }
    function dt(B) {
      return B.type === "LogicalExpression" && (B.operator === "&&" || B.operator === "||");
    }
    function vt(B) {
      return B.type === "LogicalExpression" && B.operator === "??";
    }
    function W(B, z) {
      return dt(B) && vt(z) || vt(B) && dt(z);
    }
    function Ye(B) {
      return S.has(B);
    }
    function Ue(B, z) {
      return B.test ? z.getTokenAfter(B.test, at) : z.getFirstToken(B, 1);
    }
    function Ve(B) {
      return B.type === "Identifier" ? B.name : B.value;
    }
    function xe(B) {
      return B.value === null ? B.raw === "null" ? !1 : typeof B.regex == "object" ? !0 : null : !!B.value;
    }
    function re(B, z) {
      switch (B.type) {
        case "Literal":
          return z === "||" && xe(B) === !0 || z === "&&" && xe(B) === !1;
        case "UnaryExpression":
          return z === "&&" && B.operator === "void";
        case "LogicalExpression":
          return z === B.operator && (re(B.left, z) || re(B.right, z));
        case "AssignmentExpression":
          return ["||=", "&&="].includes(B.operator) && z === B.operator.slice(0, -1) && re(B.right, z);
      }
      return !1;
    }
    function ne(B, z) {
      const ce = B.references.find((ye) => ye.identifier === z);
      return !!(ce && ce.resolved && ce.resolved.scope.type === "global" && ce.resolved.defs.length === 0);
    }
    function ae(B, z, ce) {
      if (!z)
        return !0;
      switch (z.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return !0;
        case "ClassExpression":
        case "ObjectExpression":
          return !0;
        case "TemplateLiteral":
          return ce && z.quasis.some((ye) => ye.value.cooked.length) || z.expressions.every((ye) => ae(B, ye, !1));
        case "ArrayExpression":
          return ce ? !0 : z.elements.every((ye) => ae(B, ye, !1));
        case "UnaryExpression":
          return z.operator === "void" || z.operator === "typeof" && ce ? !0 : z.operator === "!" ? ae(B, z.argument, !0) : ae(B, z.argument, !1);
        case "BinaryExpression":
          return ae(B, z.left, !1) && ae(B, z.right, !1) && z.operator !== "in";
        case "LogicalExpression": {
          const ye = ae(B, z.left, ce), Be = ae(B, z.right, ce), we = ye && re(z.left, z.operator), Pe = ce && Be && re(z.right, z.operator);
          return ye && Be || we || Pe;
        }
        case "NewExpression":
          return ce;
        case "AssignmentExpression":
          return z.operator === "=" ? ae(B, z.right, ce) : ["||=", "&&="].includes(z.operator) && ce ? re(z.right, z.operator.slice(0, -1)) : !1;
        case "SequenceExpression":
          return ae(B, z.expressions[z.expressions.length - 1], ce);
        case "SpreadElement":
          return ae(B, z.argument, ce);
        case "CallExpression":
          return z.callee.type === "Identifier" && z.callee.name === "Boolean" && (z.arguments.length === 0 || ae(B, z.arguments[0], !0)) ? ne(B, z.callee) : !1;
        case "Identifier":
          return z.name === "undefined" && ne(B, z);
      }
      return !1;
    }
    function fe(B) {
      if (B.type !== "ExpressionStatement")
        return !1;
      const z = B.parent;
      return z.type === "Program" || z.type === "BlockStatement" && L(z.parent);
    }
    function de(B) {
      return B.type === "ExpressionStatement" && typeof B.directive == "string";
    }
    function ee(B) {
      const z = B.range[0];
      let ce = B;
      for (; (ce = ce.parent) && ce.range[0] === z; )
        if (ce.type === "ExpressionStatement")
          return !0;
      return !1;
    }
    let te;
    {
      const B = /* @__PURE__ */ new Set(["BreakStatement", "ContinueStatement"]), z = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]), ce = /* @__PURE__ */ new Set(["Identifier", "Keyword"]), ye = {
        __proto__: null,
        break: "BreakStatement",
        continue: "ContinueStatement",
        debugger: "DebuggerStatement",
        do: "DoWhileStatement",
        else: "IfStatement",
        return: "ReturnStatement",
        yield: "YieldExpression"
      }, Be = /* @__PURE__ */ new Set([":", ";", "{", "=>", "++", "--"]), we = /* @__PURE__ */ new Set([
        "DoWhileStatement",
        "ForInStatement",
        "ForOfStatement",
        "ForStatement",
        "IfStatement",
        "WhileStatement",
        "WithStatement"
      ]);
      te = function(Pe, st) {
        const We = Pe.getTokenBefore(st);
        if (!We || We.type === "Punctuator" && Be.has(We.value))
          return !1;
        const _e = Pe.getNodeByRangeIndex(We.range[0]);
        if (mt(We))
          return !we.has(_e.type);
        if (et(We))
          return _e.type === "BlockStatement" && _e.parent.type === "FunctionExpression" || _e.type === "ClassBody" && _e.parent.type === "ClassExpression" || _e.type === "ObjectExpression";
        if (ce.has(We.type)) {
          if (B.has(_e.parent.type))
            return !1;
          const je = We.value, $e = ye[je];
          return _e.type !== $e;
        }
        return We.type === "String" ? !z.has(_e.parent.type) : !0;
      };
    }
    i.exports = {
      COMMENTS_IGNORE_PATTERN: g,
      LINEBREAKS: y,
      LINEBREAK_MATCHER: a,
      SHEBANG_MATCHER: n,
      STATEMENT_LIST_PARENTS: v,
      /**
       * Determines whether two adjacent tokens are on the same line.
       * @param {Object} left The left token object.
       * @param {Object} right The right token object.
       * @returns {boolean} Whether or not the tokens are on the same line.
       * @public
       */
      isTokenOnSameLine(B, z) {
        return B.loc.end.line === z.loc.start.line;
      },
      isNullOrUndefined: k,
      isCallee: w,
      isES5Constructor: A,
      getUpperFunction: R,
      isFunction: L,
      isLoop: _,
      isInLoop: I,
      isArrayFromMethod: Ce,
      isParenthesised: G,
      createGlobalLinebreakMatcher: e,
      equalTokens: Ct,
      isArrowToken: Z,
      isClosingBraceToken: et,
      isClosingBracketToken: Te,
      isClosingParenToken: mt,
      isColonToken: at,
      isCommaToken: Ee,
      isCommentToken: nt,
      isDotToken: ke,
      isQuestionDotToken: Ie,
      isKeywordToken: rt,
      isNotClosingBraceToken: H(et),
      isNotClosingBracketToken: H(Te),
      isNotClosingParenToken: H(mt),
      isNotColonToken: H(at),
      isNotCommaToken: H(Ee),
      isNotDotToken: H(ke),
      isNotQuestionDotToken: H(Ie),
      isNotOpeningBraceToken: H(Ke),
      isNotOpeningBracketToken: H(Y),
      isNotOpeningParenToken: H(lt),
      isNotSemicolonToken: H(Je),
      isOpeningBraceToken: Ke,
      isOpeningBracketToken: Y,
      isOpeningParenToken: lt,
      isSemicolonToken: Je,
      isEqToken: M,
      /**
       * Checks whether or not a given node is a string literal.
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is a string literal.
       */
      isStringLiteral(B) {
        return B.type === "Literal" && typeof B.value == "string" || B.type === "TemplateLiteral";
      },
      /**
       * Checks whether a given node is a breakable statement or not.
       * The node is breakable if the node is one of the following type:
       *
       * - DoWhileStatement
       * - ForInStatement
       * - ForOfStatement
       * - ForStatement
       * - SwitchStatement
       * - WhileStatement
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is breakable.
       */
      isBreakableStatement(B) {
        return u.test(B.type);
      },
      /**
       * Gets references which are non initializer and writable.
       * @param {Reference[]} references An array of references.
       * @returns {Reference[]} An array of only references which are non initializer and writable.
       * @public
       */
      getModifyingReferences(B) {
        return B.filter(C);
      },
      /**
       * Validate that a string passed in is surrounded by the specified character
       * @param {string} val The text to check.
       * @param {string} character The character to see if it's surrounded by.
       * @returns {boolean} True if the text is surrounded by the character, false if not.
       * @private
       */
      isSurroundedBy(B, z) {
        return B[0] === z && B[B.length - 1] === z;
      },
      /**
       * Returns whether the provided node is an ESLint directive comment or not
       * @param {Line|Block} node The comment token to be checked
       * @returns {boolean} `true` if the node is an ESLint directive comment
       */
      isDirectiveComment(B) {
        const z = B.value.trim();
        return B.type === "Line" && z.startsWith("eslint-") || B.type === "Block" && d.test(z);
      },
      /**
       * Gets the trailing statement of a given node.
       *
       *     if (code)
       *         consequent;
       *
       * When taking this `IfStatement`, returns `consequent;` statement.
       * @param {ASTNode} A node to get.
       * @returns {ASTNode|null} The trailing statement's node.
       */
      getTrailingStatement: o.ast.trailingStatement,
      /**
       * Finds the variable by a given name in a given scope and its upper scopes.
       * @param {eslint-scope.Scope} initScope A scope to start find.
       * @param {string} name A variable name to find.
       * @returns {eslint-scope.Variable|null} A found variable or `null`.
       */
      getVariableByName(B, z) {
        let ce = B;
        for (; ce; ) {
          const ye = ce.set.get(z);
          if (ye)
            return ye;
          ce = ce.upper;
        }
        return null;
      },
      /**
       * Checks whether or not a given function node is the default `this` binding.
       *
       * First, this checks the node:
       *
       * - The given node is not in `PropertyDefinition#value` position.
       * - The given node is not `StaticBlock`.
       * - The function name does not start with uppercase. It's a convention to capitalize the names
       *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.
       * - The function does not have a JSDoc comment that has a @this tag.
       *
       * Next, this checks the location of the node.
       * If the location is below, this judges `this` is valid.
       *
       * - The location is not on an object literal.
       * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous
       *   functions only, as the name of the variable is considered to be the name of the function in this case.
       *   This check is not performed if `capIsConstructor` is set to `false`.
       * - The location is not on an ES2015 class.
       * - Its `bind`/`call`/`apply` method is not called directly.
       * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
       * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`
       * or any expression that is `PropertyDefinition#value` node.
       * @param {SourceCode} sourceCode A SourceCode instance to get comments.
       * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts
       * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.
       * @returns {boolean} The function node is the default `this` binding.
       */
      isDefaultThisBinding(B, z, { capIsConstructor: ce = !0 } = {}) {
        if (B.parent.type === "PropertyDefinition" && B.parent.value === B || B.type === "StaticBlock" || ce && A(B) || N(B, z))
          return !1;
        const ye = B.id === null;
        let Be = B;
        for (; Be; ) {
          const we = Be.parent;
          switch (we.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
            case "ChainExpression":
              Be = we;
              break;
            case "ReturnStatement": {
              const Pe = R(we);
              if (Pe === null || !w(Pe))
                return !0;
              Be = Pe.parent;
              break;
            }
            case "ArrowFunctionExpression":
              if (Be !== we.body || !w(we))
                return !0;
              Be = we.parent;
              break;
            case "Property":
            case "PropertyDefinition":
            case "MethodDefinition":
              return we.value !== Be;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return !(we.left.type === "MemberExpression" || ce && ye && we.left.type === "Identifier" && x(we.left.name));
            case "VariableDeclarator":
              return !(ce && ye && we.init === Be && we.id.type === "Identifier" && x(we.id.name));
            case "MemberExpression":
              if (we.object === Be && X(we, null, s)) {
                const Pe = we.parent.type === "ChainExpression" ? we.parent : we;
                return !(w(Pe) && Pe.parent.arguments.length >= 1 && !k(Pe.parent.arguments[0]));
              }
              return !0;
            case "CallExpression":
              return le(we.callee) ? we.arguments.length !== 3 || we.arguments[0] !== Be || k(we.arguments[1]) : Ce(we.callee) ? we.arguments.length !== 3 || we.arguments[1] !== Be || k(we.arguments[2]) : j(we.callee) ? we.arguments.length !== 2 || we.arguments[0] !== Be || k(we.arguments[1]) : !0;
            default:
              return !0;
          }
        }
        return !0;
      },
      /**
       * Get the precedence level based on the node type
       * @param {ASTNode} node node to evaluate
       * @returns {int} precedence level
       * @private
       */
      getPrecedence(B) {
        switch (B.type) {
          case "SequenceExpression":
            return 0;
          case "AssignmentExpression":
          case "ArrowFunctionExpression":
          case "YieldExpression":
            return 1;
          case "ConditionalExpression":
            return 3;
          case "LogicalExpression":
            switch (B.operator) {
              case "||":
              case "??":
                return 4;
              case "&&":
                return 5;
            }
          case "BinaryExpression":
            switch (B.operator) {
              case "|":
                return 6;
              case "^":
                return 7;
              case "&":
                return 8;
              case "==":
              case "!=":
              case "===":
              case "!==":
                return 9;
              case "<":
              case "<=":
              case ">":
              case ">=":
              case "in":
              case "instanceof":
                return 10;
              case "<<":
              case ">>":
              case ">>>":
                return 11;
              case "+":
              case "-":
                return 12;
              case "*":
              case "/":
              case "%":
                return 13;
              case "**":
                return 15;
            }
          case "UnaryExpression":
          case "AwaitExpression":
            return 16;
          case "UpdateExpression":
            return 17;
          case "CallExpression":
          case "ChainExpression":
          case "ImportExpression":
            return 18;
          case "NewExpression":
            return 19;
          default:
            return B.type in t ? 20 : -1;
        }
      },
      /**
       * Checks whether the given node is an empty block node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty block.
       */
      isEmptyBlock(B) {
        return !!(B && B.type === "BlockStatement" && B.body.length === 0);
      },
      /**
       * Checks whether the given node is an empty function node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty function.
       */
      isEmptyFunction(B) {
        return L(B) && i.exports.isEmptyBlock(B.body);
      },
      /**
       * Get directives from directive prologue of a Program or Function node.
       * @param {ASTNode} node The node to check.
       * @returns {ASTNode[]} The directives found in the directive prologue.
       */
      getDirectivePrologue(B) {
        const z = [];
        if (B.type === "Program" || B.type === "FunctionDeclaration" || B.type === "FunctionExpression" || /*
        * Do not check arrow functions with implicit return.
        * `() => "use strict";` returns the string `"use strict"`.
        */
        B.type === "ArrowFunctionExpression" && B.body.type === "BlockStatement") {
          const ce = B.type === "Program" ? B.body : B.body.body;
          for (const ye of ce)
            if (ye.type === "ExpressionStatement" && ye.expression.type === "Literal")
              z.push(ye);
            else
              break;
        }
        return z;
      },
      /**
       * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
       * after the node will be parsed as a decimal point, rather than a property-access dot.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if this node is a decimal integer.
       * @example
       *
       * 0         // true
       * 5         // true
       * 50        // true
       * 5_000     // true
       * 1_234_56  // true
       * 08        // true
       * 0192      // true
       * 5.        // false
       * .5        // false
       * 5.0       // false
       * 5.00_00   // false
       * 05        // false
       * 0x5       // false
       * 0b101     // false
       * 0b11_01   // false
       * 0o5       // false
       * 5e0       // false
       * 5e1_000   // false
       * 5n        // false
       * 1_000n    // false
       * "5"       // false
       *
       */
      isDecimalInteger(B) {
        return B.type === "Literal" && typeof B.value == "number" && T.test(B.raw);
      },
      /**
       * Determines whether this token is a decimal integer numeric token.
       * This is similar to isDecimalInteger(), but for tokens.
       * @param {Token} token The token to check.
       * @returns {boolean} `true` if this token is a decimal integer.
       */
      isDecimalIntegerNumericToken(B) {
        return B.type === "Numeric" && T.test(B.value);
      },
      /**
       * Gets the name and kind of the given function node.
       *
       * - `function foo() {}`  .................... `function 'foo'`
       * - `(function foo() {})`  .................. `function 'foo'`
       * - `(function() {})`  ...................... `function`
       * - `function* foo() {}`  ................... `generator function 'foo'`
       * - `(function* foo() {})`  ................. `generator function 'foo'`
       * - `(function*() {})`  ..................... `generator function`
       * - `() => {}`  ............................. `arrow function`
       * - `async () => {}`  ....................... `async arrow function`
       * - `({ foo: function foo() {} })`  ......... `method 'foo'`
       * - `({ foo: function() {} })`  ............. `method 'foo'`
       * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
       * - `({ [foo]: function() {} })`  ........... `method`
       * - `({ foo() {} })`  ....................... `method 'foo'`
       * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
       * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
       * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
       * - `({ [foo]: function*() {} })`  .......... `generator method`
       * - `({ *foo() {} })`  ...................... `generator method 'foo'`
       * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
       * - `({ foo: async function() {} })`  ....... `async method 'foo'`
       * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
       * - `({ [foo]: async function() {} })`  ..... `async method`
       * - `({ async foo() {} })`  ................. `async method 'foo'`
       * - `({ get foo() {} })`  ................... `getter 'foo'`
       * - `({ set foo(a) {} })`  .................. `setter 'foo'`
       * - `class A { constructor() {} }`  ......... `constructor`
       * - `class A { foo() {} }`  ................. `method 'foo'`
       * - `class A { *foo() {} }`  ................ `generator method 'foo'`
       * - `class A { async foo() {} }`  ........... `async method 'foo'`
       * - `class A { ['foo']() {} }`  ............. `method 'foo'`
       * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
       * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
       * - `class A { [foo]() {} }`  ............... `method`
       * - `class A { *[foo]() {} }`  .............. `generator method`
       * - `class A { async [foo]() {} }`  ......... `async method`
       * - `class A { get foo() {} }`  ............. `getter 'foo'`
       * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
       * - `class A { static foo() {} }`  .......... `static method 'foo'`
       * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
       * - `class A { static async foo() {} }`  .... `static async method 'foo'`
       * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
       * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
       * - `class A { foo = () => {}; }`  .......... `method 'foo'`
       * - `class A { foo = function() {}; }`  ..... `method 'foo'`
       * - `class A { foo = function bar() {}; }`  . `method 'foo'`
       * - `class A { static foo = () => {}; }`  ... `static method 'foo'`
       * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`
       * - `class A { #foo = () => {}; }`  ......... `private method #foo`
       * - `class A { static #foo = () => {}; }`  .. `static private method #foo`
       * - `class A { '#foo'() {} }`  .............. `method '#foo'`
       * - `class A { #foo() {} }`  ................ `private method #foo`
       * - `class A { static #foo() {} }`  ......... `static private method #foo`
       * @param {ASTNode} node The function node to get.
       * @returns {string} The name and kind of the function node.
       */
      getFunctionNameWithKind(B) {
        const z = B.parent, ce = [];
        if ((z.type === "MethodDefinition" || z.type === "PropertyDefinition") && (z.static && ce.push("static"), !z.computed && z.key.type === "PrivateIdentifier" && ce.push("private")), B.async && ce.push("async"), B.generator && ce.push("generator"), z.type === "Property" || z.type === "MethodDefinition") {
          if (z.kind === "constructor")
            return "constructor";
          z.kind === "get" ? ce.push("getter") : z.kind === "set" ? ce.push("setter") : ce.push("method");
        } else z.type === "PropertyDefinition" ? ce.push("method") : (B.type === "ArrowFunctionExpression" && ce.push("arrow"), ce.push("function"));
        if (z.type === "Property" || z.type === "MethodDefinition" || z.type === "PropertyDefinition")
          if (!z.computed && z.key.type === "PrivateIdentifier")
            ce.push(`#${z.key.name}`);
          else {
            const ye = q(z);
            ye !== null ? ce.push(`'${ye}'`) : B.id && ce.push(`'${B.id.name}'`);
          }
        else B.id && ce.push(`'${B.id.name}'`);
        return ce.join(" ");
      },
      /**
       * Gets the location of the given function node for reporting.
       *
       * - `function foo() {}`
       *    ^^^^^^^^^^^^
       * - `(function foo() {})`
       *     ^^^^^^^^^^^^
       * - `(function() {})`
       *     ^^^^^^^^
       * - `function* foo() {}`
       *    ^^^^^^^^^^^^^
       * - `(function* foo() {})`
       *     ^^^^^^^^^^^^^
       * - `(function*() {})`
       *     ^^^^^^^^^
       * - `() => {}`
       *       ^^
       * - `async () => {}`
       *             ^^
       * - `({ foo: function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ foo: function() {} })`
       *       ^^^^^^^^^^^^^
       * - `({ ['foo']: function() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function() {} })`
       *       ^^^^^^^^^^^^^^^
       * - `({ foo() {} })`
       *       ^^^
       * - `({ foo: function* foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ foo: function*() {} })`
       *       ^^^^^^^^^^^^^^
       * - `({ ['foo']: function*() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function*() {} })`
       *       ^^^^^^^^^^^^^^^^
       * - `({ *foo() {} })`
       *       ^^^^
       * - `({ foo: async function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ foo: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^
       * - `({ ['foo']: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^
       * - `({ async foo() {} })`
       *       ^^^^^^^^^
       * - `({ get foo() {} })`
       *       ^^^^^^^
       * - `({ set foo(a) {} })`
       *       ^^^^^^^
       * - `class A { constructor() {} }`
       *              ^^^^^^^^^^^
       * - `class A { foo() {} }`
       *              ^^^
       * - `class A { *foo() {} }`
       *              ^^^^
       * - `class A { async foo() {} }`
       *              ^^^^^^^^^
       * - `class A { ['foo']() {} }`
       *              ^^^^^^^
       * - `class A { *['foo']() {} }`
       *              ^^^^^^^^
       * - `class A { async ['foo']() {} }`
       *              ^^^^^^^^^^^^^
       * - `class A { [foo]() {} }`
       *              ^^^^^
       * - `class A { *[foo]() {} }`
       *              ^^^^^^
       * - `class A { async [foo]() {} }`
       *              ^^^^^^^^^^^
       * - `class A { get foo() {} }`
       *              ^^^^^^^
       * - `class A { set foo(a) {} }`
       *              ^^^^^^^
       * - `class A { static foo() {} }`
       *              ^^^^^^^^^^
       * - `class A { static *foo() {} }`
       *              ^^^^^^^^^^^
       * - `class A { static async foo() {} }`
       *              ^^^^^^^^^^^^^^^^
       * - `class A { static get foo() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static set foo(a) {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { foo = function() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static foo = function() {} }`
       *              ^^^^^^^^^^^^^^^^^^^^^
       * - `class A { foo = (a, b) => {} }`
       *              ^^^^^^
       * @param {ASTNode} node The function node to get.
       * @param {SourceCode} sourceCode The source code object to get tokens.
       * @returns {string} The location of the function node for reporting.
       */
      getFunctionHeadLoc(B, z) {
        const ce = B.parent;
        let ye = null, Be = null;
        if (ce.type === "Property" || ce.type === "MethodDefinition" || ce.type === "PropertyDefinition")
          ye = ce.loc.start, Be = ot(B, z).loc.start;
        else if (B.type === "ArrowFunctionExpression") {
          const we = z.getTokenBefore(B.body, Z);
          ye = we.loc.start, Be = we.loc.end;
        } else
          ye = B.loc.start, Be = ot(B, z).loc.start;
        return {
          start: Object.assign({}, ye),
          end: Object.assign({}, Be)
        };
      },
      /**
       * Gets next location when the result is not out of bound, otherwise returns null.
       *
       * Assumptions:
       *
       * - The given location represents a valid location in the given source code.
       * - Columns are 0-based.
       * - Lines are 1-based.
       * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.
       * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.
       *   The start (column 0) of that extra line is considered to be a valid location.
       *
       * Examples of successive locations (line, column):
       *
       * code: foo
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null
       *
       * code: foo<LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: foo<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: a<LF>b
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null
       *
       * code: a<LF>b<LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<CR><LF>b<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<LF><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null
       *
       * code: <LF>
       * locations: (1, 0) -> (2, 0) -> null
       *
       * code:
       * locations: (1, 0) -> null
       * @param {SourceCode} sourceCode The sourceCode
       * @param {{line: number, column: number}} location The location
       * @returns {{line: number, column: number} | null} Next location
       */
      getNextLocation(B, { line: z, column: ce }) {
        return ce < B.lines[z - 1].length ? {
          line: z,
          column: ce + 1
        } : z < B.lines.length ? {
          line: z + 1,
          column: 0
        } : null;
      },
      /**
       * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
       * surrounding the node.
       * @param {SourceCode} sourceCode The source code object
       * @param {ASTNode} node An expression node
       * @returns {string} The text representing the node, with all surrounding parentheses included
       */
      getParenthesisedText(B, z) {
        let ce = B.getFirstToken(z), ye = B.getLastToken(z);
        for (; B.getTokenBefore(ce) && B.getTokenBefore(ce).type === "Punctuator" && B.getTokenBefore(ce).value === "(" && B.getTokenAfter(ye) && B.getTokenAfter(ye).type === "Punctuator" && B.getTokenAfter(ye).value === ")"; )
          ce = B.getTokenBefore(ce), ye = B.getTokenAfter(ye);
        return B.getText().slice(ce.range[0], ye.range[1]);
      },
      /**
       * Determine if a node has a possibility to be an Error object
       * @param {ASTNode} node ASTNode to check
       * @returns {boolean} True if there is a chance it contains an Error obj
       */
      couldBeError(B) {
        switch (B.type) {
          case "Identifier":
          case "CallExpression":
          case "NewExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
          case "AwaitExpression":
          case "ChainExpression":
            return !0;
          case "AssignmentExpression":
            return ["=", "&&="].includes(B.operator) ? i.exports.couldBeError(B.right) : ["||=", "??="].includes(B.operator) ? i.exports.couldBeError(B.left) || i.exports.couldBeError(B.right) : !1;
          case "SequenceExpression": {
            const z = B.expressions;
            return z.length !== 0 && i.exports.couldBeError(z[z.length - 1]);
          }
          case "LogicalExpression":
            return B.operator === "&&" ? i.exports.couldBeError(B.right) : i.exports.couldBeError(B.left) || i.exports.couldBeError(B.right);
          case "ConditionalExpression":
            return i.exports.couldBeError(B.consequent) || i.exports.couldBeError(B.alternate);
          default:
            return !1;
        }
      },
      /**
       * Check if a given node is a numeric literal or not.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if the node is a number or bigint literal.
       */
      isNumericLiteral(B) {
        return B.type === "Literal" && (typeof B.value == "number" || !!B.bigint);
      },
      /**
       * Determines whether two tokens can safely be placed next to each other without merging into a single token
       * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
       * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
       * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
       * next to each other, behavior is undefined (although it should return `true` in most cases).
       */
      canTokensBeAdjacent(B, z) {
        const ce = {
          ecmaVersion: f.latestEcmaVersion,
          comment: !0,
          range: !0
        };
        let ye;
        if (typeof B == "string") {
          let we;
          try {
            we = f.tokenize(B, ce);
          } catch {
            return !1;
          }
          const Pe = we.comments;
          if (ye = we[we.length - 1], Pe.length) {
            const st = Pe[Pe.length - 1];
            (!ye || st.range[0] > ye.range[0]) && (ye = st);
          }
        } else
          ye = B;
        if (ye.type === "Shebang" || ye.type === "Hashbang")
          return !1;
        let Be;
        if (typeof z == "string") {
          let we;
          try {
            we = f.tokenize(z, ce);
          } catch {
            return !1;
          }
          const Pe = we.comments;
          if (Be = we[0], Pe.length) {
            const st = Pe[0];
            (!Be || st.range[0] < Be.range[0]) && (Be = st);
          }
        } else
          Be = z;
        if (ye.type === "Punctuator" || Be.type === "Punctuator") {
          if (ye.type === "Punctuator" && Be.type === "Punctuator") {
            const we = /* @__PURE__ */ new Set(["+", "++"]), Pe = /* @__PURE__ */ new Set(["-", "--"]);
            return !(we.has(ye.value) && we.has(Be.value) || Pe.has(ye.value) && Pe.has(Be.value));
          }
          return ye.type === "Punctuator" && ye.value === "/" ? !["Block", "Line", "RegularExpression"].includes(Be.type) : !0;
        }
        return !!(ye.type === "String" || Be.type === "String" || ye.type === "Template" || Be.type === "Template" || ye.type !== "Numeric" && Be.type === "Numeric" && Be.value.startsWith(".") || ye.type === "Block" || Be.type === "Block" || Be.type === "Line" || Be.type === "PrivateIdentifier");
      },
      /**
       * Get the `loc` object of a given name in a `/*globals` directive comment.
       * @param {SourceCode} sourceCode The source code to convert index to loc.
       * @param {Comment} comment The `/*globals` directive comment which include the name.
       * @param {string} name The name to find.
       * @returns {SourceLocation} The `loc` object.
       */
      getNameLocationInGlobalDirectiveComment(B, z, ce) {
        const ye = new RegExp(`[\\s,]${r(ce)}(?:$|[\\s,:])`, "gu");
        ye.lastIndex = z.value.indexOf("global") + 6;
        const Be = ye.exec(z.value), we = B.getLocFromIndex(
          z.range[0] + 2 + (Be ? Be.index + 1 : 0)
        ), Pe = {
          line: we.line,
          column: we.column + (Be ? ce.length : 1)
        };
        return { start: we, end: Pe };
      },
      /**
       * Determines whether the given raw string contains an octal escape sequence
       * or a non-octal decimal escape sequence ("\8", "\9").
       *
       * "\1", "\2" ... "\7", "\8", "\9"
       * "\00", "\01" ... "\07", "\08", "\09"
       *
       * "\0", when not followed by a digit, is not an octal escape sequence.
       * @param {string} rawString A string in its raw representation.
       * @returns {boolean} `true` if the string contains at least one octal escape sequence
       * or at least one non-octal decimal escape sequence.
       */
      hasOctalOrNonOctalDecimalEscapeSequence(B) {
        return b.test(B);
      },
      /**
       * Determines whether the given node is a template literal without expressions.
       * @param {ASTNode} node Node to check.
       * @returns {boolean} True if the node is a template literal without expressions.
       */
      isStaticTemplateLiteral(B) {
        return B.type === "TemplateLiteral" && B.expressions.length === 0;
      },
      isReferenceToGlobalVariable: ne,
      isLogicalExpression: dt,
      isCoalesceExpression: vt,
      isMixedLogicalAndCoalesceExpressions: W,
      isNullLiteral: O,
      getStaticStringValue: U,
      getStaticPropertyName: q,
      skipChainExpression: F,
      isSpecificId: P,
      isSpecificMemberAccess: X,
      equalLiteralValue: Q,
      isSameReference: ue,
      isLogicalAssignmentOperator: Ye,
      getSwitchCaseColonToken: Ue,
      getModuleExportName: Ve,
      isConstant: ae,
      isTopLevelExpressionStatement: fe,
      isDirective: de,
      isStartOfExpressionStatement: ee,
      needsPrecedingSemicolon: te
    };
  }(pi)), pi.exports;
}
var di, Sm;
function XA() {
  if (Sm) return di;
  Sm = 1;
  const i = Re();
  function t(e, a) {
    if (e.length !== a.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      const p = e[n], m = a[n];
      if (p.type !== m.type || p.value !== m.value)
        return !1;
    }
    return !0;
  }
  function o(e, a) {
    return typeof e == "string" && typeof a == "string" ? e === a : Array.isArray(e) && Array.isArray(a) ? t(e, a) : !1;
  }
  function f(e) {
    return e.kind === "get" || e.kind === "set";
  }
  function r(e, a, n, p) {
    const m = e.parent;
    return m.type === "CallExpression" && i.isSpecificMemberAccess(m.callee, n, p) && m.arguments[a] === e;
  }
  function u(e) {
    if (r(e, 2, "Object", "defineProperty") || r(e, 2, "Reflect", "defineProperty"))
      return !0;
    const a = e.parent.parent;
    return a.type === "ObjectExpression" && (r(a, 1, "Object", "create") || r(a, 1, "Object", "defineProperties"));
  }
  return di = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce getter and setter pairs in objects and classes",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/accessor-pairs"
      },
      schema: [{
        type: "object",
        properties: {
          getWithoutSet: {
            type: "boolean",
            default: !1
          },
          setWithoutGet: {
            type: "boolean",
            default: !0
          },
          enforceForClassMembers: {
            type: "boolean",
            default: !0
          }
        },
        additionalProperties: !1
      }],
      messages: {
        missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
        missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
        missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
        missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
        missingGetterInClass: "Getter is not present for class {{ name }}.",
        missingSetterInClass: "Setter is not present for class {{ name }}."
      }
    },
    create(e) {
      const a = e.options[0] || {}, n = a.getWithoutSet === !0, p = a.setWithoutGet !== !1, m = a.enforceForClassMembers !== !1, h = e.sourceCode;
      function l(b, S) {
        b.type === "Property" ? e.report({
          node: b,
          messageId: `${S}InObjectLiteral`,
          loc: i.getFunctionHeadLoc(b.value, h),
          data: { name: i.getFunctionNameWithKind(b.value) }
        }) : b.type === "MethodDefinition" ? e.report({
          node: b,
          messageId: `${S}InClass`,
          loc: i.getFunctionHeadLoc(b.value, h),
          data: { name: i.getFunctionNameWithKind(b.value) }
        }) : e.report({
          node: b,
          messageId: `${S}InPropertyDescriptor`
        });
      }
      function s(b, S) {
        for (const C of b)
          l(C, S);
      }
      function c(b) {
        const S = [];
        let C = !1;
        for (let x = 0; x < b.length; x++) {
          const A = b[x];
          if (f(A)) {
            const R = i.getStaticPropertyName(A), L = R !== null ? R : h.getTokens(A.key);
            for (let _ = 0; _ < S.length; _++) {
              const I = S[_];
              if (o(I.key, L)) {
                I.getters.push(...A.kind === "get" ? [A] : []), I.setters.push(...A.kind === "set" ? [A] : []), C = !0;
                break;
              }
            }
            C || S.push({
              key: L,
              getters: A.kind === "get" ? [A] : [],
              setters: A.kind === "set" ? [A] : []
            }), C = !1;
          }
        }
        for (const { getters: x, setters: A } of S)
          p && A.length && !x.length && s(A, "missingGetter"), n && x.length && !A.length && s(x, "missingSetter");
      }
      function g(b) {
        c(b.properties.filter((S) => S.type === "Property"));
      }
      function d(b) {
        const S = new Set(b.properties.filter((A) => A.type === "Property" && A.kind === "init" && !A.computed).map(({ key: A }) => A.name)), C = S.has("get"), x = S.has("set");
        p && x && !C && l(b, "missingGetter"), n && C && !x && l(b, "missingSetter");
      }
      function y(b) {
        g(b), u(b) && d(b);
      }
      function v(b) {
        const S = b.body.filter((C) => C.type === "MethodDefinition");
        c(S.filter((C) => C.static)), c(S.filter((C) => !C.static));
      }
      const T = {};
      return (p || n) && (T.ObjectExpression = y, m && (T.ClassBody = v)), T;
    }
  }, di;
}
var Ei, Am;
function zA() {
  if (Am) return Ei;
  Am = 1;
  const i = Re();
  return Ei = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce linebreaks after opening and before closing array brackets",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/array-bracket-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consistent"]
            },
            {
              type: "object",
              properties: {
                multiline: {
                  type: "boolean"
                },
                minItems: {
                  type: ["integer", "null"],
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
        unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
        missingOpeningLinebreak: "A linebreak is required after '['.",
        missingClosingLinebreak: "A linebreak is required before ']'."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(m) {
        let h = !1, l = !1, s = 0;
        return m ? m === "consistent" ? (h = !0, s = Number.POSITIVE_INFINITY) : m === "always" || m.minItems === 0 ? s = 0 : m === "never" ? s = Number.POSITIVE_INFINITY : (l = !!m.multiline, s = m.minItems || Number.POSITIVE_INFINITY) : (h = !1, l = !0, s = Number.POSITIVE_INFINITY), { consistent: h, multiline: l, minItems: s };
      }
      function r(m) {
        const h = f(m);
        return { ArrayExpression: h, ArrayPattern: h };
      }
      function u(m, h) {
        t.report({
          node: m,
          loc: h.loc,
          messageId: "unexpectedOpeningLinebreak",
          fix(l) {
            const s = o.getTokenAfter(h, { includeComments: !0 });
            return i.isCommentToken(s) ? null : l.removeRange([h.range[1], s.range[0]]);
          }
        });
      }
      function e(m, h) {
        t.report({
          node: m,
          loc: h.loc,
          messageId: "unexpectedClosingLinebreak",
          fix(l) {
            const s = o.getTokenBefore(h, { includeComments: !0 });
            return i.isCommentToken(s) ? null : l.removeRange([s.range[1], h.range[0]]);
          }
        });
      }
      function a(m, h) {
        t.report({
          node: m,
          loc: h.loc,
          messageId: "missingOpeningLinebreak",
          fix(l) {
            return l.insertTextAfter(h, `
`);
          }
        });
      }
      function n(m, h) {
        t.report({
          node: m,
          loc: h.loc,
          messageId: "missingClosingLinebreak",
          fix(l) {
            return l.insertTextBefore(h, `
`);
          }
        });
      }
      function p(m) {
        const h = m.elements, s = r(t.options[0])[m.type], c = o.getFirstToken(m), g = o.getLastToken(m), d = o.getTokenAfter(c, { includeComments: !0 }), y = o.getTokenBefore(g, { includeComments: !0 }), v = o.getTokenAfter(c), T = o.getTokenBefore(g);
        h.length >= s.minItems || s.multiline && h.length > 0 && d.loc.start.line !== y.loc.end.line || h.length === 0 && d.type === "Block" && d.loc.start.line !== y.loc.end.line && d === y || s.consistent && c.loc.end.line !== v.loc.start.line ? (i.isTokenOnSameLine(c, v) && a(m, c), i.isTokenOnSameLine(T, g) && n(m, g)) : (i.isTokenOnSameLine(c, v) || u(m, c), i.isTokenOnSameLine(T, g) || e(m, g));
      }
      return {
        ArrayPattern: p,
        ArrayExpression: p
      };
    }
  }, Ei;
}
var yi, Tm;
function HA() {
  if (Tm) return yi;
  Tm = 1;
  const i = Re();
  return yi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside array brackets",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/array-bracket-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            singleValue: {
              type: "boolean"
            },
            objectsInArrays: {
              type: "boolean"
            },
            arraysInArrays: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'."
      }
    },
    create(t) {
      const o = t.options[0] === "always", f = t.sourceCode;
      function r(s) {
        return t.options[1] ? t.options[1][s] === !o : !1;
      }
      const u = {
        spaced: o,
        singleElementException: r("singleValue"),
        objectsInArraysException: r("objectsInArrays"),
        arraysInArraysException: r("arraysInArrays")
      };
      function e(s, c) {
        const g = f.getTokenAfter(c);
        t.report({
          node: s,
          loc: { start: c.loc.end, end: g.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: c.value
          },
          fix(d) {
            return d.removeRange([c.range[1], g.range[0]]);
          }
        });
      }
      function a(s, c) {
        const g = f.getTokenBefore(c);
        t.report({
          node: s,
          loc: { start: g.loc.end, end: c.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: c.value
          },
          fix(d) {
            return d.removeRange([g.range[1], c.range[0]]);
          }
        });
      }
      function n(s, c) {
        t.report({
          node: s,
          loc: c.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: c.value
          },
          fix(g) {
            return g.insertTextAfter(c, " ");
          }
        });
      }
      function p(s, c) {
        t.report({
          node: s,
          loc: c.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: c.value
          },
          fix(g) {
            return g.insertTextBefore(c, " ");
          }
        });
      }
      function m(s) {
        return s && (s.type === "ObjectExpression" || s.type === "ObjectPattern");
      }
      function h(s) {
        return s && (s.type === "ArrayExpression" || s.type === "ArrayPattern");
      }
      function l(s) {
        if (u.spaced && s.elements.length === 0)
          return;
        const c = f.getFirstToken(s), g = f.getFirstToken(s, 1), d = s.typeAnnotation ? f.getTokenBefore(s.typeAnnotation) : f.getLastToken(s), y = f.getTokenBefore(d), v = s.elements[0], T = s.elements[s.elements.length - 1], b = u.objectsInArraysException && m(v) || u.arraysInArraysException && h(v) || u.singleElementException && s.elements.length === 1 ? !u.spaced : u.spaced, S = u.objectsInArraysException && m(T) || u.arraysInArraysException && h(T) || u.singleElementException && s.elements.length === 1 ? !u.spaced : u.spaced;
        i.isTokenOnSameLine(c, g) && (b && !f.isSpaceBetweenTokens(c, g) && n(s, c), !b && f.isSpaceBetweenTokens(c, g) && e(s, c)), c !== y && i.isTokenOnSameLine(y, d) && (S && !f.isSpaceBetweenTokens(y, d) && p(s, d), !S && f.isSpaceBetweenTokens(y, d) && a(s, d));
      }
      return {
        ArrayPattern: l,
        ArrayExpression: l
      };
    }
  }, yi;
}
var Ci, bm;
function JA() {
  if (bm) return Ci;
  bm = 1;
  const i = Re(), t = /^(?:Arrow)?FunctionExpression$/u, o = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;
  function f(m) {
    return i.isSpecificMemberAccess(m, null, o);
  }
  function r(m) {
    for (const h of m)
      if (h.reachable)
        return !0;
    return !1;
  }
  function u(m) {
    return ["from", "of", "isArray"].includes(m) ? "Array.".concat(m) : "Array.prototype.".concat(m);
  }
  function e(m) {
    let h = m;
    for (; h; ) {
      const l = h.parent;
      switch (l.type) {
        case "LogicalExpression":
        case "ConditionalExpression":
        case "ChainExpression":
          h = l;
          break;
        case "ReturnStatement": {
          const s = i.getUpperFunction(l);
          if (s === null || !i.isCallee(s))
            return null;
          h = s.parent;
          break;
        }
        case "CallExpression":
          return i.isArrayFromMethod(l.callee) && l.arguments.length >= 2 && l.arguments[1] === h ? "from" : f(l.callee) && l.arguments.length >= 1 && l.arguments[0] === h ? i.getStaticPropertyName(l.callee) : null;
        default:
          return null;
      }
    }
    return null;
  }
  function a(m) {
    return m.type === "UnaryExpression" && m.operator === "void";
  }
  function n(m, h, l) {
    const s = (
      // prepending `void ` will fail if the node has a lower precedence than void
      i.getPrecedence(h) < i.getPrecedence({ type: "UnaryExpression", operator: "void" }) && // check if there are parentheses around the node to avoid redundant parentheses
      !i.isParenthesised(m, h)
    ), c = m.getTokenBefore(
      h,
      h.parent.type === "ArrowFunctionExpression" ? i.isArrowToken : (y) => y.type === "Keyword" && y.value === "return"
    ), g = m.getTokenAfter(c), d = (
      // is return token, as => allows void to be adjacent
      c.value === "return" && // If two tokens (return and "(") are adjacent
      c.range[1] === g.range[0]
    );
    return [
      l.insertTextBefore(g, `${d ? " " : ""}void ${s ? "(" : ""}`),
      l.insertTextAfter(h, s ? ")" : "")
    ];
  }
  function p(m, h, l) {
    const s = m.getTokenBefore(h.body, i.isArrowToken), c = m.getTokenAfter(s), g = m.getLastToken(h);
    return [
      l.insertTextBefore(c, "{"),
      l.insertTextAfter(g, "}")
    ];
  }
  return Ci = {
    meta: {
      type: "problem",
      docs: {
        description: "Enforce `return` statements in callbacks of array methods",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/array-callback-return"
      },
      // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- false positive
      hasSuggestions: !0,
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean",
              default: !1
            },
            checkForEach: {
              type: "boolean",
              default: !1
            },
            allowVoid: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
        expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}.",
        wrapBraces: "Wrap the expression in `{}`.",
        prependVoid: "Prepend `void` to the expression."
      }
    },
    create(m) {
      const h = m.options[0] || { allowImplicit: !1, checkForEach: !1, allowVoid: !1 }, l = m.sourceCode;
      let s = {
        arrayMethodName: null,
        upper: null,
        codePath: null,
        hasReturn: !1,
        shouldCheck: !1,
        node: null
      };
      function c(g) {
        if (!s.shouldCheck)
          return;
        const d = { messageId: "", suggest: [] };
        if (s.arrayMethodName === "forEach") {
          if (h.checkForEach && g.type === "ArrowFunctionExpression" && g.expression)
            if (h.allowVoid) {
              if (a(g.body))
                return;
              d.messageId = "expectedNoReturnValue", d.suggest = [
                {
                  messageId: "wrapBraces",
                  fix(y) {
                    return p(l, g, y);
                  }
                },
                {
                  messageId: "prependVoid",
                  fix(y) {
                    return n(l, g.body, y);
                  }
                }
              ];
            } else
              d.messageId = "expectedNoReturnValue", d.suggest = [{
                messageId: "wrapBraces",
                fix(y) {
                  return p(l, g, y);
                }
              }];
        } else
          g.body.type === "BlockStatement" && r(s.currentSegments) && (d.messageId = s.hasReturn ? "expectedAtEnd" : "expectedInside");
        if (d.messageId) {
          const y = i.getFunctionNameWithKind(g);
          m.report({
            node: g,
            loc: i.getFunctionHeadLoc(g, l),
            messageId: d.messageId,
            data: { name: y, arrayMethodName: u(s.arrayMethodName) },
            suggest: d.suggest.length !== 0 ? d.suggest : null
          });
        }
      }
      return {
        // Stacks this function's information.
        onCodePathStart(g, d) {
          let y = null;
          t.test(d.type) && (y = e(d)), s = {
            arrayMethodName: y,
            upper: s,
            codePath: g,
            hasReturn: !1,
            shouldCheck: y && !d.async && !d.generator,
            node: d,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Pops this function's information.
        onCodePathEnd() {
          s = s.upper;
        },
        onUnreachableCodePathSegmentStart(g) {
          s.currentSegments.add(g);
        },
        onUnreachableCodePathSegmentEnd(g) {
          s.currentSegments.delete(g);
        },
        onCodePathSegmentStart(g) {
          s.currentSegments.add(g);
        },
        onCodePathSegmentEnd(g) {
          s.currentSegments.delete(g);
        },
        // Checks the return statement is valid.
        ReturnStatement(g) {
          if (!s.shouldCheck)
            return;
          s.hasReturn = !0;
          const d = { messageId: "", suggest: [] };
          if (s.arrayMethodName === "forEach") {
            if (h.checkForEach && g.argument)
              if (h.allowVoid) {
                if (a(g.argument))
                  return;
                d.messageId = "expectedNoReturnValue", d.suggest = [{
                  messageId: "prependVoid",
                  fix(y) {
                    return n(l, g.argument, y);
                  }
                }];
              } else
                d.messageId = "expectedNoReturnValue";
          } else
            !h.allowImplicit && !g.argument && (d.messageId = "expectedReturnValue");
          d.messageId && m.report({
            node: g,
            messageId: d.messageId,
            data: {
              name: i.getFunctionNameWithKind(s.node),
              arrayMethodName: u(s.arrayMethodName)
            },
            suggest: d.suggest.length !== 0 ? d.suggest : null
          });
        },
        // Reports a given function if the last path is reachable.
        "FunctionExpression:exit": c,
        "ArrowFunctionExpression:exit": c
      };
    }
  }, Ci;
}
var vi, xm;
function QA() {
  if (xm) return vi;
  xm = 1;
  const i = Re();
  return vi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce line breaks after each array element",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/array-element-newline"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          basicConfig: {
            oneOf: [
              {
                enum: ["always", "never", "consistent"]
              },
              {
                type: "object",
                properties: {
                  multiline: {
                    type: "boolean"
                  },
                  minItems: {
                    type: ["integer", "null"],
                    minimum: 0
                  }
                },
                additionalProperties: !1
              }
            ]
          }
        },
        type: "array",
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/basicConfig"
              },
              {
                type: "object",
                properties: {
                  ArrayExpression: {
                    $ref: "#/definitions/basicConfig"
                  },
                  ArrayPattern: {
                    $ref: "#/definitions/basicConfig"
                  }
                },
                additionalProperties: !1,
                minProperties: 1
              }
            ]
          }
        ]
      },
      messages: {
        unexpectedLineBreak: "There should be no linebreak here.",
        missingLineBreak: "There should be a linebreak after this element."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(n) {
        let p = !1, m = !1, h;
        const l = n || "always";
        return l === "always" || l.minItems === 0 ? h = 0 : l === "never" ? h = Number.POSITIVE_INFINITY : l === "consistent" ? (p = !0, h = Number.POSITIVE_INFINITY) : (m = !!l.multiline, h = l.minItems || Number.POSITIVE_INFINITY), { consistent: p, multiline: m, minItems: h };
      }
      function r(n) {
        if (n && (n.ArrayExpression || n.ArrayPattern)) {
          let m, h;
          return n.ArrayExpression && (m = f(n.ArrayExpression)), n.ArrayPattern && (h = f(n.ArrayPattern)), { ArrayExpression: m, ArrayPattern: h };
        }
        const p = f(n);
        return { ArrayExpression: p, ArrayPattern: p };
      }
      function u(n) {
        const p = o.getTokenBefore(n, { includeComments: !0 });
        t.report({
          loc: {
            start: p.loc.end,
            end: n.loc.start
          },
          messageId: "unexpectedLineBreak",
          fix(m) {
            if (i.isCommentToken(p))
              return null;
            if (!i.isTokenOnSameLine(p, n))
              return m.replaceTextRange([p.range[1], n.range[0]], " ");
            const h = o.getTokenBefore(p, { includeComments: !0 });
            return i.isCommentToken(h) ? null : m.replaceTextRange([h.range[1], p.range[0]], "");
          }
        });
      }
      function e(n) {
        const p = o.getTokenBefore(n, { includeComments: !0 });
        t.report({
          loc: {
            start: p.loc.end,
            end: n.loc.start
          },
          messageId: "missingLineBreak",
          fix(m) {
            return m.replaceTextRange([p.range[1], n.range[0]], `
`);
          }
        });
      }
      function a(n) {
        const p = n.elements, h = r(t.options[0])[n.type];
        if (!h)
          return;
        let l = !1;
        h.multiline && (l = p.filter((g) => g !== null).some((g) => g.loc.start.line !== g.loc.end.line));
        let s = 0;
        for (let g = 0; g < n.elements.length; g++) {
          const d = n.elements[g], y = p[g - 1];
          if (g === 0 || d === null || y === null)
            continue;
          const v = o.getFirstTokenBetween(y, d, i.isCommaToken), T = o.getTokenBefore(v), b = o.getTokenAfter(v);
          i.isTokenOnSameLine(T, b) || s++;
        }
        const c = p.length >= h.minItems || h.multiline && l || h.consistent && s > 0 && s < n.elements.length;
        p.forEach((g, d) => {
          const y = p[d - 1];
          if (d === 0 || g === null || y === null)
            return;
          const v = o.getFirstTokenBetween(y, g, i.isCommaToken), T = o.getTokenBefore(v), b = o.getTokenAfter(v);
          c ? i.isTokenOnSameLine(T, b) && e(b) : i.isTokenOnSameLine(T, b) || u(b);
        });
      }
      return {
        ArrayPattern: a,
        ArrayExpression: a
      };
    }
  }, vi;
}
var Si, Rm;
function YA() {
  if (Rm) return Si;
  Rm = 1;
  const i = Re();
  return Si = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require braces around arrow function bodies",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/arrow-body-style"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["as-needed"]
              },
              {
                type: "object",
                properties: {
                  requireReturnForObjectLiteral: { type: "boolean" }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
        unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
        unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
        unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
        expectedBlock: "Expected block statement surrounding arrow body."
      }
    },
    create(t) {
      const o = t.options, f = o[0] === "always", r = !o[0] || o[0] === "as-needed", u = o[0] === "never", e = o[1] && o[1].requireReturnForObjectLiteral, a = t.sourceCode;
      let n = null;
      function p(s) {
        return s && s.type === "Punctuator" && /^[([/`+-]/u.test(s.value);
      }
      function m(s) {
        let c = s;
        for (; !i.isParenthesised(a, c); )
          c = c.parent;
        return a.getTokenAfter(c);
      }
      function h(s) {
        return s && s.parent ? s.parent.type === "ForStatement" && s.parent.init === s ? !0 : h(s.parent) : !1;
      }
      function l(s) {
        const c = s.body;
        if (c.type === "BlockStatement") {
          const g = c.body;
          if (g.length !== 1 && !u || r && e && g[0].type === "ReturnStatement" && g[0].argument && g[0].argument.type === "ObjectExpression")
            return;
          if (u || r && g[0].type === "ReturnStatement") {
            let d;
            g.length === 0 ? d = "unexpectedEmptyBlock" : g.length > 1 ? d = "unexpectedOtherBlock" : g[0].argument === null ? d = "unexpectedSingleBlock" : i.isOpeningBraceToken(a.getFirstToken(g[0], { skip: 1 })) ? d = "unexpectedObjectBlock" : d = "unexpectedSingleBlock", t.report({
              node: s,
              loc: c.loc,
              messageId: d,
              fix(y) {
                const v = [];
                if (g.length !== 1 || g[0].type !== "ReturnStatement" || !g[0].argument || p(a.getTokenAfter(c)))
                  return v;
                const T = a.getFirstToken(c), b = a.getLastToken(c), S = a.getFirstToken(g[0], 1), C = a.getLastToken(g[0]);
                return a.commentsExistBetween(T, S) || a.commentsExistBetween(C, b) ? v.push(
                  y.remove(T),
                  y.remove(b),
                  y.remove(a.getTokenAfter(T))
                  // return keyword
                ) : v.push(
                  y.removeRange([T.range[0], S.range[0]]),
                  y.removeRange([C.range[1], b.range[1]])
                ), (i.isOpeningBraceToken(S) || g[0].argument.type === "SequenceExpression" || n.hasInOperator && h(s)) && (i.isParenthesised(a, g[0].argument) || v.push(
                  y.insertTextBefore(S, "("),
                  y.insertTextAfter(C, ")")
                )), i.isSemicolonToken(C) && v.push(y.remove(C)), v;
              }
            });
          }
        } else
          (f || r && e && c.type === "ObjectExpression") && t.report({
            node: s,
            loc: c.loc,
            messageId: "expectedBlock",
            fix(g) {
              const d = [], y = a.getTokenBefore(c, i.isArrowToken), [v, T] = a.getTokensAfter(y, { count: 2 }), b = a.getLastToken(s);
              let S = null;
              if (i.isOpeningParenToken(v) && i.isOpeningBraceToken(T)) {
                const C = a.getNodeByRangeIndex(T.range[0]);
                C.type === "ObjectExpression" && (S = C);
              }
              if (S) {
                const C = v, x = T;
                i.isTokenOnSameLine(C, x) ? d.push(g.replaceText(C, "{return ")) : d.push(
                  g.replaceText(C, "{"),
                  g.insertTextBefore(x, "return ")
                ), d.push(g.remove(m(S))), d.push(g.insertTextAfter(b, "}"));
              } else
                d.push(g.insertTextBefore(v, "{return ")), d.push(g.insertTextAfter(b, "}"));
              return d;
            }
          });
      }
      return {
        "BinaryExpression[operator='in']"() {
          let s = n;
          for (; s; )
            s.hasInOperator = !0, s = s.upper;
        },
        ArrowFunctionExpression() {
          n = {
            upper: n,
            hasInOperator: !1
          };
        },
        "ArrowFunctionExpression:exit"(s) {
          l(s), n = n.upper;
        }
      };
    }
  }, Si;
}
var Ai, Dm;
function ZA() {
  if (Dm) return Ai;
  Dm = 1;
  const i = Re();
  function t(o) {
    return o.body.type === "BlockStatement";
  }
  return Ai = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require parentheses around arrow function arguments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/arrow-parens"
      },
      fixable: "code",
      schema: [
        {
          enum: ["always", "as-needed"]
        },
        {
          type: "object",
          properties: {
            requireForBlockBody: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedParens: "Unexpected parentheses around single function argument.",
        expectedParens: "Expected parentheses around arrow function argument.",
        unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
        expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
      }
    },
    create(o) {
      const f = o.options[0] === "as-needed", r = f && o.options[1] && o.options[1].requireForBlockBody === !0, u = o.sourceCode;
      function e(m) {
        const h = u.getTokenBefore(m.params[0]);
        return h && i.isOpeningParenToken(h) && m.range[0] <= h.range[0] ? h : null;
      }
      function a(m) {
        return u.getTokenAfter(m.params[0], i.isClosingParenToken);
      }
      function n(m, h) {
        return u.commentsExistBetween(h, a(m));
      }
      function p(m, h) {
        const l = m.async ? 1 : 0;
        return u.getFirstToken(m, { skip: l }) !== h;
      }
      return {
        "ArrowFunctionExpression[params.length=1]"(m) {
          const h = !f || r && t(m), l = e(m), s = l !== null, [c] = m.params;
          h && !s && o.report({
            node: m,
            messageId: r ? "expectedParensBlock" : "expectedParens",
            loc: c.loc,
            *fix(g) {
              yield g.insertTextBefore(c, "("), yield g.insertTextAfter(c, ")");
            }
          }), !h && s && c.type === "Identifier" && !c.typeAnnotation && !m.returnType && !n(m, l) && !p(m, l) && o.report({
            node: m,
            messageId: r ? "unexpectedParensInline" : "unexpectedParens",
            loc: c.loc,
            *fix(g) {
              const d = u.getTokenBefore(l), y = a(m);
              d && d.range[1] === l.range[0] && !i.canTokensBeAdjacent(d, u.getFirstToken(c)) && (yield g.insertTextBefore(l, " ")), yield g.removeRange([l.range[0], c.range[0]]), yield g.removeRange([c.range[1], y.range[1]]);
            }
          });
        }
      };
    }
  }, Ai;
}
var Ti, Lm;
function eT() {
  if (Lm) return Ti;
  Lm = 1;
  const i = Re();
  return Ti = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after the arrow in arrow functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/arrow-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: !0
            },
            after: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expectedBefore: "Missing space before =>.",
        unexpectedBefore: "Unexpected space before =>.",
        expectedAfter: "Missing space after =>.",
        unexpectedAfter: "Unexpected space after =>."
      }
    },
    create(t) {
      const o = Object.assign({}, t.options[0]);
      o.before = o.before !== !1, o.after = o.after !== !1;
      const f = t.sourceCode;
      function r(a) {
        const n = f.getTokenBefore(a.body, i.isArrowToken);
        return {
          before: f.getTokenBefore(n),
          arrow: n,
          after: f.getTokenAfter(n)
        };
      }
      function u(a) {
        const n = a.arrow.range[0] - a.before.range[1], p = a.after.range[0] - a.arrow.range[1];
        return { before: n, after: p };
      }
      function e(a) {
        const n = r(a), p = u(n);
        o.before ? p.before === 0 && t.report({
          node: n.before,
          messageId: "expectedBefore",
          fix(m) {
            return m.insertTextBefore(n.arrow, " ");
          }
        }) : p.before > 0 && t.report({
          node: n.before,
          messageId: "unexpectedBefore",
          fix(m) {
            return m.removeRange([n.before.range[1], n.arrow.range[0]]);
          }
        }), o.after ? p.after === 0 && t.report({
          node: n.after,
          messageId: "expectedAfter",
          fix(m) {
            return m.insertTextAfter(n.arrow, " ");
          }
        }) : p.after > 0 && t.report({
          node: n.after,
          messageId: "unexpectedAfter",
          fix(m) {
            return m.removeRange([n.arrow.range[1], n.after.range[0]]);
          }
        });
      }
      return {
        ArrowFunctionExpression: e
      };
    }
  }, Ti;
}
var bi, _m;
function tT() {
  return _m || (_m = 1, bi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce the use of variables within the scope they are defined",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/block-scoped-var"
      },
      schema: [],
      messages: {
        outOfScope: "'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context."
      }
    },
    create(i) {
      let t = [];
      const o = i.sourceCode;
      function f(a) {
        t.push(a.range);
      }
      function r() {
        t.pop();
      }
      function u(a, n) {
        const p = a.identifier, m = n.name.loc.start;
        i.report({
          node: p,
          messageId: "outOfScope",
          data: {
            name: p.name,
            definitionLine: m.line,
            definitionColumn: m.column + 1
          }
        });
      }
      function e(a) {
        if (a.kind !== "var")
          return;
        const n = t[t.length - 1];
        function p(h) {
          const l = h.identifier.range;
          return l[0] < n[0] || l[1] > n[1];
        }
        const m = o.getDeclaredVariables(a);
        for (let h = 0; h < m.length; ++h)
          m[h].references.filter(p).forEach((l) => u(l, m[h].defs.find((s) => s.parent === a)));
      }
      return {
        Program(a) {
          t = [a.range];
        },
        // Manages scopes.
        BlockStatement: f,
        "BlockStatement:exit": r,
        ForStatement: f,
        "ForStatement:exit": r,
        ForInStatement: f,
        "ForInStatement:exit": r,
        ForOfStatement: f,
        "ForOfStatement:exit": r,
        SwitchStatement: f,
        "SwitchStatement:exit": r,
        CatchClause: f,
        "CatchClause:exit": r,
        StaticBlock: f,
        "StaticBlock:exit": r,
        // Finds and reports references which are outside of valid scope.
        VariableDeclaration: e
      };
    }
  }), bi;
}
var xi, wm;
function rT() {
  if (wm) return xi;
  wm = 1;
  const i = Re();
  return xi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow or enforce spaces inside of blocks after opening block and before closing block",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/block-spacing"
      },
      fixable: "whitespace",
      schema: [
        { enum: ["always", "never"] }
      ],
      messages: {
        missing: "Requires a space {{location}} '{{token}}'.",
        extra: "Unexpected space(s) {{location}} '{{token}}'."
      }
    },
    create(t) {
      const o = t.options[0] !== "never", f = o ? "missing" : "extra", r = t.sourceCode;
      function u(n) {
        return n.type === "SwitchStatement" ? n.cases.length > 0 ? r.getTokenBefore(n.cases[0]) : r.getLastToken(n, 1) : n.type === "StaticBlock" ? r.getFirstToken(n, { skip: 1 }) : r.getFirstToken(n);
      }
      function e(n, p) {
        return !i.isTokenOnSameLine(n, p) || r.isSpaceBetweenTokens(n, p) === o;
      }
      function a(n) {
        const p = u(n), m = r.getLastToken(n), h = r.getTokenAfter(p, { includeComments: !0 }), l = r.getTokenBefore(m, { includeComments: !0 });
        if (!(p.type !== "Punctuator" || p.value !== "{" || m.type !== "Punctuator" || m.value !== "}" || h === m) && !(!o && h.type === "Line")) {
          if (!e(p, h)) {
            let s = p.loc;
            f === "extra" && (s = {
              start: p.loc.end,
              end: h.loc.start
            }), t.report({
              node: n,
              loc: s,
              messageId: f,
              data: {
                location: "after",
                token: p.value
              },
              fix(c) {
                return o ? c.insertTextBefore(h, " ") : c.removeRange([p.range[1], h.range[0]]);
              }
            });
          }
          if (!e(l, m)) {
            let s = m.loc;
            f === "extra" && (s = {
              start: l.loc.end,
              end: m.loc.start
            }), t.report({
              node: n,
              loc: s,
              messageId: f,
              data: {
                location: "before",
                token: m.value
              },
              fix(c) {
                return o ? c.insertTextAfter(l, " ") : c.removeRange([l.range[1], m.range[0]]);
              }
            });
          }
        }
      }
      return {
        BlockStatement: a,
        StaticBlock: a,
        SwitchStatement: a
      };
    }
  }, xi;
}
var Ri, km;
function nT() {
  if (km) return Ri;
  km = 1;
  const i = Re();
  return Ri = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent brace style for blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/brace-style"
      },
      schema: [
        {
          enum: ["1tbs", "stroustrup", "allman"]
        },
        {
          type: "object",
          properties: {
            allowSingleLine: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "whitespace",
      messages: {
        nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
        sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
        blockSameLine: "Statement inside of curly braces should be on next line.",
        nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
        singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
        sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
      }
    },
    create(t) {
      const o = t.options[0] || "1tbs", f = t.options[1] || {}, r = t.sourceCode;
      function u(n, p) {
        const m = [n.range[1], p.range[0]];
        return r.text.slice(m[0], m[1]).trim() ? null : (l) => l.replaceTextRange(m, " ");
      }
      function e(n, p) {
        const m = r.getTokenBefore(n), h = r.getTokenAfter(n), l = r.getTokenBefore(p), s = f.allowSingleLine && i.isTokenOnSameLine(n, p);
        o !== "allman" && !i.isTokenOnSameLine(m, n) && t.report({
          node: n,
          messageId: "nextLineOpen",
          fix: u(m, n)
        }), o === "allman" && i.isTokenOnSameLine(m, n) && !s && t.report({
          node: n,
          messageId: "sameLineOpen",
          fix: (c) => c.insertTextBefore(n, `
`)
        }), i.isTokenOnSameLine(n, h) && h !== p && !s && t.report({
          node: n,
          messageId: "blockSameLine",
          fix: (c) => c.insertTextAfter(n, `
`)
        }), l !== n && !s && i.isTokenOnSameLine(l, p) && t.report({
          node: p,
          messageId: "singleLineClose",
          fix: (c) => c.insertTextBefore(p, `
`)
        });
      }
      function a(n) {
        const p = r.getTokenAfter(n);
        o === "1tbs" && !i.isTokenOnSameLine(n, p) && t.report({
          node: n,
          messageId: "nextLineClose",
          fix: u(n, p)
        }), o !== "1tbs" && i.isTokenOnSameLine(n, p) && t.report({
          node: n,
          messageId: "sameLineClose",
          fix: (m) => m.insertTextAfter(n, `
`)
        });
      }
      return {
        BlockStatement(n) {
          i.STATEMENT_LIST_PARENTS.has(n.parent.type) || e(r.getFirstToken(n), r.getLastToken(n));
        },
        StaticBlock(n) {
          e(
            r.getFirstToken(n, { skip: 1 }),
            // skip the `static` token
            r.getLastToken(n)
          );
        },
        ClassBody(n) {
          e(r.getFirstToken(n), r.getLastToken(n));
        },
        SwitchStatement(n) {
          const p = r.getLastToken(n), m = r.getTokenBefore(n.cases.length ? n.cases[0] : p);
          e(m, p);
        },
        IfStatement(n) {
          n.consequent.type === "BlockStatement" && n.alternate && a(r.getLastToken(n.consequent));
        },
        TryStatement(n) {
          a(r.getLastToken(n.block)), n.handler && n.finalizer && a(r.getLastToken(n.handler.body));
        }
      };
    }
  }, Ri;
}
var Di, Bm;
function sT() {
  return Bm || (Bm = 1, Di = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Require `return` statements after callbacks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/callback-return"
      },
      schema: [{
        type: "array",
        items: { type: "string" }
      }],
      messages: {
        missingReturn: "Expected return with your callback function."
      }
    },
    create(i) {
      const t = i.options[0] || ["callback", "cb", "next"], o = i.sourceCode;
      function f(a, n) {
        return a.parent ? n.includes(a.parent.type) ? a.parent : f(a.parent, n) : null;
      }
      function r(a) {
        if (a.type === "Identifier")
          return !0;
        if (a.type === "MemberExpression") {
          if (a.object.type === "Identifier")
            return !0;
          if (a.object.type === "MemberExpression")
            return r(a.object);
        }
        return !1;
      }
      function u(a) {
        return r(a.callee) && t.includes(o.getText(a.callee));
      }
      function e(a, n) {
        return !n || n.type !== "ExpressionStatement" ? !1 : n.expression === a || (n.expression.type === "BinaryExpression" || n.expression.type === "LogicalExpression") && n.expression.right === a;
      }
      return {
        CallExpression(a) {
          if (!u(a))
            return;
          const n = f(a, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
          if (n.type !== "ReturnStatement" && n.type !== "ArrowFunctionExpression") {
            if (n.type === "BlockStatement") {
              const p = n.body[n.body.length - 1];
              if (e(a, p)) {
                const m = n.parent.type;
                if (m === "FunctionExpression" || m === "FunctionDeclaration" || m === "ArrowFunctionExpression")
                  return;
              }
              if (p.type === "ReturnStatement" && e(a, n.body[n.body.length - 2]))
                return;
            }
            f(a, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]) && i.report({ node: a, messageId: "missingReturn" });
          }
        }
      };
    }
  }), Di;
}
var Li, Pm;
function iT() {
  if (Pm) return Li;
  Pm = 1;
  const i = Re();
  return Li = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce camelcase naming convention",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/camelcase"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: {
              type: "boolean",
              default: !1
            },
            ignoreImports: {
              type: "boolean",
              default: !1
            },
            ignoreGlobals: {
              type: "boolean",
              default: !1
            },
            properties: {
              enum: ["always", "never"]
            },
            allow: {
              type: "array",
              items: [
                {
                  type: "string"
                }
              ],
              minItems: 0,
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        notCamelCase: "Identifier '{{name}}' is not in camel case.",
        notCamelCasePrivate: "#{{name}} is not in camel case."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.properties === "never" ? "never" : "always", r = o.ignoreDestructuring, u = o.ignoreImports, e = o.ignoreGlobals, a = o.allow || [], n = t.sourceCode, p = /* @__PURE__ */ new Set();
      function m(y) {
        const v = y.replace(/^_+|_+$/gu, "");
        return v.includes("_") && v !== v.toUpperCase();
      }
      function h(y) {
        return a.some(
          (v) => y === v || y.match(new RegExp(v, "u"))
        );
      }
      function l(y) {
        return !m(y) || h(y);
      }
      function s(y) {
        const v = y.parent;
        switch (v.type) {
          case "AssignmentExpression":
          case "AssignmentPattern":
            return v.left === y;
          case "Property":
            return v.parent.type === "ObjectPattern" && v.value === y;
          case "ArrayPattern":
          case "RestElement":
            return !0;
          default:
            return !1;
        }
      }
      function c(y) {
        const v = y.name, T = y.parent.type === "AssignmentPattern" ? y.parent : y, b = T.parent;
        switch (b.type) {
          case "Property":
            return (b.parent.type === "ObjectPattern" || b.parent.type === "ObjectExpression") && b.value === T && !b.computed && b.key.type === "Identifier" && b.key.name === v;
          case "ImportSpecifier":
            return b.local === y && i.getModuleExportName(b.imported) === v;
          default:
            return !1;
        }
      }
      function g(y) {
        p.has(y.range[0]) || (p.add(y.range[0]), t.report({
          node: y,
          messageId: y.type === "PrivateIdentifier" ? "notCamelCasePrivate" : "notCamelCase",
          data: { name: y.name }
        }));
      }
      function d(y) {
        y.parent.type === "CallExpression" || y.parent.type === "NewExpression" || y.parent.type === "AssignmentPattern" && y.parent.right === y || r && c(y) || g(y);
      }
      return {
        // Report camelcase of global variable references ------------------
        Program(y) {
          const v = n.getScope(y);
          if (!e) {
            for (const T of v.variables)
              if (!(T.identifiers.length > 0 || l(T.name)))
                for (const b of T.references)
                  d(b.identifier);
          }
          for (const T of v.through) {
            const b = T.identifier;
            l(b.name) || d(b);
          }
        },
        // Report camelcase of declared variables --------------------------
        [[
          "VariableDeclaration",
          "FunctionDeclaration",
          "FunctionExpression",
          "ArrowFunctionExpression",
          "ClassDeclaration",
          "ClassExpression",
          "CatchClause"
        ]](y) {
          for (const v of n.getDeclaredVariables(y)) {
            if (l(v.name))
              continue;
            const T = v.identifiers[0];
            r && c(T) || g(T);
            for (const b of v.references)
              b.init || d(b.identifier);
          }
        },
        // Report camelcase in properties ----------------------------------
        [[
          "ObjectExpression > Property[computed!=true] > Identifier.key",
          "MethodDefinition[computed!=true] > Identifier.key",
          "PropertyDefinition[computed!=true] > Identifier.key",
          "MethodDefinition > PrivateIdentifier.key",
          "PropertyDefinition > PrivateIdentifier.key"
        ]](y) {
          f === "never" || l(y.name) || g(y);
        },
        "MemberExpression[computed!=true] > Identifier.property"(y) {
          f === "never" || !s(y.parent) || // ← ignore read-only references.
          l(y.name) || g(y);
        },
        // Report camelcase in import --------------------------------------
        ImportDeclaration(y) {
          for (const v of n.getDeclaredVariables(y)) {
            if (l(v.name))
              continue;
            const T = v.identifiers[0];
            u && c(T) || g(T);
            for (const b of v.references)
              d(b.identifier);
          }
        },
        // Report camelcase in re-export -----------------------------------
        [[
          "ExportAllDeclaration > Identifier.exported",
          "ExportSpecifier > Identifier.exported"
        ]](y) {
          l(y.name) || g(y);
        },
        // Report camelcase in labels --------------------------------------
        [[
          "LabeledStatement > Identifier.label",
          /*
           * For backward compatibility, report references as well.
           * It looks unnecessary because declarations are reported.
           */
          "BreakStatement > Identifier.label",
          "ContinueStatement > Identifier.label"
        ]](y) {
          l(y.name) || g(y);
        }
      };
    }
  }, Li;
}
/**
 * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
 * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
 * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
 * @author Kevin Partington
 * @license MIT License (from JSCS). See below.
 */
var _i, Im;
function aT() {
  return Im || (Im = 1, _i = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u), _i;
}
var wi, Fm;
function oT() {
  if (Fm) return wi;
  Fm = 1;
  const i = aT(), o = Re().COMMENTS_IGNORE_PATTERN, f = /\s/gu, r = /^\s*[^:/?#\s]+:\/\/[^?#]/u, u = {
    type: "object",
    properties: {
      ignorePattern: {
        type: "string"
      },
      ignoreInlineComments: {
        type: "boolean"
      },
      ignoreConsecutiveComments: {
        type: "boolean"
      }
    },
    additionalProperties: !1
  }, e = {
    ignorePattern: "",
    ignoreInlineComments: !1,
    ignoreConsecutiveComments: !1
  };
  function a(m, h) {
    return Object.assign({}, e, m[h] || m);
  }
  function n(m = {}) {
    return {
      Line: a(m, "line"),
      Block: a(m, "block")
    };
  }
  function p(m) {
    Object.keys(m).forEach((h) => {
      const l = m[h].ignorePattern;
      if (l) {
        const s = RegExp(`^\\s*(?:${l})`, "u");
        m[h].ignorePatternRegExp = s;
      }
    });
  }
  return wi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce or disallow capitalization of the first letter of a comment",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/capitalized-comments"
      },
      fixable: "code",
      schema: [
        { enum: ["always", "never"] },
        {
          oneOf: [
            u,
            {
              type: "object",
              properties: {
                line: u,
                block: u
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
        unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
      }
    },
    create(m) {
      const h = m.options[0] || "always", l = n(m.options[1]), s = m.sourceCode;
      p(l);
      function c(v) {
        const T = s.getTokenBefore(v, { includeComments: !0 }), b = s.getTokenAfter(v, { includeComments: !0 });
        return !!(T && b && v.loc.start.line === T.loc.end.line && v.loc.end.line === b.loc.start.line);
      }
      function g(v) {
        const T = s.getTokenBefore(v, { includeComments: !0 });
        return !!(T && ["Block", "Line"].includes(T.type));
      }
      function d(v, T) {
        if (o.test(v.value))
          return !0;
        const b = v.value.replace(/\*/gu, "");
        if (T.ignorePatternRegExp && T.ignorePatternRegExp.test(b) || T.ignoreInlineComments && c(v) || T.ignoreConsecutiveComments && g(v) || r.test(b))
          return !0;
        const S = b.replace(f, "");
        if (S.length === 0)
          return !0;
        const C = S[0];
        if (!i.test(C))
          return !0;
        const x = C !== C.toLocaleLowerCase(), A = C !== C.toLocaleUpperCase();
        return !(h === "always" && A || h === "never" && x);
      }
      function y(v) {
        const T = l[v.type];
        if (!d(v, T)) {
          const S = h === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
          m.report({
            node: null,
            // Intentionally using loc instead
            loc: v.loc,
            messageId: S,
            fix(C) {
              const x = v.value.match(i);
              return C.replaceTextRange(
                // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)
                [v.range[0] + x.index + 2, v.range[0] + x.index + 3],
                h === "always" ? x[0].toLocaleUpperCase() : x[0].toLocaleLowerCase()
              );
            }
          });
        }
      }
      return {
        Program() {
          s.getAllComments().filter((T) => T.type !== "Shebang").forEach(y);
        }
      };
    }
  }, wi;
}
var ki, Nm;
function lT() {
  if (Nm) return ki;
  Nm = 1;
  const i = Re();
  return ki = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce that class methods utilize `this`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/class-methods-use-this"
      },
      schema: [{
        type: "object",
        properties: {
          exceptMethods: {
            type: "array",
            items: {
              type: "string"
            }
          },
          enforceForClassFields: {
            type: "boolean",
            default: !0
          }
        },
        additionalProperties: !1
      }],
      messages: {
        missingThis: "Expected 'this' to be used by class {{name}}."
      }
    },
    create(t) {
      const o = Object.assign({}, t.options[0]), f = o.enforceForClassFields !== !1, r = new Set(o.exceptMethods || []), u = [];
      function e() {
        u.push(!1);
      }
      function a() {
        return u.pop();
      }
      function n() {
        e();
      }
      function p(s) {
        switch (s.type) {
          case "MethodDefinition":
            return !s.static && s.kind !== "constructor";
          case "PropertyDefinition":
            return !s.static && f;
          default:
            return !1;
        }
      }
      function m(s) {
        if (p(s)) {
          if (s.computed)
            return !0;
          const c = s.key.type === "PrivateIdentifier" ? "#" : "", g = s.key.type === "Literal" ? i.getStaticStringValue(s.key) : s.key.name || "";
          return !r.has(c + g);
        }
        return !1;
      }
      function h(s) {
        const c = a();
        m(s.parent) && !c && t.report({
          node: s,
          loc: i.getFunctionHeadLoc(s, t.sourceCode),
          messageId: "missingThis",
          data: {
            name: i.getFunctionNameWithKind(s)
          }
        });
      }
      function l() {
        u.length && (u[u.length - 1] = !0);
      }
      return {
        FunctionDeclaration: n,
        "FunctionDeclaration:exit": h,
        FunctionExpression: n,
        "FunctionExpression:exit": h,
        /*
         * Class field value are implicit functions.
         */
        "PropertyDefinition > *.key:exit": e,
        "PropertyDefinition:exit": a,
        /*
         * Class static blocks are implicit functions. They aren't required to use `this`,
         * but we have to push context so that it captures any use of `this` in the static block
         * separately from enclosing contexts, because static blocks have their own `this` and it
         * shouldn't count as used `this` in enclosing contexts.
         */
        StaticBlock: e,
        "StaticBlock:exit": a,
        ThisExpression: l,
        Super: l,
        ...f && {
          "PropertyDefinition > ArrowFunctionExpression.value": n,
          "PropertyDefinition > ArrowFunctionExpression.value:exit": h
        }
      };
    }
  }, ki;
}
var Bi, Om;
function uT() {
  if (Om) return Bi;
  Om = 1;
  const i = Re(), t = Object.freeze({
    arrays: "never",
    objects: "never",
    imports: "never",
    exports: "never",
    functions: "never"
  });
  function o(r) {
    return !(r.type === "RestElement" || r.type === "RestProperty" || r.type === "ExperimentalRestProperty");
  }
  function f(r, u) {
    return typeof r == "string" ? {
      arrays: r,
      objects: r,
      imports: r,
      exports: r,
      functions: u < 2017 ? "ignore" : r
    } : typeof r == "object" && r !== null ? {
      arrays: r.arrays || t.arrays,
      objects: r.objects || t.objects,
      imports: r.imports || t.imports,
      exports: r.exports || t.exports,
      functions: r.functions || t.functions
    } : t;
  }
  return Bi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow trailing commas",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/comma-dangle"
      },
      fixable: "code",
      schema: {
        definitions: {
          value: {
            enum: [
              "always-multiline",
              "always",
              "never",
              "only-multiline"
            ]
          },
          valueWithIgnore: {
            enum: [
              "always-multiline",
              "always",
              "ignore",
              "never",
              "only-multiline"
            ]
          }
        },
        type: "array",
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/value"
              },
              {
                type: "object",
                properties: {
                  arrays: { $ref: "#/definitions/valueWithIgnore" },
                  objects: { $ref: "#/definitions/valueWithIgnore" },
                  imports: { $ref: "#/definitions/valueWithIgnore" },
                  exports: { $ref: "#/definitions/valueWithIgnore" },
                  functions: { $ref: "#/definitions/valueWithIgnore" }
                },
                additionalProperties: !1
              }
            ]
          }
        ],
        additionalItems: !1
      },
      messages: {
        unexpected: "Unexpected trailing comma.",
        missing: "Missing trailing comma."
      }
    },
    create(r) {
      const u = f(r.options[0], r.languageOptions.ecmaVersion), e = r.sourceCode;
      function a(g) {
        function d(y) {
          return y[y.length - 1];
        }
        switch (g.type) {
          case "ObjectExpression":
          case "ObjectPattern":
            return d(g.properties);
          case "ArrayExpression":
          case "ArrayPattern":
            return d(g.elements);
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
            return d(g.specifiers);
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
            return d(g.params);
          case "CallExpression":
          case "NewExpression":
            return d(g.arguments);
          default:
            return null;
        }
      }
      function n(g, d) {
        switch (g.type) {
          case "ObjectExpression":
          case "ArrayExpression":
          case "CallExpression":
          case "NewExpression":
            return e.getLastToken(g, 1);
          default: {
            const y = e.getTokenAfter(d);
            return i.isCommaToken(y) ? y : e.getLastToken(d);
          }
        }
      }
      function p(g) {
        const d = a(g);
        if (!d)
          return !1;
        const y = n(g, d);
        return e.getTokenAfter(y).loc.end.line !== y.loc.end.line;
      }
      function m(g) {
        const d = a(g);
        if (!d || g.type === "ImportDeclaration" && d.type !== "ImportSpecifier")
          return;
        const y = n(g, d);
        i.isCommaToken(y) && r.report({
          node: d,
          loc: y.loc,
          messageId: "unexpected",
          *fix(v) {
            yield v.remove(y), yield v.insertTextBefore(e.getTokenBefore(y), ""), yield v.insertTextAfter(e.getTokenAfter(y), "");
          }
        });
      }
      function h(g) {
        const d = a(g);
        if (!d || g.type === "ImportDeclaration" && d.type !== "ImportSpecifier")
          return;
        if (!o(d)) {
          m(g);
          return;
        }
        const y = n(g, d);
        y.value !== "," && r.report({
          node: d,
          loc: {
            start: y.loc.end,
            end: i.getNextLocation(e, y.loc.end)
          },
          messageId: "missing",
          *fix(v) {
            yield v.insertTextAfter(y, ","), yield v.insertTextBefore(y, ""), yield v.insertTextAfter(e.getTokenAfter(y), "");
          }
        });
      }
      function l(g) {
        p(g) ? h(g) : m(g);
      }
      function s(g) {
        p(g) || m(g);
      }
      const c = {
        always: h,
        "always-multiline": l,
        "only-multiline": s,
        never: m,
        ignore() {
        }
      };
      return {
        ObjectExpression: c[u.objects],
        ObjectPattern: c[u.objects],
        ArrayExpression: c[u.arrays],
        ArrayPattern: c[u.arrays],
        ImportDeclaration: c[u.imports],
        ExportNamedDeclaration: c[u.exports],
        FunctionDeclaration: c[u.functions],
        FunctionExpression: c[u.functions],
        ArrowFunctionExpression: c[u.functions],
        CallExpression: c[u.functions],
        NewExpression: c[u.functions]
      };
    }
  }, Bi;
}
var Pi, Um;
function cT() {
  if (Um) return Pi;
  Um = 1;
  const i = Re();
  return Pi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after commas",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/comma-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: !1
            },
            after: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        missing: "A space is required {{loc}} ','.",
        unexpected: "There should be no space {{loc}} ','."
      }
    },
    create(t) {
      const o = t.sourceCode, f = o.tokensAndComments, r = {
        before: t.options[0] ? t.options[0].before : !1,
        after: t.options[0] ? t.options[0].after : !0
      }, u = [];
      function e(n, p, m) {
        t.report({
          node: n,
          fix(h) {
            if (r[p])
              return p === "before" ? h.insertTextBefore(n, " ") : h.insertTextAfter(n, " ");
            let l, s;
            const c = "";
            return p === "before" ? (l = m.range[1], s = n.range[0]) : (l = n.range[1], s = m.range[0]), h.replaceTextRange([l, s], c);
          },
          messageId: r[p] ? "missing" : "unexpected",
          data: {
            loc: p
          }
        });
      }
      function a(n) {
        let p = o.getFirstToken(n);
        n.elements.forEach((m) => {
          let h;
          m === null ? (h = o.getTokenAfter(p), i.isCommaToken(h) && u.push(h)) : h = o.getTokenAfter(m), p = h;
        });
      }
      return {
        "Program:exit"() {
          f.forEach((n, p) => {
            if (!i.isCommaToken(n))
              return;
            const m = f[p - 1], h = f[p + 1];
            m && !i.isCommaToken(m) && // ignore spacing between two commas
            /*
             * `commaTokensToIgnore` are ending commas of `null` elements (array holes/elisions).
             * In addition to spacing between two commas, this can also ignore:
             *
             *   - Spacing after `[` (controlled by array-bracket-spacing)
             *       Example: [ , ]
             *                 ^
             *   - Spacing after a comment (for backwards compatibility, this was possibly unintentional)
             *       Example: [a, /* * / ,]
             *                          ^
             */
            !u.includes(n) && i.isTokenOnSameLine(m, n) && r.before !== o.isSpaceBetweenTokens(m, n) && e(n, "before", m), h && !i.isCommaToken(h) && // ignore spacing between two commas
            !i.isClosingParenToken(h) && // controlled by space-in-parens
            !i.isClosingBracketToken(h) && // controlled by array-bracket-spacing
            !i.isClosingBraceToken(h) && // controlled by object-curly-spacing
            !(!r.after && h.type === "Line") && // special case, allow space before line comment
            i.isTokenOnSameLine(n, h) && r.after !== o.isSpaceBetweenTokens(n, h) && e(n, "after", h);
          });
        },
        ArrayExpression: a,
        ArrayPattern: a
      };
    }
  }, Pi;
}
var Ii, Vm;
function fT() {
  if (Vm) return Ii;
  Vm = 1;
  const i = Re();
  return Ii = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent comma style",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/comma-style"
      },
      fixable: "code",
      schema: [
        {
          enum: ["first", "last"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
        expectedCommaFirst: "',' should be placed first.",
        expectedCommaLast: "',' should be placed last."
      }
    },
    create(t) {
      const o = t.options[0] || "last", f = t.sourceCode, r = {
        ArrayPattern: !0,
        ArrowFunctionExpression: !0,
        CallExpression: !0,
        FunctionDeclaration: !0,
        FunctionExpression: !0,
        ImportDeclaration: !0,
        ObjectPattern: !0,
        NewExpression: !0
      };
      if (t.options.length === 2 && Object.prototype.hasOwnProperty.call(t.options[1], "exceptions")) {
        const m = Object.keys(t.options[1].exceptions);
        for (let h = 0; h < m.length; h++)
          r[m[h]] = t.options[1].exceptions[m[h]];
      }
      function u(m, h) {
        switch (m) {
          case "between":
            return `,${h.replace(i.LINEBREAK_MATCHER, "")}`;
          case "first":
            return `${h},`;
          case "last":
            return `,${h}`;
          default:
            return "";
        }
      }
      function e(m, h, l, s) {
        const c = f.text.slice(h.range[1], l.range[0]) + f.text.slice(l.range[1], s.range[0]), g = [h.range[1], s.range[0]];
        return function(d) {
          return d.replaceTextRange(g, u(m, c));
        };
      }
      function a(m, h, l, s) {
        if (!(i.isTokenOnSameLine(h, l) && i.isTokenOnSameLine(m, h))) if (!i.isTokenOnSameLine(h, l) && !i.isTokenOnSameLine(m, h)) {
          const c = f.getCommentsAfter(h)[0], g = c && c.type === "Block" && i.isTokenOnSameLine(h, c) ? o : "between";
          t.report({
            node: s,
            loc: h.loc,
            messageId: "unexpectedLineBeforeAndAfterComma",
            fix: e(g, m, h, l)
          });
        } else o === "first" && !i.isTokenOnSameLine(h, l) ? t.report({
          node: s,
          loc: h.loc,
          messageId: "expectedCommaFirst",
          fix: e(o, m, h, l)
        }) : o === "last" && i.isTokenOnSameLine(h, l) && t.report({
          node: s,
          loc: h.loc,
          messageId: "expectedCommaLast",
          fix: e(o, m, h, l)
        });
      }
      function n(m, h) {
        const l = m[h], s = m.type === "ArrayExpression" || m.type === "ArrayPattern";
        if (l.length > 1 || s) {
          let c = f.getFirstToken(m);
          if (l.forEach((g) => {
            const d = g ? f.getTokenBefore(g) : c, y = g ? f.getFirstToken(g) : f.getTokenAfter(d), v = g || y;
            if (i.isCommaToken(d) && a(c, d, y, v), g) {
              const T = f.getTokenAfter(g, i.isNotClosingParenToken);
              c = T ? f.getTokenBefore(T) : f.ast.tokens[f.ast.tokens.length - 1];
            } else
              c = y;
          }), s) {
            const g = f.getLastToken(m), d = f.getTokenBefore(g);
            i.isCommaToken(d) && a(
              f.getTokenBefore(d),
              d,
              g,
              g
            );
          }
        }
      }
      const p = {};
      return r.VariableDeclaration || (p.VariableDeclaration = function(m) {
        n(m, "declarations");
      }), r.ObjectExpression || (p.ObjectExpression = function(m) {
        n(m, "properties");
      }), r.ObjectPattern || (p.ObjectPattern = function(m) {
        n(m, "properties");
      }), r.ArrayExpression || (p.ArrayExpression = function(m) {
        n(m, "elements");
      }), r.ArrayPattern || (p.ArrayPattern = function(m) {
        n(m, "elements");
      }), r.FunctionDeclaration || (p.FunctionDeclaration = function(m) {
        n(m, "params");
      }), r.FunctionExpression || (p.FunctionExpression = function(m) {
        n(m, "params");
      }), r.ArrowFunctionExpression || (p.ArrowFunctionExpression = function(m) {
        n(m, "params");
      }), r.CallExpression || (p.CallExpression = function(m) {
        n(m, "arguments");
      }), r.ImportDeclaration || (p.ImportDeclaration = function(m) {
        n(m, "specifiers");
      }), r.NewExpression || (p.NewExpression = function(m) {
        n(m, "arguments");
      }), p;
    }
  }, Ii;
}
var tn = {}, rn = {}, Fi = {}, Mm;
function Dv() {
  return Mm || (Mm = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.EXTENDED_PICTOGRAPHIC = i.CLUSTER_BREAK = void 0, function(t) {
      t[t.CR = 0] = "CR", t[t.LF = 1] = "LF", t[t.CONTROL = 2] = "CONTROL", t[t.EXTEND = 3] = "EXTEND", t[t.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", t[t.SPACINGMARK = 5] = "SPACINGMARK", t[t.L = 6] = "L", t[t.V = 7] = "V", t[t.T = 8] = "T", t[t.LV = 9] = "LV", t[t.LVT = 10] = "LVT", t[t.OTHER = 11] = "OTHER", t[t.PREPEND = 12] = "PREPEND", t[t.E_BASE = 13] = "E_BASE", t[t.E_MODIFIER = 14] = "E_MODIFIER", t[t.ZWJ = 15] = "ZWJ", t[t.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", t[t.E_BASE_GAZ = 17] = "E_BASE_GAZ";
    }(i.CLUSTER_BREAK || (i.CLUSTER_BREAK = {})), i.EXTENDED_PICTOGRAPHIC = 101;
  }(Fi)), Fi;
}
var nn = {}, Km;
function pT() {
  if (Km) return nn;
  Km = 1, Object.defineProperty(nn, "__esModule", { value: !0 });
  const i = Dv(), t = 0, o = 1, f = 2, r = 3, u = 4;
  let e = class {
    /**
     * Check if the the character at the position {pos} of the string is surrogate
     * @param str {string}
     * @param pos {number}
     * @returns {boolean}
     */
    static isSurrogate(n, p) {
      return 55296 <= n.charCodeAt(p) && n.charCodeAt(p) <= 56319 && 56320 <= n.charCodeAt(p + 1) && n.charCodeAt(p + 1) <= 57343;
    }
    /**
     * The String.prototype.codePointAt polyfill
     * Private function, gets a Unicode code point from a JavaScript UTF-16 string
     * handling surrogate pairs appropriately
     * @param str {string}
     * @param idx {number}
     * @returns {number}
     */
    static codePointAt(n, p) {
      p === void 0 && (p = 0);
      const m = n.charCodeAt(p);
      if (55296 <= m && m <= 56319 && p < n.length - 1) {
        const h = m, l = n.charCodeAt(p + 1);
        return 56320 <= l && l <= 57343 ? (h - 55296) * 1024 + (l - 56320) + 65536 : h;
      }
      if (56320 <= m && m <= 57343 && p >= 1) {
        const h = n.charCodeAt(p - 1), l = m;
        return 55296 <= h && h <= 56319 ? (h - 55296) * 1024 + (l - 56320) + 65536 : l;
      }
      return m;
    }
    //
    /**
     * Private function, returns whether a break is allowed between the two given grapheme breaking classes
     * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
     * @param start {number}
     * @param mid {Array<number>}
     * @param end {number}
     * @param startEmoji {number}
     * @param midEmoji {Array<number>}
     * @param endEmoji {number}
     * @returns {number}
     */
    static shouldBreak(n, p, m, h, l, s) {
      const c = [n].concat(p).concat([m]), g = [h].concat(l).concat([s]), d = c[c.length - 2], y = m, v = s, T = c.lastIndexOf(i.CLUSTER_BREAK.REGIONAL_INDICATOR);
      if (T > 0 && c.slice(1, T).every(function(S) {
        return S === i.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }) && [i.CLUSTER_BREAK.PREPEND, i.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(d) === -1)
        return c.filter(function(S) {
          return S === i.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }).length % 2 === 1 ? r : u;
      if (d === i.CLUSTER_BREAK.CR && y === i.CLUSTER_BREAK.LF)
        return t;
      if (d === i.CLUSTER_BREAK.CONTROL || d === i.CLUSTER_BREAK.CR || d === i.CLUSTER_BREAK.LF)
        return o;
      if (y === i.CLUSTER_BREAK.CONTROL || y === i.CLUSTER_BREAK.CR || y === i.CLUSTER_BREAK.LF)
        return o;
      if (d === i.CLUSTER_BREAK.L && (y === i.CLUSTER_BREAK.L || y === i.CLUSTER_BREAK.V || y === i.CLUSTER_BREAK.LV || y === i.CLUSTER_BREAK.LVT))
        return t;
      if ((d === i.CLUSTER_BREAK.LV || d === i.CLUSTER_BREAK.V) && (y === i.CLUSTER_BREAK.V || y === i.CLUSTER_BREAK.T))
        return t;
      if ((d === i.CLUSTER_BREAK.LVT || d === i.CLUSTER_BREAK.T) && y === i.CLUSTER_BREAK.T)
        return t;
      if (y === i.CLUSTER_BREAK.EXTEND || y === i.CLUSTER_BREAK.ZWJ)
        return t;
      if (y === i.CLUSTER_BREAK.SPACINGMARK)
        return t;
      if (d === i.CLUSTER_BREAK.PREPEND)
        return t;
      const b = g.slice(0, -1).lastIndexOf(i.EXTENDED_PICTOGRAPHIC);
      return b !== -1 && g[b] === i.EXTENDED_PICTOGRAPHIC && c.slice(b + 1, -2).every(function(S) {
        return S === i.CLUSTER_BREAK.EXTEND;
      }) && d === i.CLUSTER_BREAK.ZWJ && v === i.EXTENDED_PICTOGRAPHIC ? t : p.indexOf(i.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? f : d === i.CLUSTER_BREAK.REGIONAL_INDICATOR && y === i.CLUSTER_BREAK.REGIONAL_INDICATOR ? t : o;
    }
  };
  return nn.default = e, nn;
}
var sn = {}, jm;
function hT() {
  if (jm) return sn;
  jm = 1, Object.defineProperty(sn, "__esModule", { value: !0 });
  let i = class {
    constructor(o, f) {
      this._index = 0, this._str = o, this._nextBreak = f;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let o;
      if ((o = this._nextBreak(this._str, this._index)) < this._str.length) {
        const f = this._str.slice(this._index, o);
        return this._index = o, { value: f, done: !1 };
      }
      if (this._index < this._str.length) {
        const f = this._str.slice(this._index);
        return this._index = this._str.length, { value: f, done: !1 };
      }
      return { value: void 0, done: !0 };
    }
  };
  return sn.default = i, sn;
}
var qm;
function mT() {
  if (qm) return rn;
  qm = 1;
  var i = this && this.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(rn, "__esModule", { value: !0 });
  const t = Dv(), o = i(pT()), f = i(hT());
  let r = class dr {
    /**
     * Returns the next grapheme break in the string after the given index
     * @param string {string}
     * @param index {number}
     * @returns {number}
     */
    static nextBreak(e, a) {
      if (a === void 0 && (a = 0), a < 0)
        return 0;
      if (a >= e.length - 1)
        return e.length;
      const n = o.default.codePointAt(e, a), p = dr.getGraphemeBreakProperty(n), m = dr.getEmojiProperty(n), h = [], l = [];
      for (let s = a + 1; s < e.length; s++) {
        if (o.default.isSurrogate(e, s - 1))
          continue;
        const c = o.default.codePointAt(e, s), g = dr.getGraphemeBreakProperty(c), d = dr.getEmojiProperty(c);
        if (o.default.shouldBreak(p, h, g, m, l, d))
          return s;
        h.push(g), l.push(d);
      }
      return e.length;
    }
    /**
     * Breaks the given string into an array of grapheme clusters
     * @param str {string}
     * @returns {string[]}
     */
    splitGraphemes(e) {
      const a = [];
      let n = 0, p;
      for (; (p = dr.nextBreak(e, n)) < e.length; )
        a.push(e.slice(n, p)), n = p;
      return n < e.length && a.push(e.slice(n)), a;
    }
    /**
     * Returns an iterator of grapheme clusters in the given string
     * @param str {string}
     * @returns {GraphemerIterator}
     */
    iterateGraphemes(e) {
      return new f.default(e, dr.nextBreak);
    }
    /**
     * Returns the number of grapheme clusters in the given string
     * @param str {string}
     * @returns {number}
     */
    countGraphemes(e) {
      let a = 0, n = 0, p;
      for (; (p = dr.nextBreak(e, n)) < e.length; )
        n = p, a++;
      return n < e.length && a++, a;
    }
    /**
     * Given a Unicode code point, determines this symbol's grapheme break property
     * @param code {number} Unicode code point
     * @returns {number}
     */
    static getGraphemeBreakProperty(e) {
      if (e < 48905) {
        if (e < 44116) {
          if (e < 4141) {
            if (e < 2818) {
              if (e < 2363)
                if (e < 1759) {
                  if (e < 1471) {
                    if (e < 127) {
                      if (e < 11) {
                        if (e < 10) {
                          if (0 <= e && e <= 9)
                            return t.CLUSTER_BREAK.CONTROL;
                        } else if (e === 10)
                          return t.CLUSTER_BREAK.LF;
                      } else if (e < 13) {
                        if (11 <= e && e <= 12)
                          return t.CLUSTER_BREAK.CONTROL;
                      } else if (e < 14) {
                        if (e === 13)
                          return t.CLUSTER_BREAK.CR;
                      } else if (14 <= e && e <= 31)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (e < 768) {
                      if (e < 173) {
                        if (127 <= e && e <= 159)
                          return t.CLUSTER_BREAK.CONTROL;
                      } else if (e === 173)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (e < 1155) {
                      if (768 <= e && e <= 879)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1425) {
                      if (1155 <= e && e <= 1161)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1425 <= e && e <= 1469)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1552) {
                    if (e < 1476) {
                      if (e < 1473) {
                        if (e === 1471)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (1473 <= e && e <= 1474)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1479) {
                      if (1476 <= e && e <= 1477)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1536) {
                      if (e === 1479)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1536 <= e && e <= 1541)
                      return t.CLUSTER_BREAK.PREPEND;
                  } else if (e < 1648) {
                    if (e < 1564) {
                      if (1552 <= e && e <= 1562)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1611) {
                      if (e === 1564)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (1611 <= e && e <= 1631)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1750) {
                    if (e === 1648)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1757) {
                    if (1750 <= e && e <= 1756)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 1757)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2075) {
                  if (e < 1840)
                    if (e < 1770) {
                      if (e < 1767) {
                        if (1759 <= e && e <= 1764)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (1767 <= e && e <= 1768)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1807) {
                      if (1770 <= e && e <= 1773)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else {
                      if (e === 1807)
                        return t.CLUSTER_BREAK.PREPEND;
                      if (e === 1809)
                        return t.CLUSTER_BREAK.EXTEND;
                    }
                  else if (e < 2027) {
                    if (e < 1958) {
                      if (1840 <= e && e <= 1866)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1958 <= e && e <= 1968)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2045) {
                    if (2027 <= e && e <= 2035)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2070) {
                    if (e === 2045)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2070 <= e && e <= 2073)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2200) {
                  if (e < 2089) {
                    if (e < 2085) {
                      if (2075 <= e && e <= 2083)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2085 <= e && e <= 2087)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2137) {
                    if (2089 <= e && e <= 2093)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2192) {
                    if (2137 <= e && e <= 2139)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2192 <= e && e <= 2193)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2275) {
                  if (e < 2250) {
                    if (2200 <= e && e <= 2207)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2274) {
                    if (2250 <= e && e <= 2273)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2274)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2307) {
                  if (2275 <= e && e <= 2306)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 2307)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 2362)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 2561) {
                if (e < 2434) {
                  if (e < 2381) {
                    if (e < 2366) {
                      if (e === 2363)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                      if (e === 2364)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2369) {
                      if (2366 <= e && e <= 2368)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e < 2377) {
                      if (2369 <= e && e <= 2376)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2377 <= e && e <= 2380)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2385) {
                    if (e < 2382) {
                      if (e === 2381)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2382 <= e && e <= 2383)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2402) {
                    if (2385 <= e && e <= 2391)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2433) {
                    if (2402 <= e && e <= 2403)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2433)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2503) {
                  if (e < 2494) {
                    if (e < 2492) {
                      if (2434 <= e && e <= 2435)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2492)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2495) {
                    if (e === 2494)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2497) {
                    if (2495 <= e && e <= 2496)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2497 <= e && e <= 2500)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2519) {
                  if (e < 2507) {
                    if (2503 <= e && e <= 2504)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2509) {
                    if (2507 <= e && e <= 2508)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2509)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2530) {
                  if (e === 2519)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2558) {
                  if (2530 <= e && e <= 2531)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 2558)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2691) {
                if (e < 2631) {
                  if (e < 2620) {
                    if (e < 2563) {
                      if (2561 <= e && e <= 2562)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e === 2563)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2622) {
                    if (e === 2620)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2625) {
                    if (2622 <= e && e <= 2624)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2625 <= e && e <= 2626)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2672) {
                  if (e < 2635) {
                    if (2631 <= e && e <= 2632)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2641) {
                    if (2635 <= e && e <= 2637)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2641)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2677) {
                  if (2672 <= e && e <= 2673)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2689) {
                  if (e === 2677)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (2689 <= e && e <= 2690)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2761) {
                if (e < 2750) {
                  if (e === 2691)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 2748)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2753) {
                  if (2750 <= e && e <= 2752)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2759) {
                  if (2753 <= e && e <= 2757)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (2759 <= e && e <= 2760)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2786) {
                if (e < 2763) {
                  if (e === 2761)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2765) {
                  if (2763 <= e && e <= 2764)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2765)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2810) {
                if (2786 <= e && e <= 2787)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2817) {
                if (2810 <= e && e <= 2815)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 2817)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3315) {
              if (e < 3076) {
                if (e < 2946) {
                  if (e < 2887) {
                    if (e < 2878) {
                      if (e < 2876) {
                        if (2818 <= e && e <= 2819)
                          return t.CLUSTER_BREAK.SPACINGMARK;
                      } else if (e === 2876)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2880) {
                      if (2878 <= e && e <= 2879)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2881) {
                      if (e === 2880)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (2881 <= e && e <= 2884)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2893) {
                    if (e < 2891) {
                      if (2887 <= e && e <= 2888)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (2891 <= e && e <= 2892)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2901) {
                    if (e === 2893)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2914) {
                    if (2901 <= e && e <= 2903)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2914 <= e && e <= 2915)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3014) {
                  if (e < 3007) {
                    if (e === 2946 || e === 3006)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3008) {
                    if (e === 3007)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3009) {
                    if (e === 3008)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3009 <= e && e <= 3010)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3031) {
                  if (e < 3018) {
                    if (3014 <= e && e <= 3016)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3021) {
                    if (3018 <= e && e <= 3020)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 3021)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3072) {
                  if (e === 3031)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3073) {
                  if (e === 3072)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3073 <= e && e <= 3075)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3262) {
                if (e < 3146) {
                  if (e < 3134) {
                    if (e === 3076 || e === 3132)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3137) {
                    if (3134 <= e && e <= 3136)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3142) {
                    if (3137 <= e && e <= 3140)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3142 <= e && e <= 3144)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3201) {
                  if (e < 3157) {
                    if (3146 <= e && e <= 3149)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3170) {
                    if (3157 <= e && e <= 3158)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3170 <= e && e <= 3171)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3202) {
                  if (e === 3201)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3260) {
                  if (3202 <= e && e <= 3203)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3260)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3270) {
                if (e < 3264) {
                  if (e === 3262)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 3263)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3266) {
                  if (3264 <= e && e <= 3265)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3267) {
                  if (e === 3266)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3267 <= e && e <= 3268)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3276) {
                if (e < 3271) {
                  if (e === 3270)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3274) {
                  if (3271 <= e && e <= 3272)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (3274 <= e && e <= 3275)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3285) {
                if (3276 <= e && e <= 3277)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3298) {
                if (3285 <= e && e <= 3286)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3298 <= e && e <= 3299)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3551) {
              if (e < 3406) {
                if (e < 3391) {
                  if (e < 3330) {
                    if (e < 3328) {
                      if (e === 3315)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (3328 <= e && e <= 3329)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3387) {
                    if (3330 <= e && e <= 3331)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3390) {
                    if (3387 <= e && e <= 3388)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 3390)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3398) {
                  if (e < 3393) {
                    if (3391 <= e && e <= 3392)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3393 <= e && e <= 3396)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3402) {
                  if (3398 <= e && e <= 3400)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3405) {
                  if (3402 <= e && e <= 3404)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3405)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3530) {
                if (e < 3426) {
                  if (e === 3406)
                    return t.CLUSTER_BREAK.PREPEND;
                  if (e === 3415)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3457) {
                  if (3426 <= e && e <= 3427)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3458) {
                  if (e === 3457)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3458 <= e && e <= 3459)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3538) {
                if (e < 3535) {
                  if (e === 3530)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3536) {
                  if (e === 3535)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3536 <= e && e <= 3537)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3542) {
                if (3538 <= e && e <= 3540)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3544) {
                if (e === 3542)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3544 <= e && e <= 3550)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3893) {
              if (e < 3655) {
                if (e < 3633) {
                  if (e < 3570) {
                    if (e === 3551)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3570 <= e && e <= 3571)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3635) {
                  if (e === 3633)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3636) {
                  if (e === 3635)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (3636 <= e && e <= 3642)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3764)
                if (e < 3761) {
                  if (3655 <= e && e <= 3662)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 3761)
                    return t.CLUSTER_BREAK.EXTEND;
                  if (e === 3763)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                }
              else if (e < 3784) {
                if (3764 <= e && e <= 3772)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3864) {
                if (3784 <= e && e <= 3790)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3864 <= e && e <= 3865)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3967) {
              if (e < 3897) {
                if (e === 3893 || e === 3895)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3902) {
                if (e === 3897)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3953) {
                if (3902 <= e && e <= 3903)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (3953 <= e && e <= 3966)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3981) {
              if (e < 3968) {
                if (e === 3967)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3974) {
                if (3968 <= e && e <= 3972)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3974 <= e && e <= 3975)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3993) {
              if (3981 <= e && e <= 3991)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 4038) {
              if (3993 <= e && e <= 4028)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 4038)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 7204) {
            if (e < 6448) {
              if (e < 5938) {
                if (e < 4226) {
                  if (e < 4157) {
                    if (e < 4146) {
                      if (e < 4145) {
                        if (4141 <= e && e <= 4144)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (e === 4145)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e < 4153) {
                      if (4146 <= e && e <= 4151)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 4155) {
                      if (4153 <= e && e <= 4154)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (4155 <= e && e <= 4156)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4184) {
                    if (e < 4182) {
                      if (4157 <= e && e <= 4158)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (4182 <= e && e <= 4183)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4190) {
                    if (4184 <= e && e <= 4185)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4209) {
                    if (4190 <= e && e <= 4192)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (4209 <= e && e <= 4212)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 4352) {
                  if (e < 4229) {
                    if (e === 4226)
                      return t.CLUSTER_BREAK.EXTEND;
                    if (e === 4228)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4237) {
                    if (4229 <= e && e <= 4230)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 4237 || e === 4253)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 4957) {
                  if (e < 4448) {
                    if (4352 <= e && e <= 4447)
                      return t.CLUSTER_BREAK.L;
                  } else if (e < 4520) {
                    if (4448 <= e && e <= 4519)
                      return t.CLUSTER_BREAK.V;
                  } else if (4520 <= e && e <= 4607)
                    return t.CLUSTER_BREAK.T;
                } else if (e < 5906) {
                  if (4957 <= e && e <= 4959)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 5909) {
                  if (5906 <= e && e <= 5908)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 5909)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6089) {
                if (e < 6070) {
                  if (e < 5970) {
                    if (e < 5940) {
                      if (5938 <= e && e <= 5939)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e === 5940)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 6002) {
                    if (5970 <= e && e <= 5971)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 6068) {
                    if (6002 <= e && e <= 6003)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (6068 <= e && e <= 6069)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6078) {
                  if (e < 6071) {
                    if (e === 6070)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (6071 <= e && e <= 6077)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6086) {
                  if (6078 <= e && e <= 6085)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6087) {
                  if (e === 6086)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6087 <= e && e <= 6088)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6277)
                if (e < 6155) {
                  if (e < 6109) {
                    if (6089 <= e && e <= 6099)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 6109)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6158) {
                  if (6155 <= e && e <= 6157)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 6158)
                    return t.CLUSTER_BREAK.CONTROL;
                  if (e === 6159)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 6435) {
                if (e < 6313) {
                  if (6277 <= e && e <= 6278)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6432) {
                  if (e === 6313)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6432 <= e && e <= 6434)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6439) {
                if (6435 <= e && e <= 6438)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6441) {
                if (6439 <= e && e <= 6440)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (6441 <= e && e <= 6443)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6971) {
              if (e < 6744)
                if (e < 6681) {
                  if (e < 6451) {
                    if (e < 6450) {
                      if (6448 <= e && e <= 6449)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 6450)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 6457) {
                    if (6451 <= e && e <= 6456)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 6679) {
                    if (6457 <= e && e <= 6459)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (6679 <= e && e <= 6680)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6741) {
                  if (e < 6683) {
                    if (6681 <= e && e <= 6682)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6683)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6742) {
                  if (e === 6741)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else {
                  if (e === 6742)
                    return t.CLUSTER_BREAK.EXTEND;
                  if (e === 6743)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                }
              else if (e < 6771) {
                if (e < 6754) {
                  if (e < 6752) {
                    if (6744 <= e && e <= 6750)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 6752)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6757) {
                  if (e === 6754)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6765) {
                  if (6757 <= e && e <= 6764)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6765 <= e && e <= 6770)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6912) {
                if (e < 6783) {
                  if (6771 <= e && e <= 6780)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6832) {
                  if (e === 6783)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6832 <= e && e <= 6862)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6916) {
                if (6912 <= e && e <= 6915)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6964) {
                if (e === 6916)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (6964 <= e && e <= 6970)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 7080) {
              if (e < 7019) {
                if (e < 6973) {
                  if (e === 6971)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 6972)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6978) {
                  if (6973 <= e && e <= 6977)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6979) {
                  if (e === 6978)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6979 <= e && e <= 6980)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7073) {
                if (e < 7040) {
                  if (7019 <= e && e <= 7027)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 7042) {
                  if (7040 <= e && e <= 7041)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7042)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7074) {
                if (e === 7073)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7078) {
                if (7074 <= e && e <= 7077)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (7078 <= e && e <= 7079)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7144)
              if (e < 7083) {
                if (e < 7082) {
                  if (7080 <= e && e <= 7081)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7082)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7142) {
                if (7083 <= e && e <= 7085)
                  return t.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 7142)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 7143)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 7150) {
              if (e < 7146) {
                if (7144 <= e && e <= 7145)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 7149) {
                if (7146 <= e && e <= 7148)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 7149)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 7151) {
              if (e === 7150)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7154) {
              if (7151 <= e && e <= 7153)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (7154 <= e && e <= 7155)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43346) {
            if (e < 11647) {
              if (e < 7415) {
                if (e < 7380) {
                  if (e < 7220) {
                    if (e < 7212) {
                      if (7204 <= e && e <= 7211)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (7212 <= e && e <= 7219)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 7222) {
                    if (7220 <= e && e <= 7221)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 7376) {
                    if (7222 <= e && e <= 7223)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (7376 <= e && e <= 7378)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 7394) {
                  if (e < 7393) {
                    if (7380 <= e && e <= 7392)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 7393)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7405) {
                  if (7394 <= e && e <= 7400)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7405 || e === 7412)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 8205)
                if (e < 7616) {
                  if (e < 7416) {
                    if (e === 7415)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7416 <= e && e <= 7417)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 8203) {
                  if (7616 <= e && e <= 7679)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 8203)
                    return t.CLUSTER_BREAK.CONTROL;
                  if (e === 8204)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 8288) {
                if (e < 8206) {
                  if (e === 8205)
                    return t.CLUSTER_BREAK.ZWJ;
                } else if (e < 8232) {
                  if (8206 <= e && e <= 8207)
                    return t.CLUSTER_BREAK.CONTROL;
                } else if (8232 <= e && e <= 8238)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 8400) {
                if (8288 <= e && e <= 8303)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 11503) {
                if (8400 <= e && e <= 8432)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (11503 <= e && e <= 11505)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43043) {
              if (e < 42612) {
                if (e < 12330) {
                  if (e < 11744) {
                    if (e === 11647)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (11744 <= e && e <= 11775)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 12441) {
                  if (12330 <= e && e <= 12335)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 42607) {
                  if (12441 <= e && e <= 12442)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (42607 <= e && e <= 42610)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43010) {
                if (e < 42654) {
                  if (42612 <= e && e <= 42621)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 42736) {
                  if (42654 <= e && e <= 42655)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (42736 <= e && e <= 42737)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43014) {
                if (e === 43010)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 43014 || e === 43019)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43188) {
              if (e < 43047) {
                if (e < 43045) {
                  if (43043 <= e && e <= 43044)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (43045 <= e && e <= 43046)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43052) {
                if (e === 43047)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43136) {
                if (e === 43052)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43136 <= e && e <= 43137)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43263) {
              if (e < 43204) {
                if (43188 <= e && e <= 43203)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43232) {
                if (43204 <= e && e <= 43205)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43232 <= e && e <= 43249)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43302) {
              if (e === 43263)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43335) {
              if (43302 <= e && e <= 43309)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (43335 <= e && e <= 43345)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 43698) {
            if (e < 43493) {
              if (e < 43444)
                if (e < 43392) {
                  if (e < 43360) {
                    if (43346 <= e && e <= 43347)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (43360 <= e && e <= 43388)
                    return t.CLUSTER_BREAK.L;
                } else if (e < 43395) {
                  if (43392 <= e && e <= 43394)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 43395)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 43443)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 43450) {
                if (e < 43446) {
                  if (43444 <= e && e <= 43445)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (43446 <= e && e <= 43449)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43452) {
                if (43450 <= e && e <= 43451)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43454) {
                if (43452 <= e && e <= 43453)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43454 <= e && e <= 43456)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43573) {
              if (e < 43567) {
                if (e < 43561) {
                  if (e === 43493)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (43561 <= e && e <= 43566)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43569) {
                if (43567 <= e && e <= 43568)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43571) {
                if (43569 <= e && e <= 43570)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43571 <= e && e <= 43572)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43597) {
              if (e < 43587) {
                if (43573 <= e && e <= 43574)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 43587 || e === 43596)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43644) {
              if (e === 43597)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43644 || e === 43696)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 44006) {
            if (e < 43756)
              if (e < 43710) {
                if (e < 43703) {
                  if (43698 <= e && e <= 43700)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (43703 <= e && e <= 43704)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43713) {
                if (43710 <= e && e <= 43711)
                  return t.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43713)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 43755)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 43766) {
              if (e < 43758) {
                if (43756 <= e && e <= 43757)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43765) {
                if (43758 <= e && e <= 43759)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 43765)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 44003) {
              if (e === 43766)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 44005) {
              if (44003 <= e && e <= 44004)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44005)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 44032)
            if (e < 44009) {
              if (e < 44008) {
                if (44006 <= e && e <= 44007)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 44008)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 44012) {
              if (44009 <= e && e <= 44010)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 44012)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 44013)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 44061) {
            if (e < 44033) {
              if (e === 44032)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 44060) {
              if (44033 <= e && e <= 44059)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 44060)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 44088) {
            if (44061 <= e && e <= 44087)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 44089) {
            if (e === 44088)
              return t.CLUSTER_BREAK.LV;
          } else if (44089 <= e && e <= 44115)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 46497) {
          if (e < 45293) {
            if (e < 44704) {
              if (e < 44397) {
                if (e < 44256) {
                  if (e < 44173) {
                    if (e < 44144) {
                      if (e < 44117) {
                        if (e === 44116)
                          return t.CLUSTER_BREAK.LV;
                      } else if (44117 <= e && e <= 44143)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e < 44145) {
                      if (e === 44144)
                        return t.CLUSTER_BREAK.LV;
                    } else if (e < 44172) {
                      if (44145 <= e && e <= 44171)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44172)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44201) {
                    if (e < 44200) {
                      if (44173 <= e && e <= 44199)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44200)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44228) {
                    if (44201 <= e && e <= 44227)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44229) {
                    if (e === 44228)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44229 <= e && e <= 44255)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44313) {
                  if (e < 44284) {
                    if (e < 44257) {
                      if (e === 44256)
                        return t.CLUSTER_BREAK.LV;
                    } else if (44257 <= e && e <= 44283)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44285) {
                    if (e === 44284)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44312) {
                    if (44285 <= e && e <= 44311)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44312)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44368) {
                  if (e < 44340) {
                    if (44313 <= e && e <= 44339)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44341) {
                    if (e === 44340)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44341 <= e && e <= 44367)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44369) {
                  if (e === 44368)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44396) {
                  if (44369 <= e && e <= 44395)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44396)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44537) {
                if (e < 44480) {
                  if (e < 44425) {
                    if (e < 44424) {
                      if (44397 <= e && e <= 44423)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44424)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44452) {
                    if (44425 <= e && e <= 44451)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44453) {
                    if (e === 44452)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44453 <= e && e <= 44479)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44508) {
                  if (e < 44481) {
                    if (e === 44480)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44481 <= e && e <= 44507)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44509) {
                  if (e === 44508)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44536) {
                  if (44509 <= e && e <= 44535)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44536)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44620) {
                if (e < 44565) {
                  if (e < 44564) {
                    if (44537 <= e && e <= 44563)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44564)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44592) {
                  if (44565 <= e && e <= 44591)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44593) {
                  if (e === 44592)
                    return t.CLUSTER_BREAK.LV;
                } else if (44593 <= e && e <= 44619)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44649) {
                if (e < 44621) {
                  if (e === 44620)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44648) {
                  if (44621 <= e && e <= 44647)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44648)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44676) {
                if (44649 <= e && e <= 44675)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44677) {
                if (e === 44676)
                  return t.CLUSTER_BREAK.LV;
              } else if (44677 <= e && e <= 44703)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 44985) {
              if (e < 44844) {
                if (e < 44761) {
                  if (e < 44732) {
                    if (e < 44705) {
                      if (e === 44704)
                        return t.CLUSTER_BREAK.LV;
                    } else if (44705 <= e && e <= 44731)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44733) {
                    if (e === 44732)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44760) {
                    if (44733 <= e && e <= 44759)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44760)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44789) {
                  if (e < 44788) {
                    if (44761 <= e && e <= 44787)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44788)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44816) {
                  if (44789 <= e && e <= 44815)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44817) {
                  if (e === 44816)
                    return t.CLUSTER_BREAK.LV;
                } else if (44817 <= e && e <= 44843)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44901) {
                if (e < 44872) {
                  if (e < 44845) {
                    if (e === 44844)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44845 <= e && e <= 44871)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44873) {
                  if (e === 44872)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44900) {
                  if (44873 <= e && e <= 44899)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44900)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44956) {
                if (e < 44928) {
                  if (44901 <= e && e <= 44927)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44929) {
                  if (e === 44928)
                    return t.CLUSTER_BREAK.LV;
                } else if (44929 <= e && e <= 44955)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44957) {
                if (e === 44956)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44984) {
                if (44957 <= e && e <= 44983)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 44984)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45152) {
              if (e < 45068) {
                if (e < 45013) {
                  if (e < 45012) {
                    if (44985 <= e && e <= 45011)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 45012)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45040) {
                  if (45013 <= e && e <= 45039)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45041) {
                  if (e === 45040)
                    return t.CLUSTER_BREAK.LV;
                } else if (45041 <= e && e <= 45067)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45097) {
                if (e < 45069) {
                  if (e === 45068)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45096) {
                  if (45069 <= e && e <= 45095)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45096)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45124) {
                if (45097 <= e && e <= 45123)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45125) {
                if (e === 45124)
                  return t.CLUSTER_BREAK.LV;
              } else if (45125 <= e && e <= 45151)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45209) {
              if (e < 45180) {
                if (e < 45153) {
                  if (e === 45152)
                    return t.CLUSTER_BREAK.LV;
                } else if (45153 <= e && e <= 45179)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45181) {
                if (e === 45180)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45208) {
                if (45181 <= e && e <= 45207)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45208)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45264) {
              if (e < 45236) {
                if (45209 <= e && e <= 45235)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45237) {
                if (e === 45236)
                  return t.CLUSTER_BREAK.LV;
              } else if (45237 <= e && e <= 45263)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45265) {
              if (e === 45264)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45292) {
              if (45265 <= e && e <= 45291)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 45292)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 45908) {
            if (e < 45600) {
              if (e < 45433) {
                if (e < 45376) {
                  if (e < 45321) {
                    if (e < 45320) {
                      if (45293 <= e && e <= 45319)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 45320)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 45348) {
                    if (45321 <= e && e <= 45347)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 45349) {
                    if (e === 45348)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45349 <= e && e <= 45375)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45404) {
                  if (e < 45377) {
                    if (e === 45376)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45377 <= e && e <= 45403)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45405) {
                  if (e === 45404)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45432) {
                  if (45405 <= e && e <= 45431)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45432)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45516) {
                if (e < 45461) {
                  if (e < 45460) {
                    if (45433 <= e && e <= 45459)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 45460)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45488) {
                  if (45461 <= e && e <= 45487)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45489) {
                  if (e === 45488)
                    return t.CLUSTER_BREAK.LV;
                } else if (45489 <= e && e <= 45515)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45545) {
                if (e < 45517) {
                  if (e === 45516)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45544) {
                  if (45517 <= e && e <= 45543)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45544)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45572) {
                if (45545 <= e && e <= 45571)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45573) {
                if (e === 45572)
                  return t.CLUSTER_BREAK.LV;
              } else if (45573 <= e && e <= 45599)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45741) {
              if (e < 45657) {
                if (e < 45628) {
                  if (e < 45601) {
                    if (e === 45600)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45601 <= e && e <= 45627)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45629) {
                  if (e === 45628)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45656) {
                  if (45629 <= e && e <= 45655)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45656)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45712) {
                if (e < 45684) {
                  if (45657 <= e && e <= 45683)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45685) {
                  if (e === 45684)
                    return t.CLUSTER_BREAK.LV;
                } else if (45685 <= e && e <= 45711)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45713) {
                if (e === 45712)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45740) {
                if (45713 <= e && e <= 45739)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45740)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45824) {
              if (e < 45769) {
                if (e < 45768) {
                  if (45741 <= e && e <= 45767)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45768)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45796) {
                if (45769 <= e && e <= 45795)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45797) {
                if (e === 45796)
                  return t.CLUSTER_BREAK.LV;
              } else if (45797 <= e && e <= 45823)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45853) {
              if (e < 45825) {
                if (e === 45824)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45852) {
                if (45825 <= e && e <= 45851)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45852)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45880) {
              if (45853 <= e && e <= 45879)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45881) {
              if (e === 45880)
                return t.CLUSTER_BREAK.LV;
            } else if (45881 <= e && e <= 45907)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46189) {
            if (e < 46048) {
              if (e < 45965) {
                if (e < 45936) {
                  if (e < 45909) {
                    if (e === 45908)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45909 <= e && e <= 45935)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45937) {
                  if (e === 45936)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45964) {
                  if (45937 <= e && e <= 45963)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45964)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45993) {
                if (e < 45992) {
                  if (45965 <= e && e <= 45991)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45992)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46020) {
                if (45993 <= e && e <= 46019)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46021) {
                if (e === 46020)
                  return t.CLUSTER_BREAK.LV;
              } else if (46021 <= e && e <= 46047)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46105) {
              if (e < 46076) {
                if (e < 46049) {
                  if (e === 46048)
                    return t.CLUSTER_BREAK.LV;
                } else if (46049 <= e && e <= 46075)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46077) {
                if (e === 46076)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46104) {
                if (46077 <= e && e <= 46103)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46104)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46160) {
              if (e < 46132) {
                if (46105 <= e && e <= 46131)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46133) {
                if (e === 46132)
                  return t.CLUSTER_BREAK.LV;
              } else if (46133 <= e && e <= 46159)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46161) {
              if (e === 46160)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46188) {
              if (46161 <= e && e <= 46187)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 46188)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46356) {
            if (e < 46272) {
              if (e < 46217) {
                if (e < 46216) {
                  if (46189 <= e && e <= 46215)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46216)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46244) {
                if (46217 <= e && e <= 46243)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46245) {
                if (e === 46244)
                  return t.CLUSTER_BREAK.LV;
              } else if (46245 <= e && e <= 46271)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46301) {
              if (e < 46273) {
                if (e === 46272)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46300) {
                if (46273 <= e && e <= 46299)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46300)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46328) {
              if (46301 <= e && e <= 46327)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46329) {
              if (e === 46328)
                return t.CLUSTER_BREAK.LV;
            } else if (46329 <= e && e <= 46355)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46413) {
            if (e < 46384) {
              if (e < 46357) {
                if (e === 46356)
                  return t.CLUSTER_BREAK.LV;
              } else if (46357 <= e && e <= 46383)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46385) {
              if (e === 46384)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46412) {
              if (46385 <= e && e <= 46411)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 46412)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46468) {
            if (e < 46440) {
              if (46413 <= e && e <= 46439)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46441) {
              if (e === 46440)
                return t.CLUSTER_BREAK.LV;
            } else if (46441 <= e && e <= 46467)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46469) {
            if (e === 46468)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46496) {
            if (46469 <= e && e <= 46495)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 46496)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 47701) {
          if (e < 47112) {
            if (e < 46804) {
              if (e < 46637) {
                if (e < 46580) {
                  if (e < 46525) {
                    if (e < 46524) {
                      if (46497 <= e && e <= 46523)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 46524)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 46552) {
                    if (46525 <= e && e <= 46551)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 46553) {
                    if (e === 46552)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46553 <= e && e <= 46579)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46608) {
                  if (e < 46581) {
                    if (e === 46580)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46581 <= e && e <= 46607)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46609) {
                  if (e === 46608)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46636) {
                  if (46609 <= e && e <= 46635)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46636)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46720) {
                if (e < 46665) {
                  if (e < 46664) {
                    if (46637 <= e && e <= 46663)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 46664)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46692) {
                  if (46665 <= e && e <= 46691)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46693) {
                  if (e === 46692)
                    return t.CLUSTER_BREAK.LV;
                } else if (46693 <= e && e <= 46719)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46749) {
                if (e < 46721) {
                  if (e === 46720)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46748) {
                  if (46721 <= e && e <= 46747)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46748)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46776) {
                if (46749 <= e && e <= 46775)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46777) {
                if (e === 46776)
                  return t.CLUSTER_BREAK.LV;
              } else if (46777 <= e && e <= 46803)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46945) {
              if (e < 46861) {
                if (e < 46832) {
                  if (e < 46805) {
                    if (e === 46804)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46805 <= e && e <= 46831)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46833) {
                  if (e === 46832)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46860) {
                  if (46833 <= e && e <= 46859)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46860)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46916) {
                if (e < 46888) {
                  if (46861 <= e && e <= 46887)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46889) {
                  if (e === 46888)
                    return t.CLUSTER_BREAK.LV;
                } else if (46889 <= e && e <= 46915)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46917) {
                if (e === 46916)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46944) {
                if (46917 <= e && e <= 46943)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46944)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47028) {
              if (e < 46973) {
                if (e < 46972) {
                  if (46945 <= e && e <= 46971)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46972)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47e3) {
                if (46973 <= e && e <= 46999)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47001) {
                if (e === 47e3)
                  return t.CLUSTER_BREAK.LV;
              } else if (47001 <= e && e <= 47027)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47057) {
              if (e < 47029) {
                if (e === 47028)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47056) {
                if (47029 <= e && e <= 47055)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47056)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47084) {
              if (47057 <= e && e <= 47083)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47085) {
              if (e === 47084)
                return t.CLUSTER_BREAK.LV;
            } else if (47085 <= e && e <= 47111)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47393) {
            if (e < 47252) {
              if (e < 47169) {
                if (e < 47140) {
                  if (e < 47113) {
                    if (e === 47112)
                      return t.CLUSTER_BREAK.LV;
                  } else if (47113 <= e && e <= 47139)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 47141) {
                  if (e === 47140)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 47168) {
                  if (47141 <= e && e <= 47167)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47168)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47197) {
                if (e < 47196) {
                  if (47169 <= e && e <= 47195)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47196)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47224) {
                if (47197 <= e && e <= 47223)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47225) {
                if (e === 47224)
                  return t.CLUSTER_BREAK.LV;
              } else if (47225 <= e && e <= 47251)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47309) {
              if (e < 47280) {
                if (e < 47253) {
                  if (e === 47252)
                    return t.CLUSTER_BREAK.LV;
                } else if (47253 <= e && e <= 47279)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47281) {
                if (e === 47280)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47308) {
                if (47281 <= e && e <= 47307)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47308)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47364) {
              if (e < 47336) {
                if (47309 <= e && e <= 47335)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47337) {
                if (e === 47336)
                  return t.CLUSTER_BREAK.LV;
              } else if (47337 <= e && e <= 47363)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47365) {
              if (e === 47364)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47392) {
              if (47365 <= e && e <= 47391)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 47392)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47560) {
            if (e < 47476) {
              if (e < 47421) {
                if (e < 47420) {
                  if (47393 <= e && e <= 47419)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47420)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47448) {
                if (47421 <= e && e <= 47447)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47449) {
                if (e === 47448)
                  return t.CLUSTER_BREAK.LV;
              } else if (47449 <= e && e <= 47475)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47505) {
              if (e < 47477) {
                if (e === 47476)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47504) {
                if (47477 <= e && e <= 47503)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47504)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47532) {
              if (47505 <= e && e <= 47531)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47533) {
              if (e === 47532)
                return t.CLUSTER_BREAK.LV;
            } else if (47533 <= e && e <= 47559)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47617) {
            if (e < 47588) {
              if (e < 47561) {
                if (e === 47560)
                  return t.CLUSTER_BREAK.LV;
              } else if (47561 <= e && e <= 47587)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47589) {
              if (e === 47588)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47616) {
              if (47589 <= e && e <= 47615)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 47616)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47672) {
            if (e < 47644) {
              if (47617 <= e && e <= 47643)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47645) {
              if (e === 47644)
                return t.CLUSTER_BREAK.LV;
            } else if (47645 <= e && e <= 47671)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47673) {
            if (e === 47672)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47700) {
            if (47673 <= e && e <= 47699)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 47700)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48316) {
          if (e < 48008) {
            if (e < 47841) {
              if (e < 47784) {
                if (e < 47729) {
                  if (e < 47728) {
                    if (47701 <= e && e <= 47727)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 47728)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 47756) {
                  if (47729 <= e && e <= 47755)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 47757) {
                  if (e === 47756)
                    return t.CLUSTER_BREAK.LV;
                } else if (47757 <= e && e <= 47783)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47812) {
                if (e < 47785) {
                  if (e === 47784)
                    return t.CLUSTER_BREAK.LV;
                } else if (47785 <= e && e <= 47811)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47813) {
                if (e === 47812)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47840) {
                if (47813 <= e && e <= 47839)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47840)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47924) {
              if (e < 47869) {
                if (e < 47868) {
                  if (47841 <= e && e <= 47867)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47868)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47896) {
                if (47869 <= e && e <= 47895)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47897) {
                if (e === 47896)
                  return t.CLUSTER_BREAK.LV;
              } else if (47897 <= e && e <= 47923)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47953) {
              if (e < 47925) {
                if (e === 47924)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47952) {
                if (47925 <= e && e <= 47951)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47952)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47980) {
              if (47953 <= e && e <= 47979)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47981) {
              if (e === 47980)
                return t.CLUSTER_BREAK.LV;
            } else if (47981 <= e && e <= 48007)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48149) {
            if (e < 48065) {
              if (e < 48036) {
                if (e < 48009) {
                  if (e === 48008)
                    return t.CLUSTER_BREAK.LV;
                } else if (48009 <= e && e <= 48035)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48037) {
                if (e === 48036)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 48064) {
                if (48037 <= e && e <= 48063)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48064)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48120) {
              if (e < 48092) {
                if (48065 <= e && e <= 48091)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48093) {
                if (e === 48092)
                  return t.CLUSTER_BREAK.LV;
              } else if (48093 <= e && e <= 48119)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48121) {
              if (e === 48120)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48148) {
              if (48121 <= e && e <= 48147)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48148)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48232) {
            if (e < 48177) {
              if (e < 48176) {
                if (48149 <= e && e <= 48175)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48176)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48204) {
              if (48177 <= e && e <= 48203)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48205) {
              if (e === 48204)
                return t.CLUSTER_BREAK.LV;
            } else if (48205 <= e && e <= 48231)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48261) {
            if (e < 48233) {
              if (e === 48232)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48260) {
              if (48233 <= e && e <= 48259)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48260)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48288) {
            if (48261 <= e && e <= 48287)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48289) {
            if (e === 48288)
              return t.CLUSTER_BREAK.LV;
          } else if (48289 <= e && e <= 48315)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48597) {
          if (e < 48456) {
            if (e < 48373) {
              if (e < 48344) {
                if (e < 48317) {
                  if (e === 48316)
                    return t.CLUSTER_BREAK.LV;
                } else if (48317 <= e && e <= 48343)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48345) {
                if (e === 48344)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 48372) {
                if (48345 <= e && e <= 48371)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48372)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48401) {
              if (e < 48400) {
                if (48373 <= e && e <= 48399)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48400)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48428) {
              if (48401 <= e && e <= 48427)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48429) {
              if (e === 48428)
                return t.CLUSTER_BREAK.LV;
            } else if (48429 <= e && e <= 48455)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48513) {
            if (e < 48484) {
              if (e < 48457) {
                if (e === 48456)
                  return t.CLUSTER_BREAK.LV;
              } else if (48457 <= e && e <= 48483)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48485) {
              if (e === 48484)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48512) {
              if (48485 <= e && e <= 48511)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48512)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48568) {
            if (e < 48540) {
              if (48513 <= e && e <= 48539)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48541) {
              if (e === 48540)
                return t.CLUSTER_BREAK.LV;
            } else if (48541 <= e && e <= 48567)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48569) {
            if (e === 48568)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48596) {
            if (48569 <= e && e <= 48595)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 48596)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48764) {
          if (e < 48680) {
            if (e < 48625) {
              if (e < 48624) {
                if (48597 <= e && e <= 48623)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48624)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48652) {
              if (48625 <= e && e <= 48651)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48653) {
              if (e === 48652)
                return t.CLUSTER_BREAK.LV;
            } else if (48653 <= e && e <= 48679)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48709) {
            if (e < 48681) {
              if (e === 48680)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48708) {
              if (48681 <= e && e <= 48707)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48708)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48736) {
            if (48709 <= e && e <= 48735)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48737) {
            if (e === 48736)
              return t.CLUSTER_BREAK.LV;
          } else if (48737 <= e && e <= 48763)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48821) {
          if (e < 48792) {
            if (e < 48765) {
              if (e === 48764)
                return t.CLUSTER_BREAK.LV;
            } else if (48765 <= e && e <= 48791)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48793) {
            if (e === 48792)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48820) {
            if (48793 <= e && e <= 48819)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 48820)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48876) {
          if (e < 48848) {
            if (48821 <= e && e <= 48847)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48849) {
            if (e === 48848)
              return t.CLUSTER_BREAK.LV;
          } else if (48849 <= e && e <= 48875)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48877) {
          if (e === 48876)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48904) {
          if (48877 <= e && e <= 48903)
            return t.CLUSTER_BREAK.LVT;
        } else if (e === 48904)
          return t.CLUSTER_BREAK.LV;
      } else if (e < 53720) {
        if (e < 51312) {
          if (e < 50108) {
            if (e < 49493) {
              if (e < 49212) {
                if (e < 49045) {
                  if (e < 48988) {
                    if (e < 48933) {
                      if (e < 48932) {
                        if (48905 <= e && e <= 48931)
                          return t.CLUSTER_BREAK.LVT;
                      } else if (e === 48932)
                        return t.CLUSTER_BREAK.LV;
                    } else if (e < 48960) {
                      if (48933 <= e && e <= 48959)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e < 48961) {
                      if (e === 48960)
                        return t.CLUSTER_BREAK.LV;
                    } else if (48961 <= e && e <= 48987)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49016) {
                    if (e < 48989) {
                      if (e === 48988)
                        return t.CLUSTER_BREAK.LV;
                    } else if (48989 <= e && e <= 49015)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49017) {
                    if (e === 49016)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49044) {
                    if (49017 <= e && e <= 49043)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49044)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49128) {
                  if (e < 49073) {
                    if (e < 49072) {
                      if (49045 <= e && e <= 49071)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 49072)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49100) {
                    if (49073 <= e && e <= 49099)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49101) {
                    if (e === 49100)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49101 <= e && e <= 49127)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49157) {
                  if (e < 49129) {
                    if (e === 49128)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49156) {
                    if (49129 <= e && e <= 49155)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49156)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49184) {
                  if (49157 <= e && e <= 49183)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49185) {
                  if (e === 49184)
                    return t.CLUSTER_BREAK.LV;
                } else if (49185 <= e && e <= 49211)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49352) {
                if (e < 49269) {
                  if (e < 49240) {
                    if (e < 49213) {
                      if (e === 49212)
                        return t.CLUSTER_BREAK.LV;
                    } else if (49213 <= e && e <= 49239)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49241) {
                    if (e === 49240)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49268) {
                    if (49241 <= e && e <= 49267)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49268)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49297) {
                  if (e < 49296) {
                    if (49269 <= e && e <= 49295)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49296)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49324) {
                  if (49297 <= e && e <= 49323)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49325) {
                  if (e === 49324)
                    return t.CLUSTER_BREAK.LV;
                } else if (49325 <= e && e <= 49351)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49409) {
                if (e < 49380) {
                  if (e < 49353) {
                    if (e === 49352)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49353 <= e && e <= 49379)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49381) {
                  if (e === 49380)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49408) {
                  if (49381 <= e && e <= 49407)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49408)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49464) {
                if (e < 49436) {
                  if (49409 <= e && e <= 49435)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49437) {
                  if (e === 49436)
                    return t.CLUSTER_BREAK.LV;
                } else if (49437 <= e && e <= 49463)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49465) {
                if (e === 49464)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49492) {
                if (49465 <= e && e <= 49491)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 49492)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 49800) {
              if (e < 49633) {
                if (e < 49576) {
                  if (e < 49521) {
                    if (e < 49520) {
                      if (49493 <= e && e <= 49519)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 49520)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49548) {
                    if (49521 <= e && e <= 49547)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49549) {
                    if (e === 49548)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49549 <= e && e <= 49575)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49604) {
                  if (e < 49577) {
                    if (e === 49576)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49577 <= e && e <= 49603)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49605) {
                  if (e === 49604)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49632) {
                  if (49605 <= e && e <= 49631)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49632)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49716) {
                if (e < 49661) {
                  if (e < 49660) {
                    if (49633 <= e && e <= 49659)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49660)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49688) {
                  if (49661 <= e && e <= 49687)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49689) {
                  if (e === 49688)
                    return t.CLUSTER_BREAK.LV;
                } else if (49689 <= e && e <= 49715)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49745) {
                if (e < 49717) {
                  if (e === 49716)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49744) {
                  if (49717 <= e && e <= 49743)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49744)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49772) {
                if (49745 <= e && e <= 49771)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49773) {
                if (e === 49772)
                  return t.CLUSTER_BREAK.LV;
              } else if (49773 <= e && e <= 49799)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 49941) {
              if (e < 49857) {
                if (e < 49828) {
                  if (e < 49801) {
                    if (e === 49800)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49801 <= e && e <= 49827)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49829) {
                  if (e === 49828)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49856) {
                  if (49829 <= e && e <= 49855)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49856)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49912) {
                if (e < 49884) {
                  if (49857 <= e && e <= 49883)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49885) {
                  if (e === 49884)
                    return t.CLUSTER_BREAK.LV;
                } else if (49885 <= e && e <= 49911)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49913) {
                if (e === 49912)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49940) {
                if (49913 <= e && e <= 49939)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 49940)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50024) {
              if (e < 49969) {
                if (e < 49968) {
                  if (49941 <= e && e <= 49967)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49968)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49996) {
                if (49969 <= e && e <= 49995)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49997) {
                if (e === 49996)
                  return t.CLUSTER_BREAK.LV;
              } else if (49997 <= e && e <= 50023)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50053) {
              if (e < 50025) {
                if (e === 50024)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50052) {
                if (50025 <= e && e <= 50051)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50052)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50080) {
              if (50053 <= e && e <= 50079)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50081) {
              if (e === 50080)
                return t.CLUSTER_BREAK.LV;
            } else if (50081 <= e && e <= 50107)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 50697) {
            if (e < 50389) {
              if (e < 50248) {
                if (e < 50165) {
                  if (e < 50136) {
                    if (e < 50109) {
                      if (e === 50108)
                        return t.CLUSTER_BREAK.LV;
                    } else if (50109 <= e && e <= 50135)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 50137) {
                    if (e === 50136)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 50164) {
                    if (50137 <= e && e <= 50163)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50164)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50193) {
                  if (e < 50192) {
                    if (50165 <= e && e <= 50191)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50192)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50220) {
                  if (50193 <= e && e <= 50219)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50221) {
                  if (e === 50220)
                    return t.CLUSTER_BREAK.LV;
                } else if (50221 <= e && e <= 50247)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50305) {
                if (e < 50276) {
                  if (e < 50249) {
                    if (e === 50248)
                      return t.CLUSTER_BREAK.LV;
                  } else if (50249 <= e && e <= 50275)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50277) {
                  if (e === 50276)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50304) {
                  if (50277 <= e && e <= 50303)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50304)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50360) {
                if (e < 50332) {
                  if (50305 <= e && e <= 50331)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50333) {
                  if (e === 50332)
                    return t.CLUSTER_BREAK.LV;
                } else if (50333 <= e && e <= 50359)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50361) {
                if (e === 50360)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50388) {
                if (50361 <= e && e <= 50387)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50388)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50556) {
              if (e < 50472) {
                if (e < 50417) {
                  if (e < 50416) {
                    if (50389 <= e && e <= 50415)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50416)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50444) {
                  if (50417 <= e && e <= 50443)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50445) {
                  if (e === 50444)
                    return t.CLUSTER_BREAK.LV;
                } else if (50445 <= e && e <= 50471)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50501) {
                if (e < 50473) {
                  if (e === 50472)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50500) {
                  if (50473 <= e && e <= 50499)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50500)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50528) {
                if (50501 <= e && e <= 50527)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50529) {
                if (e === 50528)
                  return t.CLUSTER_BREAK.LV;
              } else if (50529 <= e && e <= 50555)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50613) {
              if (e < 50584) {
                if (e < 50557) {
                  if (e === 50556)
                    return t.CLUSTER_BREAK.LV;
                } else if (50557 <= e && e <= 50583)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50585) {
                if (e === 50584)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50612) {
                if (50585 <= e && e <= 50611)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50612)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50668) {
              if (e < 50640) {
                if (50613 <= e && e <= 50639)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50641) {
                if (e === 50640)
                  return t.CLUSTER_BREAK.LV;
              } else if (50641 <= e && e <= 50667)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50669) {
              if (e === 50668)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50696) {
              if (50669 <= e && e <= 50695)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 50696)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51004) {
            if (e < 50837) {
              if (e < 50780) {
                if (e < 50725) {
                  if (e < 50724) {
                    if (50697 <= e && e <= 50723)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50724)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50752) {
                  if (50725 <= e && e <= 50751)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50753) {
                  if (e === 50752)
                    return t.CLUSTER_BREAK.LV;
                } else if (50753 <= e && e <= 50779)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50808) {
                if (e < 50781) {
                  if (e === 50780)
                    return t.CLUSTER_BREAK.LV;
                } else if (50781 <= e && e <= 50807)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50809) {
                if (e === 50808)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50836) {
                if (50809 <= e && e <= 50835)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50836)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50920) {
              if (e < 50865) {
                if (e < 50864) {
                  if (50837 <= e && e <= 50863)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50864)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50892) {
                if (50865 <= e && e <= 50891)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50893) {
                if (e === 50892)
                  return t.CLUSTER_BREAK.LV;
              } else if (50893 <= e && e <= 50919)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50949) {
              if (e < 50921) {
                if (e === 50920)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50948) {
                if (50921 <= e && e <= 50947)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50948)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50976) {
              if (50949 <= e && e <= 50975)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50977) {
              if (e === 50976)
                return t.CLUSTER_BREAK.LV;
            } else if (50977 <= e && e <= 51003)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51145) {
            if (e < 51061) {
              if (e < 51032) {
                if (e < 51005) {
                  if (e === 51004)
                    return t.CLUSTER_BREAK.LV;
                } else if (51005 <= e && e <= 51031)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51033) {
                if (e === 51032)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51060) {
                if (51033 <= e && e <= 51059)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51060)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51116) {
              if (e < 51088) {
                if (51061 <= e && e <= 51087)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51089) {
                if (e === 51088)
                  return t.CLUSTER_BREAK.LV;
              } else if (51089 <= e && e <= 51115)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51117) {
              if (e === 51116)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51144) {
              if (51117 <= e && e <= 51143)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51144)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51228) {
            if (e < 51173) {
              if (e < 51172) {
                if (51145 <= e && e <= 51171)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51172)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51200) {
              if (51173 <= e && e <= 51199)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51201) {
              if (e === 51200)
                return t.CLUSTER_BREAK.LV;
            } else if (51201 <= e && e <= 51227)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51257) {
            if (e < 51229) {
              if (e === 51228)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51256) {
              if (51229 <= e && e <= 51255)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51256)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51284) {
            if (51257 <= e && e <= 51283)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51285) {
            if (e === 51284)
              return t.CLUSTER_BREAK.LV;
          } else if (51285 <= e && e <= 51311)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 52516) {
          if (e < 51901) {
            if (e < 51593) {
              if (e < 51452) {
                if (e < 51369) {
                  if (e < 51340) {
                    if (e < 51313) {
                      if (e === 51312)
                        return t.CLUSTER_BREAK.LV;
                    } else if (51313 <= e && e <= 51339)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 51341) {
                    if (e === 51340)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 51368) {
                    if (51341 <= e && e <= 51367)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51368)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51397) {
                  if (e < 51396) {
                    if (51369 <= e && e <= 51395)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51396)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51424) {
                  if (51397 <= e && e <= 51423)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51425) {
                  if (e === 51424)
                    return t.CLUSTER_BREAK.LV;
                } else if (51425 <= e && e <= 51451)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51509) {
                if (e < 51480) {
                  if (e < 51453) {
                    if (e === 51452)
                      return t.CLUSTER_BREAK.LV;
                  } else if (51453 <= e && e <= 51479)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51481) {
                  if (e === 51480)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51508) {
                  if (51481 <= e && e <= 51507)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 51508)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51564) {
                if (e < 51536) {
                  if (51509 <= e && e <= 51535)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51537) {
                  if (e === 51536)
                    return t.CLUSTER_BREAK.LV;
                } else if (51537 <= e && e <= 51563)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51565) {
                if (e === 51564)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51592) {
                if (51565 <= e && e <= 51591)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51592)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51760) {
              if (e < 51676) {
                if (e < 51621) {
                  if (e < 51620) {
                    if (51593 <= e && e <= 51619)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51620)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51648) {
                  if (51621 <= e && e <= 51647)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51649) {
                  if (e === 51648)
                    return t.CLUSTER_BREAK.LV;
                } else if (51649 <= e && e <= 51675)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51705) {
                if (e < 51677) {
                  if (e === 51676)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51704) {
                  if (51677 <= e && e <= 51703)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 51704)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51732) {
                if (51705 <= e && e <= 51731)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51733) {
                if (e === 51732)
                  return t.CLUSTER_BREAK.LV;
              } else if (51733 <= e && e <= 51759)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51817) {
              if (e < 51788) {
                if (e < 51761) {
                  if (e === 51760)
                    return t.CLUSTER_BREAK.LV;
                } else if (51761 <= e && e <= 51787)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51789) {
                if (e === 51788)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51816) {
                if (51789 <= e && e <= 51815)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51816)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51872) {
              if (e < 51844) {
                if (51817 <= e && e <= 51843)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51845) {
                if (e === 51844)
                  return t.CLUSTER_BREAK.LV;
              } else if (51845 <= e && e <= 51871)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51873) {
              if (e === 51872)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51900) {
              if (51873 <= e && e <= 51899)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51900)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52208) {
            if (e < 52041) {
              if (e < 51984) {
                if (e < 51929) {
                  if (e < 51928) {
                    if (51901 <= e && e <= 51927)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51928)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51956) {
                  if (51929 <= e && e <= 51955)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51957) {
                  if (e === 51956)
                    return t.CLUSTER_BREAK.LV;
                } else if (51957 <= e && e <= 51983)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52012) {
                if (e < 51985) {
                  if (e === 51984)
                    return t.CLUSTER_BREAK.LV;
                } else if (51985 <= e && e <= 52011)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52013) {
                if (e === 52012)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52040) {
                if (52013 <= e && e <= 52039)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52040)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52124) {
              if (e < 52069) {
                if (e < 52068) {
                  if (52041 <= e && e <= 52067)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52068)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52096) {
                if (52069 <= e && e <= 52095)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52097) {
                if (e === 52096)
                  return t.CLUSTER_BREAK.LV;
              } else if (52097 <= e && e <= 52123)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52153) {
              if (e < 52125) {
                if (e === 52124)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52152) {
                if (52125 <= e && e <= 52151)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52152)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52180) {
              if (52153 <= e && e <= 52179)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52181) {
              if (e === 52180)
                return t.CLUSTER_BREAK.LV;
            } else if (52181 <= e && e <= 52207)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52349) {
            if (e < 52265) {
              if (e < 52236) {
                if (e < 52209) {
                  if (e === 52208)
                    return t.CLUSTER_BREAK.LV;
                } else if (52209 <= e && e <= 52235)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52237) {
                if (e === 52236)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52264) {
                if (52237 <= e && e <= 52263)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52264)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52320) {
              if (e < 52292) {
                if (52265 <= e && e <= 52291)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52293) {
                if (e === 52292)
                  return t.CLUSTER_BREAK.LV;
              } else if (52293 <= e && e <= 52319)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52321) {
              if (e === 52320)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52348) {
              if (52321 <= e && e <= 52347)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52348)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52432) {
            if (e < 52377) {
              if (e < 52376) {
                if (52349 <= e && e <= 52375)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52376)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52404) {
              if (52377 <= e && e <= 52403)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52405) {
              if (e === 52404)
                return t.CLUSTER_BREAK.LV;
            } else if (52405 <= e && e <= 52431)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52461) {
            if (e < 52433) {
              if (e === 52432)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52460) {
              if (52433 <= e && e <= 52459)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52460)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52488) {
            if (52461 <= e && e <= 52487)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52489) {
            if (e === 52488)
              return t.CLUSTER_BREAK.LV;
          } else if (52489 <= e && e <= 52515)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53105) {
          if (e < 52797) {
            if (e < 52656) {
              if (e < 52573) {
                if (e < 52544) {
                  if (e < 52517) {
                    if (e === 52516)
                      return t.CLUSTER_BREAK.LV;
                  } else if (52517 <= e && e <= 52543)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 52545) {
                  if (e === 52544)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 52572) {
                  if (52545 <= e && e <= 52571)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52572)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52601) {
                if (e < 52600) {
                  if (52573 <= e && e <= 52599)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52600)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52628) {
                if (52601 <= e && e <= 52627)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52629) {
                if (e === 52628)
                  return t.CLUSTER_BREAK.LV;
              } else if (52629 <= e && e <= 52655)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52713) {
              if (e < 52684) {
                if (e < 52657) {
                  if (e === 52656)
                    return t.CLUSTER_BREAK.LV;
                } else if (52657 <= e && e <= 52683)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52685) {
                if (e === 52684)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52712) {
                if (52685 <= e && e <= 52711)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52712)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52768) {
              if (e < 52740) {
                if (52713 <= e && e <= 52739)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52741) {
                if (e === 52740)
                  return t.CLUSTER_BREAK.LV;
              } else if (52741 <= e && e <= 52767)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52769) {
              if (e === 52768)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52796) {
              if (52769 <= e && e <= 52795)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52796)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52964) {
            if (e < 52880) {
              if (e < 52825) {
                if (e < 52824) {
                  if (52797 <= e && e <= 52823)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52824)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52852) {
                if (52825 <= e && e <= 52851)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52853) {
                if (e === 52852)
                  return t.CLUSTER_BREAK.LV;
              } else if (52853 <= e && e <= 52879)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52909) {
              if (e < 52881) {
                if (e === 52880)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52908) {
                if (52881 <= e && e <= 52907)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52908)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52936) {
              if (52909 <= e && e <= 52935)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52937) {
              if (e === 52936)
                return t.CLUSTER_BREAK.LV;
            } else if (52937 <= e && e <= 52963)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53021) {
            if (e < 52992) {
              if (e < 52965) {
                if (e === 52964)
                  return t.CLUSTER_BREAK.LV;
              } else if (52965 <= e && e <= 52991)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52993) {
              if (e === 52992)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53020) {
              if (52993 <= e && e <= 53019)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53020)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53076) {
            if (e < 53048) {
              if (53021 <= e && e <= 53047)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53049) {
              if (e === 53048)
                return t.CLUSTER_BREAK.LV;
            } else if (53049 <= e && e <= 53075)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53077) {
            if (e === 53076)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53104) {
            if (53077 <= e && e <= 53103)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53104)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53412) {
          if (e < 53245) {
            if (e < 53188) {
              if (e < 53133) {
                if (e < 53132) {
                  if (53105 <= e && e <= 53131)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 53132)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 53160) {
                if (53133 <= e && e <= 53159)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53161) {
                if (e === 53160)
                  return t.CLUSTER_BREAK.LV;
              } else if (53161 <= e && e <= 53187)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53216) {
              if (e < 53189) {
                if (e === 53188)
                  return t.CLUSTER_BREAK.LV;
              } else if (53189 <= e && e <= 53215)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53217) {
              if (e === 53216)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53244) {
              if (53217 <= e && e <= 53243)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53244)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53328) {
            if (e < 53273) {
              if (e < 53272) {
                if (53245 <= e && e <= 53271)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 53272)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53300) {
              if (53273 <= e && e <= 53299)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53301) {
              if (e === 53300)
                return t.CLUSTER_BREAK.LV;
            } else if (53301 <= e && e <= 53327)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53357) {
            if (e < 53329) {
              if (e === 53328)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53356) {
              if (53329 <= e && e <= 53355)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53356)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53384) {
            if (53357 <= e && e <= 53383)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53385) {
            if (e === 53384)
              return t.CLUSTER_BREAK.LV;
          } else if (53385 <= e && e <= 53411)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53553) {
          if (e < 53469) {
            if (e < 53440) {
              if (e < 53413) {
                if (e === 53412)
                  return t.CLUSTER_BREAK.LV;
              } else if (53413 <= e && e <= 53439)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53441) {
              if (e === 53440)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53468) {
              if (53441 <= e && e <= 53467)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53468)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53524) {
            if (e < 53496) {
              if (53469 <= e && e <= 53495)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53497) {
              if (e === 53496)
                return t.CLUSTER_BREAK.LV;
            } else if (53497 <= e && e <= 53523)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53525) {
            if (e === 53524)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53552) {
            if (53525 <= e && e <= 53551)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53552)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53636) {
          if (e < 53581) {
            if (e < 53580) {
              if (53553 <= e && e <= 53579)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53580)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53608) {
            if (53581 <= e && e <= 53607)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53609) {
            if (e === 53608)
              return t.CLUSTER_BREAK.LV;
          } else if (53609 <= e && e <= 53635)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53665) {
          if (e < 53637) {
            if (e === 53636)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53664) {
            if (53637 <= e && e <= 53663)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53664)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53692) {
          if (53665 <= e && e <= 53691)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53693) {
          if (e === 53692)
            return t.CLUSTER_BREAK.LV;
        } else if (53693 <= e && e <= 53719)
          return t.CLUSTER_BREAK.LVT;
      } else if (e < 70459) {
        if (e < 54897) {
          if (e < 54308) {
            if (e < 54001) {
              if (e < 53860) {
                if (e < 53777) {
                  if (e < 53748) {
                    if (e < 53721) {
                      if (e === 53720)
                        return t.CLUSTER_BREAK.LV;
                    } else if (53721 <= e && e <= 53747)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 53749) {
                    if (e === 53748)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 53776) {
                    if (53749 <= e && e <= 53775)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 53776)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53805) {
                  if (e < 53804) {
                    if (53777 <= e && e <= 53803)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 53804)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53832) {
                  if (53805 <= e && e <= 53831)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53833) {
                  if (e === 53832)
                    return t.CLUSTER_BREAK.LV;
                } else if (53833 <= e && e <= 53859)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53917) {
                if (e < 53888) {
                  if (e < 53861) {
                    if (e === 53860)
                      return t.CLUSTER_BREAK.LV;
                  } else if (53861 <= e && e <= 53887)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53889) {
                  if (e === 53888)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53916) {
                  if (53889 <= e && e <= 53915)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 53916)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 53972) {
                if (e < 53944) {
                  if (53917 <= e && e <= 53943)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53945) {
                  if (e === 53944)
                    return t.CLUSTER_BREAK.LV;
                } else if (53945 <= e && e <= 53971)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53973) {
                if (e === 53972)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54e3) {
                if (53973 <= e && e <= 53999)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54e3)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54141) {
              if (e < 54084) {
                if (e < 54029) {
                  if (e < 54028) {
                    if (54001 <= e && e <= 54027)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 54028)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54056) {
                  if (54029 <= e && e <= 54055)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54057) {
                  if (e === 54056)
                    return t.CLUSTER_BREAK.LV;
                } else if (54057 <= e && e <= 54083)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54112) {
                if (e < 54085) {
                  if (e === 54084)
                    return t.CLUSTER_BREAK.LV;
                } else if (54085 <= e && e <= 54111)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54113) {
                if (e === 54112)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54140) {
                if (54113 <= e && e <= 54139)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54140)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54224) {
              if (e < 54169) {
                if (e < 54168) {
                  if (54141 <= e && e <= 54167)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54168)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54196) {
                if (54169 <= e && e <= 54195)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54197) {
                if (e === 54196)
                  return t.CLUSTER_BREAK.LV;
              } else if (54197 <= e && e <= 54223)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54253) {
              if (e < 54225) {
                if (e === 54224)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54252) {
                if (54225 <= e && e <= 54251)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54252)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54280) {
              if (54253 <= e && e <= 54279)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54281) {
              if (e === 54280)
                return t.CLUSTER_BREAK.LV;
            } else if (54281 <= e && e <= 54307)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54589) {
            if (e < 54448) {
              if (e < 54365) {
                if (e < 54336) {
                  if (e < 54309) {
                    if (e === 54308)
                      return t.CLUSTER_BREAK.LV;
                  } else if (54309 <= e && e <= 54335)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54337) {
                  if (e === 54336)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54364) {
                  if (54337 <= e && e <= 54363)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54364)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54393) {
                if (e < 54392) {
                  if (54365 <= e && e <= 54391)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54392)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54420) {
                if (54393 <= e && e <= 54419)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54421) {
                if (e === 54420)
                  return t.CLUSTER_BREAK.LV;
              } else if (54421 <= e && e <= 54447)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54505) {
              if (e < 54476) {
                if (e < 54449) {
                  if (e === 54448)
                    return t.CLUSTER_BREAK.LV;
                } else if (54449 <= e && e <= 54475)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54477) {
                if (e === 54476)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54504) {
                if (54477 <= e && e <= 54503)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54504)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54560) {
              if (e < 54532) {
                if (54505 <= e && e <= 54531)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54533) {
                if (e === 54532)
                  return t.CLUSTER_BREAK.LV;
              } else if (54533 <= e && e <= 54559)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54561) {
              if (e === 54560)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54588) {
              if (54561 <= e && e <= 54587)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 54588)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54756) {
            if (e < 54672) {
              if (e < 54617) {
                if (e < 54616) {
                  if (54589 <= e && e <= 54615)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54616)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54644) {
                if (54617 <= e && e <= 54643)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54645) {
                if (e === 54644)
                  return t.CLUSTER_BREAK.LV;
              } else if (54645 <= e && e <= 54671)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54701) {
              if (e < 54673) {
                if (e === 54672)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54700) {
                if (54673 <= e && e <= 54699)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54700)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54728) {
              if (54701 <= e && e <= 54727)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54729) {
              if (e === 54728)
                return t.CLUSTER_BREAK.LV;
            } else if (54729 <= e && e <= 54755)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54813) {
            if (e < 54784) {
              if (e < 54757) {
                if (e === 54756)
                  return t.CLUSTER_BREAK.LV;
              } else if (54757 <= e && e <= 54783)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54785) {
              if (e === 54784)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54812) {
              if (54785 <= e && e <= 54811)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 54812)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54868) {
            if (e < 54840) {
              if (54813 <= e && e <= 54839)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54841) {
              if (e === 54840)
                return t.CLUSTER_BREAK.LV;
            } else if (54841 <= e && e <= 54867)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54869) {
            if (e === 54868)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54896) {
            if (54869 <= e && e <= 54895)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 54896)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 69632) {
          if (e < 55216) {
            if (e < 55037) {
              if (e < 54980) {
                if (e < 54925) {
                  if (e < 54924) {
                    if (54897 <= e && e <= 54923)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 54924)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54952) {
                  if (54925 <= e && e <= 54951)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54953) {
                  if (e === 54952)
                    return t.CLUSTER_BREAK.LV;
                } else if (54953 <= e && e <= 54979)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55008) {
                if (e < 54981) {
                  if (e === 54980)
                    return t.CLUSTER_BREAK.LV;
                } else if (54981 <= e && e <= 55007)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55009) {
                if (e === 55008)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55036) {
                if (55009 <= e && e <= 55035)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 55036)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 55120) {
              if (e < 55065) {
                if (e < 55064) {
                  if (55037 <= e && e <= 55063)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 55064)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55092) {
                if (55065 <= e && e <= 55091)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55093) {
                if (e === 55092)
                  return t.CLUSTER_BREAK.LV;
              } else if (55093 <= e && e <= 55119)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 55149) {
              if (e < 55121) {
                if (e === 55120)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55148) {
                if (55121 <= e && e <= 55147)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 55148)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 55176) {
              if (55149 <= e && e <= 55175)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 55177) {
              if (e === 55176)
                return t.CLUSTER_BREAK.LV;
            } else if (55177 <= e && e <= 55203)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 68097) {
            if (e < 65279) {
              if (e < 64286) {
                if (e < 55243) {
                  if (55216 <= e && e <= 55238)
                    return t.CLUSTER_BREAK.V;
                } else if (55243 <= e && e <= 55291)
                  return t.CLUSTER_BREAK.T;
              } else if (e < 65024) {
                if (e === 64286)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 65056) {
                if (65024 <= e && e <= 65039)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (65056 <= e && e <= 65071)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 66045) {
              if (e < 65438) {
                if (e === 65279)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 65520) {
                if (65438 <= e && e <= 65439)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (65520 <= e && e <= 65531)
                return t.CLUSTER_BREAK.CONTROL;
            } else if (e < 66272) {
              if (e === 66045)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 66422) {
              if (e === 66272)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (66422 <= e && e <= 66426)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 68325) {
            if (e < 68108) {
              if (e < 68101) {
                if (68097 <= e && e <= 68099)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (68101 <= e && e <= 68102)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 68152) {
              if (68108 <= e && e <= 68111)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 68159) {
              if (68152 <= e && e <= 68154)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 68159)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69373) {
            if (e < 68900) {
              if (68325 <= e && e <= 68326)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69291) {
              if (68900 <= e && e <= 68903)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (69291 <= e && e <= 69292)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69446) {
            if (69373 <= e && e <= 69375)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69506) {
            if (69446 <= e && e <= 69456)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (69506 <= e && e <= 69509)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70016) {
          if (e < 69815) {
            if (e < 69747) {
              if (e < 69634) {
                if (e === 69632)
                  return t.CLUSTER_BREAK.SPACINGMARK;
                if (e === 69633)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 69688) {
                if (e === 69634)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 69744) {
                if (69688 <= e && e <= 69702)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 69744)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69762) {
              if (e < 69759) {
                if (69747 <= e && e <= 69748)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (69759 <= e && e <= 69761)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69808) {
              if (e === 69762)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69811) {
              if (69808 <= e && e <= 69810)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (69811 <= e && e <= 69814)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69888)
            if (e < 69821) {
              if (e < 69817) {
                if (69815 <= e && e <= 69816)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (69817 <= e && e <= 69818)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69826) {
              if (e === 69821)
                return t.CLUSTER_BREAK.PREPEND;
            } else {
              if (e === 69826)
                return t.CLUSTER_BREAK.EXTEND;
              if (e === 69837)
                return t.CLUSTER_BREAK.PREPEND;
            }
          else if (e < 69933) {
            if (e < 69927) {
              if (69888 <= e && e <= 69890)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69932) {
              if (69927 <= e && e <= 69931)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 69932)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69957) {
            if (69933 <= e && e <= 69940)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70003) {
            if (69957 <= e && e <= 69958)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70003)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70194) {
          if (e < 70082) {
            if (e < 70067) {
              if (e < 70018) {
                if (70016 <= e && e <= 70017)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 70018)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70070) {
              if (70067 <= e && e <= 70069)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70079) {
              if (70070 <= e && e <= 70078)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (70079 <= e && e <= 70080)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70095) {
            if (e < 70089) {
              if (70082 <= e && e <= 70083)
                return t.CLUSTER_BREAK.PREPEND;
            } else if (e < 70094) {
              if (70089 <= e && e <= 70092)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 70094)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70188) {
            if (e === 70095)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70191) {
            if (70188 <= e && e <= 70190)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (70191 <= e && e <= 70193)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70209) {
          if (e < 70197) {
            if (e < 70196) {
              if (70194 <= e && e <= 70195)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70196)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70198) {
            if (e === 70197)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70206) {
            if (70198 <= e && e <= 70199)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e === 70206)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70371) {
          if (e < 70367) {
            if (e === 70209)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70368) {
            if (e === 70367)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (70368 <= e && e <= 70370)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70400) {
          if (70371 <= e && e <= 70378)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70402) {
          if (70400 <= e && e <= 70401)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (70402 <= e && e <= 70403)
          return t.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72343) {
        if (e < 71339) {
          if (e < 70841) {
            if (e < 70512) {
              if (e < 70471) {
                if (e < 70463) {
                  if (e < 70462) {
                    if (70459 <= e && e <= 70460)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 70462)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 70464) {
                  if (e === 70463)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 70465) {
                  if (e === 70464)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (70465 <= e && e <= 70468)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70487) {
                if (e < 70475) {
                  if (70471 <= e && e <= 70472)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (70475 <= e && e <= 70477)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70498) {
                if (e === 70487)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70502) {
                if (70498 <= e && e <= 70499)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70502 <= e && e <= 70508)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70725) {
              if (e < 70712) {
                if (e < 70709) {
                  if (70512 <= e && e <= 70516)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (70709 <= e && e <= 70711)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70720) {
                if (70712 <= e && e <= 70719)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70722) {
                if (70720 <= e && e <= 70721)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70722 <= e && e <= 70724)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70832) {
              if (e < 70726) {
                if (e === 70725)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 70726 || e === 70750)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70833) {
              if (e === 70832)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70835) {
              if (70833 <= e && e <= 70834)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (70835 <= e && e <= 70840)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71096) {
            if (e < 70847)
              if (e < 70843) {
                if (e === 70841)
                  return t.CLUSTER_BREAK.SPACINGMARK;
                if (e === 70842)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70845) {
                if (70843 <= e && e <= 70844)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 70845)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 70846)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 71087) {
              if (e < 70849) {
                if (70847 <= e && e <= 70848)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70850) {
                if (e === 70849)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70850 <= e && e <= 70851)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71088) {
              if (e === 71087)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71090) {
              if (71088 <= e && e <= 71089)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71090 <= e && e <= 71093)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71216) {
            if (e < 71102) {
              if (e < 71100) {
                if (71096 <= e && e <= 71099)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (71100 <= e && e <= 71101)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71103) {
              if (e === 71102)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71132) {
              if (71103 <= e && e <= 71104)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (71132 <= e && e <= 71133)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71229) {
            if (e < 71219) {
              if (71216 <= e && e <= 71218)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71227) {
              if (71219 <= e && e <= 71226)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (71227 <= e && e <= 71228)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71230) {
            if (e === 71229)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71231) {
            if (e === 71230)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (71231 <= e && e <= 71232)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 71999)
          if (e < 71463) {
            if (e < 71350) {
              if (e < 71341) {
                if (e === 71339)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 71340)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 71342) {
                if (e === 71341)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 71344) {
                if (71342 <= e && e <= 71343)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (71344 <= e && e <= 71349)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71453) {
              if (e === 71350)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 71351)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71458) {
              if (71453 <= e && e <= 71455)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71462) {
              if (71458 <= e && e <= 71461)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 71462)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71984) {
            if (e < 71727) {
              if (e < 71724) {
                if (71463 <= e && e <= 71467)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (71724 <= e && e <= 71726)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71736) {
              if (71727 <= e && e <= 71735)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71737) {
              if (e === 71736)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71737 <= e && e <= 71738)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71995) {
            if (e < 71985) {
              if (e === 71984)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71991) {
              if (71985 <= e && e <= 71989)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71991 <= e && e <= 71992)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71997) {
            if (71995 <= e && e <= 71996)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 71997)
              return t.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71998)
              return t.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72193)
          if (e < 72145)
            if (e < 72001) {
              if (e === 71999)
                return t.CLUSTER_BREAK.PREPEND;
              if (e === 72e3)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72002) {
              if (e === 72001)
                return t.CLUSTER_BREAK.PREPEND;
            } else {
              if (e === 72002)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 72003)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 72156) {
            if (e < 72148) {
              if (72145 <= e && e <= 72147)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72154) {
              if (72148 <= e && e <= 72151)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (72154 <= e && e <= 72155)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72160) {
            if (72156 <= e && e <= 72159)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 72160)
              return t.CLUSTER_BREAK.EXTEND;
            if (e === 72164)
              return t.CLUSTER_BREAK.SPACINGMARK;
          }
        else if (e < 72263) {
          if (e < 72249) {
            if (e < 72243) {
              if (72193 <= e && e <= 72202)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (72243 <= e && e <= 72248)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72250) {
            if (e === 72249)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72251) {
            if (e === 72250)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (72251 <= e && e <= 72254)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 72281) {
          if (e < 72273) {
            if (e === 72263)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72279) {
            if (72273 <= e && e <= 72278)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (72279 <= e && e <= 72280)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72324) {
          if (72281 <= e && e <= 72283)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 72330) {
          if (72324 <= e && e <= 72329)
            return t.CLUSTER_BREAK.PREPEND;
        } else if (72330 <= e && e <= 72342)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 94033) {
        if (e < 73104) {
          if (e < 72881) {
            if (e < 72766) {
              if (e < 72751) {
                if (e < 72344) {
                  if (e === 72343)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (72344 <= e && e <= 72345)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 72752) {
                if (e === 72751)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 72760) {
                if (72752 <= e && e <= 72758)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (72760 <= e && e <= 72765)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72850) {
              if (e === 72766)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 72767)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72873) {
              if (72850 <= e && e <= 72871)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72874) {
              if (e === 72873)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (72874 <= e && e <= 72880)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73018) {
            if (e < 72884) {
              if (e < 72882) {
                if (e === 72881)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (72882 <= e && e <= 72883)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72885) {
              if (e === 72884)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 73009) {
              if (72885 <= e && e <= 72886)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73009 <= e && e <= 73014)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73030) {
            if (e < 73020) {
              if (e === 73018)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 73023) {
              if (73020 <= e && e <= 73021)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73023 <= e && e <= 73029)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73031) {
            if (e === 73030)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (e < 73098) {
            if (e === 73031)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (73098 <= e && e <= 73102)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73526) {
          if (e < 73459)
            if (e < 73109) {
              if (e < 73107) {
                if (73104 <= e && e <= 73105)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (73107 <= e && e <= 73108)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 73110) {
              if (e === 73109)
                return t.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 73110)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 73111)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 73474) {
            if (e < 73461) {
              if (73459 <= e && e <= 73460)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 73472) {
              if (73461 <= e && e <= 73462)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (73472 <= e && e <= 73473)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73475) {
            if (e === 73474)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (e < 73524) {
            if (e === 73475)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (73524 <= e && e <= 73525)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 78896)
          if (e < 73536) {
            if (e < 73534) {
              if (73526 <= e && e <= 73530)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73534 <= e && e <= 73535)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73537) {
            if (e === 73536)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73537)
              return t.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73538)
              return t.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 92912) {
          if (e < 78912) {
            if (78896 <= e && e <= 78911)
              return t.CLUSTER_BREAK.CONTROL;
          } else if (e < 78919) {
            if (e === 78912)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (78919 <= e && e <= 78933)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 92976) {
          if (92912 <= e && e <= 92916)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 94031) {
          if (92976 <= e && e <= 92982)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 94031)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 121476) {
        if (e < 119143)
          if (e < 113824) {
            if (e < 94180) {
              if (e < 94095) {
                if (94033 <= e && e <= 94087)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (94095 <= e && e <= 94098)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 94192) {
              if (e === 94180)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 113821) {
              if (94192 <= e && e <= 94193)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (113821 <= e && e <= 113822)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 118576) {
            if (e < 118528) {
              if (113824 <= e && e <= 113827)
                return t.CLUSTER_BREAK.CONTROL;
            } else if (118528 <= e && e <= 118573)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119141) {
            if (118576 <= e && e <= 118598)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 119141)
              return t.CLUSTER_BREAK.EXTEND;
            if (e === 119142)
              return t.CLUSTER_BREAK.SPACINGMARK;
          }
        else if (e < 119173) {
          if (e < 119150) {
            if (e < 119149) {
              if (119143 <= e && e <= 119145)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 119149)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 119155) {
            if (119150 <= e && e <= 119154)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119163) {
            if (119155 <= e && e <= 119162)
              return t.CLUSTER_BREAK.CONTROL;
          } else if (119163 <= e && e <= 119170)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121344) {
          if (e < 119210) {
            if (119173 <= e && e <= 119179)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119362) {
            if (119210 <= e && e <= 119213)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (119362 <= e && e <= 119364)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121403) {
          if (121344 <= e && e <= 121398)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121461) {
          if (121403 <= e && e <= 121452)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 121461)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 123628) {
        if (e < 122907) {
          if (e < 121505) {
            if (e < 121499) {
              if (e === 121476)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (121499 <= e && e <= 121503)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122880) {
            if (121505 <= e && e <= 121519)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122888) {
            if (122880 <= e && e <= 122886)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (122888 <= e && e <= 122904)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123023) {
          if (e < 122915) {
            if (122907 <= e && e <= 122913)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122918) {
            if (122915 <= e && e <= 122916)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (122918 <= e && e <= 122922)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123184) {
          if (e === 123023)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123566) {
          if (123184 <= e && e <= 123190)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 123566)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 127995) {
        if (e < 125136) {
          if (e < 124140) {
            if (123628 <= e && e <= 123631)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (124140 <= e && e <= 124143)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 125252) {
          if (125136 <= e && e <= 125142)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 127462) {
          if (125252 <= e && e <= 125258)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (127462 <= e && e <= 127487)
          return t.CLUSTER_BREAK.REGIONAL_INDICATOR;
      } else if (e < 917632) {
        if (e < 917504) {
          if (127995 <= e && e <= 127999)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 917536) {
          if (917504 <= e && e <= 917535)
            return t.CLUSTER_BREAK.CONTROL;
        } else if (917536 <= e && e <= 917631)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 917760) {
        if (917632 <= e && e <= 917759)
          return t.CLUSTER_BREAK.CONTROL;
      } else if (e < 918e3) {
        if (917760 <= e && e <= 917999)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (918e3 <= e && e <= 921599)
        return t.CLUSTER_BREAK.CONTROL;
      return t.CLUSTER_BREAK.OTHER;
    }
    /**
     * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
     * @param code {number} Unicode code point
     * @returns {number}
     */
    static getEmojiProperty(e) {
      if (e < 10160) {
        if (e < 9728) {
          if (e < 9e3) {
            if (e < 8482) {
              if (e < 8252) {
                if (e === 169 || e === 174)
                  return t.EXTENDED_PICTOGRAPHIC;
              } else if (e === 8252 || e === 8265)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8596) {
              if (e === 8482 || e === 8505)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8617) {
              if (8596 <= e && e <= 8601)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8986) {
              if (8617 <= e && e <= 8618)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (8986 <= e && e <= 8987)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9410) {
            if (e < 9167) {
              if (e === 9e3 || e === 9096)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9193) {
              if (e === 9167)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9208) {
              if (9193 <= e && e <= 9203)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9208 <= e && e <= 9210)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9654) {
            if (e < 9642) {
              if (e === 9410)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9642 <= e && e <= 9643)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9664) {
            if (e === 9654)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9723) {
            if (e === 9664)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (9723 <= e && e <= 9726)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10035) {
          if (e < 10004) {
            if (e < 9748) {
              if (e < 9735) {
                if (9728 <= e && e <= 9733)
                  return t.EXTENDED_PICTOGRAPHIC;
              } else if (9735 <= e && e <= 9746)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9872) {
              if (9748 <= e && e <= 9861)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9992) {
              if (9872 <= e && e <= 9989)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9992 <= e && e <= 10002)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10013) {
            if (e === 10004 || e === 10006)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10017) {
            if (e === 10013)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10017 || e === 10024)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10067) {
          if (e < 10055) {
            if (e < 10052) {
              if (10035 <= e && e <= 10036)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 10052)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10060) {
            if (e === 10055)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10060 || e === 10062)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10083) {
          if (e < 10071) {
            if (10067 <= e && e <= 10069)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10071)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10133) {
          if (10083 <= e && e <= 10087)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10145) {
          if (10133 <= e && e <= 10135)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10145)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127489) {
        if (e < 12951) {
          if (e < 11035) {
            if (e < 10548) {
              if (e === 10160 || e === 10175)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 11013) {
              if (10548 <= e && e <= 10549)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (11013 <= e && e <= 11015)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11093) {
            if (e < 11088) {
              if (11035 <= e && e <= 11036)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 11088)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 12336) {
            if (e === 11093)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 12336 || e === 12349)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127340) {
          if (e < 126976) {
            if (e === 12951 || e === 12953)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127245) {
            if (126976 <= e && e <= 127231)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127279) {
            if (127245 <= e && e <= 127247)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127279)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127374) {
          if (e < 127358) {
            if (127340 <= e && e <= 127345)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (127358 <= e && e <= 127359)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127377) {
          if (e === 127374)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127405) {
          if (127377 <= e && e <= 127386)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (127405 <= e && e <= 127461)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128981) {
        if (e < 127561) {
          if (e < 127535) {
            if (e < 127514) {
              if (127489 <= e && e <= 127503)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 127514)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127538) {
            if (e === 127535)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127548) {
            if (127538 <= e && e <= 127546)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (127548 <= e && e <= 127551)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128326) {
          if (e < 128e3) {
            if (127561 <= e && e <= 127994)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (128e3 <= e && e <= 128317)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128640) {
          if (128326 <= e && e <= 128591)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128884) {
          if (128640 <= e && e <= 128767)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (128884 <= e && e <= 128895)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129198) {
        if (e < 129096) {
          if (e < 129036) {
            if (128981 <= e && e <= 129023)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (129036 <= e && e <= 129039)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 129114) {
          if (129096 <= e && e <= 129103)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 129160) {
          if (129114 <= e && e <= 129119)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (129160 <= e && e <= 129167)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129340) {
        if (e < 129292) {
          if (129198 <= e && e <= 129279)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (129292 <= e && e <= 129338)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129351) {
        if (129340 <= e && e <= 129349)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 130048) {
        if (129351 <= e && e <= 129791)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (130048 <= e && e <= 131069)
        return t.EXTENDED_PICTOGRAPHIC;
      return t.CLUSTER_BREAK.OTHER;
    }
  };
  return rn.default = r, rn;
}
var $m;
function gT() {
  if ($m) return tn;
  $m = 1;
  var i = this && this.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(tn, "__esModule", { value: !0 });
  const t = i(mT());
  return tn.default = t.default, tn;
}
var Ni, Gm;
function Sr() {
  if (Gm) return Ni;
  Gm = 1;
  const i = gT().default, t = /^[\u0000-\u007f]*$/u;
  let o;
  function f(u) {
    return u.length <= 1 ? u.toUpperCase() : u[0].toUpperCase() + u.slice(1);
  }
  function r(u) {
    return t.test(u) ? u.length : (o || (o = new i()), o.countGraphemes(u));
  }
  return Ni = {
    upperCaseFirst: f,
    getGraphemeCount: r
  }, Ni;
}
var Oi, Wm;
function dT() {
  if (Wm) return Oi;
  Wm = 1;
  const i = Re(), { upperCaseFirst: t } = Sr();
  return Oi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum cyclomatic complexity allowed in a program",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/complexity"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
      }
    },
    create(o) {
      const f = o.options[0];
      let r = 20;
      typeof f == "object" && (Object.prototype.hasOwnProperty.call(f, "maximum") || Object.prototype.hasOwnProperty.call(f, "max")) ? r = f.maximum || f.max : typeof f == "number" && (r = f);
      const u = [];
      function e() {
        u[u.length - 1]++;
      }
      return {
        onCodePathStart() {
          u.push(1);
        },
        // Each branching in the code adds 1 to the complexity
        CatchClause: e,
        ConditionalExpression: e,
        LogicalExpression: e,
        ForStatement: e,
        ForInStatement: e,
        ForOfStatement: e,
        IfStatement: e,
        WhileStatement: e,
        DoWhileStatement: e,
        // Avoid `default`
        "SwitchCase[test]": e,
        // Logical assignment operators have short-circuiting behavior
        AssignmentExpression(a) {
          i.isLogicalAssignmentOperator(a.operator) && e();
        },
        onCodePathEnd(a, n) {
          const p = u.pop();
          if (!(a.origin !== "function" && a.origin !== "class-field-initializer" && a.origin !== "class-static-block") && p > r) {
            let m;
            a.origin === "class-field-initializer" ? m = "class field initializer" : a.origin === "class-static-block" ? m = "class static block" : m = i.getFunctionNameWithKind(n), o.report({
              node: n,
              messageId: "complex",
              data: {
                name: t(m),
                complexity: p,
                max: r
              }
            });
          }
        }
      };
    }
  }, Oi;
}
var Ui, Xm;
function ET() {
  if (Xm) return Ui;
  Xm = 1;
  const i = Re();
  return Ui = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside computed property brackets",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/computed-property-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            enforceForClassMembers: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] === "always", r = !t.options[1] || t.options[1].enforceForClassMembers;
      function u(h, l, s) {
        t.report({
          node: h,
          loc: { start: l.loc.end, end: s.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: l.value
          },
          fix(c) {
            return c.removeRange([l.range[1], s.range[0]]);
          }
        });
      }
      function e(h, l, s) {
        t.report({
          node: h,
          loc: { start: s.loc.end, end: l.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: l.value
          },
          fix(c) {
            return c.removeRange([s.range[1], l.range[0]]);
          }
        });
      }
      function a(h, l) {
        t.report({
          node: h,
          loc: l.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: l.value
          },
          fix(s) {
            return s.insertTextAfter(l, " ");
          }
        });
      }
      function n(h, l) {
        t.report({
          node: h,
          loc: l.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: l.value
          },
          fix(s) {
            return s.insertTextBefore(l, " ");
          }
        });
      }
      function p(h) {
        return function(l) {
          if (!l.computed)
            return;
          const s = l[h], c = o.getTokenBefore(s, i.isOpeningBracketToken), g = o.getTokenAfter(c, { includeComments: !0 }), d = o.getTokenAfter(s, i.isClosingBracketToken), y = o.getTokenBefore(d, { includeComments: !0 });
          i.isTokenOnSameLine(c, g) && (f ? !o.isSpaceBetweenTokens(c, g) && i.isTokenOnSameLine(c, g) && a(l, c) : o.isSpaceBetweenTokens(c, g) && u(l, c, g)), i.isTokenOnSameLine(y, d) && (f ? !o.isSpaceBetweenTokens(y, d) && i.isTokenOnSameLine(y, d) && n(l, d) : o.isSpaceBetweenTokens(y, d) && e(l, d, y));
        };
      }
      const m = {
        Property: p("key"),
        MemberExpression: p("property")
      };
      return r && (m.MethodDefinition = m.PropertyDefinition = m.Property), m;
    }
  }, Ui;
}
var Vi, zm;
function yT() {
  if (zm) return Vi;
  zm = 1;
  const i = Re(), { upperCaseFirst: t } = Sr();
  function o(r) {
    for (const u of r)
      if (u.reachable)
        return !1;
    return !0;
  }
  function f(r) {
    return r.type === "FunctionExpression" && r.parent && r.parent.type === "MethodDefinition" && r.parent.kind === "constructor";
  }
  return Vi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `return` statements to either always or never specify values",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/consistent-return"
      },
      schema: [{
        type: "object",
        properties: {
          treatUndefinedAsUnspecified: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        missingReturn: "Expected to return a value at the end of {{name}}.",
        missingReturnValue: "{{name}} expected a return value.",
        unexpectedReturnValue: "{{name}} expected no return value."
      }
    },
    create(r) {
      const e = (r.options[0] || {}).treatUndefinedAsUnspecified === !0;
      let a = null;
      function n(p) {
        let m, h;
        !a.hasReturnValue || o(a.currentSegments) || i.isES5Constructor(p) || f(p) || (p.type === "Program" ? (m = { line: 1, column: 0 }, h = "program") : p.type === "ArrowFunctionExpression" ? m = r.sourceCode.getTokenBefore(p.body, i.isArrowToken).loc : p.parent.type === "MethodDefinition" || p.parent.type === "Property" && p.parent.method ? m = p.parent.key.loc : m = (p.id || r.sourceCode.getFirstToken(p)).loc, h || (h = i.getFunctionNameWithKind(p)), r.report({
          node: p,
          loc: m,
          messageId: "missingReturn",
          data: { name: h }
        }));
      }
      return {
        // Initializes/Disposes state of each code path.
        onCodePathStart(p, m) {
          a = {
            upper: a,
            codePath: p,
            hasReturn: !1,
            hasReturnValue: !1,
            messageId: "",
            node: m,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        onCodePathEnd() {
          a = a.upper;
        },
        onUnreachableCodePathSegmentStart(p) {
          a.currentSegments.add(p);
        },
        onUnreachableCodePathSegmentEnd(p) {
          a.currentSegments.delete(p);
        },
        onCodePathSegmentStart(p) {
          a.currentSegments.add(p);
        },
        onCodePathSegmentEnd(p) {
          a.currentSegments.delete(p);
        },
        // Reports a given return statement if it's inconsistent.
        ReturnStatement(p) {
          const m = p.argument;
          let h = !!m;
          e && h && (h = !i.isSpecificId(m, "undefined") && m.operator !== "void"), a.hasReturn ? a.hasReturnValue !== h && r.report({
            node: p,
            messageId: a.messageId,
            data: a.data
          }) : (a.hasReturn = !0, a.hasReturnValue = h, a.messageId = h ? "missingReturnValue" : "unexpectedReturnValue", a.data = {
            name: a.node.type === "Program" ? "Program" : t(i.getFunctionNameWithKind(a.node))
          });
        },
        // Reports a given program/function if the implicit returning is not consistent.
        "Program:exit": n,
        "FunctionDeclaration:exit": n,
        "FunctionExpression:exit": n,
        "ArrowFunctionExpression:exit": n
      };
    }
  }, Vi;
}
var Mi, Hm;
function CT() {
  return Hm || (Hm = 1, Mi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce consistent naming when capturing the current execution context",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/consistent-this"
      },
      schema: {
        type: "array",
        items: {
          type: "string",
          minLength: 1
        },
        uniqueItems: !0
      },
      messages: {
        aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
        unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
      }
    },
    create(i) {
      let t = [];
      const o = i.sourceCode;
      i.options.length === 0 ? t.push("that") : t = i.options;
      function f(a, n) {
        i.report({ node: a, messageId: "aliasNotAssignedToThis", data: { name: n } });
      }
      function r(a, n, p) {
        const m = p.type === "ThisExpression";
        t.includes(n) ? (!m || a.operator && a.operator !== "=") && f(a, n) : m && i.report({ node: a, messageId: "unexpectedAlias", data: { name: n } });
      }
      function u(a, n) {
        const p = n.set.get(a);
        p && (p.defs.some((m) => m.node.type === "VariableDeclarator" && m.node.init !== null) || p.references.some((m) => {
          const h = m.writeExpr;
          return m.from === n && h && h.type === "ThisExpression" && h.parent.operator === "=";
        }) || p.defs.map((m) => m.node).forEach((m) => {
          f(m, a);
        }));
      }
      function e(a) {
        const n = o.getScope(a);
        t.forEach((p) => {
          u(p, n);
        });
      }
      return {
        "Program:exit": e,
        "FunctionExpression:exit": e,
        "FunctionDeclaration:exit": e,
        VariableDeclarator(a) {
          const n = a.id, p = n.type === "ArrayPattern" || n.type === "ObjectPattern";
          a.init !== null && !p && r(a, n.name, a.init);
        },
        AssignmentExpression(a) {
          a.left.type === "Identifier" && r(a, a.left.name, a.right);
        }
      };
    }
  }), Mi;
}
var Ki, Jm;
function vT() {
  if (Jm) return Ki;
  Jm = 1;
  function i(f) {
    for (const r of f)
      if (r.reachable)
        return !0;
    return !1;
  }
  function t(f) {
    return f.type === "FunctionExpression" && f.parent.type === "MethodDefinition" && f.parent.kind === "constructor";
  }
  function o(f) {
    if (!f)
      return !1;
    switch (f.type) {
      case "ClassExpression":
      case "FunctionExpression":
      case "ThisExpression":
      case "MemberExpression":
      case "CallExpression":
      case "NewExpression":
      case "ChainExpression":
      case "YieldExpression":
      case "TaggedTemplateExpression":
      case "MetaProperty":
        return !0;
      case "Identifier":
        return f.name !== "undefined";
      case "AssignmentExpression":
        return ["=", "&&="].includes(f.operator) ? o(f.right) : ["||=", "??="].includes(f.operator) ? o(f.left) || o(f.right) : !1;
      case "LogicalExpression":
        return f.operator === "&&" ? o(f.right) : o(f.left) || o(f.right);
      case "ConditionalExpression":
        return o(f.alternate) || o(f.consequent);
      case "SequenceExpression": {
        const r = f.expressions[f.expressions.length - 1];
        return o(r);
      }
      default:
        return !1;
    }
  }
  return Ki = {
    meta: {
      type: "problem",
      docs: {
        description: "Require `super()` calls in constructors",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/constructor-super"
      },
      schema: [],
      messages: {
        missingSome: "Lacked a call of 'super()' in some code paths.",
        missingAll: "Expected to call 'super()'.",
        duplicate: "Unexpected duplicate 'super()'.",
        badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
        unexpected: "Unexpected 'super()'."
      }
    },
    create(f) {
      let r = null, u = /* @__PURE__ */ Object.create(null);
      function e(n) {
        return n.reachable && u[n.id].calledInSomePaths;
      }
      function a(n) {
        return n.nextSegments.length === 1 && n.nextSegments[0].isLoopedPrevSegment(n) ? !0 : n.reachable && u[n.id].calledInEveryPaths;
      }
      return {
        /**
         * Stacks a constructor information.
         * @param {CodePath} codePath A code path which was started.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathStart(n, p) {
          if (t(p)) {
            const h = p.parent.parent.parent.superClass;
            r = {
              upper: r,
              isConstructor: !0,
              hasExtends: !!h,
              superIsConstructor: o(h),
              codePath: n,
              currentSegments: /* @__PURE__ */ new Set()
            };
          } else
            r = {
              upper: r,
              isConstructor: !1,
              hasExtends: !1,
              superIsConstructor: !1,
              codePath: n,
              currentSegments: /* @__PURE__ */ new Set()
            };
        },
        /**
         * Pops a constructor information.
         * And reports if `super()` lacked.
         * @param {CodePath} codePath A code path which was ended.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathEnd(n, p) {
          const m = r.hasExtends;
          if (r = r.upper, !m)
            return;
          const h = n.returnedSegments, l = h.every(a), s = h.some(e);
          l || f.report({
            messageId: s ? "missingSome" : "missingAll",
            node: p.parent
          });
        },
        /**
         * Initialize information of a given code path segment.
         * @param {CodePathSegment} segment A code path segment to initialize.
         * @returns {void}
         */
        onCodePathSegmentStart(n) {
          if (r.currentSegments.add(n), !(r && r.isConstructor && r.hasExtends))
            return;
          const p = u[n.id] = {
            calledInSomePaths: !1,
            calledInEveryPaths: !1,
            validNodes: []
          }, m = n.prevSegments;
          m.length > 0 && (p.calledInSomePaths = m.some(e), p.calledInEveryPaths = m.every(a));
        },
        onUnreachableCodePathSegmentStart(n) {
          r.currentSegments.add(n);
        },
        onUnreachableCodePathSegmentEnd(n) {
          r.currentSegments.delete(n);
        },
        onCodePathSegmentEnd(n) {
          r.currentSegments.delete(n);
        },
        /**
         * Update information of the code path segment when a code path was
         * looped.
         * @param {CodePathSegment} fromSegment The code path segment of the
         *      end of a loop.
         * @param {CodePathSegment} toSegment A code path segment of the head
         *      of a loop.
         * @returns {void}
         */
        onCodePathSegmentLoop(n, p) {
          if (!(r && r.isConstructor && r.hasExtends))
            return;
          const m = p.prevSegments.length >= 2;
          r.codePath.traverseSegments(
            { first: p, last: n },
            (h) => {
              const l = u[h.id], s = h.prevSegments;
              if (l.calledInSomePaths = s.some(e), l.calledInEveryPaths = s.every(a), l.calledInSomePaths || m) {
                const c = l.validNodes;
                l.validNodes = [];
                for (let g = 0; g < c.length; ++g) {
                  const d = c[g];
                  f.report({
                    messageId: "duplicate",
                    node: d
                  });
                }
              }
            }
          );
        },
        /**
         * Checks for a call of `super()`.
         * @param {ASTNode} node A CallExpression node to check.
         * @returns {void}
         */
        "CallExpression:exit"(n) {
          if (r && r.isConstructor && n.callee.type === "Super")
            if (r.hasExtends) {
              const p = r.currentSegments;
              let m = !1, h = null;
              for (const l of p)
                l.reachable && (h = u[l.id], m = m || h.calledInSomePaths, h.calledInSomePaths = h.calledInEveryPaths = !0);
              h && (m ? f.report({
                messageId: "duplicate",
                node: n
              }) : r.superIsConstructor ? h.validNodes.push(n) : f.report({
                messageId: "badSuper",
                node: n
              }));
            } else i(r.currentSegments) && f.report({
              messageId: "unexpected",
              node: n
            });
        },
        /**
         * Set the mark to the returned path as `super()` was called.
         * @param {ASTNode} node A ReturnStatement node to check.
         * @returns {void}
         */
        ReturnStatement(n) {
          if (!(r && r.isConstructor && r.hasExtends) || !n.argument)
            return;
          const p = r.currentSegments;
          for (const m of p)
            if (m.reachable) {
              const h = u[m.id];
              h.calledInSomePaths = h.calledInEveryPaths = !0;
            }
        },
        /**
         * Resets state.
         * @returns {void}
         */
        "Program:exit"() {
          u = /* @__PURE__ */ Object.create(null);
        }
      };
    }
  }, Ki;
}
var ji, Qm;
function ST() {
  if (Qm) return ji;
  Qm = 1;
  const i = Re();
  return ji = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce consistent brace style for all control statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/curly"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["multi", "multi-line", "multi-or-nest"]
              },
              {
                enum: ["consistent"]
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        missingCurlyAfter: "Expected { after '{{name}}'.",
        missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
        unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
        unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
      }
    },
    create(t) {
      const o = t.options[0] === "multi", f = t.options[0] === "multi-line", r = t.options[0] === "multi-or-nest", u = t.options[1] === "consistent", e = t.sourceCode;
      function a(y) {
        const v = e.getTokenBefore(y), T = e.getLastToken(y), b = i.isSemicolonToken(T) ? e.getTokenBefore(T) : T;
        return v.loc.start.line === b.loc.end.line;
      }
      function n(y) {
        if (y.type === "EmptyStatement")
          return !0;
        const v = e.getFirstToken(y), T = e.getLastToken(y), b = i.isSemicolonToken(T) ? e.getTokenBefore(T) : T;
        return v.loc.start.line === b.loc.end.line;
      }
      function p(y) {
        return y.type === "VariableDeclaration" ? y.kind === "const" || y.kind === "let" : y.type === "FunctionDeclaration" || y.type === "ClassDeclaration";
      }
      function m(y) {
        return y.value === "else" && y.type === "Keyword";
      }
      function h(y) {
        const v = e.getTokenAfter(y);
        return !!v && m(v);
      }
      function l(y) {
        const v = e.getTokenBefore(y), T = e.getTokenAfter(y), b = e.getNodeByRangeIndex(v.range[0]);
        return i.isSemicolonToken(v) || !T || b.type === "BlockStatement" && b.parent.type !== "FunctionExpression" && b.parent.type !== "ArrowFunctionExpression" ? !1 : !!(v.loc.end.line === T.loc.start.line || /^[([/`+-]/u.test(T.value) || v.type === "Punctuator" && (v.value === "++" || v.value === "--"));
      }
      function s(y) {
        switch (y.type) {
          case "IfStatement":
            return y.alternate ? s(y.alternate) : !0;
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
          case "LabeledStatement":
          case "WithStatement":
          case "WhileStatement":
            return s(y.body);
          default:
            return !1;
        }
      }
      function c(y) {
        const v = y.body[0];
        return p(v) || s(v) && h(y);
      }
      function g(y, v, T, b) {
        const S = v.type === "BlockStatement";
        let C = null;
        if (S && (v.body.length !== 1 || c(v)))
          C = !0;
        else if (o)
          C = !1;
        else if (f)
          a(v) || (C = !0);
        else if (r)
          if (S) {
            const x = v.body[0], A = e.getCommentsBefore(x);
            C = !n(x) || A.length > 0;
          } else
            C = !n(v);
        else
          C = !0;
        return {
          actual: S,
          expected: C,
          check() {
            this.expected !== null && this.expected !== this.actual && (this.expected ? t.report({
              node: y,
              loc: v.loc,
              messageId: b && b.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
              data: {
                name: T
              },
              fix: (x) => x.replaceText(v, `{${e.getText(v)}}`)
            }) : t.report({
              node: y,
              loc: v.loc,
              messageId: b && b.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
              data: {
                name: T
              },
              fix(x) {
                const A = y.type === "DoWhileStatement" && e.getTokenBefore(v).range[1] === v.range[0] && !i.canTokensBeAdjacent("do", e.getFirstToken(v, { skip: 1 })), R = e.getFirstToken(v), L = e.getLastToken(v), _ = e.getTokenBefore(L);
                if (l(L))
                  return null;
                const I = e.getText().slice(R.range[1], _.range[0]) + e.getText(_) + e.getText().slice(_.range[1], L.range[0]);
                return x.replaceText(v, (A ? " " : "") + I);
              }
            }));
          }
        };
      }
      function d(y) {
        const v = [];
        for (let T = y; T; T = T.alternate)
          if (v.push(g(T, T.consequent, "if", { condition: !0 })), T.alternate && T.alternate.type !== "IfStatement") {
            v.push(g(T, T.alternate, "else"));
            break;
          }
        if (u) {
          const T = v.some((b) => b.expected !== null ? b.expected : b.actual);
          v.forEach((b) => {
            b.expected = T;
          });
        }
        return v;
      }
      return {
        IfStatement(y) {
          const v = y.parent;
          v.type === "IfStatement" && v.alternate === y || d(y).forEach((b) => {
            b.check();
          });
        },
        WhileStatement(y) {
          g(y, y.body, "while", { condition: !0 }).check();
        },
        DoWhileStatement(y) {
          g(y, y.body, "do").check();
        },
        ForStatement(y) {
          g(y, y.body, "for", { condition: !0 }).check();
        },
        ForInStatement(y) {
          g(y, y.body, "for-in").check();
        },
        ForOfStatement(y) {
          g(y, y.body, "for-of").check();
        }
      };
    }
  }, ji;
}
var qi, Ym;
function AT() {
  if (Ym) return qi;
  Ym = 1;
  const i = /^no default$/iu;
  return qi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `default` cases in `switch` statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/default-case"
      },
      schema: [{
        type: "object",
        properties: {
          commentPattern: {
            type: "string"
          }
        },
        additionalProperties: !1
      }],
      messages: {
        missingDefaultCase: "Expected a default case."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.commentPattern ? new RegExp(o.commentPattern, "u") : i, r = t.sourceCode;
      function u(e) {
        return e[e.length - 1];
      }
      return {
        SwitchStatement(e) {
          if (!e.cases.length)
            return;
          if (!e.cases.some((n) => n.test === null)) {
            let n;
            const p = u(e.cases), m = r.getCommentsAfter(p);
            m.length && (n = u(m)), (!n || !f.test(n.value.trim())) && t.report({ node: e, messageId: "missingDefaultCase" });
          }
        }
      };
    }
  }, qi;
}
var $i, Zm;
function TT() {
  return Zm || (Zm = 1, $i = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce default clauses in switch statements to be last",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/default-case-last"
      },
      schema: [],
      messages: {
        notLast: "Default clause should be the last clause."
      }
    },
    create(i) {
      return {
        SwitchStatement(t) {
          const o = t.cases, f = o.findIndex((r) => r.test === null);
          if (f !== -1 && f !== o.length - 1) {
            const r = o[f];
            i.report({ node: r, messageId: "notLast" });
          }
        }
      };
    }
  }), $i;
}
var Gi, eg;
function bT() {
  return eg || (eg = 1, Gi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce default parameters to be last",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/default-param-last"
      },
      schema: [],
      messages: {
        shouldBeLast: "Default parameters should be last."
      }
    },
    create(i) {
      function t(o) {
        let f = !1;
        for (let r = o.params.length - 1; r >= 0; r -= 1) {
          const u = o.params[r];
          if (u.type !== "AssignmentPattern" && u.type !== "RestElement") {
            f = !0;
            continue;
          }
          f && u.type === "AssignmentPattern" && i.report({
            node: u,
            messageId: "shouldBeLast"
          });
        }
      }
      return {
        FunctionDeclaration: t,
        FunctionExpression: t,
        ArrowFunctionExpression: t
      };
    }
  }), Gi;
}
var Wi, tg;
function xT() {
  if (tg) return Wi;
  tg = 1;
  const i = Re();
  return Wi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent newlines before and after dots",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/dot-location"
      },
      schema: [
        {
          enum: ["object", "property"]
        }
      ],
      fixable: "code",
      messages: {
        expectedDotAfterObject: "Expected dot to be on same line as object.",
        expectedDotBeforeProperty: "Expected dot to be on same line as property."
      }
    },
    create(t) {
      const o = t.options[0], f = o === "object" || !o, r = t.sourceCode;
      function u(a) {
        const n = a.property, p = r.getTokenBefore(n);
        if (f) {
          const m = r.getTokenBefore(p);
          i.isTokenOnSameLine(m, p) || t.report({
            node: a,
            loc: p.loc,
            messageId: "expectedDotAfterObject",
            *fix(h) {
              p.value.startsWith(".") && i.isDecimalIntegerNumericToken(m) ? yield h.insertTextAfter(m, ` ${p.value}`) : yield h.insertTextAfter(m, p.value), yield h.remove(p);
            }
          });
        } else i.isTokenOnSameLine(p, n) || t.report({
          node: a,
          loc: p.loc,
          messageId: "expectedDotBeforeProperty",
          *fix(m) {
            yield m.remove(p), yield m.insertTextBefore(n, p.value);
          }
        });
      }
      function e(a) {
        a.computed || u(a);
      }
      return {
        MemberExpression: e
      };
    }
  }, Wi;
}
var Xi, rg;
function Hf() {
  return rg || (rg = 1, Xi = [
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with"
  ]), Xi;
}
var zi, ng;
function RT() {
  if (ng) return zi;
  ng = 1;
  const i = Re(), t = Hf(), o = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u, f = /* @__PURE__ */ new Set(["string", "boolean"]);
  return zi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce dot notation whenever possible",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/dot-notation"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowKeywords: {
              type: "boolean",
              default: !0
            },
            allowPattern: {
              type: "string",
              default: ""
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        useDot: "[{{key}}] is better written in dot notation.",
        useBrackets: ".{{key}} is a syntax error."
      }
    },
    create(r) {
      const u = r.options[0] || {}, e = u.allowKeywords === void 0 || u.allowKeywords, a = r.sourceCode;
      let n;
      u.allowPattern && (n = new RegExp(u.allowPattern, "u"));
      function p(m, h) {
        if (o.test(h) && (e || !t.includes(String(h))) && !(n && n.test(h))) {
          const l = m.property.type === "Literal" ? JSON.stringify(h) : `\`${h}\``;
          r.report({
            node: m.property,
            messageId: "useDot",
            data: {
              key: l
            },
            *fix(s) {
              const c = a.getTokenAfter(m.object, i.isOpeningBracketToken), g = a.getLastToken(m), d = a.getTokenAfter(m);
              a.commentsExistBetween(c, g) || (m.optional || (yield s.insertTextBefore(
                c,
                i.isDecimalInteger(m.object) ? " ." : "."
              )), yield s.replaceTextRange(
                [c.range[0], g.range[1]],
                h
              ), d && g.range[1] === d.range[0] && !i.canTokensBeAdjacent(String(h), d) && (yield s.insertTextAfter(m, " ")));
            }
          });
        }
      }
      return {
        MemberExpression(m) {
          m.computed && m.property.type === "Literal" && (f.has(typeof m.property.value) || i.isNullLiteral(m.property)) && p(m, m.property.value), m.computed && i.isStaticTemplateLiteral(m.property) && p(m, m.property.quasis[0].value.cooked), !e && !m.computed && m.property.type === "Identifier" && t.includes(String(m.property.name)) && r.report({
            node: m.property,
            messageId: "useBrackets",
            data: {
              key: m.property.name
            },
            *fix(h) {
              const l = a.getTokenBefore(m.property);
              m.object.type === "Identifier" && m.object.name === "let" && !m.optional || a.commentsExistBetween(l, m.property) || (m.optional || (yield h.remove(l)), yield h.replaceText(m.property, `["${m.property.name}"]`));
            }
          });
        }
      };
    }
  }, zi;
}
var Hi, sg;
function DT() {
  return sg || (sg = 1, Hi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow newline at the end of files",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/eol-last"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "unix", "windows"]
        }
      ],
      messages: {
        missing: "Newline required at end of file but not found.",
        unexpected: "Newline not allowed at end of file."
      }
    },
    create(i) {
      return {
        Program: function(o) {
          const f = i.sourceCode, r = f.getText(), u = f.lines[f.lines.length - 1], e = {
            column: u.length,
            line: f.lines.length
          }, a = `
`, n = `\r${a}`, p = r.endsWith(a);
          if (!r.length)
            return;
          let m = i.options[0] || "always", h = !1;
          if (m === "unix" && (m = "always"), m === "windows" && (m = "always", h = !0), m === "always" && !p)
            i.report({
              node: o,
              loc: e,
              messageId: "missing",
              fix(l) {
                return l.insertTextAfterRange([0, r.length], h ? n : a);
              }
            });
          else if (m === "never" && p) {
            const l = f.lines[f.lines.length - 2];
            i.report({
              node: o,
              loc: {
                start: { line: f.lines.length - 1, column: l.length },
                end: { line: f.lines.length, column: 0 }
              },
              messageId: "unexpected",
              fix(s) {
                const c = /(?:\r?\n)+$/u, g = c.exec(f.text), d = g.index, y = f.text.length;
                return s.replaceTextRange([d, y], "");
              }
            });
          }
        }
      };
    }
  }), Hi;
}
var Ji, ig;
function LT() {
  if (ig) return Ji;
  ig = 1;
  const i = Re();
  return Ji = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require the use of `===` and `!==`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/eqeqeq"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  null: {
                    enum: ["always", "never", "ignore"]
                  }
                },
                additionalProperties: !1
              }
            ],
            additionalItems: !1
          },
          {
            type: "array",
            items: [
              {
                enum: ["smart", "allow-null"]
              }
            ],
            additionalItems: !1
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
      }
    },
    create(t) {
      const o = t.options[0] || "always", f = t.options[1] || {}, r = t.sourceCode, u = o === "always" ? f.null || "always" : "ignore", e = u === "always", a = u === "never";
      function n(s) {
        return s.type === "UnaryExpression" && s.operator === "typeof";
      }
      function p(s) {
        return n(s.left) || n(s.right);
      }
      function m(s) {
        return s.left.type === "Literal" && s.right.type === "Literal" && typeof s.left.value == typeof s.right.value;
      }
      function h(s) {
        return i.isNullLiteral(s.right) || i.isNullLiteral(s.left);
      }
      function l(s, c) {
        const g = r.getFirstTokenBetween(
          s.left,
          s.right,
          (d) => d.value === s.operator
        );
        t.report({
          node: s,
          loc: g.loc,
          messageId: "unexpected",
          data: { expectedOperator: c, actualOperator: s.operator },
          fix(d) {
            return p(s) || m(s) ? d.replaceText(g, c) : null;
          }
        });
      }
      return {
        BinaryExpression(s) {
          const c = h(s);
          if (s.operator !== "==" && s.operator !== "!=") {
            a && c && l(s, s.operator.slice(0, -1));
            return;
          }
          o === "smart" && (p(s) || m(s) || c) || !e && c || l(s, `${s.operator}=`);
        }
      };
    }
  }, Ji;
}
var Qi, ag;
function _T() {
  if (ag) return Qi;
  ag = 1;
  const { getStaticValue: i } = Ft();
  return Qi = {
    meta: {
      type: "problem",
      docs: {
        description: 'Enforce "for" loop update clause moving the counter in the right direction',
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/for-direction"
      },
      fixable: null,
      schema: [],
      messages: {
        incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
      }
    },
    create(t) {
      const { sourceCode: o } = t;
      function f(a) {
        t.report({
          node: a,
          messageId: "incorrectDirection"
        });
      }
      function r(a, n) {
        const p = i(a.right, o.getScope(a));
        if (p && ["bigint", "boolean", "number"].includes(typeof p.value)) {
          const m = Math.sign(Number(p.value)) || 0;
          return n * m;
        }
        return 0;
      }
      function u(a, n) {
        if (a.argument.type === "Identifier" && a.argument.name === n) {
          if (a.operator === "++")
            return 1;
          if (a.operator === "--")
            return -1;
        }
        return 0;
      }
      function e(a, n) {
        if (a.left.name === n) {
          if (a.operator === "+=")
            return r(a, 1);
          if (a.operator === "-=")
            return r(a, -1);
        }
        return 0;
      }
      return {
        ForStatement(a) {
          if (a.test && a.test.type === "BinaryExpression" && a.update)
            for (const n of ["left", "right"]) {
              if (a.test[n].type !== "Identifier")
                continue;
              const p = a.test[n].name, m = a.test.operator, h = a.update;
              let l;
              if (m === "<" || m === "<=")
                l = n === "left" ? -1 : 1;
              else if (m === ">" || m === ">=")
                l = n === "left" ? 1 : -1;
              else
                return;
              h.type === "UpdateExpression" ? u(h, p) === l && f(a) : h.type === "AssignmentExpression" && e(h, p) === l && f(a);
            }
        }
      };
    }
  }, Qi;
}
var Yi, og;
function wT() {
  if (og) return Yi;
  og = 1;
  const i = Re();
  return Yi = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow spacing between function identifiers and their invocations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/func-call-spacing"
      },
      fixable: "whitespace",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  allowNewlines: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
        unexpectedNewline: "Unexpected newline between function name and paren.",
        missing: "Missing space between function name and paren."
      }
    },
    create(t) {
      const o = t.options[0] !== "always", f = !o && t.options[1] && t.options[1].allowNewlines, r = t.sourceCode, u = r.getText();
      function e(a, n, p) {
        const m = u.slice(n.range[1], p.range[0]).replace(/\/\*.*?\*\//gu, ""), h = /\s/u.test(m), l = h && i.LINEBREAK_MATCHER.test(m);
        o && h ? t.report({
          node: a,
          loc: {
            start: n.loc.end,
            end: {
              line: p.loc.start.line,
              column: p.loc.start.column - 1
            }
          },
          messageId: "unexpectedWhitespace",
          fix(s) {
            return r.commentsExistBetween(n, p) ? null : a.optional ? s.replaceTextRange([n.range[1], p.range[0]], "?.") : l ? null : s.removeRange([n.range[1], p.range[0]]);
          }
        }) : !o && !h ? t.report({
          node: a,
          loc: {
            start: {
              line: n.loc.end.line,
              column: n.loc.end.column - 1
            },
            end: p.loc.start
          },
          messageId: "missing",
          fix(s) {
            return a.optional ? null : s.insertTextBefore(p, " ");
          }
        }) : !o && !f && l && t.report({
          node: a,
          loc: {
            start: n.loc.end,
            end: p.loc.start
          },
          messageId: "unexpectedNewline",
          fix(s) {
            if (!a.optional || r.commentsExistBetween(n, p))
              return null;
            const c = [n.range[1], p.range[0]], g = r.getTokenAfter(n);
            return g.range[0] === n.range[1] ? s.replaceTextRange(c, "?. ") : g.range[1] === p.range[0] ? s.replaceTextRange(c, " ?.") : s.replaceTextRange(c, " ?. ");
          }
        });
      }
      return {
        "CallExpression, NewExpression"(a) {
          const n = r.getLastToken(a), p = r.getLastToken(a.callee), m = r.getFirstTokenBetween(p, n, i.isOpeningParenToken), h = m && r.getTokenBefore(m, i.isNotQuestionDotToken);
          m && m.range[1] < a.range[1] && e(a, h, m);
        },
        ImportExpression(a) {
          const n = r.getFirstToken(a), p = r.getTokenAfter(n);
          e(a, n, p);
        }
      };
    }
  }, Yi;
}
var Zi, lg;
function kT() {
  if (lg) return Zi;
  lg = 1;
  const i = Re(), t = En();
  function o(e) {
    return e.type === "MemberExpression" && e.object.type === "Identifier" && e.object.name === "module" && (e.property.type === "Identifier" && e.property.name === "exports" || e.property.type === "Literal" && e.property.value === "exports");
  }
  function f(e, a) {
    return a >= 2015 ? t.keyword.isIdentifierES6(e) : t.keyword.isIdentifierES5(e);
  }
  const r = { enum: ["always", "never"] }, u = {
    type: "object",
    properties: {
      considerPropertyDescriptor: {
        type: "boolean"
      },
      includeCommonJSModuleExports: {
        type: "boolean"
      }
    },
    additionalProperties: !1
  };
  return Zi = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require function names to match the name of the variable or property to which they are assigned",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/func-name-matching"
      },
      schema: {
        anyOf: [{
          type: "array",
          additionalItems: !1,
          items: [r, u]
        }, {
          type: "array",
          additionalItems: !1,
          items: [u]
        }]
      },
      messages: {
        matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
        matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
        notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
        notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
      }
    },
    create(e) {
      const a = (typeof e.options[0] == "object" ? e.options[0] : e.options[1]) || {}, n = typeof e.options[0] == "string" ? e.options[0] : "always", p = a.considerPropertyDescriptor, m = a.includeCommonJSModuleExports, h = e.languageOptions.ecmaVersion;
      function l(d, y, v) {
        return v ? v.type === "CallExpression" && i.isSpecificMemberAccess(v.callee, d, y) : !1;
      }
      function s(d, y) {
        return n === "always" && d !== y || n === "never" && d === y;
      }
      function c(d, y, v, T) {
        let b;
        n === "always" && T ? b = "matchProperty" : n === "always" ? b = "matchVariable" : T ? b = "notMatchProperty" : b = "notMatchVariable", e.report({
          node: d,
          messageId: b,
          data: {
            name: y,
            funcName: v
          }
        });
      }
      function g(d) {
        return d.type === "Literal" && typeof d.value == "string";
      }
      return {
        VariableDeclarator(d) {
          !d.init || d.init.type !== "FunctionExpression" || d.id.type !== "Identifier" || d.init.id && s(d.id.name, d.init.id.name) && c(d, d.id.name, d.init.id.name, !1);
        },
        AssignmentExpression(d) {
          if (d.right.type !== "FunctionExpression" || d.left.computed && d.left.property.type !== "Literal" || !m && o(d.left) || d.left.type !== "Identifier" && d.left.type !== "MemberExpression")
            return;
          const y = d.left.type === "MemberExpression", v = y ? i.getStaticPropertyName(d.left) : d.left.name;
          d.right.id && v && f(v) && s(v, d.right.id.name) && c(d, v, d.right.id.name, y);
        },
        "Property, PropertyDefinition[value]"(d) {
          if (d.value.type === "FunctionExpression" && d.value.id) {
            if (d.key.type === "Identifier" && !d.computed) {
              const y = d.value.id.name;
              let v = d.key.name;
              if (p && v === "value" && d.parent.type === "ObjectExpression")
                if (l("Object", "defineProperty", d.parent.parent) || l("Reflect", "defineProperty", d.parent.parent)) {
                  const T = d.parent.parent.arguments[1];
                  g(T) && s(T.value, y) && c(d, T.value, y, !0);
                } else l("Object", "defineProperties", d.parent.parent.parent.parent) || l("Object", "create", d.parent.parent.parent.parent) ? (v = d.parent.parent.key.name, !d.parent.parent.computed && s(v, y) && c(d, v, y, !0)) : s(v, y) && c(d, v, y, !0);
              else s(v, y) && c(d, v, y, !0);
              return;
            }
            g(d.key) && f(d.key.value, h) && s(d.key.value, d.value.id.name) && c(d, d.key.value, d.value.id.name, !0);
          }
        }
      };
    }
  }, Zi;
}
var ea, ug;
function BT() {
  if (ug) return ea;
  ug = 1;
  const i = Re();
  function t(o) {
    return o && o.defs[0].type === "FunctionName";
  }
  return ea = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow named `function` expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/func-names"
      },
      schema: {
        definitions: {
          value: {
            enum: [
              "always",
              "as-needed",
              "never"
            ]
          }
        },
        items: [
          {
            $ref: "#/definitions/value"
          },
          {
            type: "object",
            properties: {
              generators: {
                $ref: "#/definitions/value"
              }
            },
            additionalProperties: !1
          }
        ]
      },
      messages: {
        unnamed: "Unexpected unnamed {{name}}.",
        named: "Unexpected named {{name}}."
      }
    },
    create(o) {
      const f = o.sourceCode;
      function r(m) {
        return m.generator && o.options.length > 1 && o.options[1].generators ? o.options[1].generators : o.options[0] || "always";
      }
      function u(m) {
        const h = m.parent;
        return h.type === "MethodDefinition" || h.type === "Property" && (h.method || h.kind === "get" || h.kind === "set");
      }
      function e(m) {
        const h = m.parent;
        return u(m) || h.type === "VariableDeclarator" && h.id.type === "Identifier" && h.init === m || h.type === "Property" && h.value === m || h.type === "PropertyDefinition" && h.value === m || h.type === "AssignmentExpression" && h.left.type === "Identifier" && h.right === m || h.type === "AssignmentPattern" && h.left.type === "Identifier" && h.right === m;
      }
      function a(m) {
        o.report({
          node: m,
          messageId: "unnamed",
          loc: i.getFunctionHeadLoc(m, f),
          data: { name: i.getFunctionNameWithKind(m) }
        });
      }
      function n(m) {
        o.report({
          node: m,
          messageId: "named",
          loc: i.getFunctionHeadLoc(m, f),
          data: { name: i.getFunctionNameWithKind(m) }
        });
      }
      function p(m) {
        const h = f.getDeclaredVariables(m)[0];
        if (t(h) && h.references.length > 0)
          return;
        const l = !!(m.id && m.id.name), s = r(m);
        s === "never" ? l && m.type !== "FunctionDeclaration" && n(m) : s === "as-needed" ? !l && !e(m) && a(m) : !l && !u(m) && a(m);
      }
      return {
        "FunctionExpression:exit": p,
        "ExportDefaultDeclaration > FunctionDeclaration": p
      };
    }
  }, ea;
}
var ta, cg;
function PT() {
  return cg || (cg = 1, ta = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce the consistent use of either `function` declarations or expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/func-style"
      },
      schema: [
        {
          enum: ["declaration", "expression"]
        },
        {
          type: "object",
          properties: {
            allowArrowFunctions: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expression: "Expected a function expression.",
        declaration: "Expected a function declaration."
      }
    },
    create(i) {
      const t = i.options[0], o = i.options[1] && i.options[1].allowArrowFunctions, f = t === "declaration", r = [], u = {
        FunctionDeclaration(e) {
          r.push(!1), !f && e.parent.type !== "ExportDefaultDeclaration" && i.report({ node: e, messageId: "expression" });
        },
        "FunctionDeclaration:exit"() {
          r.pop();
        },
        FunctionExpression(e) {
          r.push(!1), f && e.parent.type === "VariableDeclarator" && i.report({ node: e.parent, messageId: "declaration" });
        },
        "FunctionExpression:exit"() {
          r.pop();
        },
        ThisExpression() {
          r.length > 0 && (r[r.length - 1] = !0);
        }
      };
      return o || (u.ArrowFunctionExpression = function() {
        r.push(!1);
      }, u["ArrowFunctionExpression:exit"] = function(e) {
        const a = r.pop();
        f && !a && e.parent.type === "VariableDeclarator" && i.report({ node: e.parent, messageId: "declaration" });
      }), u;
    }
  }), ta;
}
var ra, fg;
function IT() {
  return fg || (fg = 1, ra = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce line breaks between arguments of a function call",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/function-call-argument-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "consistent"]
        }
      ],
      messages: {
        unexpectedLineBreak: "There should be no line break here.",
        missingLineBreak: "There should be a line break after this argument."
      }
    },
    create(i) {
      const t = i.sourceCode, o = {
        unexpected: {
          messageId: "unexpectedLineBreak",
          check: (u, e) => u.loc.end.line !== e.loc.start.line,
          createFix: (u, e) => (a) => a.replaceTextRange([e.range[1], u.range[0]], " ")
        },
        missing: {
          messageId: "missingLineBreak",
          check: (u, e) => u.loc.end.line === e.loc.start.line,
          createFix: (u, e) => (a) => a.replaceTextRange([e.range[1], u.range[0]], `
`)
        }
      };
      function f(u, e) {
        for (let a = 1; a < u.arguments.length; a++) {
          const n = t.getLastToken(u.arguments[a - 1]), p = t.getFirstToken(u.arguments[a]);
          if (e.check(n, p)) {
            const m = t.getTokenBefore(
              p,
              { includeComments: !0 }
            ), h = m.type === "Line";
            i.report({
              node: u,
              loc: {
                start: m.loc.end,
                end: p.loc.start
              },
              messageId: e.messageId,
              fix: h ? null : e.createFix(p, m)
            });
          }
        }
      }
      function r(u) {
        if (u.arguments.length < 2)
          return;
        const e = i.options[0] || "always";
        if (e === "never")
          f(u, o.unexpected);
        else if (e === "always")
          f(u, o.missing);
        else if (e === "consistent") {
          const a = t.getLastToken(u.arguments[0]), n = t.getFirstToken(u.arguments[1]);
          a.loc.end.line === n.loc.start.line ? f(u, o.unexpected) : f(u, o.missing);
        }
      }
      return {
        CallExpression: r,
        NewExpression: r
      };
    }
  }), ra;
}
var na, pg;
function FT() {
  if (pg) return na;
  pg = 1;
  const i = Re();
  return na = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent line breaks inside function parentheses",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/function-paren-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
            },
            {
              type: "object",
              properties: {
                minItems: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        expectedBefore: "Expected newline before ')'.",
        expectedAfter: "Expected newline after '('.",
        expectedBetween: "Expected newline between arguments/params.",
        unexpectedBefore: "Unexpected newline before ')'.",
        unexpectedAfter: "Unexpected newline after '('."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || "multiline", r = f === "multiline", u = f === "multiline-arguments", e = f === "consistent";
      let a;
      typeof f == "object" ? a = f.minItems : f === "always" ? a = 0 : f === "never" ? a = 1 / 0 : a = null;
      function n(l, s) {
        return u && l.length === 1 ? s : r || u ? l.some((c, g) => g !== l.length - 1 && c.loc.end.line !== l[g + 1].loc.start.line) : e ? s : l.length >= a;
      }
      function p(l, s) {
        const c = l.leftParen, g = l.rightParen, d = o.getTokenAfter(c), y = o.getTokenBefore(g), v = !i.isTokenOnSameLine(c, d), T = !i.isTokenOnSameLine(y, g), b = n(s, v);
        v && !b ? t.report({
          node: c,
          messageId: "unexpectedAfter",
          fix(S) {
            return o.getText().slice(c.range[1], d.range[0]).trim() ? null : S.removeRange([c.range[1], d.range[0]]);
          }
        }) : !v && b && t.report({
          node: c,
          messageId: "expectedAfter",
          fix: (S) => S.insertTextAfter(c, `
`)
        }), T && !b ? t.report({
          node: g,
          messageId: "unexpectedBefore",
          fix(S) {
            return o.getText().slice(y.range[1], g.range[0]).trim() ? null : S.removeRange([y.range[1], g.range[0]]);
          }
        }) : !T && b && t.report({
          node: g,
          messageId: "expectedBefore",
          fix: (S) => S.insertTextBefore(g, `
`)
        });
      }
      function m(l, s) {
        const c = l.leftParen, g = o.getTokenAfter(c), d = !i.isTokenOnSameLine(c, g), y = n(s, d);
        for (let v = 0; v <= s.length - 2; v++) {
          const T = s[v], b = s[v + 1];
          !(T.loc.end.line !== b.loc.start.line) && y && t.report({
            node: T,
            messageId: "expectedBetween",
            fix: (C) => C.insertTextBefore(b, `
`)
          });
        }
      }
      function h(l) {
        switch (l.type) {
          case "NewExpression":
            if (!l.arguments.length && !(i.isOpeningParenToken(o.getLastToken(l, { skip: 1 })) && i.isClosingParenToken(o.getLastToken(l)) && l.callee.range[1] < l.range[1]))
              return null;
          case "CallExpression":
            return {
              leftParen: o.getTokenAfter(l.callee, i.isOpeningParenToken),
              rightParen: o.getLastToken(l)
            };
          case "FunctionDeclaration":
          case "FunctionExpression": {
            const s = o.getFirstToken(l, i.isOpeningParenToken), c = l.params.length ? o.getTokenAfter(l.params[l.params.length - 1], i.isClosingParenToken) : o.getTokenAfter(s);
            return { leftParen: s, rightParen: c };
          }
          case "ArrowFunctionExpression": {
            const s = o.getFirstToken(l, { skip: l.async ? 1 : 0 });
            if (!i.isOpeningParenToken(s))
              return null;
            const c = l.params.length ? o.getTokenAfter(l.params[l.params.length - 1], i.isClosingParenToken) : o.getTokenAfter(s);
            return {
              leftParen: s,
              rightParen: c
            };
          }
          case "ImportExpression": {
            const s = o.getFirstToken(l, 1), c = o.getLastToken(l);
            return { leftParen: s, rightParen: c };
          }
          default:
            throw new TypeError(`unexpected node with type ${l.type}`);
        }
      }
      return {
        [[
          "ArrowFunctionExpression",
          "CallExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "ImportExpression",
          "NewExpression"
        ]](l) {
          const s = h(l);
          let c;
          l.type === "ImportExpression" ? c = [l.source] : i.isFunction(l) ? c = l.params : c = l.arguments, s && (p(s, c), u && m(s, c));
        }
      };
    }
  }, na;
}
var sa, hg;
function NT() {
  if (hg) return sa;
  hg = 1;
  const i = {
    oneOf: [
      {
        enum: ["before", "after", "both", "neither"]
      },
      {
        type: "object",
        properties: {
          before: { type: "boolean" },
          after: { type: "boolean" }
        },
        additionalProperties: !1
      }
    ]
  };
  return sa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing around `*` operators in generator functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/generator-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: { type: "boolean" },
                after: { type: "boolean" },
                named: i,
                anonymous: i,
                method: i
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(t) {
      const o = {
        before: { before: !0, after: !1 },
        after: { before: !1, after: !0 },
        both: { before: !0, after: !0 },
        neither: { before: !1, after: !1 }
      };
      function f(h, l) {
        return h ? typeof h == "string" ? o[h] : Object.assign({}, l, h) : l;
      }
      const r = function(h) {
        const l = f(h, o.before);
        return {
          named: f(h.named, l),
          anonymous: f(h.anonymous, l),
          method: f(h.method, l)
        };
      }(t.options[0] || {}), u = t.sourceCode;
      function e(h) {
        return h.value === "*" && h.type === "Punctuator";
      }
      function a(h) {
        return u.getFirstToken(
          h.parent.method || h.parent.type === "MethodDefinition" ? h.parent : h,
          e
        );
      }
      function n(h) {
        return h[0].toUpperCase() + h.slice(1);
      }
      function p(h, l, s, c) {
        if (!!(c.range[0] - s.range[1]) !== r[h][l]) {
          const g = s.value === "*", d = r[h][l], y = g ? s : c, v = `${d ? "missing" : "unexpected"}${n(l)}`;
          t.report({
            node: y,
            messageId: v,
            fix(T) {
              return d ? g ? T.insertTextAfter(y, " ") : T.insertTextBefore(y, " ") : T.removeRange([s.range[1], c.range[0]]);
            }
          });
        }
      }
      function m(h) {
        if (!h.generator)
          return;
        const l = a(h), s = u.getTokenBefore(l), c = u.getTokenAfter(l);
        let g = "named";
        h.parent.type === "MethodDefinition" || h.parent.type === "Property" && h.parent.method ? g = "method" : h.id || (g = "anonymous"), g === "method" && l === u.getFirstToken(h.parent) || p(g, "before", s, l), p(g, "after", l, c);
      }
      return {
        FunctionDeclaration: m,
        FunctionExpression: m
      };
    }
  }, sa;
}
var ia, mg;
function OT() {
  if (mg) return ia;
  mg = 1;
  const i = Re(), t = /^(?:Arrow)?FunctionExpression$/u;
  function o(f) {
    for (const r of f)
      if (r.reachable)
        return !0;
    return !1;
  }
  return ia = {
    meta: {
      type: "problem",
      docs: {
        description: "Enforce `return` statements in getters",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/getter-return"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expected: "Expected to return a value in {{name}}.",
        expectedAlways: "Expected {{name}} to always return a value."
      }
    },
    create(f) {
      const r = f.options[0] || { allowImplicit: !1 }, u = f.sourceCode;
      let e = {
        upper: null,
        codePath: null,
        hasReturn: !1,
        shouldCheck: !1,
        node: null,
        currentSegments: []
      };
      function a(p) {
        e.shouldCheck && o(e.currentSegments) && f.report({
          node: p,
          loc: i.getFunctionHeadLoc(p, u),
          messageId: e.hasReturn ? "expectedAlways" : "expected",
          data: {
            name: i.getFunctionNameWithKind(e.node)
          }
        });
      }
      function n(p) {
        const m = p.parent;
        if (t.test(p.type) && p.body.type === "BlockStatement") {
          if (m.kind === "get")
            return !0;
          if (m.type === "Property" && i.getStaticPropertyName(m) === "get" && m.parent.type === "ObjectExpression") {
            if (m.parent.parent.type === "CallExpression") {
              const h = m.parent.parent.callee;
              if (i.isSpecificMemberAccess(h, "Object", "defineProperty") || i.isSpecificMemberAccess(h, "Reflect", "defineProperty"))
                return !0;
            }
            if (m.parent.parent.type === "Property" && m.parent.parent.parent.type === "ObjectExpression" && m.parent.parent.parent.parent.type === "CallExpression") {
              const h = m.parent.parent.parent.parent.callee;
              return i.isSpecificMemberAccess(h, "Object", "defineProperties") || i.isSpecificMemberAccess(h, "Object", "create");
            }
          }
        }
        return !1;
      }
      return {
        // Stacks this function's information.
        onCodePathStart(p, m) {
          e = {
            upper: e,
            codePath: p,
            hasReturn: !1,
            shouldCheck: n(m),
            node: m,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Pops this function's information.
        onCodePathEnd() {
          e = e.upper;
        },
        onUnreachableCodePathSegmentStart(p) {
          e.currentSegments.add(p);
        },
        onUnreachableCodePathSegmentEnd(p) {
          e.currentSegments.delete(p);
        },
        onCodePathSegmentStart(p) {
          e.currentSegments.add(p);
        },
        onCodePathSegmentEnd(p) {
          e.currentSegments.delete(p);
        },
        // Checks the return statement is valid.
        ReturnStatement(p) {
          e.shouldCheck && (e.hasReturn = !0, !r.allowImplicit && !p.argument && f.report({
            node: p,
            messageId: "expected",
            data: {
              name: i.getFunctionNameWithKind(e.node)
            }
          }));
        },
        // Reports a given function if the last path is reachable.
        "FunctionExpression:exit": a,
        "ArrowFunctionExpression:exit": a
      };
    }
  }, ia;
}
var aa, gg;
function UT() {
  if (gg) return aa;
  gg = 1;
  const i = /* @__PURE__ */ new Set([
    "AssignmentExpression",
    "VariableDeclarator",
    "MemberExpression",
    "ExpressionStatement",
    "CallExpression",
    "ConditionalExpression",
    "Program",
    "VariableDeclaration",
    "ChainExpression"
  ]);
  function t(f, r) {
    const u = f.references.filter((e) => e.identifier.range[0] === r.range[0] && e.identifier.range[1] === r.range[1]);
    return u.length === 1 ? u[0] : null;
  }
  function o(f, r) {
    const u = t(f, r);
    return u && u.resolved && u.resolved.defs.length > 0;
  }
  return aa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Require `require()` calls to be placed at top-level module scope",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/global-require"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected require()."
      }
    },
    create(f) {
      const r = f.sourceCode;
      return {
        CallExpression(u) {
          const e = r.getScope(u);
          u.callee.name === "require" && !o(e, u.callee) && (r.getAncestors(u).every((n) => i.has(n.type)) || f.report({ node: u, messageId: "unexpected" }));
        }
      };
    }
  }, aa;
}
var oa, dg;
function VT() {
  if (dg) return oa;
  dg = 1;
  const i = Re();
  function t(r, u) {
    if (r.length !== u.length)
      return !1;
    for (let e = 0; e < r.length; e++) {
      const a = r[e], n = u[e];
      if (a.type !== n.type || a.value !== n.value)
        return !1;
    }
    return !0;
  }
  function o(r, u) {
    return typeof r == "string" && typeof u == "string" ? r === u : Array.isArray(r) && Array.isArray(u) ? t(r, u) : !1;
  }
  function f(r) {
    return r.kind === "get" || r.kind === "set";
  }
  return oa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require grouped accessor pairs in object literals and classes",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/grouped-accessor-pairs"
      },
      schema: [
        {
          enum: ["anyOrder", "getBeforeSet", "setBeforeGet"]
        }
      ],
      messages: {
        notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
        invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
      }
    },
    create(r) {
      const u = r.options[0] || "anyOrder", e = r.sourceCode;
      function a(p, m, h) {
        r.report({
          node: h,
          messageId: p,
          loc: i.getFunctionHeadLoc(h.value, e),
          data: {
            formerName: i.getFunctionNameWithKind(m.value),
            latterName: i.getFunctionNameWithKind(h.value)
          }
        });
      }
      function n(p, m) {
        const h = [];
        let l = !1;
        for (let s = 0; s < p.length; s++) {
          const c = p[s];
          if (m(c) && f(c)) {
            const g = i.getStaticPropertyName(c), d = g !== null ? g : e.getTokens(c.key);
            for (let y = 0; y < h.length; y++) {
              const v = h[y];
              if (o(v.key, d)) {
                v.getters.push(...c.kind === "get" ? [c] : []), v.setters.push(...c.kind === "set" ? [c] : []), l = !0;
                break;
              }
            }
            l || h.push({
              key: d,
              getters: c.kind === "get" ? [c] : [],
              setters: c.kind === "set" ? [c] : []
            }), l = !1;
          }
        }
        for (const { getters: s, setters: c } of h)
          if (s.length === 1 && c.length === 1) {
            const [g] = s, [d] = c, y = p.indexOf(g), v = p.indexOf(d), T = y < v ? g : d, b = y < v ? d : g;
            Math.abs(y - v) > 1 ? a("notGrouped", T, b) : (u === "getBeforeSet" && y > v || u === "setBeforeGet" && y < v) && a("invalidOrder", T, b);
          }
      }
      return {
        ObjectExpression(p) {
          n(p.properties, (m) => m.type === "Property");
        },
        ClassBody(p) {
          n(p.body, (m) => m.type === "MethodDefinition" && !m.static), n(p.body, (m) => m.type === "MethodDefinition" && m.static);
        }
      };
    }
  }, oa;
}
var la, Eg;
function MT() {
  return Eg || (Eg = 1, la = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `for-in` loops to include an `if` statement",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/guard-for-in"
      },
      schema: [],
      messages: {
        wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
      }
    },
    create(i) {
      return {
        ForInStatement(t) {
          const o = t.body;
          if (o.type !== "EmptyStatement" && o.type !== "IfStatement" && !(o.type === "BlockStatement" && o.body.length === 0) && !(o.type === "BlockStatement" && o.body.length === 1 && o.body[0].type === "IfStatement")) {
            if (o.type === "BlockStatement" && o.body.length >= 1 && o.body[0].type === "IfStatement") {
              const f = o.body[0];
              if (f.consequent.type === "ContinueStatement" || f.consequent.type === "BlockStatement" && f.consequent.body.length === 1 && f.consequent.body[0].type === "ContinueStatement")
                return;
            }
            i.report({ node: t, messageId: "wrap" });
          }
        }
      };
    }
  }), la;
}
var ua, yg;
function KT() {
  return yg || (yg = 1, ua = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Require error handling in callbacks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/handle-callback-err"
      },
      schema: [
        {
          type: "string"
        }
      ],
      messages: {
        expected: "Expected error to be handled."
      }
    },
    create(i) {
      const t = i.options[0] || "err", o = i.sourceCode;
      function f(a) {
        return a[0] === "^";
      }
      function r(a) {
        return f(t) ? new RegExp(t, "u").test(a) : a === t;
      }
      function u(a) {
        return a.variables.filter((n) => n.defs[0] && n.defs[0].type === "Parameter");
      }
      function e(a) {
        const n = o.getScope(a), p = u(n), m = p[0];
        m && r(m.name) && m.references.length === 0 && i.report({ node: a, messageId: "expected" });
      }
      return {
        FunctionDeclaration: e,
        FunctionExpression: e,
        ArrowFunctionExpression: e
      };
    }
  }), ua;
}
var ca, Cg;
function jT() {
  if (Cg) return ca;
  Cg = 1;
  function i(r) {
    const u = r.parent;
    return (
      // normal assignment
      u.type === "AssignmentExpression" && u.left === r || // destructuring
      u.type === "ArrayPattern" || u.type === "RestElement" || u.type === "Property" && u.value === r && u.parent.type === "ObjectPattern" || u.type === "AssignmentPattern" && u.left === r
    );
  }
  function t(r) {
    const u = r.parent;
    return u.type === "ImportSpecifier" && u.imported !== u.local && u.imported === r || u.type === "ExportSpecifier" && u.parent.source && // re-export
    u.local !== u.exported && u.local === r;
  }
  function o(r) {
    const u = r.parent;
    return !u.computed && u.type === "Property" && u.parent.type === "ObjectPattern" && u.value !== r && u.key === r;
  }
  function f(r) {
    const u = r.parent;
    return u.type === "Property" && u.parent.type === "ObjectExpression" && u.shorthand;
  }
  return ca = {
    meta: {
      deprecated: !0,
      replacedBy: ["id-denylist"],
      type: "suggestion",
      docs: {
        description: "Disallow specified identifiers",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/id-blacklist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted."
      }
    },
    create(r) {
      const u = new Set(r.options), e = /* @__PURE__ */ new Set(), a = r.sourceCode;
      let n;
      function p(s) {
        return u.has(s);
      }
      function m(s) {
        const c = n.set.get(s.name);
        return c && c.defs.length === 0 && c.references.some((g) => g.identifier === s);
      }
      function h(s) {
        const c = s.parent;
        return c.type === "MemberExpression" && c.property === s && !c.computed ? i(c) : c.type !== "CallExpression" && c.type !== "NewExpression" && !t(s) && !o(s) && !(m(s) && !f(s));
      }
      function l(s) {
        e.has(s.range.toString()) || (r.report({
          node: s,
          messageId: "restricted",
          data: {
            name: s.name
          }
        }), e.add(s.range.toString()));
      }
      return {
        Program(s) {
          n = a.getScope(s);
        },
        Identifier(s) {
          p(s.name) && h(s) && l(s);
        }
      };
    }
  }, ca;
}
var fa, vg;
function qT() {
  if (vg) return fa;
  vg = 1;
  function i(f) {
    const r = f.parent;
    return (
      // normal assignment
      r.type === "AssignmentExpression" && r.left === f || // destructuring
      r.type === "ArrayPattern" || r.type === "RestElement" || r.type === "Property" && r.value === f && r.parent.type === "ObjectPattern" || r.type === "AssignmentPattern" && r.left === f
    );
  }
  function t(f) {
    const r = f.parent;
    return r.type === "ImportSpecifier" && r.imported !== r.local && r.imported === f || r.type === "ExportSpecifier" && r.parent.source && // re-export
    r.local !== r.exported && r.local === f;
  }
  function o(f) {
    const r = f.parent;
    return !r.computed && r.type === "Property" && r.parent.type === "ObjectPattern" && r.key === f;
  }
  return fa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified identifiers",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/id-denylist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted.",
        restrictedPrivate: "Identifier '#{{name}}' is restricted."
      }
    },
    create(f) {
      const r = new Set(f.options), u = /* @__PURE__ */ new Set(), e = f.sourceCode;
      let a;
      function n(l) {
        return r.has(l);
      }
      function p(l) {
        const s = a.set.get(l.name);
        return s && s.defs.length === 0 && s.references.some((c) => c.identifier === l);
      }
      function m(l) {
        const s = l.parent;
        return s.type === "MemberExpression" && s.property === l && !s.computed ? i(s) : s.type !== "CallExpression" && s.type !== "NewExpression" && !t(l) && !o(l) && !p(l);
      }
      function h(l) {
        if (!u.has(l.range.toString())) {
          const s = l.type === "PrivateIdentifier";
          f.report({
            node: l,
            messageId: s ? "restrictedPrivate" : "restricted",
            data: {
              name: l.name
            }
          }), u.add(l.range.toString());
        }
      }
      return {
        Program(l) {
          a = e.getScope(l);
        },
        [[
          "Identifier",
          "PrivateIdentifier"
        ]](l) {
          n(l.name) && m(l) && h(l);
        }
      };
    }
  }, fa;
}
var pa, Sg;
function $T() {
  if (Sg) return pa;
  Sg = 1;
  const { getGraphemeCount: i } = Sr();
  return pa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce minimum and maximum identifier lengths",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/id-length"
      },
      schema: [
        {
          type: "object",
          properties: {
            min: {
              type: "integer",
              default: 2
            },
            max: {
              type: "integer"
            },
            exceptions: {
              type: "array",
              uniqueItems: !0,
              items: {
                type: "string"
              }
            },
            exceptionPatterns: {
              type: "array",
              uniqueItems: !0,
              items: {
                type: "string"
              }
            },
            properties: {
              enum: ["always", "never"]
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
        tooShortPrivate: "Identifier name '#{{name}}' is too short (< {{min}}).",
        tooLong: "Identifier name '{{name}}' is too long (> {{max}}).",
        tooLongPrivate: "Identifier name #'{{name}}' is too long (> {{max}})."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = typeof o.min < "u" ? o.min : 2, r = typeof o.max < "u" ? o.max : 1 / 0, u = o.properties !== "never", e = new Set(o.exceptions), a = (o.exceptionPatterns || []).map((h) => new RegExp(h, "u")), n = /* @__PURE__ */ new Set();
      function p(h) {
        return a.some((l) => l.test(h));
      }
      const m = {
        MemberExpression: u && function(h) {
          return !h.computed && // regular property assignment
          (h.parent.left === h && h.parent.type === "AssignmentExpression" || // or the last identifier in an ObjectPattern destructuring
          h.parent.type === "Property" && h.parent.value === h && h.parent.parent.type === "ObjectPattern" && h.parent.parent.parent.left === h.parent.parent);
        },
        AssignmentPattern(h, l) {
          return h.left === l;
        },
        VariableDeclarator(h, l) {
          return h.id === l;
        },
        Property(h, l) {
          if (h.parent.type === "ObjectPattern") {
            const s = h.value.name === h.key.name;
            return !s && h.value === l || s && h.key === l && u;
          }
          return u && !h.computed && h.key.name === l.name;
        },
        ImportDefaultSpecifier: !0,
        RestElement: !0,
        FunctionExpression: !0,
        ArrowFunctionExpression: !0,
        ClassDeclaration: !0,
        FunctionDeclaration: !0,
        MethodDefinition: !0,
        PropertyDefinition: !0,
        CatchClause: !0,
        ArrayPattern: !0
      };
      return {
        [[
          "Identifier",
          "PrivateIdentifier"
        ]](h) {
          const l = h.name, s = h.parent, c = i(l), g = c < f, d = c > r;
          if (!(g || d) || e.has(l) || p(l))
            return;
          const y = m[s.type];
          if (y && !n.has(h.range.toString()) && (y === !0 || y(s, h))) {
            n.add(h.range.toString());
            let v = g ? "tooShort" : "tooLong";
            h.type === "PrivateIdentifier" && (v += "Private"), t.report({
              node: h,
              messageId: v,
              data: { name: l, min: f, max: r }
            });
          }
        }
      };
    }
  }, pa;
}
var ha, Ag;
function GT() {
  return Ag || (Ag = 1, ha = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require identifiers to match a specified regular expression",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/id-match"
      },
      schema: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            properties: {
              type: "boolean",
              default: !1
            },
            classFields: {
              type: "boolean",
              default: !1
            },
            onlyDeclarations: {
              type: "boolean",
              default: !1
            },
            ignoreDestructuring: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
        notMatchPrivate: "Identifier '#{{name}}' does not match the pattern '{{pattern}}'."
      }
    },
    create(i) {
      const t = i.options[0] || "^.+$", o = new RegExp(t, "u"), f = i.options[1] || {}, r = !!f.properties, u = !!f.classFields, e = !!f.onlyDeclarations, a = !!f.ignoreDestructuring, n = i.sourceCode;
      let p;
      const m = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]), l = /* @__PURE__ */ new Set(["FunctionDeclaration", "VariableDeclarator"]), s = /* @__PURE__ */ new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);
      function c(T) {
        const b = p.set.get(T.name);
        return b && b.defs.length === 0 && b.references.some((S) => S.identifier === T);
      }
      function g(T) {
        return !o.test(T);
      }
      function d(T) {
        let { parent: b } = T;
        for (; b; ) {
          if (b.type === "ObjectPattern")
            return !0;
          b = b.parent;
        }
        return !1;
      }
      function y(T, b) {
        return (!e || l.has(T.type)) && !h.has(T.type) && g(b);
      }
      function v(T) {
        if (!m.has(T.range.toString())) {
          const b = T.type === "PrivateIdentifier" ? "notMatchPrivate" : "notMatch";
          i.report({
            node: T,
            messageId: b,
            data: {
              name: T.name,
              pattern: t
            }
          }), m.add(T.range.toString());
        }
      }
      return {
        Program(T) {
          p = n.getScope(T);
        },
        Identifier(T) {
          const b = T.name, S = T.parent, C = S.type === "MemberExpression" ? S.parent : S;
          if (!c(T))
            if (S.type === "MemberExpression") {
              if (!r)
                return;
              S.object.type === "Identifier" && S.object.name === b || C.type === "AssignmentExpression" && C.left.type === "MemberExpression" && C.left.property.name === T.name ? g(b) && v(T) : C.type === "AssignmentExpression" && C.right.type !== "MemberExpression" && g(b) && v(T);
            } else if (S.type === "Property" && S.parent.type === "ObjectExpression" && S.key === T && !S.computed)
              r && g(b) && v(T);
            else if (S.type === "Property" || S.type === "AssignmentPattern") {
              if (S.parent && S.parent.type === "ObjectPattern") {
                !a && S.shorthand && S.value.left && g(b) && v(T);
                const x = S.key.name === S.value.name;
                if (!x && S.key === T)
                  return;
                S.value.name && g(b) && !(x && a) && v(T);
              }
              if (!r && !S.computed || a && d(T))
                return;
              S.right !== T && y(C, b) && v(T);
            } else s.has(S.type) ? S.local && S.local.name === T.name && g(b) && v(T) : S.type === "PropertyDefinition" ? u && g(b) && v(T) : y(C, b) && v(T);
        },
        PrivateIdentifier(T) {
          T.parent.type === "PropertyDefinition" && !u || g(T.name) && v(T);
        }
      };
    }
  }), ha;
}
var ma, Tg;
function WT() {
  if (Tg) return ma;
  Tg = 1;
  const { isCommentToken: i, isNotOpeningParenToken: t } = Re();
  return ma = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce the location of arrow function bodies",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/implicit-arrow-linebreak"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["beside", "below"]
        }
      ],
      messages: {
        expected: "Expected a linebreak before this expression.",
        unexpected: "Expected no linebreak before this expression."
      }
    },
    create(o) {
      const f = o.sourceCode, r = o.options[0] || "beside";
      function u(e) {
        if (e.body.type === "BlockStatement")
          return;
        const a = f.getTokenBefore(e.body, t), n = f.getTokenAfter(a);
        a.loc.end.line === n.loc.start.line && r === "below" ? o.report({
          node: n,
          messageId: "expected",
          fix: (p) => p.insertTextBefore(n, `
`)
        }) : a.loc.end.line !== n.loc.start.line && r === "beside" && o.report({
          node: n,
          messageId: "unexpected",
          fix(p) {
            return f.getFirstTokenBetween(a, n, { includeComments: !0, filter: i }) ? null : p.replaceTextRange([a.range[1], n.range[0]], " ");
          }
        });
      }
      return {
        ArrowFunctionExpression: (e) => u(e)
      };
    }
  }, ma;
}
var ga, bg;
function XT() {
  if (bg) return ga;
  bg = 1;
  const i = Re(), t = /* @__PURE__ */ new Set([
    "AssignmentExpression",
    "AssignmentPattern",
    "ArrayExpression",
    "ArrayPattern",
    "ArrowFunctionExpression",
    "AwaitExpression",
    "BlockStatement",
    "BinaryExpression",
    "BreakStatement",
    "CallExpression",
    "CatchClause",
    "ChainExpression",
    "ClassBody",
    "ClassDeclaration",
    "ClassExpression",
    "ConditionalExpression",
    "ContinueStatement",
    "DoWhileStatement",
    "DebuggerStatement",
    "EmptyStatement",
    "ExperimentalRestProperty",
    "ExperimentalSpreadProperty",
    "ExpressionStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement",
    "FunctionDeclaration",
    "FunctionExpression",
    "Identifier",
    "IfStatement",
    "Literal",
    "LabeledStatement",
    "LogicalExpression",
    "MemberExpression",
    "MetaProperty",
    "MethodDefinition",
    "NewExpression",
    "ObjectExpression",
    "ObjectPattern",
    "PrivateIdentifier",
    "Program",
    "Property",
    "PropertyDefinition",
    "RestElement",
    "ReturnStatement",
    "SequenceExpression",
    "SpreadElement",
    "StaticBlock",
    "Super",
    "SwitchCase",
    "SwitchStatement",
    "TaggedTemplateExpression",
    "TemplateElement",
    "TemplateLiteral",
    "ThisExpression",
    "ThrowStatement",
    "TryStatement",
    "UnaryExpression",
    "UpdateExpression",
    "VariableDeclaration",
    "VariableDeclarator",
    "WhileStatement",
    "WithStatement",
    "YieldExpression",
    "JSXFragment",
    "JSXOpeningFragment",
    "JSXClosingFragment",
    "JSXIdentifier",
    "JSXNamespacedName",
    "JSXMemberExpression",
    "JSXEmptyExpression",
    "JSXExpressionContainer",
    "JSXElement",
    "JSXClosingElement",
    "JSXOpeningElement",
    "JSXAttribute",
    "JSXSpreadAttribute",
    "JSXText",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration",
    "ExportSpecifier",
    "ImportDeclaration",
    "ImportSpecifier",
    "ImportDefaultSpecifier",
    "ImportNamespaceSpecifier",
    "ImportExpression"
  ]);
  class o {
    /**
     * Creates an empty map
     * @param {number} maxKey The maximum key
     */
    constructor(a) {
      this._values = Array(a + 1);
    }
    /**
     * Inserts an entry into the map.
     * @param {number} key The entry's key
     * @param {any} value The entry's value
     * @returns {void}
     */
    insert(a, n) {
      this._values[a] = n;
    }
    /**
     * Finds the value of the entry with the largest key less than or equal to the provided key
     * @param {number} key The provided key
     * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.
     */
    findLastNotAfter(a) {
      const n = this._values;
      for (let p = a; p >= 0; p--) {
        const m = n[p];
        if (m)
          return m;
      }
    }
    /**
     * Deletes all of the keys in the interval [start, end)
     * @param {number} start The start of the range
     * @param {number} end The end of the range
     * @returns {void}
     */
    deleteRange(a, n) {
      this._values.fill(void 0, a, n);
    }
  }
  class f {
    /**
     * @param {SourceCode} sourceCode A SourceCode object
     */
    constructor(a) {
      this.sourceCode = a, this.firstTokensByLineNumber = /* @__PURE__ */ new Map();
      const n = a.tokensAndComments;
      for (let p = 0; p < n.length; p++) {
        const m = n[p];
        this.firstTokensByLineNumber.has(m.loc.start.line) || this.firstTokensByLineNumber.set(m.loc.start.line, m), !this.firstTokensByLineNumber.has(m.loc.end.line) && a.text.slice(m.range[1] - m.loc.end.column, m.range[1]).trim() && this.firstTokensByLineNumber.set(m.loc.end.line, m);
      }
    }
    /**
     * Gets the first token on a given token's line
     * @param {Token|ASTNode} token a node or token
     * @returns {Token} The first token on the given line
     */
    getFirstTokenOfLine(a) {
      return this.firstTokensByLineNumber.get(a.loc.start.line);
    }
    /**
     * Determines whether a token is the first token in its line
     * @param {Token} token The token
     * @returns {boolean} `true` if the token is the first on its line
     */
    isFirstTokenOfLine(a) {
      return this.getFirstTokenOfLine(a) === a;
    }
    /**
     * Get the actual indent of a token
     * @param {Token} token Token to examine. This should be the first token on its line.
     * @returns {string} The indentation characters that precede the token
     */
    getTokenIndent(a) {
      return this.sourceCode.text.slice(a.range[0] - a.loc.start.column, a.range[0]);
    }
  }
  class r {
    /**
     * @param {TokenInfo} tokenInfo a TokenInfo instance
     * @param {number} indentSize The desired size of each indentation level
     * @param {string} indentType The indentation character
     * @param {number} maxIndex The maximum end index of any token
     */
    constructor(a, n, p, m) {
      this._tokenInfo = a, this._indentSize = n, this._indentType = p, this._indexMap = new o(m), this._indexMap.insert(0, { offset: 0, from: null, force: !1 }), this._lockedFirstTokens = /* @__PURE__ */ new WeakMap(), this._desiredIndentCache = /* @__PURE__ */ new WeakMap(), this._ignoredTokens = /* @__PURE__ */ new WeakSet();
    }
    _getOffsetDescriptor(a) {
      return this._indexMap.findLastNotAfter(a.range[0]);
    }
    /**
     * Sets the offset column of token B to match the offset column of token A.
     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
     * most cases, `setDesiredOffset` should be used instead.
     * @param {Token} baseToken The first token
     * @param {Token} offsetToken The second token, whose offset should be matched to the first token
     * @returns {void}
     */
    matchOffsetOf(a, n) {
      this._lockedFirstTokens.set(n, a);
    }
    /**
     * Sets the desired offset of a token.
     *
     * This uses a line-based offset collapsing behavior to handle tokens on the same line.
     * For example, consider the following two cases:
     *
     * (
     *     [
     *         bar
     *     ]
     * )
     *
     * ([
     *     bar
     * ])
     *
     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
     * from the start of its line.
     *
     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
     * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
     * by 1 indent level from the start of the line.
     *
     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
     * without needing to check which lines those tokens are on.
     *
     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
     * behavior can occur. For example, consider the following cases:
     *
     * foo(
     * ).
     *     bar(
     *         baz
     *     )
     *
     * foo(
     * ).bar(
     *     baz
     * )
     *
     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
     * collapsing would occur).
     *
     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
     * in the second case.
     * @param {Token} token The token
     * @param {Token} fromToken The token that `token` should be offset from
     * @param {number} offset The desired indent level
     * @returns {void}
     */
    setDesiredOffset(a, n, p) {
      return this.setDesiredOffsets(a.range, n, p);
    }
    /**
     * Sets the desired offset of all tokens in a range
     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
     * it). This means that the offset of each token is updated O(AST depth) times.
     * It would not be performant to store and update the offsets for each token independently, because the rule would end
     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
     *
     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
     * list could represent the state of the offset tree at a given point:
     *
     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file
     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
     * - Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token
     *
     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
     * `setDesiredOffsets([30, 43], fooToken, 1);`
     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
     * @param {Token} fromToken The token that this is offset from
     * @param {number} offset The desired indent level
     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
     * @returns {void}
     */
    setDesiredOffsets(a, n, p, m) {
      const h = { offset: p, from: n, force: m }, l = this._indexMap.findLastNotAfter(a[1]), s = n && n.range[0] >= a[0] && n.range[1] <= a[1], c = s && this._getOffsetDescriptor(n);
      this._indexMap.deleteRange(a[0] + 1, a[1]), this._indexMap.insert(a[0], h), s && (this._indexMap.insert(n.range[0], c), this._indexMap.insert(n.range[1], h)), this._indexMap.insert(a[1], l);
    }
    /**
     * Gets the desired indent of a token
     * @param {Token} token The token
     * @returns {string} The desired indent of the token
     */
    getDesiredIndent(a) {
      if (!this._desiredIndentCache.has(a))
        if (this._ignoredTokens.has(a))
          this._desiredIndentCache.set(
            a,
            this._tokenInfo.getTokenIndent(a)
          );
        else if (this._lockedFirstTokens.has(a)) {
          const n = this._lockedFirstTokens.get(a);
          this._desiredIndentCache.set(
            a,
            // (indentation for the first element's line)
            this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(n)) + // (space between the start of the first element's line and the first element)
            this._indentType.repeat(n.loc.start.column - this._tokenInfo.getFirstTokenOfLine(n).loc.start.column)
          );
        } else {
          const n = this._getOffsetDescriptor(a), p = n.from && n.from.loc.start.line === a.loc.start.line && !/^\s*?\n/u.test(a.value) && !n.force ? 0 : n.offset * this._indentSize;
          this._desiredIndentCache.set(
            a,
            (n.from ? this.getDesiredIndent(n.from) : "") + this._indentType.repeat(p)
          );
        }
      return this._desiredIndentCache.get(a);
    }
    /**
     * Ignores a token, preventing it from being reported.
     * @param {Token} token The token
     * @returns {void}
     */
    ignoreToken(a) {
      this._tokenInfo.isFirstTokenOfLine(a) && this._ignoredTokens.add(a);
    }
    /**
     * Gets the first token that the given token's indentation is dependent on
     * @param {Token} token The token
     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
     */
    getFirstDependency(a) {
      return this._getOffsetDescriptor(a).from;
    }
  }
  const u = {
    oneOf: [
      {
        type: "integer",
        minimum: 0
      },
      {
        enum: ["first", "off"]
      }
    ]
  };
  return ga = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent indentation",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/indent"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            VariableDeclarator: {
              oneOf: [
                u,
                {
                  type: "object",
                  properties: {
                    var: u,
                    let: u,
                    const: u
                  },
                  additionalProperties: !1
                }
              ]
            },
            outerIIFEBody: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            MemberExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: u,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: u,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            },
            StaticBlock: {
              type: "object",
              properties: {
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            },
            CallExpression: {
              type: "object",
              properties: {
                arguments: u
              },
              additionalProperties: !1
            },
            ArrayExpression: u,
            ObjectExpression: u,
            ImportDeclaration: u,
            flatTernaryExpressions: {
              type: "boolean",
              default: !1
            },
            offsetTernaryExpressions: {
              type: "boolean",
              default: !1
            },
            ignoredNodes: {
              type: "array",
              items: {
                type: "string",
                not: {
                  pattern: ":exit$"
                }
              }
            },
            ignoreComments: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(e) {
      let m = "space", h = 4;
      const l = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: 1,
          let: 1,
          const: 1
        },
        outerIIFEBody: 1,
        FunctionDeclaration: {
          parameters: 1,
          body: 1
        },
        FunctionExpression: {
          parameters: 1,
          body: 1
        },
        StaticBlock: {
          body: 1
        },
        CallExpression: {
          arguments: 1
        },
        MemberExpression: 1,
        ArrayExpression: 1,
        ObjectExpression: 1,
        ImportDeclaration: 1,
        flatTernaryExpressions: !1,
        ignoredNodes: [],
        ignoreComments: !1
      };
      e.options.length && (e.options[0] === "tab" ? (h = 1, m = "tab") : (h = e.options[0], m = "space"), e.options[1] && (Object.assign(l, e.options[1]), (typeof l.VariableDeclarator == "number" || l.VariableDeclarator === "first") && (l.VariableDeclarator = {
        var: l.VariableDeclarator,
        let: l.VariableDeclarator,
        const: l.VariableDeclarator
      })));
      const s = e.sourceCode, c = new f(s), g = new r(c, h, m === "space" ? " " : "	", s.text.length), d = /* @__PURE__ */ new WeakSet();
      function y(P, X, Q) {
        const ue = `${P} ${m}${P === 1 ? "" : "s"}`, le = `space${X === 1 ? "" : "s"}`, Ce = `tab${Q === 1 ? "" : "s"}`;
        let j;
        return X > 0 ? j = m === "space" ? X : `${X} ${le}` : Q > 0 ? j = m === "tab" ? Q : `${Q} ${Ce}` : j = "0", {
          expected: ue,
          actual: j
        };
      }
      function v(P, X) {
        const Q = Array.from(c.getTokenIndent(P)), ue = Q.filter((Ce) => Ce === " ").length, le = Q.filter((Ce) => Ce === "	").length;
        e.report({
          node: P,
          messageId: "wrongIndentation",
          data: y(X.length, ue, le),
          loc: {
            start: { line: P.loc.start.line, column: 0 },
            end: { line: P.loc.start.line, column: P.loc.start.column }
          },
          fix(Ce) {
            const j = [P.range[0] - P.loc.start.column, P.range[0]], H = X;
            return Ce.replaceTextRange(j, H);
          }
        });
      }
      function T(P, X) {
        const Q = c.getTokenIndent(P);
        return Q === X || // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
        Q.includes(" ") && Q.includes("	");
      }
      function b(P) {
        if (!P.parent || P.parent.type !== "CallExpression" || P.parent.callee !== P)
          return !1;
        let X = P.parent && P.parent.parent;
        for (; X.type === "UnaryExpression" && ["!", "~", "+", "-"].includes(X.operator) || X.type === "AssignmentExpression" || X.type === "LogicalExpression" || X.type === "SequenceExpression" || X.type === "VariableDeclarator"; )
          X = X.parent;
        return (X.type === "ExpressionStatement" || X.type === "VariableDeclaration") && X.parent.type === "Program";
      }
      function S(P) {
        const Q = P.match(/\s*$/u)[0].match(i.createGlobalLinebreakMatcher());
        return Q === null ? 0 : Q.length;
      }
      function C(P, X, Q, ue) {
        function le(Ce) {
          let j = s.getTokenBefore(Ce);
          for (; i.isOpeningParenToken(j) && j !== X; )
            j = s.getTokenBefore(j);
          return s.getTokenAfter(j);
        }
        g.setDesiredOffsets(
          [X.range[1], Q.range[0]],
          X,
          typeof ue == "number" ? ue : 1
        ), g.setDesiredOffset(Q, X, 0), !(ue === "first" && P.length && !P[0]) && P.forEach((Ce, j) => {
          if (Ce && (ue === "off" && g.ignoreToken(le(Ce)), j !== 0))
            if (ue === "first" && c.isFirstTokenOfLine(le(Ce)))
              g.matchOffsetOf(le(P[0]), le(Ce));
            else {
              const H = P[j - 1], N = H && le(H), G = H && s.getLastToken(H);
              H && G.loc.end.line - S(G.value) > X.loc.end.line && g.setDesiredOffsets(
                [H.range[1], Ce.range[1]],
                N,
                0
              );
            }
        });
      }
      function x(P) {
        if (P.type !== "BlockStatement") {
          const X = s.getTokenBefore(P, i.isNotOpeningParenToken);
          let Q = s.getFirstToken(P), ue = s.getLastToken(P);
          for (; i.isOpeningParenToken(s.getTokenBefore(Q)) && i.isClosingParenToken(s.getTokenAfter(ue)); )
            Q = s.getTokenBefore(Q), ue = s.getTokenAfter(ue);
          g.setDesiredOffsets([Q.range[0], ue.range[1]], X, 1);
        }
      }
      function A(P) {
        let X;
        P.arguments.length ? X = s.getFirstTokenBetween(P.callee, P.arguments[0], i.isOpeningParenToken) : X = s.getLastToken(P, 1);
        const Q = s.getLastToken(P);
        if (d.add(X), d.add(Q), P.optional) {
          const Ce = s.getTokenAfter(P.callee, i.isQuestionDotToken), j = s.getTokensBetween(P.callee, Ce, { filter: i.isClosingParenToken }).length, H = j ? s.getTokenBefore(P.callee, { skip: j - 1 }) : s.getFirstToken(P.callee), N = s.getTokenBefore(Ce), G = N.loc.end.line === X.loc.start.line ? N : H;
          g.setDesiredOffset(Ce, G, 1);
        }
        const ue = P.callee.type === "TaggedTemplateExpression" ? s.getFirstToken(P.callee.quasi) : X, le = s.getTokenBefore(ue);
        g.setDesiredOffset(X, le, 0), C(P.arguments, X, Q, l.CallExpression.arguments);
      }
      function R(P) {
        const X = [], Q = [];
        for (let ue = 0; ue < P.length; ue++) {
          const le = P[ue];
          i.isOpeningParenToken(le) ? X.push(le) : i.isClosingParenToken(le) && Q.push({ left: X.pop(), right: le });
        }
        for (let ue = Q.length - 1; ue >= 0; ue--) {
          const le = Q[ue].left, Ce = Q[ue].right;
          if (!d.has(le) && !d.has(Ce)) {
            const j = new Set(s.getTokensBetween(le, Ce));
            j.forEach((H) => {
              j.has(g.getFirstDependency(H)) || g.setDesiredOffset(H, le, 1);
            });
          }
          g.setDesiredOffset(Ce, le, 0);
        }
      }
      function L(P) {
        const X = new Set(s.getTokens(P, { includeComments: !0 }));
        X.forEach((Q) => {
          if (!X.has(g.getFirstDependency(Q))) {
            const ue = c.getFirstTokenOfLine(Q);
            Q === ue ? g.ignoreToken(Q) : g.setDesiredOffset(Q, ue, 0);
          }
        });
      }
      function _(P, X) {
        let Q = X;
        for (; Q.parent && !Q.parent.type.endsWith("Statement") && !Q.parent.type.endsWith("Declaration"); )
          Q = Q.parent;
        return Q = Q.parent, !Q || Q.loc.start.line === P.loc.start.line;
      }
      function I(P, X) {
        const Q = P.loc.end.line, ue = X.loc.start.line;
        if (Q === ue || Q === ue - 1)
          return !1;
        for (let le = Q + 1; le < ue; ++le)
          if (!c.firstTokensByLineNumber.has(le))
            return !0;
        return !1;
      }
      const O = /* @__PURE__ */ new Set(), k = {
        "ArrayExpression, ArrayPattern"(P) {
          const X = s.getFirstToken(P), Q = s.getTokenAfter([...P.elements].reverse().find((ue) => ue) || X, i.isClosingBracketToken);
          C(P.elements, X, Q, l.ArrayExpression);
        },
        "ObjectExpression, ObjectPattern"(P) {
          const X = s.getFirstToken(P), Q = s.getTokenAfter(
            P.properties.length ? P.properties[P.properties.length - 1] : X,
            i.isClosingBraceToken
          );
          C(P.properties, X, Q, l.ObjectExpression);
        },
        ArrowFunctionExpression(P) {
          const X = s.getFirstToken(P, { skip: P.async ? 1 : 0 });
          if (i.isOpeningParenToken(X)) {
            const Q = X, ue = s.getTokenBefore(P.body, i.isClosingParenToken);
            d.add(Q), d.add(ue), C(P.params, Q, ue, l.FunctionExpression.parameters);
          }
          x(P.body);
        },
        AssignmentExpression(P) {
          const X = s.getFirstTokenBetween(P.left, P.right, (Q) => Q.value === P.operator);
          g.setDesiredOffsets([X.range[0], P.range[1]], s.getLastToken(P.left), 1), g.ignoreToken(X), g.ignoreToken(s.getTokenAfter(X));
        },
        "BinaryExpression, LogicalExpression"(P) {
          const X = s.getFirstTokenBetween(P.left, P.right, (ue) => ue.value === P.operator), Q = s.getTokenAfter(X);
          g.ignoreToken(X), g.ignoreToken(Q), g.setDesiredOffset(Q, X, 0);
        },
        "BlockStatement, ClassBody"(P) {
          let X;
          P.parent && b(P.parent) ? X = l.outerIIFEBody : P.parent && (P.parent.type === "FunctionExpression" || P.parent.type === "ArrowFunctionExpression") ? X = l.FunctionExpression.body : P.parent && P.parent.type === "FunctionDeclaration" ? X = l.FunctionDeclaration.body : X = 1, i.STATEMENT_LIST_PARENTS.has(P.parent.type) || g.setDesiredOffset(s.getFirstToken(P), s.getFirstToken(P.parent), 0), C(P.body, s.getFirstToken(P), s.getLastToken(P), X);
        },
        CallExpression: A,
        "ClassDeclaration[superClass], ClassExpression[superClass]"(P) {
          const X = s.getFirstToken(P), Q = s.getTokenBefore(P.superClass, i.isNotOpeningParenToken);
          g.setDesiredOffsets([Q.range[0], P.body.range[0]], X, 1);
        },
        ConditionalExpression(P) {
          const X = s.getFirstToken(P);
          if (!l.flatTernaryExpressions || !i.isTokenOnSameLine(P.test, P.consequent) || _(X, P)) {
            const Q = s.getFirstTokenBetween(P.test, P.consequent, (H) => H.type === "Punctuator" && H.value === "?"), ue = s.getFirstTokenBetween(P.consequent, P.alternate, (H) => H.type === "Punctuator" && H.value === ":"), le = s.getTokenAfter(Q), Ce = s.getTokenBefore(ue), j = s.getTokenAfter(ue);
            g.setDesiredOffset(Q, X, 1), g.setDesiredOffset(ue, X, 1), g.setDesiredOffset(le, X, le.type === "Punctuator" && l.offsetTernaryExpressions ? 2 : 1), Ce.loc.end.line === j.loc.start.line ? g.setDesiredOffset(j, le, 0) : g.setDesiredOffset(j, X, j.type === "Punctuator" && l.offsetTernaryExpressions ? 2 : 1);
          }
        },
        "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement": (P) => x(P.body),
        ExportNamedDeclaration(P) {
          if (P.declaration === null) {
            const X = s.getLastToken(P, i.isClosingBraceToken);
            C(P.specifiers, s.getFirstToken(P, { skip: 1 }), X, 1), P.source && g.setDesiredOffsets([X.range[1], P.range[1]], s.getFirstToken(P), 1);
          }
        },
        ForStatement(P) {
          const X = s.getFirstToken(P, 1);
          P.init && g.setDesiredOffsets(P.init.range, X, 1), P.test && g.setDesiredOffsets(P.test.range, X, 1), P.update && g.setDesiredOffsets(P.update.range, X, 1), x(P.body);
        },
        "FunctionDeclaration, FunctionExpression"(P) {
          const X = s.getTokenBefore(P.body), Q = s.getTokenBefore(P.params.length ? P.params[0] : X);
          d.add(Q), d.add(X), C(P.params, Q, X, l[P.type].parameters);
        },
        IfStatement(P) {
          x(P.consequent), P.alternate && x(P.alternate);
        },
        /*
         * For blockless nodes with semicolon-first style, don't indent the semicolon.
         * e.g.
         * if (foo)
         *     bar()
         * ; [1, 2, 3].map(foo)
         *
         * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.
         */
        ":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit"(P) {
          let X;
          P.type === "IfStatement" ? (X = [P.consequent], P.alternate && X.push(P.alternate)) : X = [P.body];
          for (const Q of X) {
            const ue = s.getLastToken(Q);
            if (i.isSemicolonToken(ue)) {
              const le = s.getTokenBefore(ue), Ce = s.getTokenAfter(ue);
              !i.isTokenOnSameLine(le, ue) && Ce && i.isTokenOnSameLine(ue, Ce) && g.setDesiredOffset(
                ue,
                s.getFirstToken(P),
                0
              );
            }
          }
        },
        ImportDeclaration(P) {
          if (P.specifiers.some((le) => le.type === "ImportSpecifier")) {
            const le = s.getFirstToken(P, i.isOpeningBraceToken), Ce = s.getLastToken(P, i.isClosingBraceToken);
            C(P.specifiers.filter((j) => j.type === "ImportSpecifier"), le, Ce, l.ImportDeclaration);
          }
          const X = s.getLastToken(P, (le) => le.type === "Identifier" && le.value === "from"), Q = s.getLastToken(P, (le) => le.type === "String"), ue = s.getLastToken(P, (le) => le.type === "Punctuator" && le.value === ";");
          if (X) {
            const le = ue && ue.range[1] === Q.range[1] ? P.range[1] : Q.range[1];
            g.setDesiredOffsets([X.range[0], le], s.getFirstToken(P), 1);
          }
        },
        ImportExpression(P) {
          const X = s.getFirstToken(P, 1), Q = s.getLastToken(P);
          d.add(X), d.add(Q), g.setDesiredOffset(X, s.getTokenBefore(X), 0), C([P.source], X, Q, l.CallExpression.arguments);
        },
        "MemberExpression, JSXMemberExpression, MetaProperty"(P) {
          const X = P.type === "MetaProperty" ? P.meta : P.object, Q = s.getFirstTokenBetween(X, P.property, i.isNotClosingParenToken), ue = s.getTokenAfter(Q), le = s.getTokensBetween(X, P.property, { filter: i.isClosingParenToken }).length, Ce = le ? s.getTokenBefore(X, { skip: le - 1 }) : s.getFirstToken(X), j = s.getTokenBefore(Q), H = P.computed ? Q : ue;
          P.computed && (g.setDesiredOffset(s.getLastToken(P), Q, 0), g.setDesiredOffsets(P.property.range, Q, 1));
          const N = j.loc.end.line === H.loc.start.line ? j : Ce;
          typeof l.MemberExpression == "number" ? (g.setDesiredOffset(Q, N, l.MemberExpression), g.setDesiredOffset(ue, P.computed ? Q : N, l.MemberExpression)) : (g.ignoreToken(Q), g.ignoreToken(ue), g.setDesiredOffset(Q, N, 0), g.setDesiredOffset(ue, Q, 0));
        },
        NewExpression(P) {
          (P.arguments.length > 0 || i.isClosingParenToken(s.getLastToken(P)) && i.isOpeningParenToken(s.getLastToken(P, 1))) && A(P);
        },
        Property(P) {
          if (!P.shorthand && !P.method && P.kind === "init") {
            const X = s.getFirstTokenBetween(P.key, P.value, i.isColonToken);
            g.ignoreToken(s.getTokenAfter(X));
          }
        },
        PropertyDefinition(P) {
          const X = s.getFirstToken(P), Q = s.getLastToken(P);
          let ue = null;
          if (P.computed) {
            const le = s.getTokenBefore(P.key, i.isOpeningBracketToken), Ce = ue = s.getTokenAfter(P.key, i.isClosingBracketToken), j = [le.range[1], Ce.range[0]];
            le !== X && g.setDesiredOffset(le, X, 0), g.setDesiredOffsets(j, le, 1), g.setDesiredOffset(Ce, le, 0);
          } else {
            const le = ue = s.getFirstToken(P.key);
            le !== X && g.setDesiredOffset(le, X, 1);
          }
          if (P.value) {
            const le = s.getTokenBefore(P.value, i.isEqToken), Ce = s.getTokenAfter(le);
            g.setDesiredOffset(le, ue, 1), g.setDesiredOffset(Ce, le, 1), i.isSemicolonToken(Q) && g.setDesiredOffset(Q, le, 1);
          } else i.isSemicolonToken(Q) && g.setDesiredOffset(Q, ue, 1);
        },
        StaticBlock(P) {
          const X = s.getFirstToken(P, { skip: 1 }), Q = s.getLastToken(P);
          C(P.body, X, Q, l.StaticBlock.body);
        },
        SwitchStatement(P) {
          const X = s.getTokenAfter(P.discriminant, i.isOpeningBraceToken), Q = s.getLastToken(P);
          g.setDesiredOffsets([X.range[1], Q.range[0]], X, l.SwitchCase), P.cases.length && s.getTokensBetween(
            P.cases[P.cases.length - 1],
            Q,
            { includeComments: !0, filter: i.isCommentToken }
          ).forEach((ue) => g.ignoreToken(ue));
        },
        SwitchCase(P) {
          if (!(P.consequent.length === 1 && P.consequent[0].type === "BlockStatement")) {
            const X = s.getFirstToken(P), Q = s.getTokenAfter(P);
            g.setDesiredOffsets([X.range[1], Q.range[0]], X, 1);
          }
        },
        TemplateLiteral(P) {
          P.expressions.forEach((X, Q) => {
            const ue = P.quasis[Q], le = P.quasis[Q + 1], Ce = ue.loc.start.line === ue.loc.end.line ? s.getFirstToken(ue) : null;
            g.setDesiredOffsets([ue.range[1], le.range[0]], Ce, 1), g.setDesiredOffset(s.getFirstToken(le), Ce, 0);
          });
        },
        VariableDeclaration(P) {
          let X = Object.prototype.hasOwnProperty.call(l.VariableDeclarator, P.kind) ? l.VariableDeclarator[P.kind] : 1;
          const Q = s.getFirstToken(P), ue = s.getLastToken(P);
          if (l.VariableDeclarator[P.kind] === "first") {
            if (P.declarations.length > 1) {
              C(
                P.declarations,
                Q,
                ue,
                "first"
              );
              return;
            }
            X = 1;
          }
          P.declarations[P.declarations.length - 1].loc.start.line > P.loc.start.line ? g.setDesiredOffsets(P.range, Q, X, !0) : g.setDesiredOffsets(P.range, Q, X), i.isSemicolonToken(ue) && g.ignoreToken(ue);
        },
        VariableDeclarator(P) {
          if (P.init) {
            const X = s.getTokenBefore(P.init, i.isNotOpeningParenToken), Q = s.getTokenAfter(X);
            g.ignoreToken(X), g.ignoreToken(Q), g.setDesiredOffsets([Q.range[0], P.range[1]], X, 1), g.setDesiredOffset(X, s.getLastToken(P.id), 0);
          }
        },
        "JSXAttribute[value]"(P) {
          const X = s.getFirstTokenBetween(P.name, P.value, (Q) => Q.type === "Punctuator" && Q.value === "=");
          g.setDesiredOffsets([X.range[0], P.value.range[1]], s.getFirstToken(P.name), 1);
        },
        JSXElement(P) {
          P.closingElement && C(P.children, s.getFirstToken(P.openingElement), s.getFirstToken(P.closingElement), 1);
        },
        JSXOpeningElement(P) {
          const X = s.getFirstToken(P);
          let Q;
          P.selfClosing ? (Q = s.getLastToken(P, { skip: 1 }), g.setDesiredOffset(s.getLastToken(P), Q, 0)) : Q = s.getLastToken(P), g.setDesiredOffsets(P.name.range, s.getFirstToken(P)), C(P.attributes, X, Q, 1);
        },
        JSXClosingElement(P) {
          const X = s.getFirstToken(P);
          g.setDesiredOffsets(P.name.range, X, 1);
        },
        JSXFragment(P) {
          const X = s.getFirstToken(P.openingFragment), Q = s.getFirstToken(P.closingFragment);
          C(P.children, X, Q, 1);
        },
        JSXOpeningFragment(P) {
          const X = s.getFirstToken(P), Q = s.getLastToken(P);
          g.setDesiredOffsets(P.range, X, 1), g.matchOffsetOf(X, Q);
        },
        JSXClosingFragment(P) {
          const X = s.getFirstToken(P), Q = s.getLastToken(P, { skip: 1 }), ue = s.getLastToken(P), le = i.isTokenOnSameLine(Q, ue) ? Q : ue;
          g.setDesiredOffsets(P.range, X, 1), g.matchOffsetOf(X, le);
        },
        JSXExpressionContainer(P) {
          const X = s.getFirstToken(P), Q = s.getLastToken(P);
          g.setDesiredOffsets(
            [X.range[1], Q.range[0]],
            X,
            1
          );
        },
        JSXSpreadAttribute(P) {
          const X = s.getFirstToken(P), Q = s.getLastToken(P);
          g.setDesiredOffsets(
            [X.range[1], Q.range[0]],
            X,
            1
          );
        },
        "*"(P) {
          const X = s.getFirstToken(P);
          X && !O.has(X) && g.setDesiredOffsets(P.range, X, 0);
        }
      }, w = [], U = {};
      for (const [P, X] of Object.entries(k))
        U[P] = (Q) => w.push({ listener: X, node: Q });
      const q = /* @__PURE__ */ new Set();
      function F(P) {
        q.add(P), O.add(s.getFirstToken(P));
      }
      const $ = l.ignoredNodes.reduce(
        (P, X) => Object.assign(P, { [X]: F }),
        {}
      );
      return Object.assign(
        U,
        $,
        {
          "*:exit"(P) {
            t.has(P.type) || F(P);
          },
          "Program:exit"() {
            l.ignoreComments && s.getAllComments().forEach((X) => g.ignoreToken(X));
            for (let X = 0; X < w.length; X++) {
              const Q = w[X];
              q.has(Q.node) || Q.listener(Q.node);
            }
            q.forEach(L), R(s.ast.tokens);
            const P = /* @__PURE__ */ new WeakMap();
            for (let X = 0; X < s.ast.comments.length; X++) {
              const Q = s.ast.comments[X], ue = s.getTokenBefore(Q, { includeComments: !0 }), le = P.has(ue) ? P.get(ue) : ue;
              P.set(Q, le);
            }
            for (let X = 1; X < s.lines.length + 1; X++) {
              if (!c.firstTokensByLineNumber.has(X))
                continue;
              const Q = c.firstTokensByLineNumber.get(X);
              if (Q.loc.start.line === X) {
                if (i.isCommentToken(Q)) {
                  const ue = P.get(Q), le = ue ? s.getTokenAfter(ue) : s.ast.tokens[0], Ce = ue && !I(ue, Q), j = le && !I(Q, le);
                  if (le && i.isSemicolonToken(le) && !i.isTokenOnSameLine(Q, le) && g.setDesiredOffset(Q, le, 0), Ce && T(Q, g.getDesiredIndent(ue)) || j && T(Q, g.getDesiredIndent(le)))
                    continue;
                }
                T(Q, g.getDesiredIndent(Q)) || v(Q, g.getDesiredIndent(Q));
              }
            }
          }
        }
      );
    }
  }, ga;
}
var da, xg;
function zT() {
  if (xg) return da;
  xg = 1;
  const i = Re();
  return da = {
    meta: {
      type: "layout",
      docs: {
        description: "Enforce consistent indentation",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/indent-legacy"
      },
      deprecated: !0,
      replacedBy: ["indent"],
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0
            },
            VariableDeclarator: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  type: "object",
                  properties: {
                    var: {
                      type: "integer",
                      minimum: 0
                    },
                    let: {
                      type: "integer",
                      minimum: 0
                    },
                    const: {
                      type: "integer",
                      minimum: 0
                    }
                  }
                }
              ]
            },
            outerIIFEBody: {
              type: "integer",
              minimum: 0
            },
            MemberExpression: {
              type: "integer",
              minimum: 0
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            CallExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                }
              }
            },
            ArrayExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            },
            ObjectExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expected: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(t) {
      let u = "space", e = 4;
      const a = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: 1,
          let: 1,
          const: 1
        },
        outerIIFEBody: null,
        FunctionDeclaration: {
          parameters: null,
          body: 1
        },
        FunctionExpression: {
          parameters: null,
          body: 1
        },
        CallExpression: {
          arguments: null
        },
        ArrayExpression: 1,
        ObjectExpression: 1
      }, n = t.sourceCode;
      if (t.options.length && (t.options[0] === "tab" ? (e = 1, u = "tab") : typeof t.options[0] == "number" && (e = t.options[0], u = "space"), t.options[1])) {
        const F = t.options[1];
        a.SwitchCase = F.SwitchCase || 0;
        const $ = F.VariableDeclarator;
        typeof $ == "number" ? a.VariableDeclarator = {
          var: $,
          let: $,
          const: $
        } : typeof $ == "object" && Object.assign(a.VariableDeclarator, $), typeof F.outerIIFEBody == "number" && (a.outerIIFEBody = F.outerIIFEBody), typeof F.MemberExpression == "number" && (a.MemberExpression = F.MemberExpression), typeof F.FunctionDeclaration == "object" && Object.assign(a.FunctionDeclaration, F.FunctionDeclaration), typeof F.FunctionExpression == "object" && Object.assign(a.FunctionExpression, F.FunctionExpression), typeof F.CallExpression == "object" && Object.assign(a.CallExpression, F.CallExpression), (typeof F.ArrayExpression == "number" || typeof F.ArrayExpression == "string") && (a.ArrayExpression = F.ArrayExpression), (typeof F.ObjectExpression == "number" || typeof F.ObjectExpression == "string") && (a.ObjectExpression = F.ObjectExpression);
      }
      const p = {};
      function m(F, $, P) {
        const X = `${F} ${u}${F === 1 ? "" : "s"}`, Q = `space${$ === 1 ? "" : "s"}`, ue = `tab${P === 1 ? "" : "s"}`;
        let le;
        return $ > 0 && P > 0 ? le = `${$} ${Q} and ${P} ${ue}` : $ > 0 ? le = u === "space" ? $ : `${$} ${Q}` : P > 0 ? le = u === "tab" ? P : `${P} ${ue}` : le = "0", {
          expected: X,
          actual: le
        };
      }
      function h(F, $, P, X, Q, ue) {
        if (P && X)
          return;
        const le = (u === "space" ? " " : "	").repeat($), Ce = ue ? [F.range[1] - F.loc.end.column, F.range[1] - F.loc.end.column + P + X] : [F.range[0] - F.loc.start.column, F.range[0] - F.loc.start.column + P + X];
        t.report({
          node: F,
          loc: Q,
          messageId: "expected",
          data: m($, P, X),
          fix: (j) => j.replaceTextRange(Ce, le)
        });
      }
      function l(F, $) {
        const P = $ ? n.getLastToken(F) : n.getFirstToken(F), X = n.getText(P, P.loc.start.column).split(""), Q = X.slice(0, X.findIndex((Ce) => Ce !== " " && Ce !== "	")), ue = Q.filter((Ce) => Ce === " ").length, le = Q.filter((Ce) => Ce === "	").length;
        return {
          space: ue,
          tab: le,
          goodChar: u === "space" ? ue : le,
          badChar: u === "space" ? le : ue
        };
      }
      function s(F, $) {
        const P = $ === !0 ? n.getLastToken(F, 1) : n.getTokenBefore(F), X = $ === !0 ? F.loc.end.line : F.loc.start.line, Q = P ? P.loc.end.line : -1;
        return X !== Q;
      }
      function c(F, $) {
        const P = l(F, !1);
        if (F.type !== "ArrayExpression" && F.type !== "ObjectExpression" && (P.goodChar !== $ || P.badChar !== 0) && s(F) && h(F, $, P.space, P.tab), F.type === "IfStatement" && F.alternate) {
          const X = n.getTokenBefore(F.alternate);
          c(X, $), s(F.alternate) || c(F.alternate, $);
        }
        if (F.type === "TryStatement" && F.handler) {
          const X = n.getFirstToken(F.handler);
          c(X, $);
        }
        if (F.type === "TryStatement" && F.finalizer) {
          const X = n.getTokenBefore(F.finalizer);
          c(X, $);
        }
        if (F.type === "DoWhileStatement") {
          const X = n.getTokenAfter(F.body);
          c(X, $);
        }
      }
      function g(F, $) {
        F.forEach((P) => c(P, $));
      }
      function d(F, $) {
        const P = n.getLastToken(F), X = l(P, !0);
        (X.goodChar !== $ || X.badChar !== 0) && s(F, !0) && h(
          F,
          $,
          X.space,
          X.tab,
          { line: P.loc.start.line, column: P.loc.start.column },
          !0
        );
      }
      function y(F, $) {
        const P = n.getLastToken(F, i.isClosingParenToken);
        if (n.getText(P, P.loc.start.column).slice(0, -1).trim())
          return;
        const Q = l(P, !0);
        Q.goodChar !== $ && h(
          F,
          $,
          Q.space,
          Q.tab,
          { line: P.loc.start.line, column: P.loc.start.column },
          !0
        );
      }
      function v(F, $) {
        const P = l(F, !1);
        (P.goodChar !== $ || P.badChar !== 0) && s(F) && h(
          F,
          $,
          P.space,
          P.tab,
          { line: F.loc.start.line, column: F.loc.start.column }
        );
      }
      function T(F, $, P) {
        let X = F.parent;
        const Q = new Set(P || ["Program"]);
        for (; X.type !== $ && !Q.has(X.type) && X.type !== "Program"; )
          X = X.parent;
        return X.type === $ ? X : null;
      }
      function b(F) {
        return T(F, "VariableDeclarator");
      }
      function S(F, $) {
        return $ && $.parent.loc.start.line === F.loc.start.line && $.parent.declarations.length > 1;
      }
      function C(F) {
        const $ = F.parent;
        return $.arguments.length >= 2 && $.arguments[1] === F ? $.arguments[0].loc.end.line > $.arguments[0].loc.start.line : !1;
      }
      function x(F) {
        const $ = F.parent;
        let P = $.parent;
        if ($.type !== "CallExpression" || $.callee !== F)
          return !1;
        for (; P.type === "UnaryExpression" && (P.operator === "!" || P.operator === "~" || P.operator === "+" || P.operator === "-") || P.type === "AssignmentExpression" || P.type === "LogicalExpression" || P.type === "SequenceExpression" || P.type === "VariableDeclarator"; )
          P = P.parent;
        return (P.type === "ExpressionStatement" || P.type === "VariableDeclaration") && P.parent && P.parent.type === "Program";
      }
      function A(F) {
        const $ = F.parent;
        let P;
        if ($.parent && ($.parent.type === "Property" || $.parent.type === "ArrayExpression") ? P = l($, !1).goodChar : P = l($).goodChar, $.parent.type === "CallExpression") {
          const ue = $.parent;
          $.type !== "FunctionExpression" && $.type !== "ArrowFunctionExpression" ? ue && ue.loc.start.line < F.loc.start.line && (P = l(ue).goodChar) : C($) && ue.callee.loc.start.line === ue.callee.loc.end.line && !s($) && (P = l(ue).goodChar);
        }
        let X = e;
        a.outerIIFEBody !== null && x($) ? X = a.outerIIFEBody * e : $.type === "FunctionExpression" ? X = a.FunctionExpression.body * e : $.type === "FunctionDeclaration" && (X = a.FunctionDeclaration.body * e), P += X;
        const Q = b(F);
        Q && S(F, Q) && (P += e * a.VariableDeclarator[Q.parent.kind]), F.body.length > 0 && g(F.body, P), d(F, P - X);
      }
      function R(F) {
        const $ = n.getLastToken(F), P = F.loc.start.line, X = $.loc.end.line;
        return P === X;
      }
      function L(F) {
        if (R(F))
          return;
        let $ = F.type === "ArrayExpression" ? F.elements : F.properties;
        $ = $.filter((ue) => ue !== null);
        let P, X;
        const Q = b(F);
        if (s(F)) {
          const ue = F.parent;
          if (P = l(ue).goodChar, (!Q || Q.loc.start.line !== F.loc.start.line) && (ue.type !== "VariableDeclarator" || Q === Q.parent.declarations[0]))
            if (ue.type === "VariableDeclarator" && Q.loc.start.line === ue.loc.start.line)
              P += e * a.VariableDeclarator[Q.parent.kind];
            else if (ue.type === "ObjectExpression" || ue.type === "ArrayExpression") {
              const le = F.parent.type === "ObjectExpression" ? F.parent.properties : F.parent.elements;
              le[0] && le[0].loc.start.line === ue.loc.start.line && le[0].loc.end.line !== ue.loc.start.line || (typeof a[ue.type] == "number" ? P += a[ue.type] * e : P = le[0].loc.start.column);
            } else ue.type === "CallExpression" || ue.type === "NewExpression" ? typeof a.CallExpression.arguments == "number" ? P += a.CallExpression.arguments * e : a.CallExpression.arguments === "first" ? ue.arguments.includes(F) && (P = ue.arguments[0].loc.start.column) : P += e : (ue.type === "LogicalExpression" || ue.type === "ArrowFunctionExpression") && (P += e);
          v(F, P);
        } else
          P = l(F).goodChar;
        a[F.type] === "first" ? X = $.length ? $[0].loc.start.column : 0 : X = P + e * a[F.type], S(F, Q) && (X += e * a.VariableDeclarator[Q.parent.kind]), g($, X), !($.length > 0 && $[$.length - 1].loc.end.line === F.loc.end.line) && d(F, P + (S(F, Q) ? a.VariableDeclarator[Q.parent.kind] * e : 0));
      }
      function _(F) {
        return F.type === "BlockStatement" || F.type === "ClassBody" || F.body && F.body.type === "BlockStatement" || F.consequent && F.consequent.type === "BlockStatement";
      }
      function I(F) {
        if (R(F))
          return;
        if (F.parent && (F.parent.type === "FunctionExpression" || F.parent.type === "FunctionDeclaration" || F.parent.type === "ArrowFunctionExpression")) {
          A(F);
          return;
        }
        let $, P = [];
        const X = [
          "IfStatement",
          "WhileStatement",
          "ForStatement",
          "ForInStatement",
          "ForOfStatement",
          "DoWhileStatement",
          "ClassDeclaration",
          "TryStatement"
        ];
        F.parent && X.includes(F.parent.type) && _(F) ? $ = l(F.parent).goodChar : F.parent && F.parent.type === "CatchClause" ? $ = l(F.parent.parent).goodChar : $ = l(F).goodChar, F.type === "IfStatement" && F.consequent.type !== "BlockStatement" ? P = [F.consequent] : Array.isArray(F.body) ? P = F.body : P = [F.body], P.length > 0 && g(P, $ + e), F.type === "BlockStatement" && d(F, $);
      }
      function O(F) {
        return F.declarations.reduce(($, P) => {
          const X = $[$.length - 1];
          return (P.loc.start.line !== F.loc.start.line && !X || X && X.loc.start.line !== P.loc.start.line) && $.push(P), $;
        }, []);
      }
      function k(F) {
        const $ = O(F), P = l(F).goodChar, X = $[$.length - 1], Q = P + e * a.VariableDeclarator[F.kind];
        if (g($, Q), n.getLastToken(F).loc.end.line <= X.loc.end.line)
          return;
        const ue = n.getTokenBefore(X);
        ue.value === "," ? d(F, l(ue).goodChar) : d(F, Q - e);
      }
      function w(F) {
        F.body.type !== "BlockStatement" && I(F);
      }
      function U(F, $) {
        const P = F.type === "SwitchStatement" ? F : F.parent, X = typeof $ > "u" ? l(P).goodChar : $;
        let Q;
        return p[P.loc.start.line] ? p[P.loc.start.line] : (P.cases.length > 0 && a.SwitchCase === 0 ? Q = X : Q = X + e * a.SwitchCase, p[P.loc.start.line] = Q, Q);
      }
      function q(F) {
        const $ = /^return\s*?\(\s*?\);*?/u, P = n.getText(F).replace(
          n.getText(F.argument),
          ""
        );
        return $.test(P);
      }
      return {
        Program(F) {
          F.body.length > 0 && g(F.body, l(F).goodChar);
        },
        ClassBody: I,
        BlockStatement: I,
        WhileStatement: w,
        ForStatement: w,
        ForInStatement: w,
        ForOfStatement: w,
        DoWhileStatement: w,
        IfStatement(F) {
          F.consequent.type !== "BlockStatement" && F.consequent.loc.start.line > F.loc.start.line && I(F);
        },
        VariableDeclaration(F) {
          F.declarations[F.declarations.length - 1].loc.start.line > F.declarations[0].loc.start.line && k(F);
        },
        ObjectExpression(F) {
          L(F);
        },
        ArrayExpression(F) {
          L(F);
        },
        MemberExpression(F) {
          if (typeof a.MemberExpression > "u" || R(F) || T(F, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"]) || T(F, "AssignmentExpression", ["FunctionExpression"]))
            return;
          const $ = l(F).goodChar + e * a.MemberExpression, P = [F.property], X = n.getTokenBefore(F.property);
          X.type === "Punctuator" && X.value === "." && P.push(X), g(P, $);
        },
        SwitchStatement(F) {
          const $ = l(F).goodChar, P = U(F, $);
          g(F.cases, P), d(F, $);
        },
        SwitchCase(F) {
          if (R(F))
            return;
          const $ = U(F);
          g(F.consequent, $ + e);
        },
        FunctionDeclaration(F) {
          R(F) || (a.FunctionDeclaration.parameters === "first" && F.params.length ? g(F.params.slice(1), F.params[0].loc.start.column) : a.FunctionDeclaration.parameters !== null && g(F.params, l(F).goodChar + e * a.FunctionDeclaration.parameters));
        },
        FunctionExpression(F) {
          R(F) || (a.FunctionExpression.parameters === "first" && F.params.length ? g(F.params.slice(1), F.params[0].loc.start.column) : a.FunctionExpression.parameters !== null && g(F.params, l(F).goodChar + e * a.FunctionExpression.parameters));
        },
        ReturnStatement(F) {
          if (R(F))
            return;
          const $ = l(F).goodChar;
          q(F) ? y(F, $) : c(F, $);
        },
        CallExpression(F) {
          R(F) || (a.CallExpression.arguments === "first" && F.arguments.length ? g(F.arguments.slice(1), F.arguments[0].loc.start.column) : a.CallExpression.arguments !== null && g(F.arguments, l(F).goodChar + e * a.CallExpression.arguments));
        }
      };
    }
  }, da;
}
var Ea, Rg;
function HT() {
  if (Rg) return Ea;
  Rg = 1;
  function i(o) {
    return o.type === "ForInStatement" || o.type === "ForOfStatement" || o.type === "ForStatement";
  }
  function t(o) {
    const f = o.parent, r = f.parent;
    return i(r) ? r.type === "ForStatement" ? r.init === f : r.left === f : !!o.init;
  }
  return Ea = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow initialization in variable declarations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/init-declarations"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  ignoreForLoopInit: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        initialized: "Variable '{{idName}}' should be initialized on declaration.",
        notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
      }
    },
    create(o) {
      const f = "always", r = "never", u = o.options[0] || f, e = o.options[1] || {};
      return {
        "VariableDeclaration:exit"(a) {
          const n = a.kind, p = a.declarations;
          for (let m = 0; m < p.length; ++m) {
            const h = p[m], l = h.id, s = t(h), c = e.ignoreForLoopInit && i(a.parent);
            let g = "";
            u === f && !s ? g = "initialized" : u === r && n !== "const" && s && !c && (g = "notInitialized"), l.type === "Identifier" && g && o.report({
              node: h,
              messageId: g,
              data: {
                idName: l.name
              }
            });
          }
        }
      };
    }
  }, Ea;
}
var ya, Dg;
function JT() {
  if (Dg) return ya;
  Dg = 1;
  const i = Re(), t = {
    "prefer-double": {
      quote: '"',
      description: "singlequote",
      convert(o) {
        return o.replace(/'/gu, '"');
      }
    },
    "prefer-single": {
      quote: "'",
      description: "doublequote",
      convert(o) {
        return o.replace(/"/gu, "'");
      }
    }
  };
  return ya = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce the consistent use of either double or single quotes in JSX attributes",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/jsx-quotes"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["prefer-single", "prefer-double"]
        }
      ],
      messages: {
        unexpected: "Unexpected usage of {{description}}."
      }
    },
    create(o) {
      const f = o.options[0] || "prefer-double", r = t[f];
      function u(e) {
        return e.value.includes(r.quote) || i.isSurroundedBy(e.raw, r.quote);
      }
      return {
        JSXAttribute(e) {
          const a = e.value;
          a && i.isStringLiteral(a) && !u(a) && o.report({
            node: a,
            messageId: "unexpected",
            data: {
              description: r.description
            },
            fix(n) {
              return n.replaceText(a, r.convert(a.raw));
            }
          });
        }
      };
    }
  }, ya;
}
var Ca, Lg;
function QT() {
  if (Lg) return Ca;
  Lg = 1;
  const i = Re(), { getGraphemeCount: t } = Sr();
  function o(n) {
    return i.LINEBREAK_MATCHER.test(n);
  }
  function f(n) {
    return n[n.length - 1];
  }
  function r(n) {
    return n.loc.end.line === n.loc.start.line;
  }
  function u(n) {
    const [p] = n, m = f(n);
    return p.loc.start.line === m.loc.end.line;
  }
  function e(n, p) {
    return n.mode = p.mode || "strict", typeof p.beforeColon < "u" ? n.beforeColon = +p.beforeColon : n.beforeColon = 0, typeof p.afterColon < "u" ? n.afterColon = +p.afterColon : n.afterColon = 1, typeof p.align < "u" && (typeof p.align == "object" ? n.align = p.align : n.align = {
      on: p.align,
      mode: n.mode,
      beforeColon: n.beforeColon,
      afterColon: n.afterColon
    }), n;
  }
  function a(n, p) {
    return typeof p.align == "object" ? (n.align = e({}, p.align), n.align.on = p.align.on || "colon", n.align.mode = p.align.mode || "strict", n.multiLine = e({}, p.multiLine || p), n.singleLine = e({}, p.singleLine || p)) : (n.multiLine = e({}, p.multiLine || p), n.singleLine = e({}, p.singleLine || p), n.multiLine.align && (n.align = {
      on: n.multiLine.align.on,
      mode: n.multiLine.align.mode || n.multiLine.mode,
      beforeColon: n.multiLine.align.beforeColon,
      afterColon: n.multiLine.align.afterColon
    })), n;
  }
  return Ca = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing between keys and values in object literal properties",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/key-spacing"
      },
      fixable: "whitespace",
      schema: [{
        anyOf: [
          {
            type: "object",
            properties: {
              align: {
                anyOf: [
                  {
                    enum: ["colon", "value"]
                  },
                  {
                    type: "object",
                    properties: {
                      mode: {
                        enum: ["strict", "minimum"]
                      },
                      on: {
                        enum: ["colon", "value"]
                      },
                      beforeColon: {
                        type: "boolean"
                      },
                      afterColon: {
                        type: "boolean"
                      }
                    },
                    additionalProperties: !1
                  }
                ]
              },
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          },
          {
            type: "object",
            properties: {
              singleLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              },
              multiLine: {
                type: "object",
                properties: {
                  align: {
                    anyOf: [
                      {
                        enum: ["colon", "value"]
                      },
                      {
                        type: "object",
                        properties: {
                          mode: {
                            enum: ["strict", "minimum"]
                          },
                          on: {
                            enum: ["colon", "value"]
                          },
                          beforeColon: {
                            type: "boolean"
                          },
                          afterColon: {
                            type: "boolean"
                          }
                        },
                        additionalProperties: !1
                      }
                    ]
                  },
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            },
            additionalProperties: !1
          },
          {
            type: "object",
            properties: {
              singleLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              },
              multiLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              },
              align: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  on: {
                    enum: ["colon", "value"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            },
            additionalProperties: !1
          }
        ]
      }],
      messages: {
        extraKey: "Extra space after {{computed}}key '{{key}}'.",
        extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
        missingKey: "Missing space after {{computed}}key '{{key}}'.",
        missingValue: "Missing space before value for {{computed}}key '{{key}}'."
      }
    },
    create(n) {
      const p = n.options[0] || {}, m = a({}, p), h = m.multiLine, l = m.singleLine, s = m.align || null, c = n.sourceCode;
      function g(O) {
        return !(O.method || O.shorthand || O.kind !== "init" || O.type !== "Property");
      }
      function d(O) {
        return c.getTokenAfter(O, i.isColonToken);
      }
      function y(O) {
        const k = d(O);
        return c.getTokenBefore(k);
      }
      function v(O) {
        const k = d(O);
        return c.getTokenAfter(k);
      }
      function T(O, k) {
        const w = O.loc.start.line, U = (g(k) ? v(k.key) : k).loc.start.line;
        if (U - w <= 1)
          return !0;
        const q = c.getCommentsBefore(k);
        if (q.length && q[0].loc.start.line - w <= 1 && U - f(q).loc.end.line <= 1) {
          for (let F = 1; F < q.length; F++)
            if (q[F].loc.start.line - q[F - 1].loc.end.line > 1)
              return !1;
          return !0;
        }
        return !1;
      }
      function b(O) {
        const k = O.key;
        return O.computed ? c.getText().slice(k.range[0], k.range[1]) : i.getStaticPropertyName(O);
      }
      function S(O, k, w, U, q) {
        const F = w.length - U;
        if ((F && q === "strict" || F < 0 && q === "minimum" || F > 0 && !U && q === "minimum") && !(U && o(w))) {
          const $ = d(O.key), P = c.getTokenBefore($, { includeComments: !0 }), X = c.getTokenAfter($, { includeComments: !0 }), Q = k === "key", ue = F > 0, le = Math.abs(F), Ce = Array(le + 1).join(" "), j = Q ? P.loc.end : $.loc.start, H = Q ? $.loc.start : X.loc.start, N = Q ? P.loc : X.loc, G = ue ? { start: j, end: H } : N;
          let M;
          if (ue) {
            let Ee;
            Q ? Ee = [P.range[1], P.range[1] + le] : Ee = [X.range[0] - le, X.range[0]], M = function(ke) {
              return ke.removeRange(Ee);
            };
          } else
            Q ? M = function(Ee) {
              return Ee.insertTextAfter(P, Ce);
            } : M = function(Ee) {
              return Ee.insertTextBefore(X, Ce);
            };
          let Z = "";
          ue ? Z = k === "key" ? "extraKey" : "extraValue" : Z = k === "key" ? "missingKey" : "missingValue", n.report({
            node: O[k],
            loc: G,
            messageId: Z,
            data: {
              computed: O.computed ? "computed " : "",
              key: b(O)
            },
            fix: M
          });
        }
      }
      function C(O) {
        const k = c.getFirstToken(O), w = y(O.key);
        return t(c.getText().slice(k.range[0], w.range[1]));
      }
      function x(O) {
        const k = /(\s*):(\s*)/u.exec(c.getText().slice(
          O.key.range[1],
          O.value.range[0]
        ));
        return k ? {
          beforeColon: k[1],
          afterColon: k[2]
        } : null;
      }
      function A(O) {
        return O.properties.length === 1 ? [O.properties] : O.properties.reduce((k, w) => {
          const U = f(k), q = f(U);
          return !q || T(q, w) ? U.push(w) : k.push([w]), k;
        }, [
          []
        ]);
      }
      function R(O) {
        const k = O.length, w = O.map(C), U = s.on;
        let q = Math.max(...w), F, $, P;
        s && k > 1 ? (F = s.beforeColon, $ = s.afterColon, P = s.mode) : (F = h.beforeColon, $ = h.afterColon, P = s.mode), q += U === "colon" ? F : $;
        for (let X = 0; X < k; X++) {
          const Q = O[X], ue = x(Q);
          if (ue) {
            const le = w[X];
            U === "value" ? (S(Q, "key", ue.beforeColon, F, P), S(Q, "value", ue.afterColon, q - le, P)) : (S(Q, "key", ue.beforeColon, q - le, P), S(Q, "value", ue.afterColon, $, P));
          }
        }
      }
      function L(O, k) {
        const w = x(O);
        w && (S(O, "key", w.beforeColon, k.beforeColon, k.mode), S(O, "value", w.afterColon, k.afterColon, k.mode));
      }
      function _(O, k) {
        const w = O.length;
        for (let U = 0; U < w; U++)
          L(O[U], k);
      }
      function I(O) {
        A(O).forEach((k) => {
          const w = k.filter(g);
          w.length > 0 && u(w) ? _(w, h) : R(w);
        });
      }
      return s ? {
        ObjectExpression(O) {
          r(O) ? _(O.properties.filter(g), l) : I(O);
        }
      } : {
        Property(O) {
          L(O, r(O.parent) ? l : h);
        }
      };
    }
  }, Ca;
}
var va, _g;
function YT() {
  if (_g) return va;
  _g = 1;
  const i = Re(), t = Hf(), o = /^[)\]}>]$/u, f = /^(?:[([{<~!]|\+\+?|--?)$/u, r = /^[)\]}>*]$/u, u = /^[{*]$/u, e = /\$\{$/u, a = /^\}/u, n = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u, p = t.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
  (function() {
    p.sort();
    for (let l = 1; l < p.length; ++l)
      if (p[l] === p[l - 1])
        throw new Error(`Duplication was found in the keyword list: ${p[l]}`);
  })();
  function m(l) {
    return l.type === "Template" && e.test(l.value);
  }
  function h(l) {
    return l.type === "Template" && a.test(l.value);
  }
  return va = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after keywords",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/keyword-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: { type: "boolean", default: !0 },
            after: { type: "boolean", default: !0 },
            overrides: {
              type: "object",
              properties: p.reduce((l, s) => (l[s] = {
                type: "object",
                properties: {
                  before: { type: "boolean" },
                  after: { type: "boolean" }
                },
                additionalProperties: !1
              }, l), {}),
              additionalProperties: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expectedBefore: 'Expected space(s) before "{{value}}".',
        expectedAfter: 'Expected space(s) after "{{value}}".',
        unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
        unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
      }
    },
    create(l) {
      const s = l.sourceCode, c = /* @__PURE__ */ new WeakSet();
      function g(le, Ce) {
        const j = s.getTokenBefore(le);
        j && (n.test(j.type) || Ce.test(j.value)) && !m(j) && !c.has(j) && i.isTokenOnSameLine(j, le) && !s.isSpaceBetweenTokens(j, le) && l.report({
          loc: le.loc,
          messageId: "expectedBefore",
          data: le,
          fix(H) {
            return H.insertTextBefore(le, " ");
          }
        });
      }
      function d(le, Ce) {
        const j = s.getTokenBefore(le);
        j && (n.test(j.type) || Ce.test(j.value)) && !m(j) && !c.has(j) && i.isTokenOnSameLine(j, le) && s.isSpaceBetweenTokens(j, le) && l.report({
          loc: { start: j.loc.end, end: le.loc.start },
          messageId: "unexpectedBefore",
          data: le,
          fix(H) {
            return H.removeRange([j.range[1], le.range[0]]);
          }
        });
      }
      function y(le, Ce) {
        const j = s.getTokenAfter(le);
        j && (n.test(j.type) || Ce.test(j.value)) && !h(j) && !c.has(j) && i.isTokenOnSameLine(le, j) && !s.isSpaceBetweenTokens(le, j) && l.report({
          loc: le.loc,
          messageId: "expectedAfter",
          data: le,
          fix(H) {
            return H.insertTextAfter(le, " ");
          }
        });
      }
      function v(le, Ce) {
        const j = s.getTokenAfter(le);
        j && (n.test(j.type) || Ce.test(j.value)) && !h(j) && !c.has(j) && i.isTokenOnSameLine(le, j) && s.isSpaceBetweenTokens(le, j) && l.report({
          loc: { start: le.loc.end, end: j.loc.start },
          messageId: "unexpectedAfter",
          data: le,
          fix(H) {
            return H.removeRange([le.range[1], j.range[0]]);
          }
        });
      }
      function T(le = {}) {
        const Ce = le.before !== !1, j = le.after !== !1, H = {
          before: Ce ? g : d,
          after: j ? y : v
        }, N = le && le.overrides || {}, G = /* @__PURE__ */ Object.create(null);
        for (let M = 0; M < p.length; ++M) {
          const Z = p[M], Ee = N[Z];
          if (Ee) {
            const ke = "before" in Ee ? Ee.before : Ce, Ie = "after" in Ee ? Ee.after : j;
            G[Z] = {
              before: ke ? g : d,
              after: Ie ? y : v
            };
          } else
            G[Z] = H;
        }
        return G;
      }
      const b = T(l.options[0]);
      function S(le, Ce) {
        b[le.value].before(le, Ce || o);
      }
      function C(le, Ce) {
        b[le.value].after(le, Ce || f);
      }
      function x(le) {
        S(le), C(le);
      }
      function A(le) {
        const Ce = le && s.getFirstToken(le);
        Ce && Ce.type === "Keyword" && x(Ce);
      }
      function R(le) {
        const Ce = le && s.getFirstToken(le);
        Ce && Ce.type === "Keyword" && S(Ce);
      }
      function L(le) {
        if (le) {
          const Ce = s.getTokenBefore(le, i.isKeywordToken);
          x(Ce);
        }
      }
      function _(le) {
        const Ce = le && s.getFirstToken(le);
        Ce && (Ce.type === "Keyword" && Ce.value === "function" || Ce.value === "async") && S(Ce);
      }
      function I(le) {
        A(le), L(le.superClass);
      }
      function O(le) {
        A(le), L(le.alternate);
      }
      function k(le) {
        A(le), A(le.handler), L(le.finalizer);
      }
      function w(le) {
        A(le), L(le.test);
      }
      function U(le) {
        A(le);
        const Ce = s.getTokenBefore(le.right, i.isNotOpeningParenToken);
        s.getTokenBefore(Ce).type !== "PrivateIdentifier" && S(Ce), C(Ce);
      }
      function q(le) {
        le.await ? (S(s.getFirstToken(le, 0)), C(s.getFirstToken(le, 1))) : A(le);
        const Ce = s.getTokenBefore(le.right, i.isNotOpeningParenToken);
        s.getTokenBefore(Ce).type !== "PrivateIdentifier" && S(Ce), C(Ce);
      }
      function F(le) {
        const Ce = s.getFirstToken(le);
        if (S(Ce, r), C(Ce, u), le.type === "ExportDefaultDeclaration" && x(s.getTokenAfter(Ce)), le.type === "ExportAllDeclaration" && le.exported) {
          const j = s.getTokenBefore(le.exported);
          S(j, r), C(j, u);
        }
        if (le.source) {
          const j = s.getTokenBefore(le.source);
          S(j, r), C(j, u);
        }
      }
      function $(le) {
        if (le.imported.range[0] !== le.local.range[0]) {
          const Ce = s.getTokenBefore(le.local);
          S(Ce, r);
        }
      }
      function P(le) {
        if (le.local.range[0] !== le.exported.range[0]) {
          const Ce = s.getTokenBefore(le.exported);
          S(Ce, r), C(Ce, u);
        }
      }
      function X(le) {
        const Ce = s.getFirstToken(le, 1);
        S(Ce, r);
      }
      function Q(le) {
        if (le.static && A(le), le.kind === "get" || le.kind === "set" || (le.method || le.type === "MethodDefinition") && le.value.async) {
          const Ce = s.getTokenBefore(
            le.key,
            (j) => {
              switch (j.value) {
                case "get":
                case "set":
                case "async":
                  return !0;
                default:
                  return !1;
              }
            }
          );
          if (!Ce)
            throw new Error("Failed to find token get, set, or async beside method name");
          x(Ce);
        }
      }
      function ue(le) {
        S(s.getFirstToken(le));
      }
      return {
        // Statements
        DebuggerStatement: A,
        WithStatement: A,
        // Statements - Control flow
        BreakStatement: A,
        ContinueStatement: A,
        ReturnStatement: A,
        ThrowStatement: A,
        TryStatement: k,
        // Statements - Choice
        IfStatement: O,
        SwitchStatement: A,
        SwitchCase: A,
        // Statements - Loops
        DoWhileStatement: w,
        ForInStatement: U,
        ForOfStatement: q,
        ForStatement: A,
        WhileStatement: A,
        // Statements - Declarations
        ClassDeclaration: I,
        ExportNamedDeclaration: F,
        ExportDefaultDeclaration: F,
        ExportAllDeclaration: F,
        FunctionDeclaration: _,
        ImportDeclaration: F,
        VariableDeclaration: A,
        // Expressions
        ArrowFunctionExpression: _,
        AwaitExpression: ue,
        ClassExpression: I,
        FunctionExpression: _,
        NewExpression: R,
        Super: R,
        ThisExpression: R,
        UnaryExpression: R,
        YieldExpression: R,
        // Others
        ImportSpecifier: $,
        ExportSpecifier: P,
        ImportNamespaceSpecifier: X,
        MethodDefinition: Q,
        PropertyDefinition: Q,
        StaticBlock: A,
        Property: Q,
        // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`
        "BinaryExpression[operator='>']"(le) {
          const Ce = s.getTokenBefore(le.right, i.isNotOpeningParenToken);
          c.add(Ce);
        }
      };
    }
  }, va;
}
var Sa, wg;
function ZT() {
  if (wg) return Sa;
  wg = 1;
  const i = Re();
  return Sa = {
    meta: {
      type: "layout",
      docs: {
        description: "Enforce position of line comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/line-comment-position"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["above", "beside"]
            },
            {
              type: "object",
              properties: {
                position: {
                  enum: ["above", "beside"]
                },
                ignorePattern: {
                  type: "string"
                },
                applyDefaultPatterns: {
                  type: "boolean"
                },
                applyDefaultIgnorePatterns: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        above: "Expected comment to be above code.",
        beside: "Expected comment to be beside code."
      }
    },
    create(t) {
      const o = t.options[0];
      let f, r, u = !0;
      !o || typeof o == "string" ? f = !o || o === "above" : (f = !o.position || o.position === "above", r = o.ignorePattern, Object.prototype.hasOwnProperty.call(o, "applyDefaultIgnorePatterns") ? u = o.applyDefaultIgnorePatterns : u = o.applyDefaultPatterns !== !1);
      const e = i.COMMENTS_IGNORE_PATTERN, a = /^\s*falls?\s?through/u, n = new RegExp(r, "u"), p = t.sourceCode;
      return {
        Program() {
          p.getAllComments().filter((h) => h.type === "Line").forEach((h) => {
            if (u && (e.test(h.value) || a.test(h.value)) || r && n.test(h.value))
              return;
            const l = p.getTokenBefore(h, { includeComments: !0 }), s = l && l.loc.end.line === h.loc.start.line;
            f ? s && t.report({
              node: h,
              messageId: "above"
            }) : s || t.report({
              node: h,
              messageId: "beside"
            });
          });
        }
      };
    }
  }, Sa;
}
var Aa, kg;
function eb() {
  if (kg) return Aa;
  kg = 1;
  const i = Re();
  return Aa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent linebreak style",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/linebreak-style"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["unix", "windows"]
        }
      ],
      messages: {
        expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
        expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r, u) {
        return function(e) {
          return e.replaceTextRange(r, u);
        };
      }
      return {
        Program: function(u) {
          const e = t.options[0] || "unix", a = e === "unix", n = a ? `
` : `\r
`, p = o.getText(), m = i.createGlobalLinebreakMatcher();
          let h, l = 0;
          for (; (h = m.exec(p)) !== null; ) {
            if (l++, h[0] === n)
              continue;
            const s = h.index, c = [s, s + h[0].length];
            t.report({
              node: u,
              loc: {
                start: {
                  line: l,
                  column: o.lines[l - 1].length
                },
                end: {
                  line: l + 1,
                  column: 0
                }
              },
              messageId: a ? "expectedLF" : "expectedCRLF",
              fix: f(c, n)
            });
          }
        }
      };
    }
  }, Aa;
}
var Ta, Bg;
function tb() {
  if (Bg) return Ta;
  Bg = 1;
  const i = Re();
  function t(f) {
    return f.map((u, e) => ({
      code: u.trim(),
      num: e + 1
    })).filter((u) => !u.code).map((u) => u.num);
  }
  function o(f) {
    const r = [];
    return f.forEach((u) => {
      const e = u.loc.start.line, a = u.loc.end.line;
      r.push(e, a);
    }), r;
  }
  return Ta = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require empty lines around comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/lines-around-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            beforeBlockComment: {
              type: "boolean",
              default: !0
            },
            afterBlockComment: {
              type: "boolean",
              default: !1
            },
            beforeLineComment: {
              type: "boolean",
              default: !1
            },
            afterLineComment: {
              type: "boolean",
              default: !1
            },
            allowBlockStart: {
              type: "boolean",
              default: !1
            },
            allowBlockEnd: {
              type: "boolean",
              default: !1
            },
            allowClassStart: {
              type: "boolean"
            },
            allowClassEnd: {
              type: "boolean"
            },
            allowObjectStart: {
              type: "boolean"
            },
            allowObjectEnd: {
              type: "boolean"
            },
            allowArrayStart: {
              type: "boolean"
            },
            allowArrayEnd: {
              type: "boolean"
            },
            ignorePattern: {
              type: "string"
            },
            applyDefaultIgnorePatterns: {
              type: "boolean"
            },
            afterHashbangComment: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        after: "Expected line after comment.",
        before: "Expected line before comment."
      }
    },
    create(f) {
      const r = Object.assign({}, f.options[0]), u = r.ignorePattern, e = i.COMMENTS_IGNORE_PATTERN, a = new RegExp(u, "u"), n = r.applyDefaultIgnorePatterns !== !1;
      r.beforeBlockComment = typeof r.beforeBlockComment < "u" ? r.beforeBlockComment : !0;
      const p = f.sourceCode, m = p.lines, h = m.length + 1, l = p.getAllComments(), s = o(l), c = t(m), g = new Set(s.concat(c));
      function d(k) {
        let w = k;
        do
          w = p.getTokenBefore(w, { includeComments: !0 });
        while (w && i.isCommentToken(w));
        if (w && i.isTokenOnSameLine(w, k))
          return !0;
        w = k;
        do
          w = p.getTokenAfter(w, { includeComments: !0 });
        while (w && i.isCommentToken(w));
        return !!(w && i.isTokenOnSameLine(k, w));
      }
      function y(k, w) {
        return k.type === w || k.body && k.body.type === w || k.consequent && k.consequent.type === w;
      }
      function v(k) {
        const w = p.getNodeByRangeIndex(k.range[0]);
        if (w && w.type === "StaticBlock") {
          const U = p.getFirstToken(w, { skip: 1 });
          return k.range[0] >= U.range[0] ? w : null;
        }
        return w;
      }
      function T(k, w) {
        const U = v(k);
        if (U && y(U, w)) {
          let q = U;
          return U.type === "StaticBlock" ? q = p.getFirstToken(U, { skip: 1 }) : U.type === "SwitchStatement" && (q = p.getTokenAfter(U.discriminant, {
            filter: i.isOpeningBraceToken
          })), k.loc.start.line - q.loc.start.line === 1;
        }
        return !1;
      }
      function b(k, w) {
        const U = v(k);
        return !!U && y(U, w) && U.loc.end.line - k.loc.end.line === 1;
      }
      function S(k) {
        return T(k, "ClassBody") || T(k, "BlockStatement") || T(k, "StaticBlock") || T(k, "SwitchCase") || T(k, "SwitchStatement");
      }
      function C(k) {
        return b(k, "ClassBody") || b(k, "BlockStatement") || b(k, "StaticBlock") || b(k, "SwitchCase") || b(k, "SwitchStatement");
      }
      function x(k) {
        return T(k, "ClassBody");
      }
      function A(k) {
        return b(k, "ClassBody");
      }
      function R(k) {
        return T(k, "ObjectExpression") || T(k, "ObjectPattern");
      }
      function L(k) {
        return b(k, "ObjectExpression") || b(k, "ObjectPattern");
      }
      function _(k) {
        return T(k, "ArrayExpression") || T(k, "ArrayPattern");
      }
      function I(k) {
        return b(k, "ArrayExpression") || b(k, "ArrayPattern");
      }
      function O(k, w) {
        if (n && e.test(k.value) || u && a.test(k.value))
          return;
        let U = w.after, q = w.before;
        const F = k.loc.start.line - 1, $ = k.loc.end.line + 1, P = d(k), X = r.allowBlockStart && S(k) && !(r.allowClassStart === !1 && x(k)), Q = r.allowBlockEnd && C(k) && !(r.allowClassEnd === !1 && A(k)), ue = r.allowClassStart && x(k), le = r.allowClassEnd && A(k), Ce = r.allowObjectStart && R(k), j = r.allowObjectEnd && L(k), H = r.allowArrayStart && _(k), N = r.allowArrayEnd && I(k), G = X || ue || Ce || H, M = Q || le || j || N;
        if (F < 1 && (q = !1), $ >= h && (U = !1), P)
          return;
        const Z = p.getTokenBefore(k, { includeComments: !0 }), Ee = p.getTokenAfter(k, { includeComments: !0 });
        if (!G && q && !g.has(F) && !(i.isCommentToken(Z) && i.isTokenOnSameLine(Z, k))) {
          const ke = k.range[0] - k.loc.start.column, Ie = [ke, ke];
          f.report({
            node: k,
            messageId: "before",
            fix(Je) {
              return Je.insertTextBeforeRange(Ie, `
`);
            }
          });
        }
        !M && U && !g.has($) && !(i.isCommentToken(Ee) && i.isTokenOnSameLine(k, Ee)) && f.report({
          node: k,
          messageId: "after",
          fix(ke) {
            return ke.insertTextAfter(k, `
`);
          }
        });
      }
      return {
        Program() {
          l.forEach((k) => {
            k.type === "Line" ? (r.beforeLineComment || r.afterLineComment) && O(k, {
              after: r.afterLineComment,
              before: r.beforeLineComment
            }) : k.type === "Block" ? (r.beforeBlockComment || r.afterBlockComment) && O(k, {
              after: r.afterBlockComment,
              before: r.beforeBlockComment
            }) : k.type === "Shebang" && r.afterHashbangComment && O(k, {
              after: r.afterHashbangComment,
              before: !1
            });
          });
        }
      };
    }
  }, Ta;
}
var ba, Pg;
function rb() {
  if (Pg) return ba;
  Pg = 1;
  const i = Re();
  return ba = {
    meta: {
      type: "layout",
      docs: {
        description: "Require or disallow newlines around directives",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/lines-around-directive"
      },
      schema: [{
        oneOf: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              before: {
                enum: ["always", "never"]
              },
              after: {
                enum: ["always", "never"]
              }
            },
            additionalProperties: !1,
            minProperties: 2
          }
        ]
      }],
      fixable: "whitespace",
      messages: {
        expected: 'Expected newline {{location}} "{{value}}" directive.',
        unexpected: 'Unexpected newline {{location}} "{{value}}" directive.'
      },
      deprecated: !0,
      replacedBy: ["padding-line-between-statements"]
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || "always", r = typeof f == "string" ? f : f.before, u = typeof f == "string" ? f : f.after;
      function e(h) {
        const l = o.getTokenBefore(h, { includeComments: !0 }), s = l ? l.loc.end.line : 0;
        return h.loc.start.line - s >= 2;
      }
      function a(h) {
        const l = o.getLastToken(h), s = o.getTokenBefore(l);
        return i.isSemicolonToken(l) && l.loc.start.line > s.loc.end.line ? s : l;
      }
      function n(h) {
        const l = a(h);
        return o.getTokenAfter(l, { includeComments: !0 }).loc.start.line - l.loc.end.line >= 2;
      }
      function p(h, l, s) {
        t.report({
          node: h,
          messageId: s ? "expected" : "unexpected",
          data: {
            value: h.expression.value,
            location: l
          },
          fix(c) {
            const g = a(h);
            return s ? l === "before" ? c.insertTextBefore(h, `
`) : c.insertTextAfter(g, `
`) : c.removeRange(l === "before" ? [h.range[0] - 1, h.range[0]] : [g.range[1], g.range[1] + 1]);
          }
        });
      }
      function m(h) {
        const l = i.getDirectivePrologue(h);
        if (!l.length)
          return;
        const s = l[0], c = o.getCommentsBefore(s);
        c.length ? (r === "always" && !e(s) && p(s, "before", !0), r === "never" && e(s) && p(s, "before", !1)) : h.type === "Program" && r === "never" && !c.length && e(s) && p(s, "before", !1);
        const g = l[l.length - 1], d = h.type === "Program" ? h.body : h.body.body;
        g === d[d.length - 1] && !g.trailingComments || (u === "always" && !n(g) && p(g, "after", !0), u === "never" && n(g) && p(g, "after", !1));
      }
      return {
        Program: m,
        FunctionDeclaration: m,
        FunctionExpression: m,
        ArrowFunctionExpression: m
      };
    }
  }, ba;
}
var xa, Ig;
function nb() {
  if (Ig) return xa;
  Ig = 1;
  const i = Re(), t = {
    "*": { test: () => !0 },
    field: { test: (o) => o.type === "PropertyDefinition" },
    method: { test: (o) => o.type === "MethodDefinition" }
  };
  return xa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow an empty line between class members",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/lines-between-class-members"
      },
      fixable: "whitespace",
      schema: [
        {
          anyOf: [
            {
              type: "object",
              properties: {
                enforce: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      blankLine: { enum: ["always", "never"] },
                      prev: { enum: ["method", "field", "*"] },
                      next: { enum: ["method", "field", "*"] }
                    },
                    additionalProperties: !1,
                    required: ["blankLine", "prev", "next"]
                  },
                  minItems: 1
                }
              },
              additionalProperties: !1,
              required: ["enforce"]
            },
            {
              enum: ["always", "never"]
            }
          ]
        },
        {
          type: "object",
          properties: {
            exceptAfterSingleLine: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        never: "Unexpected blank line between class members.",
        always: "Expected blank line between class members."
      }
    },
    create(o) {
      const f = [];
      f[0] = o.options[0] || "always", f[1] = o.options[1] || { exceptAfterSingleLine: !1 };
      const r = typeof f[0] == "object" ? f[0].enforce : [{ blankLine: f[0], prev: "*", next: "*" }], u = o.sourceCode;
      function e(l, s) {
        const c = u.getLastToken(l), g = u.getTokenBefore(c), d = u.getFirstToken(s);
        return i.isSemicolonToken(c) && !i.isTokenOnSameLine(g, c) && i.isTokenOnSameLine(c, d) ? { curLast: g, nextFirst: c } : { curLast: c, nextFirst: d };
      }
      function a(l, s, c) {
        const g = u.getTokenAfter(l, { includeComments: !0 });
        return g !== s && g.loc.start.line - l.loc.end.line <= c ? a(g, s, c) : l;
      }
      function n(l, s, c) {
        const g = u.getTokenBefore(l, { includeComments: !0 });
        return g !== s && l.loc.start.line - g.loc.end.line <= c ? n(g, s, c) : l;
      }
      function p(l, s) {
        return u.getTokensBetween(l, s, { includeComments: !0 }).length !== 0;
      }
      function m(l, s) {
        return t[s].test(l);
      }
      function h(l, s) {
        for (let c = r.length - 1; c >= 0; --c) {
          const g = r[c];
          if (m(l, g.prev) && m(s, g.next))
            return g.blankLine;
        }
        return null;
      }
      return {
        ClassBody(l) {
          const s = l.body;
          for (let c = 0; c < s.length - 1; c++) {
            const g = u.getFirstToken(s[c]), { curLast: d, nextFirst: y } = e(s[c], s[c + 1]), T = !!i.isTokenOnSameLine(g, d) && f[1].exceptAfterSingleLine, b = a(d, y, 1), S = n(y, d, 1), C = S.loc.start.line - b.loc.end.line > 1, x = p(b, S), A = a(d, y, 0), R = h(s[c], s[c + 1]);
            R === "never" && C ? o.report({
              node: s[c + 1],
              messageId: "never",
              fix(L) {
                return x ? null : L.replaceTextRange([b.range[1], S.range[0]], `
`);
              }
            }) : R === "always" && !T && !C && o.report({
              node: s[c + 1],
              messageId: "always",
              fix(L) {
                return x ? null : L.insertTextAfter(A, `
`);
              }
            });
          }
        }
      };
    }
  }, xa;
}
var Ra, Fg;
function sb() {
  if (Fg) return Ra;
  Fg = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["Identifier", "Super", "ThisExpression"]);
  function o(h, l) {
    return h.type === "Identifier" && h.name === "undefined" ? i.isReferenceToGlobalVariable(l, h) : h.type === "UnaryExpression" && h.operator === "void" && h.argument.type === "Literal" && h.argument.value === 0;
  }
  function f(h) {
    return h.type === "Identifier" && h.name !== "undefined" || h.type === "MemberExpression";
  }
  function r(h, l) {
    if (h.type !== "BinaryExpression" || h.operator !== "==")
      return !1;
    const s = f(h.left) ? "left" : "right", c = s === "left" ? "right" : "left";
    return f(h[s]) && (i.isNullLiteral(h[c]) || o(h[c], l));
  }
  function u(h) {
    return h.type === "LogicalExpression" && h.operator === "||" && h.left.type === "BinaryExpression" && h.left.operator === "===" && h.right.type === "BinaryExpression" && h.right.operator === "===";
  }
  function e(h, l) {
    if (!u(h))
      return !1;
    const s = f(h.left.left) ? "left" : "right", c = s === "left" ? "right" : "left", g = f(h.right.left) ? "left" : "right", d = g === "left" ? "right" : "left";
    return i.isSameReference(h.left[s], h.right[g]) && (i.isNullLiteral(h.left[c]) && o(h.right[d], l) || o(h.left[c], l) && i.isNullLiteral(h.right[d]));
  }
  function a(h, l) {
    return h.type === "CallExpression" && h.callee.name === "Boolean" && h.arguments.length === 1 && i.isReferenceToGlobalVariable(l, h.callee);
  }
  function n(h, l) {
    const s = h.type === "UnaryExpression" && h.operator === "!", c = s ? h.argument : h;
    switch (!0) {
      case f(c):
        return { reference: c, operator: s ? "||" : "&&" };
      case (c.type === "UnaryExpression" && c.operator === "!" && f(c.argument)):
        return { reference: c.argument, operator: "&&" };
      case (a(c, l) && f(c.arguments[0])):
        return { reference: c.arguments[0], operator: s ? "||" : "&&" };
      case r(h, l):
        return { reference: f(h.left) ? h.left : h.right, operator: "??" };
      case e(h, l):
        return { reference: f(h.left.left) ? h.left.left : h.left.right, operator: "??" };
      default:
        return null;
    }
  }
  function p(h) {
    return h.type === "Program" ? !1 : h.parent.type === "WithStatement" && h.parent.body === h ? !0 : p(h.parent);
  }
  function m(h, l) {
    let s = l.left;
    for (; s.type === "LogicalExpression" && s.operator === l.operator; ) {
      if (i.isParenthesised(h, s))
        return s;
      s = s.left;
    }
    return s;
  }
  return Ra = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow logical assignment operator shorthand",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/logical-assignment-operators"
      },
      schema: {
        type: "array",
        oneOf: [{
          items: [
            { const: "always" },
            {
              type: "object",
              properties: {
                enforceForIfStatements: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ],
          minItems: 0,
          // 0 for allowing passing no options
          maxItems: 2
        }, {
          items: [{ const: "never" }],
          minItems: 1,
          maxItems: 1
        }]
      },
      fixable: "code",
      hasSuggestions: !0,
      messages: {
        assignment: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
        useLogicalOperator: "Convert this assignment to use the operator {{ operator }}.",
        logical: "Logical expression can be replaced with an assignment ({{ operator }}).",
        convertLogical: "Replace this logical expression with an assignment with the operator {{ operator }}.",
        if: "'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.",
        convertIf: "Replace this 'if' statement with a logical assignment with operator {{ operator }}.",
        unexpected: "Unexpected logical operator assignment ({{operator}}) shorthand.",
        separate: "Separate the logical assignment into an assignment with a logical operator."
      }
    },
    create(h) {
      const l = h.options[0] === "never" ? "never" : "always", s = l === "always" && h.options.length > 1 && h.options[1].enforceForIfStatements, c = h.sourceCode, g = c.getScope(c.ast).isStrict;
      function d(b) {
        return b.type === "Identifier" && (g || !p(b));
      }
      function y(b) {
        return !g && p(b) ? b.type === "Identifier" : b.type === "MemberExpression" && t.has(b.object.type) && (!b.computed || b.property.type !== "MemberExpression" && b.property.type !== "ChainExpression");
      }
      function v(b, S, C) {
        return C ? {
          ...b,
          fix: S.fix
        } : {
          ...b,
          suggest: [S]
        };
      }
      function T(b) {
        return c.getFirstTokenBetween(b.left, b.right, (S) => S.value === b.operator);
      }
      return l === "never" ? {
        // foo ||= bar
        AssignmentExpression(b) {
          if (!i.isLogicalAssignmentOperator(b.operator))
            return;
          const S = {
            messageId: "unexpected",
            node: b,
            data: { operator: b.operator }
          }, C = {
            messageId: "separate",
            *fix(x) {
              if (c.getCommentsInside(b).length > 0)
                return;
              const A = T(b);
              yield x.replaceText(A, "=");
              const R = c.getText(b.left), L = b.operator.slice(0, -1);
              yield x.insertTextAfter(A, ` ${R} ${L}`);
              const _ = i.getPrecedence(b.right) <= i.getPrecedence({ type: "LogicalExpression", operator: L }), I = b.operator === "??=" && i.isLogicalExpression(b.right);
              !i.isParenthesised(c, b.right) && (_ || I) && (yield x.insertTextBefore(b.right, "("), yield x.insertTextAfter(b.right, ")"));
            }
          };
          h.report(v(S, C, d(b.left)));
        }
      } : {
        // foo = foo || bar
        "AssignmentExpression[operator='='][right.type='LogicalExpression']"(b) {
          const S = m(c, b.right);
          if (!i.isSameReference(b.left, S))
            return;
          const C = {
            messageId: "assignment",
            node: b,
            data: { operator: `${b.right.operator}=` }
          }, x = {
            messageId: "useLogicalOperator",
            data: { operator: `${b.right.operator}=` },
            *fix(A) {
              if (c.getCommentsInside(b).length > 0)
                return;
              const R = T(b);
              yield A.insertTextBefore(R, b.right.operator);
              const L = T(S.parent), _ = c.getTokenAfter(L);
              yield A.removeRange([S.parent.range[0], _.range[0]]);
            }
          };
          h.report(v(C, x, d(b.left)));
        },
        // foo || (foo = bar)
        'LogicalExpression[right.type="AssignmentExpression"][right.operator="="]'(b) {
          if (f(b.left) && i.isSameReference(b.left, b.right.left)) {
            const S = {
              messageId: "logical",
              node: b,
              data: { operator: `${b.operator}=` }
            }, C = {
              messageId: "convertLogical",
              data: { operator: `${b.operator}=` },
              *fix(A) {
                if (c.getCommentsInside(b).length > 0)
                  return;
                const R = i.getPrecedence(b.parent), L = b.parent.type !== "ExpressionStatement" && (R === -1 || i.getPrecedence({ type: "AssignmentExpression" }) < R);
                !i.isParenthesised(c, b) && L && (yield A.insertTextBefore(b, "("), yield A.insertTextAfter(b, ")")), yield A.removeRange([b.range[0], b.right.range[0]]), yield A.removeRange([b.right.range[1], b.range[1]]);
                const _ = T(b.right);
                yield A.insertTextBefore(_, b.operator);
              }
            }, x = d(b.left) || y(b.left);
            h.report(v(S, C, x));
          }
        },
        // if (foo) foo = bar
        "IfStatement[alternate=null]"(b) {
          if (!s)
            return;
          const S = b.consequent.type === "BlockStatement";
          if (S && b.consequent.body.length !== 1)
            return;
          const C = S ? b.consequent.body[0] : b.consequent, x = c.getScope(b), A = n(b.test, x);
          if (C.type === "ExpressionStatement" && C.expression.type === "AssignmentExpression" && C.expression.operator === "=" && A !== null && i.isSameReference(A.reference, C.expression.left)) {
            const R = {
              messageId: "if",
              node: b,
              data: { operator: `${A.operator}=` }
            }, L = {
              messageId: "convertIf",
              data: { operator: `${A.operator}=` },
              *fix(I) {
                if (c.getCommentsInside(b).length > 0)
                  return;
                const O = c.getFirstToken(C), k = c.getTokenBefore(b);
                if (k !== null && k.value !== ";" && k.value !== "{" && O.type !== "Identifier" && O.type !== "Keyword")
                  return;
                const w = T(C.expression);
                yield I.insertTextBefore(w, A.operator), yield I.removeRange([b.range[0], C.range[0]]), yield I.removeRange([C.range[1], b.range[1]]);
                const U = c.getTokenAfter(C.expression);
                S && U !== null && U.value !== ";" && (yield I.insertTextAfter(b, ";"));
              }
            }, _ = d(A.reference) || b.test.type !== "LogicalExpression" && y(A.reference);
            h.report(v(R, L, _));
          }
        }
      };
    }
  }, Ra;
}
var Da, Ng;
function ib() {
  return Ng || (Ng = 1, Da = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of classes per file",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-classes-per-file"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 1
            },
            {
              type: "object",
              properties: {
                ignoreExpressions: {
                  type: "boolean"
                },
                max: {
                  type: "integer",
                  minimum: 1
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
      }
    },
    create(i) {
      const [t = {}] = i.options, [o, f] = typeof t == "number" ? [!1, t || 1] : [t.ignoreExpressions, t.max || 1];
      let r = 0;
      return {
        Program() {
          r = 0;
        },
        "Program:exit"(u) {
          r > f && i.report({
            node: u,
            messageId: "maximumExceeded",
            data: {
              classCount: r,
              max: f
            }
          });
        },
        ClassDeclaration() {
          r++;
        },
        ClassExpression() {
          o || r++;
        }
      };
    }
  }), Da;
}
var La, Og;
function ab() {
  return Og || (Og = 1, La = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum depth that blocks can be nested",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-depth"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
      }
    },
    create(i) {
      const t = [], o = i.options[0];
      let f = 4;
      typeof o == "object" && (Object.prototype.hasOwnProperty.call(o, "maximum") || Object.prototype.hasOwnProperty.call(o, "max")) && (f = o.maximum || o.max), typeof o == "number" && (f = o);
      function r() {
        t.push(0);
      }
      function u() {
        t.pop();
      }
      function e(n) {
        const p = ++t[t.length - 1];
        p > f && i.report({ node: n, messageId: "tooDeeply", data: { depth: p, maxDepth: f } });
      }
      function a() {
        t[t.length - 1]--;
      }
      return {
        Program: r,
        FunctionDeclaration: r,
        FunctionExpression: r,
        ArrowFunctionExpression: r,
        StaticBlock: r,
        IfStatement(n) {
          n.parent.type !== "IfStatement" && e(n);
        },
        SwitchStatement: e,
        TryStatement: e,
        DoWhileStatement: e,
        WhileStatement: e,
        WithStatement: e,
        ForStatement: e,
        ForInStatement: e,
        ForOfStatement: e,
        "IfStatement:exit": a,
        "SwitchStatement:exit": a,
        "TryStatement:exit": a,
        "DoWhileStatement:exit": a,
        "WhileStatement:exit": a,
        "WithStatement:exit": a,
        "ForStatement:exit": a,
        "ForInStatement:exit": a,
        "ForOfStatement:exit": a,
        "FunctionDeclaration:exit": u,
        "FunctionExpression:exit": u,
        "ArrowFunctionExpression:exit": u,
        "StaticBlock:exit": u,
        "Program:exit": u
      };
    }
  }), La;
}
var _a, Ug;
function ob() {
  if (Ug) return _a;
  Ug = 1;
  const i = {
    type: "object",
    properties: {
      code: {
        type: "integer",
        minimum: 0
      },
      comments: {
        type: "integer",
        minimum: 0
      },
      tabWidth: {
        type: "integer",
        minimum: 0
      },
      ignorePattern: {
        type: "string"
      },
      ignoreComments: {
        type: "boolean"
      },
      ignoreStrings: {
        type: "boolean"
      },
      ignoreUrls: {
        type: "boolean"
      },
      ignoreTemplateLiterals: {
        type: "boolean"
      },
      ignoreRegExpLiterals: {
        type: "boolean"
      },
      ignoreTrailingComments: {
        type: "boolean"
      }
    },
    additionalProperties: !1
  }, t = {
    anyOf: [
      i,
      {
        type: "integer",
        minimum: 0
      }
    ]
  };
  return _a = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce a maximum line length",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-len"
      },
      schema: [
        t,
        t,
        i
      ],
      messages: {
        max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
        maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
      }
    },
    create(o) {
      const f = /[^:/?#]:\/\/[^?#]/u, r = o.sourceCode;
      function u(I, O) {
        let k = 0;
        return I.replace(/\t/gu, (w, U) => {
          const q = U + k, F = O ? q % O : 0, $ = O - F;
          k += $ - 1;
        }), Array.from(I).length + k;
      }
      const e = Object.assign({}, o.options[o.options.length - 1]);
      typeof o.options[0] == "number" && (e.code = o.options[0]), typeof o.options[1] == "number" && (e.tabWidth = o.options[1]);
      const a = typeof e.code == "number" ? e.code : 80, n = typeof e.tabWidth == "number" ? e.tabWidth : 4, p = !!e.ignoreComments, m = !!e.ignoreStrings, h = !!e.ignoreTemplateLiterals, l = !!e.ignoreRegExpLiterals, s = !!e.ignoreTrailingComments || !!e.ignoreComments, c = !!e.ignoreUrls, g = e.comments;
      let d = e.ignorePattern || null;
      d && (d = new RegExp(d, "u"));
      function y(I, O, k) {
        return k && k.loc.start.line === O && O <= k.loc.end.line && (k.loc.end.line > O || k.loc.end.column === I.length);
      }
      function v(I, O, k) {
        const w = k.loc.start, U = k.loc.end, q = !I.slice(0, k.loc.start.column).trim();
        return k && (w.line < O || w.line === O && q) && (U.line > O || U.line === O && U.column === I.length);
      }
      function T(I) {
        if (!I || !I.parent || I.type !== "JSXEmptyExpression" || I.parent.type !== "JSXExpressionContainer")
          return !1;
        const O = I.parent;
        return O.loc.start.line === O.loc.end.line;
      }
      function b(I, O) {
        return I.slice(0, O.loc.start.column).replace(/\s+$/u, "");
      }
      function S(I, O, k) {
        Array.isArray(I[O]) || (I[O] = []), I[O].push(k);
      }
      function C() {
        return r.ast.tokens.filter((I) => I.type === "String" || I.type === "JSXText" && r.getNodeByRangeIndex(I.range[0] - 1).type === "JSXAttribute");
      }
      function x() {
        return r.ast.tokens.filter((I) => I.type === "Template");
      }
      function A() {
        return r.ast.tokens.filter((I) => I.type === "RegularExpression");
      }
      function R(I) {
        const O = {};
        for (let k = 0; k < I.length; k++) {
          const w = I[k];
          for (let U = w.loc.start.line; U <= w.loc.end.line; ++U)
            S(O, U, w);
        }
        return O;
      }
      function L() {
        const I = [];
        return r.getAllComments().forEach((O) => {
          const k = r.getNodeByRangeIndex(O.range[0]);
          T(k) ? I[I.length - 1] !== k.parent && I.push(k.parent) : I.push(O);
        }), I;
      }
      function _(I) {
        const O = r.lines, k = p || g || s ? L() : [];
        let w = 0;
        const U = C(), q = R(U), F = x(), $ = R(F), P = A(), X = R(P);
        O.forEach((Q, ue) => {
          const le = ue + 1;
          let Ce = !1, j;
          if (w < k.length) {
            let M = null;
            do
              M = k[++w];
            while (M && M.loc.start.line <= le);
            if (M = k[--w], v(Q, le, M))
              Ce = !0, j = Q;
            else if (s && y(Q, le, M)) {
              j = b(Q, M);
              let Z = w;
              for (; y(j, le, k[--Z]); )
                j = b(j, k[Z]);
            } else
              j = Q;
          } else
            j = Q;
          if (d && d.test(j) || c && f.test(j) || m && q[le] || h && $[le] || l && X[le])
            return;
          const H = u(j, n), N = Ce && g;
          if (Ce && p)
            return;
          const G = {
            start: {
              line: le,
              column: 0
            },
            end: {
              line: le,
              column: j.length
            }
          };
          N ? H > g && o.report({
            node: I,
            loc: G,
            messageId: "maxComment",
            data: {
              lineLength: H,
              maxCommentLength: g
            }
          }) : H > a && o.report({
            node: I,
            loc: G,
            messageId: "max",
            data: {
              lineLength: H,
              maxLength: a
            }
          });
        });
      }
      return {
        Program: _
      };
    }
  }, _a;
}
var wa, Vg;
function lb() {
  if (Vg) return wa;
  Vg = 1;
  const i = Re();
  function t(o, f) {
    return [...Array(f - o).keys()].map((r) => r + o);
  }
  return wa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of lines per file",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-lines"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                max: {
                  type: "integer",
                  minimum: 0
                },
                skipComments: {
                  type: "boolean"
                },
                skipBlankLines: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
      }
    },
    create(o) {
      const f = o.options[0];
      let r = 300;
      typeof f == "object" && Object.prototype.hasOwnProperty.call(f, "max") ? r = f.max : typeof f == "number" && (r = f);
      const u = f && f.skipComments, e = f && f.skipBlankLines, a = o.sourceCode;
      function n(m) {
        return m && (m.type === "Block" || m.type === "Line");
      }
      function p(m) {
        let h = m.loc.start.line, l = m.loc.end.line, s;
        s = m;
        do
          s = a.getTokenBefore(s, {
            includeComments: !0
          });
        while (n(s));
        s && i.isTokenOnSameLine(s, m) && (h += 1), s = m;
        do
          s = a.getTokenAfter(s, {
            includeComments: !0
          });
        while (n(s));
        return s && i.isTokenOnSameLine(m, s) && (l -= 1), h <= l ? t(h, l + 1) : [];
      }
      return {
        "Program:exit"() {
          let m = a.lines.map((h, l) => ({
            lineNumber: l + 1,
            text: h
          }));
          if (m.length > 1 && m[m.length - 1].text === "" && m.pop(), e && (m = m.filter((h) => h.text.trim() !== "")), u) {
            const h = a.getAllComments(), l = new Set(h.flatMap(p));
            m = m.filter(
              (s) => !l.has(s.lineNumber)
            );
          }
          if (m.length > r) {
            const h = {
              start: {
                line: m[r].lineNumber,
                column: 0
              },
              end: {
                line: a.lines.length,
                column: a.lines[a.lines.length - 1].length
              }
            };
            o.report({
              loc: h,
              messageId: "exceed",
              data: {
                max: r,
                actual: m.length
              }
            });
          }
        }
      };
    }
  }, wa;
}
var ka, Mg;
function ub() {
  if (Mg) return ka;
  Mg = 1;
  const i = Re(), { upperCaseFirst: t } = Sr(), f = {
    oneOf: [
      {
        type: "object",
        properties: {
          max: {
            type: "integer",
            minimum: 0
          },
          skipComments: {
            type: "boolean"
          },
          skipBlankLines: {
            type: "boolean"
          },
          IIFEs: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      },
      {
        type: "integer",
        minimum: 1
      }
    ]
  };
  function r(u) {
    const e = /* @__PURE__ */ new Map();
    return u.forEach((a) => {
      for (let n = a.loc.start.line; n <= a.loc.end.line; n++)
        e.set(n, a);
    }), e;
  }
  return ka = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of lines of code in a function",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-lines-per-function"
      },
      schema: [
        f
      ],
      messages: {
        exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
      }
    },
    create(u) {
      const e = u.sourceCode, a = e.lines, n = u.options[0];
      let p = 50, m = !1, h = !1, l = !1;
      typeof n == "object" ? (p = typeof n.max == "number" ? n.max : 50, m = !!n.skipComments, h = !!n.skipBlankLines, l = !!n.IIFEs) : typeof n == "number" && (p = n);
      const s = r(e.getAllComments());
      function c(v, T, b) {
        const S = b.loc.start, C = b.loc.end, x = S.line === T && !v.slice(0, S.column).trim(), A = C.line === T && !v.slice(C.column).trim();
        return b && (S.line < T || x) && (C.line > T || A);
      }
      function g(v) {
        return (v.type === "FunctionExpression" || v.type === "ArrowFunctionExpression") && v.parent && v.parent.type === "CallExpression" && v.parent.callee === v;
      }
      function d(v) {
        return !v.parent || v !== v.parent.value ? !1 : v.parent.type === "MethodDefinition" ? !0 : v.parent.type === "Property" ? v.parent.method === !0 || v.parent.kind === "get" || v.parent.kind === "set" : !1;
      }
      function y(v) {
        const T = d(v) ? v.parent : v;
        if (!l && g(T))
          return;
        let b = 0;
        for (let S = T.loc.start.line - 1; S < T.loc.end.line; ++S) {
          const C = a[S];
          m && s.has(S + 1) && c(C, S + 1, s.get(S + 1)) || h && C.match(/^\s*$/u) || b++;
        }
        if (b > p) {
          const S = t(i.getFunctionNameWithKind(v));
          u.report({
            node: T,
            messageId: "exceed",
            data: { name: S, lineCount: b, maxLines: p }
          });
        }
      }
      return {
        FunctionDeclaration: y,
        FunctionExpression: y,
        ArrowFunctionExpression: y
      };
    }
  }, ka;
}
var Ba, Kg;
function cb() {
  return Kg || (Kg = 1, Ba = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum depth that callbacks can be nested",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-nested-callbacks"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
      }
    },
    create(i) {
      const t = i.options[0];
      let o = 10;
      typeof t == "object" && (Object.prototype.hasOwnProperty.call(t, "maximum") || Object.prototype.hasOwnProperty.call(t, "max")) ? o = t.maximum || t.max : typeof t == "number" && (o = t);
      const f = [];
      function r(e) {
        if (e.parent.type === "CallExpression" && f.push(e), f.length > o) {
          const n = { num: f.length, max: o };
          i.report({ node: e, messageId: "exceed", data: n });
        }
      }
      function u() {
        f.pop();
      }
      return {
        ArrowFunctionExpression: r,
        "ArrowFunctionExpression:exit": u,
        FunctionExpression: r,
        "FunctionExpression:exit": u
      };
    }
  }), Ba;
}
var Pa, jg;
function fb() {
  if (jg) return Pa;
  jg = 1;
  const i = Re(), { upperCaseFirst: t } = Sr();
  return Pa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of parameters in function definitions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-params"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(o) {
      const f = o.sourceCode, r = o.options[0];
      let u = 3;
      typeof r == "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) && (u = r.maximum || r.max), typeof r == "number" && (u = r);
      function e(a) {
        a.params.length > u && o.report({
          loc: i.getFunctionHeadLoc(a, f),
          node: a,
          messageId: "exceed",
          data: {
            name: t(i.getFunctionNameWithKind(a)),
            count: a.params.length,
            max: u
          }
        });
      }
      return {
        FunctionDeclaration: e,
        ArrowFunctionExpression: e,
        FunctionExpression: e
      };
    }
  }, Pa;
}
var Ia, qg;
function pb() {
  if (qg) return Ia;
  qg = 1;
  const i = Re(), { upperCaseFirst: t } = Sr();
  return Ia = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of statements allowed in function blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-statements"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: !1
            }
          ]
        },
        {
          type: "object",
          properties: {
            ignoreTopLevelFunctions: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(o) {
      const f = [], r = o.options[0], u = o.options[1] && o.options[1].ignoreTopLevelFunctions || !1, e = [];
      let a = 10;
      typeof r == "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) ? a = r.maximum || r.max : typeof r == "number" && (a = r);
      function n(l, s, c) {
        if (s > c) {
          const g = t(i.getFunctionNameWithKind(l));
          o.report({
            node: l,
            messageId: "exceed",
            data: { name: g, count: s, max: c }
          });
        }
      }
      function p() {
        f.push(0);
      }
      function m(l) {
        const s = f.pop();
        l.type !== "StaticBlock" && (u && f.length === 0 ? e.push({ node: l, count: s }) : n(l, s, a));
      }
      function h(l) {
        f[f.length - 1] += l.body.length;
      }
      return {
        FunctionDeclaration: p,
        FunctionExpression: p,
        ArrowFunctionExpression: p,
        StaticBlock: p,
        BlockStatement: h,
        "FunctionDeclaration:exit": m,
        "FunctionExpression:exit": m,
        "ArrowFunctionExpression:exit": m,
        "StaticBlock:exit": m,
        "Program:exit"() {
          e.length !== 1 && e.forEach((l) => {
            const s = l.count, c = l.node;
            n(c, s, a);
          });
        }
      };
    }
  }, Ia;
}
var Fa, $g;
function hb() {
  if ($g) return Fa;
  $g = 1;
  const i = Re();
  return Fa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce a maximum number of statements allowed per line",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/max-statements-per-line"
      },
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 1,
              default: 1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || {}, r = typeof f.max < "u" ? f.max : 1;
      let u = 0, e = 0, a;
      const n = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;
      function p() {
        a && t.report({
          node: a,
          messageId: "exceed",
          data: {
            numberOfStatementsOnThisLine: e,
            maxStatementsPerLine: r,
            statements: e === 1 ? "statement" : "statements"
          }
        }), a = null;
      }
      function m(s) {
        return o.getLastToken(s, i.isNotSemicolonToken);
      }
      function h(s) {
        const c = s.loc.start.line;
        n.test(s.parent.type) && s.parent.alternate !== s || (c === u ? e += 1 : (p(), e = 1, u = c), e === r + 1 && (a = a || s));
      }
      function l(s) {
        const c = m(s).loc.end.line;
        c !== u && (p(), e = 1, u = c);
      }
      return {
        BreakStatement: h,
        ClassDeclaration: h,
        ContinueStatement: h,
        DebuggerStatement: h,
        DoWhileStatement: h,
        ExpressionStatement: h,
        ForInStatement: h,
        ForOfStatement: h,
        ForStatement: h,
        FunctionDeclaration: h,
        IfStatement: h,
        ImportDeclaration: h,
        LabeledStatement: h,
        ReturnStatement: h,
        SwitchStatement: h,
        ThrowStatement: h,
        TryStatement: h,
        VariableDeclaration: h,
        WhileStatement: h,
        WithStatement: h,
        ExportNamedDeclaration: h,
        ExportDefaultDeclaration: h,
        ExportAllDeclaration: h,
        "BreakStatement:exit": l,
        "ClassDeclaration:exit": l,
        "ContinueStatement:exit": l,
        "DebuggerStatement:exit": l,
        "DoWhileStatement:exit": l,
        "ExpressionStatement:exit": l,
        "ForInStatement:exit": l,
        "ForOfStatement:exit": l,
        "ForStatement:exit": l,
        "FunctionDeclaration:exit": l,
        "IfStatement:exit": l,
        "ImportDeclaration:exit": l,
        "LabeledStatement:exit": l,
        "ReturnStatement:exit": l,
        "SwitchStatement:exit": l,
        "ThrowStatement:exit": l,
        "TryStatement:exit": l,
        "VariableDeclaration:exit": l,
        "WhileStatement:exit": l,
        "WithStatement:exit": l,
        "ExportNamedDeclaration:exit": l,
        "ExportDefaultDeclaration:exit": l,
        "ExportAllDeclaration:exit": l,
        "Program:exit": p
      };
    }
  }, Fa;
}
var Na, Gg;
function mb() {
  if (Gg) return Na;
  Gg = 1;
  const i = Re();
  return Na = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a particular style for multiline comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/multiline-comment-style"
      },
      fixable: "whitespace",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["starred-block", "bare-block"]
              }
            ],
            additionalItems: !1
          },
          {
            type: "array",
            items: [
              {
                enum: ["separate-lines"]
              },
              {
                type: "object",
                properties: {
                  checkJSDoc: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            additionalItems: !1
          }
        ]
      },
      messages: {
        expectedBlock: "Expected a block comment instead of consecutive line comments.",
        expectedBareBlock: "Expected a block comment without padding stars.",
        startNewline: "Expected a linebreak after '/*'.",
        endNewline: "Expected a linebreak before '*/'.",
        missingStar: "Expected a '*' at the start of this line.",
        alignment: "Expected this line to be aligned with the start of the comment.",
        expectedLines: "Expected multiple line comments instead of a block comment."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || "starred-block", u = !!(t.options[1] || {}).checkJSDoc;
      function e(v) {
        return /^\s*\*/u.test(v);
      }
      function a([v]) {
        if (v.type !== "Block")
          return !1;
        const T = v.value.split(i.LINEBREAK_MATCHER);
        return T.length > 0 && T.every((b, S) => (S === 0 || S === T.length - 1 ? /^\s*$/u : /^\s*\*/u).test(b));
      }
      function n([v]) {
        if (v.type !== "Block")
          return !1;
        const T = v.value.split(i.LINEBREAK_MATCHER);
        return /^\*\s*$/u.test(T[0]) && T.slice(1, -1).every((b) => /^\s* /u.test(b)) && /^\s*$/u.test(T[T.length - 1]);
      }
      function p(v) {
        const T = v.map(({ value: b }) => b).filter((b) => b.trim().length).every((b) => b.startsWith(" "));
        return v.map(({ value: b }) => T ? b.replace(/^ /u, "") : b);
      }
      function m(v) {
        const T = v.value.split(i.LINEBREAK_MATCHER).filter((S, C, x) => !(C === 0 || C === x.length - 1)).map((S) => S.replace(/^\s*$/u, "")), b = T.map((S) => S.replace(/\s*\*/u, "")).filter((S) => S.trim().length).every((S) => S.startsWith(" "));
        return T.map((S) => S.replace(b ? /\s*\* ?/u : /\s*\*/u, ""));
      }
      function h(v) {
        const T = v.value.split(i.LINEBREAK_MATCHER).map((C) => C.replace(/^\s*$/u, "")), b = `${o.text.slice(v.range[0] - v.loc.start.column, v.range[0])}   `;
        let S = "";
        for (const [C, x] of T.entries()) {
          if (!x.trim().length || C === 0)
            continue;
          const [, A] = x.match(/^(\s*\*?\s*)/u);
          if (A.length < b.length) {
            const R = b.slice(A.length - b.length);
            R.length > S.length && (S = R);
          }
        }
        return T.map((C) => {
          const x = C.match(/^(\s*\*?\s*)(.*)/u), [, A, R] = x;
          return A.length > b.length ? `${A.slice(b.length - (S.length + A.length))}${R}` : A.length < b.length ? `${A.slice(b.length)}${R}` : R;
        });
      }
      function l(v) {
        const [T] = v;
        return T.type === "Line" ? p(v) : a(v) ? m(T) : h(T);
      }
      function s(v) {
        return o.text.slice(v.range[0] - v.loc.start.column, v.range[0]);
      }
      function c(v, T) {
        const b = s(v);
        return `/*
${T.map((S) => `${b} * ${S}`).join(`
`)}
${b} */`;
      }
      function g(v, T) {
        return T.map((b) => `// ${b}`).join(`
${s(v)}`);
      }
      function d(v, T) {
        return `/* ${T.join(`
${s(v)}   `)} */`;
      }
      const y = {
        "starred-block"(v) {
          const [T] = v, b = l(v);
          if (!b.some((S) => S.includes("*/")))
            if (v.length > 1)
              t.report({
                loc: {
                  start: T.loc.start,
                  end: v[v.length - 1].loc.end
                },
                messageId: "expectedBlock",
                fix(S) {
                  const C = [T.range[0], v[v.length - 1].range[1]];
                  return b.some((x) => x.startsWith("/")) ? null : S.replaceTextRange(C, c(T, b));
                }
              });
            else {
              const S = T.value.split(i.LINEBREAK_MATCHER), x = `${s(T)} *`;
              if (!/^\*?\s*$/u.test(S[0])) {
                const A = T.value.startsWith("*") ? T.range[0] + 1 : T.range[0];
                t.report({
                  loc: {
                    start: T.loc.start,
                    end: { line: T.loc.start.line, column: T.loc.start.column + 2 }
                  },
                  messageId: "startNewline",
                  fix: (R) => R.insertTextAfterRange([A, A + 2], `
${x}`)
                });
              }
              /^\s*$/u.test(S[S.length - 1]) || t.report({
                loc: {
                  start: { line: T.loc.end.line, column: T.loc.end.column - 2 },
                  end: T.loc.end
                },
                messageId: "endNewline",
                fix: (A) => A.replaceTextRange([T.range[1] - 2, T.range[1]], `
${x}/`)
              });
              for (let A = T.loc.start.line + 1; A <= T.loc.end.line; A++) {
                const R = o.lines[A - 1], L = e(R) ? "alignment" : "missingStar";
                R.startsWith(x) || t.report({
                  loc: {
                    start: { line: A, column: 0 },
                    end: { line: A, column: R.length }
                  },
                  messageId: L,
                  fix(_) {
                    const I = o.getIndexFromLoc({ line: A, column: 0 });
                    if (L === "alignment") {
                      const [, U = ""] = R.match(/^(\s*\*)/u) || [], q = I + U.length;
                      return _.replaceTextRange([I, q], x);
                    }
                    const [, O = ""] = R.match(/^(\s*)/u) || [], k = I + O.length;
                    let w;
                    for (const [U, q] of S.entries()) {
                      if (!/\S+/u.test(q))
                        continue;
                      const F = o.lines[T.loc.start.line - 1 + U], [, $ = "", P = ""] = F.match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                      w = `${O.slice($.length)}${P}`, /^\s*\//u.test(R) && w.length === 0 && (w += " ");
                      break;
                    }
                    return _.replaceTextRange([I, k], `${x}${w}`);
                  }
                });
              }
            }
        },
        "separate-lines"(v) {
          const [T] = v, b = n(v);
          if (T.type !== "Block" || !u && b)
            return;
          let S = l(v);
          b && (S = S.slice(1, S.length - 1));
          const C = o.getTokenAfter(T, { includeComments: !0 });
          C && T.loc.end.line === C.loc.start.line || t.report({
            loc: {
              start: T.loc.start,
              end: { line: T.loc.start.line, column: T.loc.start.column + 2 }
            },
            messageId: "expectedLines",
            fix(x) {
              return x.replaceText(T, g(T, S));
            }
          });
        },
        "bare-block"(v) {
          if (n(v))
            return;
          const [T] = v, b = l(v);
          T.type === "Line" && b.length > 1 && !b.some((S) => S.includes("*/")) && t.report({
            loc: {
              start: T.loc.start,
              end: v[v.length - 1].loc.end
            },
            messageId: "expectedBlock",
            fix(S) {
              return S.replaceTextRange(
                [T.range[0], v[v.length - 1].range[1]],
                d(T, b)
              );
            }
          }), a(v) && t.report({
            loc: {
              start: T.loc.start,
              end: { line: T.loc.start.line, column: T.loc.start.column + 2 }
            },
            messageId: "expectedBareBlock",
            fix(S) {
              return S.replaceText(T, d(T, b));
            }
          });
        }
      };
      return {
        Program() {
          return o.getAllComments().filter((v) => v.type !== "Shebang").filter((v) => !i.COMMENTS_IGNORE_PATTERN.test(v.value)).filter((v) => {
            const T = o.getTokenBefore(v, { includeComments: !0 });
            return !T || T.loc.end.line < v.loc.start.line;
          }).reduce((v, T, b, S) => {
            const C = o.getTokenBefore(T, { includeComments: !0 });
            return T.type === "Line" && b && S[b - 1].type === "Line" && C && C.loc.end.line === T.loc.start.line - 1 && C === S[b - 1] ? v[v.length - 1].push(T) : v.push([T]), v;
          }, []).filter((v) => !(v.length === 1 && v[0].loc.start.line === v[0].loc.end.line)).forEach(y[f]);
        }
      };
    }
  }, Na;
}
var Oa, Wg;
function gb() {
  if (Wg) return Oa;
  Wg = 1;
  const i = Re();
  return Oa = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce newlines between operands of ternary expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/multiline-ternary"
      },
      schema: [
        {
          enum: ["always", "always-multiline", "never"]
        }
      ],
      messages: {
        expectedTestCons: "Expected newline between test and consequent of ternary expression.",
        expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
        unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
        unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
      },
      fixable: "whitespace"
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0], r = f !== "never", u = f === "always-multiline";
      return {
        ConditionalExpression(e) {
          const a = o.getTokenAfter(e.test, i.isNotClosingParenToken), n = o.getTokenAfter(e.consequent, i.isNotClosingParenToken), p = o.getFirstToken(e), m = o.getTokenBefore(a), h = o.getTokenAfter(a), l = o.getTokenBefore(n), s = o.getTokenAfter(n), c = i.isTokenOnSameLine(m, h), g = i.isTokenOnSameLine(l, s), d = !!o.getCommentsInside(e).length;
          if (!r)
            c || t.report({
              node: e.test,
              loc: {
                start: p.loc.start,
                end: m.loc.end
              },
              messageId: "unexpectedTestCons",
              fix(y) {
                if (d)
                  return null;
                const v = [], T = i.isTokenOnSameLine(m, a), b = i.isTokenOnSameLine(a, h);
                return T || v.push(y.removeRange([m.range[1], a.range[0]])), b || v.push(y.removeRange([a.range[1], h.range[0]])), v;
              }
            }), g || t.report({
              node: e.consequent,
              loc: {
                start: h.loc.start,
                end: l.loc.end
              },
              messageId: "unexpectedConsAlt",
              fix(y) {
                if (d)
                  return null;
                const v = [], T = i.isTokenOnSameLine(l, n), b = i.isTokenOnSameLine(n, s);
                return T || v.push(y.removeRange([l.range[1], n.range[0]])), b || v.push(y.removeRange([n.range[1], s.range[0]])), v;
              }
            });
          else {
            if (u && e.loc.start.line === e.loc.end.line)
              return;
            c && t.report({
              node: e.test,
              loc: {
                start: p.loc.start,
                end: m.loc.end
              },
              messageId: "expectedTestCons",
              fix: (y) => d ? null : y.replaceTextRange(
                [
                  m.range[1],
                  a.range[0]
                ],
                `
`
              )
            }), g && t.report({
              node: e.consequent,
              loc: {
                start: h.loc.start,
                end: l.loc.end
              },
              messageId: "expectedConsAlt",
              fix: (y) => d ? null : y.replaceTextRange(
                [
                  l.range[1],
                  n.range[0]
                ],
                `
`
              )
            });
          }
        }
      };
    }
  }, Oa;
}
var Ua, Xg;
function db() {
  if (Xg) return Ua;
  Xg = 1;
  const i = Re(), t = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol",
    "BigInt"
  ];
  function o(u, e, a) {
    if (Object.prototype.hasOwnProperty.call(u, e) && !Array.isArray(u[e]))
      throw new TypeError(`${e}, if provided, must be an Array`);
    return u[e] || a;
  }
  function f(u, e) {
    return u[e] = !0, u;
  }
  function r(u) {
    let e = o(u, "capIsNewExceptions", t);
    return e !== t && (e = e.concat(t)), e.reduce(f, {});
  }
  return Ua = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require constructor names to begin with a capital letter",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/new-cap"
      },
      schema: [
        {
          type: "object",
          properties: {
            newIsCap: {
              type: "boolean",
              default: !0
            },
            capIsNew: {
              type: "boolean",
              default: !0
            },
            newIsCapExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            newIsCapExceptionPattern: {
              type: "string"
            },
            capIsNewExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            capIsNewExceptionPattern: {
              type: "string"
            },
            properties: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
        lower: "A constructor name should not start with a lowercase letter."
      }
    },
    create(u) {
      const e = Object.assign({}, u.options[0]);
      e.newIsCap = e.newIsCap !== !1, e.capIsNew = e.capIsNew !== !1;
      const a = e.properties === !1, n = o(e, "newIsCapExceptions", []).reduce(f, {}), p = e.newIsCapExceptionPattern ? new RegExp(e.newIsCapExceptionPattern, "u") : null, m = r(e), h = e.capIsNewExceptionPattern ? new RegExp(e.capIsNewExceptionPattern, "u") : null, l = {}, s = u.sourceCode;
      function c(v) {
        return v.callee.type === "Identifier" ? v.callee.name : i.getStaticPropertyName(v.callee) || "";
      }
      function g(v) {
        const T = v.charAt(0), b = T.toLowerCase(), S = T.toUpperCase();
        return b === S ? "non-alpha" : T === b ? "lower" : "upper";
      }
      function d(v, T, b, S) {
        const C = s.getText(T.callee);
        if (v[b] || v[C] || S && S.test(C))
          return !0;
        const x = i.skipChainExpression(T.callee);
        return b === "UTC" && x.type === "MemberExpression" ? x.object.type === "Identifier" && x.object.name === "Date" : a && x.type === "MemberExpression";
      }
      function y(v, T) {
        let b = i.skipChainExpression(v.callee);
        b.type === "MemberExpression" && (b = b.property), u.report({ node: v, loc: b.loc, messageId: T });
      }
      return e.newIsCap && (l.NewExpression = function(v) {
        const T = c(v);
        T && (g(T) !== "lower" || d(n, v, T, p) || y(v, "lower"));
      }), e.capIsNew && (l.CallExpression = function(v) {
        const T = c(v);
        T && (g(T) !== "upper" || d(m, v, T, h) || y(v, "upper"));
      }), l;
    }
  }, Ua;
}
var Va, zg;
function Eb() {
  if (zg) return Va;
  zg = 1;
  const i = Re();
  return Va = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce or disallow parentheses when invoking a constructor with no arguments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/new-parens"
      },
      fixable: "code",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        missing: "Missing '()' invoking a constructor.",
        unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
      }
    },
    create(t) {
      const f = t.options[0] !== "never", r = t.sourceCode;
      return {
        NewExpression(u) {
          if (u.arguments.length !== 0)
            return;
          const e = r.getLastToken(u), n = e && i.isClosingParenToken(e) && i.isOpeningParenToken(r.getTokenBefore(e)) && u.callee.range[1] < u.range[1];
          f ? n || t.report({
            node: u,
            messageId: "missing",
            fix: (p) => p.insertTextAfter(u, "()")
          }) : n && t.report({
            node: u,
            messageId: "unnecessary",
            fix: (p) => [
              p.remove(r.getTokenBefore(e)),
              p.remove(e),
              p.insertTextBefore(u, "("),
              p.insertTextAfter(u, ")")
            ]
          });
        }
      };
    }
  }, Va;
}
var Ma, Hg;
function yb() {
  if (Hg) return Ma;
  Hg = 1;
  const i = Re();
  return Ma = {
    meta: {
      type: "layout",
      docs: {
        description: "Require or disallow an empty line after variable declarations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/newline-after-var"
      },
      schema: [
        {
          enum: ["never", "always"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expected: "Expected blank line after variable declarations.",
        unexpected: "Unexpected blank line after variable declarations."
      },
      deprecated: !0,
      replacedBy: ["padding-line-between-statements"]
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] === "never" ? "never" : "always", r = o.getAllComments().reduce((s, c) => (s[c.loc.start.line] = c.loc.end.line, s), {});
      function u(s) {
        const c = o.getLastToken(s);
        if (c.type === "Punctuator" && c.value === ";") {
          const g = o.getTokenBefore(c);
          if (g.loc.end.line !== c.loc.start.line)
            return g;
        }
        return c;
      }
      function e(s) {
        return s === "var" || s === "let" || s === "const";
      }
      function a(s) {
        return s === "ForStatement" || s === "ForInStatement" || s === "ForOfStatement";
      }
      function n(s) {
        return s === "ExportNamedDeclaration" || s === "ExportSpecifier" || s === "ExportDefaultDeclaration" || s === "ExportAllDeclaration";
      }
      function p(s) {
        const c = o.getTokenAfter(s);
        return !c || c.type === "Punctuator" && c.value === "}";
      }
      function m(s) {
        const c = r[s];
        return r[c + 1] ? m(c + 1) : c;
      }
      function h(s, c) {
        return s.loc.start.line > m(c) + 1;
      }
      function l(s) {
        const c = u(s), g = c === o.getLastToken(s) ? o.getTokenAfter(s) : o.getLastToken(s), d = c.loc.end.line + 1;
        if (!g || a(s.parent.type) || n(s.parent.type) || g.type === "Keyword" && e(g.value) || p(s))
          return;
        const y = g.loc.start.line > d, v = typeof r[d] < "u";
        f === "never" && y && !v && t.report({
          node: s,
          messageId: "unexpected",
          fix(T) {
            const b = o.getText().slice(c.range[1], g.range[0]).split(i.LINEBREAK_MATCHER);
            return T.replaceTextRange([c.range[1], g.range[0]], `${b.slice(0, -1).join("")}
${b[b.length - 1]}`);
          }
        }), f === "always" && (!y || v && !h(g, d)) && t.report({
          node: s,
          messageId: "expected",
          fix(T) {
            return (y ? m(d) : c.loc.end.line) === g.loc.start.line ? T.insertTextBefore(g, `

`) : T.insertTextBeforeRange([g.range[0] - g.loc.start.column, g.range[1]], `
`);
          }
        });
      }
      return {
        VariableDeclaration: l
      };
    }
  }, Ma;
}
var Ka, Jg;
function Cb() {
  return Jg || (Jg = 1, Ka = {
    meta: {
      type: "layout",
      docs: {
        description: "Require an empty line before `return` statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/newline-before-return"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        expected: "Expected newline before return statement."
      },
      deprecated: !0,
      replacedBy: ["padding-line-between-statements"]
    },
    create(i) {
      const t = i.sourceCode;
      function o(n, p) {
        const m = t.getTokenBefore(n);
        return p.includes(m.value);
      }
      function f(n) {
        const p = n.parent.type;
        return n.parent.body ? Array.isArray(n.parent.body) ? n.parent.body[0] === n : n.parent.body === n : p === "IfStatement" ? o(n, ["else", ")"]) : p === "DoWhileStatement" ? o(n, ["do"]) : p === "SwitchCase" ? o(n, [":"]) : o(n, [")"]);
      }
      function r(n, p) {
        const m = t.getCommentsBefore(n);
        let h = 0;
        return m.length && m.forEach((l) => {
          h++, l.type === "Block" && (h += l.loc.end.line - l.loc.start.line), l.loc.start.line === p && h--, l.loc.end.line === n.loc.start.line && h--;
        }), h;
      }
      function u(n) {
        const p = t.getTokenBefore(n);
        let m;
        return p ? m = p.loc.end.line : m = 0, m;
      }
      function e(n) {
        const p = n.loc.start.line, m = u(n), h = r(n, m);
        return p - m - h > 1;
      }
      function a(n) {
        const p = t.getCommentsBefore(n), m = p[p.length - 1], h = t.getTokenBefore(n);
        return p.length === 0 || m.loc.end.line === h.loc.end.line && m.loc.end.line !== n.loc.start.line;
      }
      return {
        ReturnStatement(n) {
          !f(n) && !e(n) && i.report({
            node: n,
            messageId: "expected",
            fix(p) {
              if (a(n)) {
                const m = t.getTokenBefore(n), h = n.loc.start.line === m.loc.end.line ? `

` : `
`;
                return p.insertTextBefore(n, h);
              }
              return null;
            }
          });
        }
      };
    }
  }), Ka;
}
var ja, Qg;
function vb() {
  if (Qg) return ja;
  Qg = 1;
  const i = Re();
  return ja = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require a newline after each call in a method chain",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/newline-per-chained-call"
      },
      fixable: "whitespace",
      schema: [{
        type: "object",
        properties: {
          ignoreChainWithDepth: {
            type: "integer",
            minimum: 1,
            maximum: 10,
            default: 2
          }
        },
        additionalProperties: !1
      }],
      messages: {
        expected: "Expected line break before `{{callee}}`."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.ignoreChainWithDepth || 2, r = t.sourceCode;
      function u(a) {
        return a.computed ? a.optional ? "?.[" : "[" : a.optional ? "?." : ".";
      }
      function e(a) {
        const n = u(a), p = r.getText(a.property).split(i.LINEBREAK_MATCHER), m = a.computed && p.length === 1 ? "]" : "";
        return n + p[0] + m;
      }
      return {
        "CallExpression:exit"(a) {
          const n = i.skipChainExpression(a.callee);
          if (n.type !== "MemberExpression")
            return;
          let p = i.skipChainExpression(n.object), m = 1;
          for (; p && p.callee; )
            m += 1, p = i.skipChainExpression(i.skipChainExpression(p.callee).object);
          if (m > f && i.isTokenOnSameLine(n.object, n.property)) {
            const h = r.getTokenAfter(n.object, i.isNotClosingParenToken);
            t.report({
              node: n.property,
              loc: {
                start: h.loc.start,
                end: n.loc.end
              },
              messageId: "expected",
              data: {
                callee: e(n)
              },
              fix(l) {
                return l.insertTextBefore(h, `
`);
              }
            });
          }
        }
      };
    }
  }, ja;
}
var qa, Yg;
function Sb() {
  if (Yg) return qa;
  Yg = 1;
  const {
    getStaticPropertyName: i,
    getVariableByName: t,
    skipChainExpression: o
  } = Re();
  function f(a) {
    return /^(alert|confirm|prompt)$/u.test(a);
  }
  function r(a, n) {
    const p = a.references.filter((m) => m.identifier.range[0] === n.range[0] && m.identifier.range[1] === n.range[1]);
    return p.length === 1 ? p[0] : null;
  }
  function u(a, n) {
    const p = r(a, n);
    return p && p.resolved && p.resolved.defs.length > 0;
  }
  function e(a, n) {
    return a.type === "global" && n.type === "ThisExpression" ? !0 : n.type === "Identifier" && (n.name === "window" || n.name === "globalThis" && t(a, "globalThis")) ? !u(a, n) : !1;
  }
  return qa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `alert`, `confirm`, and `prompt`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-alert"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected {{name}}."
      }
    },
    create(a) {
      const n = a.sourceCode;
      return {
        CallExpression(p) {
          const m = o(p.callee), h = n.getScope(p);
          if (m.type === "Identifier") {
            const l = m.name;
            !u(h, m) && f(m.name) && a.report({
              node: p,
              messageId: "unexpected",
              data: { name: l }
            });
          } else if (m.type === "MemberExpression" && e(h, m.object)) {
            const l = i(m);
            f(l) && a.report({
              node: p,
              messageId: "unexpected",
              data: { name: l }
            });
          }
        }
      };
    }
  }, qa;
}
var $a, Zg;
function Ab() {
  if (Zg) return $a;
  Zg = 1;
  const {
    getVariableByName: i,
    isClosingParenToken: t,
    isOpeningParenToken: o,
    isStartOfExpressionStatement: f,
    needsPrecedingSemicolon: r
  } = Re();
  return $a = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `Array` constructors",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-array-constructor"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        preferLiteral: "The array literal notation [] is preferable.",
        useLiteral: "Replace with an array literal.",
        useLiteralAfterSemicolon: "Replace with an array literal, add preceding semicolon."
      }
    },
    create(u) {
      const e = u.sourceCode;
      function a(p) {
        const m = e.getLastToken(p);
        if (!t(m))
          return "";
        let h = p.callee;
        do
          if (h = e.getTokenAfter(h), !h || h === m)
            return "";
        while (!o(h));
        return e.text.slice(h.range[1], m.range[0]);
      }
      function n(p) {
        if (p.callee.type !== "Identifier" || p.callee.name !== "Array" || p.arguments.length === 1 && p.arguments[0].type !== "SpreadElement")
          return;
        const m = i(e.getScope(p), "Array");
        if (m && m.identifiers.length === 0) {
          const h = a(p);
          let l, s;
          f(p) && r(e, p) ? (l = `;[${h}]`, s = "useLiteralAfterSemicolon") : (l = `[${h}]`, s = "useLiteral"), u.report({
            node: p,
            messageId: "preferLiteral",
            suggest: [
              {
                messageId: s,
                fix: (c) => c.replaceText(p, l)
              }
            ]
          });
        }
      }
      return {
        CallExpression: n,
        NewExpression: n
      };
    }
  }, $a;
}
var Ga, ed;
function Tb() {
  return ed || (ed = 1, Ga = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow using an async function as a Promise executor",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-async-promise-executor"
      },
      fixable: null,
      schema: [],
      messages: {
        async: "Promise executor functions should not be async."
      }
    },
    create(i) {
      return {
        "NewExpression[callee.name='Promise'][arguments.0.async=true]"(t) {
          i.report({
            node: i.sourceCode.getFirstToken(t.arguments[0], (o) => o.value === "async"),
            messageId: "async"
          });
        }
      };
    }
  }), Ga;
}
var Wa, td;
function bb() {
  if (td) return Wa;
  td = 1;
  function i(o) {
    const f = o.type;
    return f === "FunctionDeclaration" || f === "FunctionExpression" || f === "ArrowFunctionExpression" || /*
    * Don't report the await expressions on for-await-of loop since it's
    * asynchronous iteration intentionally.
    */
    f === "ForOfStatement" && o.await === !0;
  }
  function t(o, f) {
    switch (f.type) {
      case "ForStatement":
        return o === f.test || o === f.update || o === f.body;
      case "ForOfStatement":
      case "ForInStatement":
        return o === f.body;
      case "WhileStatement":
      case "DoWhileStatement":
        return o === f.test || o === f.body;
      default:
        return !1;
    }
  }
  return Wa = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `await` inside of loops",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-await-in-loop"
      },
      schema: [],
      messages: {
        unexpectedAwait: "Unexpected `await` inside a loop."
      }
    },
    create(o) {
      function f(r) {
        if (r.type === "ForOfStatement" && !r.await)
          return;
        let u = r, e = u.parent;
        for (; e && !i(e); ) {
          if (t(u, e)) {
            o.report({
              node: r,
              messageId: "unexpectedAwait"
            });
            return;
          }
          u = e, e = e.parent;
        }
      }
      return {
        AwaitExpression: f,
        ForOfStatement: f
      };
    }
  }, Wa;
}
var Xa, rd;
function xb() {
  if (rd) return Xa;
  rd = 1;
  const i = [
    "^",
    "|",
    "&",
    "<<",
    ">>",
    ">>>",
    "^=",
    "|=",
    "&=",
    "<<=",
    ">>=",
    ">>>=",
    "~"
  ];
  return Xa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow bitwise operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-bitwise"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                enum: i
              },
              uniqueItems: !0
            },
            int32Hint: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "Unexpected use of '{{operator}}'."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.allow || [], r = o.int32Hint === !0;
      function u(m) {
        t.report({ node: m, messageId: "unexpected", data: { operator: m.operator } });
      }
      function e(m) {
        return i.includes(m.operator);
      }
      function a(m) {
        return f.includes(m.operator);
      }
      function n(m) {
        return r && m.operator === "|" && m.right && m.right.type === "Literal" && m.right.value === 0;
      }
      function p(m) {
        e(m) && !a(m) && !n(m) && u(m);
      }
      return {
        AssignmentExpression: p,
        BinaryExpression: p,
        UnaryExpression: p
      };
    }
  }, Xa;
}
var za, nd;
function Rb() {
  return nd || (nd = 1, za = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "problem",
      docs: {
        description: "Disallow use of the `Buffer()` constructor",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-buffer-constructor"
      },
      schema: [],
      messages: {
        deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
      }
    },
    create(i) {
      return {
        "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(t) {
          i.report({
            node: t,
            messageId: "deprecated",
            data: { expr: t.type === "CallExpression" ? "Buffer()" : "new Buffer()" }
          });
        }
      };
    }
  }), za;
}
var Ha, sd;
function Db() {
  return sd || (sd = 1, Ha = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `arguments.caller` or `arguments.callee`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-caller"
      },
      schema: [],
      messages: {
        unexpected: "Avoid arguments.{{prop}}."
      }
    },
    create(i) {
      return {
        MemberExpression(t) {
          const o = t.object.name, f = t.property.name;
          o === "arguments" && !t.computed && f && f.match(/^calle[er]$/u) && i.report({ node: t, messageId: "unexpected", data: { prop: f } });
        }
      };
    }
  }), Ha;
}
var Ja, id;
function Lb() {
  return id || (id = 1, Ja = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow lexical declarations in case clauses",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-case-declarations"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected lexical declaration in case block."
      }
    },
    create(i) {
      function t(o) {
        switch (o.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            return !0;
          case "VariableDeclaration":
            return o.kind !== "var";
          default:
            return !1;
        }
      }
      return {
        SwitchCase(o) {
          for (let f = 0; f < o.consequent.length; f++) {
            const r = o.consequent[f];
            t(r) && i.report({
              node: r,
              messageId: "unexpected"
            });
          }
        }
      };
    }
  }), Ja;
}
var Qa, ad;
function _b() {
  if (ad) return Qa;
  ad = 1;
  const i = Re();
  return Qa = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `catch` clause parameters from shadowing variables in the outer scope",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-catch-shadow"
      },
      replacedBy: ["no-shadow"],
      deprecated: !0,
      schema: [],
      messages: {
        mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r, u) {
        return i.getVariableByName(r, u) !== null;
      }
      return {
        "CatchClause[param!=null]"(r) {
          let u = o.getScope(r);
          u.block === r && (u = u.upper), f(u, r.param.name) && t.report({ node: r, messageId: "mutable", data: { name: r.param.name } });
        }
      };
    }
  }, Qa;
}
var Ya, od;
function wb() {
  if (od) return Ya;
  od = 1;
  const i = Re();
  return Ya = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning class members",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-class-assign"
      },
      schema: [],
      messages: {
        class: "'{{name}}' is a class."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(u) {
        i.getModifyingReferences(u.references).forEach((e) => {
          t.report({ node: e.identifier, messageId: "class", data: { name: e.identifier.name } });
        });
      }
      function r(u) {
        o.getDeclaredVariables(u).forEach(f);
      }
      return {
        ClassDeclaration: r,
        ClassExpression: r
      };
    }
  }, Ya;
}
var Za, ld;
function kb() {
  return ld || (ld = 1, Za = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow comparing against -0",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-compare-neg-zero"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Do not use the '{{operator}}' operator to compare against -0."
      }
    },
    create(i) {
      function t(f) {
        return f.type === "UnaryExpression" && f.operator === "-" && f.argument.type === "Literal" && f.argument.value === 0;
      }
      const o = /* @__PURE__ */ new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
      return {
        BinaryExpression(f) {
          o.has(f.operator) && (t(f.left) || t(f.right)) && i.report({
            node: f,
            messageId: "unexpected",
            data: { operator: f.operator }
          });
        }
      };
    }
  }), Za;
}
var eo, ud;
function Bb() {
  if (ud) return eo;
  ud = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]), o = {
    DoWhileStatement: "a 'do...while' statement",
    ForStatement: "a 'for' statement",
    IfStatement: "an 'if' statement",
    WhileStatement: "a 'while' statement"
  };
  return eo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow assignment operators in conditional expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-cond-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        unexpected: "Unexpected assignment within {{type}}.",
        // must match JSHint's error message
        missing: "Expected a conditional expression and instead saw an assignment."
      }
    },
    create(f) {
      const r = f.options[0] || "except-parens", u = f.sourceCode;
      function e(h) {
        return h.parent && t.has(h.parent.type) && h === h.parent.test;
      }
      function a(h) {
        let l = h;
        do
          if (e(l))
            return l.parent;
        while ((l = l.parent) && !i.isFunction(l));
        return null;
      }
      function n(h) {
        const l = u.getTokenBefore(h, 1), s = u.getTokenAfter(h, 1);
        return i.isParenthesised(u, h) && l && i.isOpeningParenToken(l) && l.range[1] <= h.range[0] && i.isClosingParenToken(s) && s.range[0] >= h.range[1];
      }
      function p(h) {
        h.test && h.test.type === "AssignmentExpression" && (h.type === "ForStatement" ? !i.isParenthesised(u, h.test) : !n(h.test)) && f.report({
          node: h.test,
          messageId: "missing"
        });
      }
      function m(h) {
        const l = a(h);
        l && f.report({
          node: h,
          messageId: "unexpected",
          data: {
            type: o[l.type] || l.type
          }
        });
      }
      return r === "always" ? {
        AssignmentExpression: m
      } : {
        DoWhileStatement: p,
        ForStatement: p,
        IfStatement: p,
        WhileStatement: p,
        ConditionalExpression: p
      };
    }
  }, eo;
}
var to, cd;
function Pb() {
  if (cd) return to;
  cd = 1;
  const i = Re();
  function t(o) {
    return o && o.type === "ConditionalExpression";
  }
  return to = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow arrow functions where they could be confused with comparisons",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-confusing-arrow"
      },
      fixable: "code",
      schema: [{
        type: "object",
        properties: {
          allowParens: { type: "boolean", default: !0 },
          onlyOneSimpleParam: { type: "boolean", default: !1 }
        },
        additionalProperties: !1
      }],
      messages: {
        confusing: "Arrow function used ambiguously with a conditional expression."
      }
    },
    create(o) {
      const f = o.options[0] || {}, r = f.allowParens || f.allowParens === void 0, u = f.onlyOneSimpleParam, e = o.sourceCode;
      function a(n) {
        const p = n.body;
        t(p) && !(r && i.isParenthesised(e, p)) && !(u && !(n.params.length === 1 && n.params[0].type === "Identifier")) && o.report({
          node: n,
          messageId: "confusing",
          fix(m) {
            return r && m.replaceText(n.body, `(${e.getText(n.body)})`);
          }
        });
      }
      return {
        ArrowFunctionExpression: a
      };
    }
  }, to;
}
var ro, fd;
function Ib() {
  if (fd) return ro;
  fd = 1;
  const i = Re();
  return ro = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `console`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-console"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      hasSuggestions: !0,
      messages: {
        unexpected: "Unexpected console statement.",
        removeConsole: "Remove the console.{{ propertyName }}()."
      }
    },
    create(t) {
      const f = (t.options[0] || {}).allow || [], r = t.sourceCode;
      function u(h) {
        const l = h.identifier;
        return l && l.name === "console";
      }
      function e(h) {
        const l = i.getStaticPropertyName(h);
        return l && f.includes(l);
      }
      function a(h) {
        const l = h.identifier, s = l.parent;
        return s.type === "MemberExpression" && s.object === l && !e(s);
      }
      function n(h) {
        const l = /^[:;{]$/u, s = /^[-[(/+`]/u, c = r.getTokenBefore(h), g = r.getTokenAfter(h);
        return !!g && s.test(g.value) && g.value !== "++" && g.value !== "--" && !!c && !l.test(c.value);
      }
      function p(h) {
        return h.parent.type === "CallExpression" && h.parent.callee === h && h.parent.parent.type === "ExpressionStatement" && i.STATEMENT_LIST_PARENTS.has(h.parent.parent.parent.type) && !n(h.parent.parent);
      }
      function m(h) {
        const l = h.identifier.parent, s = i.getStaticPropertyName(l);
        t.report({
          node: l,
          loc: l.loc,
          messageId: "unexpected",
          suggest: p(l) ? [{
            messageId: "removeConsole",
            data: { propertyName: s },
            fix(c) {
              return c.remove(l.parent.parent);
            }
          }] : []
        });
      }
      return {
        "Program:exit"(h) {
          const l = r.getScope(h), s = i.getVariableByName(l, "console"), c = s && s.defs.length > 0, g = s ? s.references : l.through.filter(u);
          c || g.filter(a).forEach(m);
        }
      };
    }
  }, ro;
}
var no, pd;
function Fb() {
  if (pd) return no;
  pd = 1;
  const i = Re();
  return no = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning `const` variables",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-const-assign"
      },
      schema: [],
      messages: {
        const: "'{{name}}' is constant."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r) {
        i.getModifyingReferences(r.references).forEach((u) => {
          t.report({ node: u.identifier, messageId: "const", data: { name: u.identifier.name } });
        });
      }
      return {
        VariableDeclaration(r) {
          r.kind === "const" && o.getDeclaredVariables(r).forEach(f);
        }
      };
    }
  }, no;
}
var so, hd;
function Nb() {
  if (hd) return so;
  hd = 1;
  const i = jf(), { isNullLiteral: t, isConstant: o, isReferenceToGlobalVariable: f, isLogicalAssignmentOperator: r } = Re(), u = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "|", "^", "&", "**", "<<", ">>", ">>>"]);
  function e(s, c) {
    return t(c) || c.type === "Identifier" && c.name === "undefined" && f(s, c) || c.type === "UnaryExpression" && c.operator === "void";
  }
  function a(s, c, g) {
    if (g && e(s, c))
      return !1;
    switch (c.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
      case "NewExpression":
      case "Literal":
      case "TemplateLiteral":
      case "UpdateExpression":
      case "BinaryExpression":
        return !0;
      case "CallExpression": {
        if (c.callee.type !== "Identifier")
          return !1;
        const d = c.callee.name;
        return (d === "Boolean" || d === "String" || d === "Number") && f(s, c.callee);
      }
      case "LogicalExpression":
        return c.operator === "??" && a(s, c.right, !0);
      case "AssignmentExpression":
        return c.operator === "=" ? a(s, c.right, g) : !r(c.operator);
      case "UnaryExpression":
        return !0;
      case "SequenceExpression": {
        const d = c.expressions[c.expressions.length - 1];
        return a(s, d, g);
      }
      case "Identifier":
        return c.name === "undefined" && f(s, c);
      case "JSXElement":
      case "JSXFragment":
        return !1;
      default:
        return !1;
    }
  }
  function n(s, c) {
    switch (c.type) {
      case "Literal":
        return typeof c.value == "boolean";
      case "CallExpression":
        return c.callee.type === "Identifier" && c.callee.name === "Boolean" && f(s, c.callee) && (c.arguments.length === 0 || o(s, c.arguments[0], !0));
      case "UnaryExpression":
        return c.operator === "!" && o(s, c.argument, !0);
      default:
        return !1;
    }
  }
  function p(s, c) {
    switch (c.type) {
      case "ObjectExpression":
      case "ClassExpression":
        return !0;
      case "ArrayExpression": {
        const g = c.elements.filter((d) => (
          // Elements can be `null` in sparse arrays: `[,,]`;
          d !== null && d.type !== "SpreadElement"
        ));
        return c.elements.length === 0 || g.length > 1;
      }
      case "ArrowFunctionExpression":
      case "FunctionExpression":
        return !0;
      case "UnaryExpression":
        return c.operator === "void" || // Always returns `undefined`
        c.operator === "typeof" ? !0 : c.operator === "!" ? o(s, c.argument, !0) : !1;
      case "NewExpression":
        return !1;
      case "CallExpression":
        return c.callee.type === "Identifier" && c.callee.name === "Boolean" && f(s, c.callee) ? c.arguments.length === 0 || o(s, c.arguments[0], !0) : !1;
      case "Literal":
        return !0;
      case "Identifier":
        return c.name === "undefined" && f(s, c);
      case "TemplateLiteral":
        return c.expressions.length === 0;
      case "AssignmentExpression":
        return c.operator === "=" ? p(s, c.right) : !1;
      case "SequenceExpression": {
        const g = c.expressions[c.expressions.length - 1];
        return p(s, g);
      }
      case "JSXElement":
      case "JSXFragment":
        return !1;
      default:
        return !1;
    }
  }
  function m(s, c) {
    switch (c.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
      case "NewExpression":
      case "TemplateLiteral":
      case "Literal":
      case "UpdateExpression":
        return !0;
      case "BinaryExpression":
        return u.has(c.operator);
      case "UnaryExpression":
        return c.operator === "delete" ? !1 : c.operator === "!" ? o(s, c.argument, !0) : !0;
      case "SequenceExpression": {
        const g = c.expressions[c.expressions.length - 1];
        return m(s, g);
      }
      case "Identifier":
        return c.name === "undefined" && f(s, c);
      case "AssignmentExpression":
        return c.operator === "=" ? m(s, c.right) : !r(c.operator);
      case "CallExpression": {
        if (c.callee.type !== "Identifier")
          return !1;
        const g = c.callee.name;
        return (g === "String" || g === "Number") && f(s, c.callee) ? !0 : g === "Boolean" && f(s, c.callee) ? c.arguments.length === 0 || o(s, c.arguments[0], !0) : !1;
      }
      case "JSXElement":
      case "JSXFragment":
        return !1;
      default:
        return !1;
    }
  }
  function h(s, c) {
    switch (c.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
        return !0;
      case "NewExpression":
        return c.callee.type !== "Identifier" ? !1 : Object.hasOwnProperty.call(i.builtin, c.callee.name) && f(s, c.callee);
      case "Literal":
        return typeof c.regex == "object";
      case "SequenceExpression": {
        const g = c.expressions[c.expressions.length - 1];
        return h(s, g);
      }
      case "AssignmentExpression":
        return c.operator === "=" ? h(s, c.right) : !1;
      case "ConditionalExpression":
        return h(s, c.consequent) && h(s, c.alternate);
      case "JSXElement":
      case "JSXFragment":
        return !1;
      default:
        return !1;
    }
  }
  function l(s, c, g, d) {
    if (d === "==" || d === "!=") {
      if (e(s, c) && a(s, g, !1) || n(s, c) && p(s, g))
        return g;
    } else if ((d === "===" || d === "!==") && (e(s, c) && a(s, g, !1) || n(s, c) && m(s, g)))
      return g;
    return null;
  }
  return so = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow expressions where the operation doesn't affect the value",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-constant-binary-expression"
      },
      schema: [],
      messages: {
        constantBinaryOperand: "Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.",
        constantShortCircuit: "Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.",
        alwaysNew: "Unexpected comparison to newly constructed object. These two values can never be equal.",
        bothAlwaysNew: "Unexpected comparison of two newly constructed objects. These two values can never be equal."
      }
    },
    create(s) {
      const c = s.sourceCode;
      return {
        LogicalExpression(g) {
          const { operator: d, left: y } = g, v = c.getScope(g);
          (d === "&&" || d === "||") && o(v, y, !0) ? s.report({ node: y, messageId: "constantShortCircuit", data: { property: "truthiness", operator: d } }) : d === "??" && a(v, y, !1) && s.report({ node: y, messageId: "constantShortCircuit", data: { property: "nullishness", operator: d } });
        },
        BinaryExpression(g) {
          const d = c.getScope(g), { right: y, left: v, operator: T } = g, b = l(d, v, y, T), S = l(d, y, v, T);
          b ? s.report({ node: b, messageId: "constantBinaryOperand", data: { operator: T, otherSide: "left" } }) : S ? s.report({ node: S, messageId: "constantBinaryOperand", data: { operator: T, otherSide: "right" } }) : T === "===" || T === "!==" ? h(d, v) ? s.report({ node: v, messageId: "alwaysNew" }) : h(d, y) && s.report({ node: y, messageId: "alwaysNew" }) : (T === "==" || T === "!=") && h(d, v) && h(d, y) && s.report({ node: v, messageId: "bothAlwaysNew" });
        }
        /*
         * In theory we could handle short-circuiting assignment operators,
         * for some constant values, but that would require walking the
         * scope to find the value of the variable being assigned. This is
         * dependant on https://github.com/eslint/eslint/issues/13776
         *
         * AssignmentExpression() {},
         */
      };
    }
  }, so;
}
var io, md;
function Ob() {
  if (md) return io;
  md = 1;
  const { isConstant: i } = Re();
  return io = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow constant expressions in conditions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-constant-condition"
      },
      schema: [
        {
          type: "object",
          properties: {
            checkLoops: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "Unexpected constant condition."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.checkLoops !== !1, r = [], u = t.sourceCode;
      let e = /* @__PURE__ */ new Set();
      function a(s) {
        s.test && i(u.getScope(s), s.test, !0) && e.add(s);
      }
      function n(s) {
        e.has(s) && (e.delete(s), t.report({ node: s.test, messageId: "unexpected" }));
      }
      function p(s) {
        s.test && i(u.getScope(s), s.test, !0) && t.report({ node: s.test, messageId: "unexpected" });
      }
      function m() {
        r.push(e), e = /* @__PURE__ */ new Set();
      }
      function h() {
        e = r.pop();
      }
      function l(s) {
        f && a(s);
      }
      return {
        ConditionalExpression: p,
        IfStatement: p,
        WhileStatement: l,
        "WhileStatement:exit": n,
        DoWhileStatement: l,
        "DoWhileStatement:exit": n,
        ForStatement: l,
        "ForStatement > .test": (s) => l(s.parent),
        "ForStatement:exit": n,
        FunctionDeclaration: m,
        "FunctionDeclaration:exit": h,
        FunctionExpression: m,
        "FunctionExpression:exit": h,
        YieldExpression: () => e.clear()
      };
    }
  }, io;
}
var ao, gd;
function Ub() {
  return gd || (gd = 1, ao = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow returning value from constructor",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-constructor-return"
      },
      schema: {},
      fixable: null,
      messages: {
        unexpected: "Unexpected return statement in constructor."
      }
    },
    create(i) {
      const t = [];
      return {
        onCodePathStart(o, f) {
          t.push(f);
        },
        onCodePathEnd() {
          t.pop();
        },
        ReturnStatement(o) {
          const f = t[t.length - 1];
          f.parent && f.parent.type === "MethodDefinition" && f.parent.kind === "constructor" && (o.parent.parent === f || o.argument) && i.report({
            node: o,
            messageId: "unexpected"
          });
        }
      };
    }
  }), ao;
}
var oo, dd;
function Vb() {
  return dd || (dd = 1, oo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `continue` statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-continue"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected use of continue statement."
      }
    },
    create(i) {
      return {
        ContinueStatement(t) {
          i.report({ node: t, messageId: "unexpected" });
        }
      };
    }
  }), oo;
}
var ar = {}, Ed;
function rr() {
  if (Ed) return ar;
  Ed = 1, Object.defineProperty(ar, "__esModule", { value: !0 });
  var i = /* @__PURE__ */ Object.freeze({
    __proto__: null
  });
  const t = 2024;
  let o, f;
  function r(Oe) {
    return Oe < 65 ? !1 : Oe < 91 ? !0 : Oe < 97 ? !1 : Oe < 123 ? !0 : e(Oe);
  }
  function u(Oe) {
    return Oe < 48 ? !1 : Oe < 58 ? !0 : Oe < 65 ? !1 : Oe < 91 || Oe === 95 ? !0 : Oe < 97 ? !1 : Oe < 123 ? !0 : e(Oe) || a(Oe);
  }
  function e(Oe) {
    return m(Oe, o ?? (o = n()));
  }
  function a(Oe) {
    return m(Oe, f ?? (f = p()));
  }
  function n() {
    return h("4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 6 n 2 5 i 15 1n 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 3 0 3 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 w 1 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 h e i f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 7 1j t e 1 b 17 r z 16 2 b z 3 8 8 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 6c 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t h3g 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1r 6 1 2 0 2 4 p f 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f d a 2 e 2 6 2 1 2 a 2 e 2 6 2 1 1w 8m a l b 7 p 5 2 15 2 8 1y 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 9p 15 7 1 27 s b 0 9 l 17 h 1b k s m d 1g 1m 1 3 0 e 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o k 1 1s 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 4f 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 12 6 56 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 j 20 7c 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i g 0 2 c 2 x 3h 0 28 pl 2v 32 i 5f 219 2o g tr i 5 33u g6 6nu fs 8 u i 26 i t j 1b h 3 w k 6 i j5 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 17 8 6w8 3 2 6 2 1 2 82 g 0 u 2 3 0 f 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1f9 u 7 5 7a 1p 43 18 b 6 h 0 8y t j 17 dh r l1 6 2 3 2 1 2 e 2 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyn x 37d 7 65 3 4g1 f 5rk 2e8 f1 15v 3t6 6 38f");
  }
  function p() {
    return h("53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 1p 7 17 n 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1k 0 2 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 4 0 d 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 6 2 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 3 t 2 u 1 v 1 1t v a 0 3 9 y 2 2 a 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 f 1e 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1r g0 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 n7q 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 ji 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 aa 1 29 2 1z a 1e 3 3f 2 1i e w a 3 1 b 3 1a a 8 0 1a 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 3 0 4e b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 5d h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 2c e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f ba 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 a 1 2 0 1d 6 4 4 e 9 44n 0 7 e aob 9 2f 9 13 4 1o 6 q 9 s6 0 2 1i 8 3 2a 0 c 1 f58 1 3mq 19 3 m f3 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 2t 0 4h 6 a 9 9x 0 1q d dv d rb 6 32 6 6 9 3o7 9 gvt3 6n");
  }
  function m(Oe, V) {
    let ie = 0, he = V.length / 2 | 0, De = 0, E = 0, D = 0;
    for (; ie < he; )
      if (De = (ie + he) / 2 | 0, E = V[2 * De], D = V[2 * De + 1], Oe < E)
        he = De;
      else if (Oe > D)
        ie = De + 1;
      else
        return !0;
    return !1;
  }
  function h(Oe) {
    let V = 0;
    return Oe.split(" ").map((ie) => V += parseInt(ie, 36) | 0);
  }
  class l {
    constructor(V, ie, he, De, E, D, K) {
      this._raw2018 = V, this._raw2019 = ie, this._raw2020 = he, this._raw2021 = De, this._raw2022 = E, this._raw2023 = D, this._raw2024 = K;
    }
    get es2018() {
      var V;
      return (V = this._set2018) !== null && V !== void 0 ? V : this._set2018 = new Set(this._raw2018.split(" "));
    }
    get es2019() {
      var V;
      return (V = this._set2019) !== null && V !== void 0 ? V : this._set2019 = new Set(this._raw2019.split(" "));
    }
    get es2020() {
      var V;
      return (V = this._set2020) !== null && V !== void 0 ? V : this._set2020 = new Set(this._raw2020.split(" "));
    }
    get es2021() {
      var V;
      return (V = this._set2021) !== null && V !== void 0 ? V : this._set2021 = new Set(this._raw2021.split(" "));
    }
    get es2022() {
      var V;
      return (V = this._set2022) !== null && V !== void 0 ? V : this._set2022 = new Set(this._raw2022.split(" "));
    }
    get es2023() {
      var V;
      return (V = this._set2023) !== null && V !== void 0 ? V : this._set2023 = new Set(this._raw2023.split(" "));
    }
    get es2024() {
      var V;
      return (V = this._set2024) !== null && V !== void 0 ? V : this._set2024 = new Set(this._raw2024.split(" "));
    }
  }
  const s = /* @__PURE__ */ new Set(["General_Category", "gc"]), c = /* @__PURE__ */ new Set(["Script", "Script_Extensions", "sc", "scx"]), g = new l("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "", "", "", "", ""), d = new l("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho", "Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", "Cpmn Cypro_Minoan Old_Uyghur Ougr Tangsa Tnsa Toto Vith Vithkuqi", "Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", ""), y = new l("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "", "EBase EComp EMod EPres ExtPict", "", "", "");
  function v(Oe, V, ie) {
    return s.has(V) ? Oe >= 2018 && g.es2018.has(ie) : c.has(V) ? Oe >= 2018 && d.es2018.has(ie) || Oe >= 2019 && d.es2019.has(ie) || Oe >= 2020 && d.es2020.has(ie) || Oe >= 2021 && d.es2021.has(ie) || Oe >= 2022 && d.es2022.has(ie) || Oe >= 2023 && d.es2023.has(ie) : !1;
  }
  function T(Oe, V) {
    return Oe >= 2018 && y.es2018.has(V) || Oe >= 2019 && y.es2019.has(V) || Oe >= 2021 && y.es2021.has(V);
  }
  const b = 8, S = 9, C = 10, x = 11, A = 12, R = 13, L = 33, _ = 35, I = 36, O = 37, k = 38, w = 40, U = 41, q = 42, F = 43, $ = 44, P = 45, X = 46, Q = 47, ue = 48, le = 49, Ce = 55, j = 57, H = 58, N = 59, G = 60, M = 61, Z = 62, Ee = 63, ke = 64, Ie = 65, Je = 66, at = 68, lt = 70, mt = 80, Y = 83, Te = 87, Ke = 90, et = 95, nt = 97, rt = 98, ot = 99, Ct = 100, dt = 102, vt = 103, W = 105, Ye = 107, Ue = 109, Ve = 110, xe = 112, re = 113, ne = 114, ae = 115, fe = 116, de = 117, ee = 118, te = 119, B = 120, z = 121, ce = 122, ye = 91, Be = 92, we = 93, Pe = 94, st = 96, We = 123, _e = 124, je = 125, $e = 126, Ae = 8204, oe = 8205, se = 8232, pe = 8233, ve = 0, Se = 1114111;
  function Ge(Oe) {
    return Oe >= Ie && Oe <= Ke || Oe >= nt && Oe <= ce;
  }
  function Ze(Oe) {
    return Oe >= ue && Oe <= j;
  }
  function ft(Oe) {
    return Oe >= ue && Oe <= Ce;
  }
  function gt(Oe) {
    return Oe >= ue && Oe <= j || Oe >= Ie && Oe <= lt || Oe >= nt && Oe <= dt;
  }
  function At(Oe) {
    return Oe === C || Oe === R || Oe === se || Oe === pe;
  }
  function ht(Oe) {
    return Oe >= ve && Oe <= Se;
  }
  function qe(Oe) {
    return Oe >= nt && Oe <= dt ? Oe - nt + 10 : Oe >= Ie && Oe <= lt ? Oe - Ie + 10 : Oe - ue;
  }
  function He(Oe) {
    return Oe >= 55296 && Oe <= 56319;
  }
  function Xe(Oe) {
    return Oe >= 56320 && Oe <= 57343;
  }
  function Me(Oe, V) {
    return (Oe - 55296) * 1024 + (V - 56320) + 65536;
  }
  const it = {
    at(Oe, V, ie) {
      return ie < V ? Oe.charCodeAt(ie) : -1;
    },
    width(Oe) {
      return 1;
    }
  }, ut = {
    at(Oe, V, ie) {
      return ie < V ? Oe.codePointAt(ie) : -1;
    },
    width(Oe) {
      return Oe > 65535 ? 2 : 1;
    }
  };
  class Tt {
    constructor() {
      this._impl = it, this._s = "", this._i = 0, this._end = 0, this._cp1 = -1, this._w1 = 1, this._cp2 = -1, this._w2 = 1, this._cp3 = -1, this._w3 = 1, this._cp4 = -1;
    }
    get source() {
      return this._s;
    }
    get index() {
      return this._i;
    }
    get currentCodePoint() {
      return this._cp1;
    }
    get nextCodePoint() {
      return this._cp2;
    }
    get nextCodePoint2() {
      return this._cp3;
    }
    get nextCodePoint3() {
      return this._cp4;
    }
    reset(V, ie, he, De) {
      this._impl = De ? ut : it, this._s = V, this._end = he, this.rewind(ie);
    }
    rewind(V) {
      const ie = this._impl;
      this._i = V, this._cp1 = ie.at(this._s, this._end, V), this._w1 = ie.width(this._cp1), this._cp2 = ie.at(this._s, this._end, V + this._w1), this._w2 = ie.width(this._cp2), this._cp3 = ie.at(this._s, this._end, V + this._w1 + this._w2), this._w3 = ie.width(this._cp3), this._cp4 = ie.at(this._s, this._end, V + this._w1 + this._w2 + this._w3);
    }
    advance() {
      if (this._cp1 !== -1) {
        const V = this._impl;
        this._i += this._w1, this._cp1 = this._cp2, this._w1 = this._w2, this._cp2 = this._cp3, this._w2 = V.width(this._cp2), this._cp3 = this._cp4, this._w3 = V.width(this._cp3), this._cp4 = V.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
      }
    }
    eat(V) {
      return this._cp1 === V ? (this.advance(), !0) : !1;
    }
    eat2(V, ie) {
      return this._cp1 === V && this._cp2 === ie ? (this.advance(), this.advance(), !0) : !1;
    }
    eat3(V, ie, he) {
      return this._cp1 === V && this._cp2 === ie && this._cp3 === he ? (this.advance(), this.advance(), this.advance(), !0) : !1;
    }
  }
  class Rt extends SyntaxError {
    constructor(V, ie, he, De) {
      let E = "";
      if (V.kind === "literal") {
        const D = V.source.slice(V.start, V.end);
        D && (E = `: ${D}`);
      } else if (V.kind === "pattern") {
        const D = V.source.slice(V.start, V.end), K = `${ie.unicode ? "u" : ""}${ie.unicodeSets ? "v" : ""}`;
        E = `: /${D}/${K}`;
      }
      super(`Invalid regular expression${E}: ${De}`), this.index = he;
    }
  }
  const xt = /* @__PURE__ */ new Set([
    "Basic_Emoji",
    "Emoji_Keycap_Sequence",
    "RGI_Emoji_Modifier_Sequence",
    "RGI_Emoji_Flag_Sequence",
    "RGI_Emoji_Tag_Sequence",
    "RGI_Emoji_ZWJ_Sequence",
    "RGI_Emoji"
  ]);
  function tt(Oe, V) {
    return Oe >= 2024 && xt.has(V);
  }
  const Lt = /* @__PURE__ */ new Set([
    Pe,
    I,
    Be,
    X,
    q,
    F,
    Ee,
    w,
    U,
    ye,
    we,
    We,
    je,
    _e
  ]), Bt = /* @__PURE__ */ new Set([
    k,
    L,
    _,
    I,
    O,
    q,
    F,
    $,
    X,
    H,
    N,
    G,
    M,
    Z,
    Ee,
    ke,
    Pe,
    st,
    $e
  ]), Ut = /* @__PURE__ */ new Set([
    w,
    U,
    ye,
    we,
    We,
    je,
    Q,
    P,
    Be,
    _e
  ]), Kt = /* @__PURE__ */ new Set([
    k,
    P,
    L,
    _,
    O,
    $,
    H,
    N,
    G,
    M,
    Z,
    ke,
    st,
    $e
  ]);
  function Nt(Oe) {
    return Lt.has(Oe);
  }
  function $t(Oe) {
    return Bt.has(Oe);
  }
  function nr(Oe) {
    return Ut.has(Oe);
  }
  function Vt(Oe) {
    return Kt.has(Oe);
  }
  function Pt(Oe) {
    return r(Oe) || Oe === I || Oe === et;
  }
  function Yt(Oe) {
    return u(Oe) || Oe === I || Oe === Ae || Oe === oe;
  }
  function Gt(Oe) {
    return Ge(Oe) || Oe === et;
  }
  function lr(Oe) {
    return Gt(Oe) || Ze(Oe);
  }
  class Zt {
    constructor(V) {
      this._reader = new Tt(), this._unicodeMode = !1, this._unicodeSetsMode = !1, this._nFlag = !1, this._lastIntValue = 0, this._lastRange = {
        min: 0,
        max: Number.POSITIVE_INFINITY
      }, this._lastStrValue = "", this._lastAssertionIsQuantifiable = !1, this._numCapturingParens = 0, this._groupNames = /* @__PURE__ */ new Set(), this._backreferenceNames = /* @__PURE__ */ new Set(), this._srcCtx = null, this._options = V ?? {};
    }
    validateLiteral(V, ie = 0, he = V.length) {
      if (this._srcCtx = { source: V, start: ie, end: he, kind: "literal" }, this._unicodeSetsMode = this._unicodeMode = this._nFlag = !1, this.reset(V, ie, he), this.onLiteralEnter(ie), this.eat(Q) && this.eatRegExpBody() && this.eat(Q)) {
        const De = this.index, E = V.includes("u", De), D = V.includes("v", De);
        this.validateFlagsInternal(V, De, he), this.validatePatternInternal(V, ie + 1, De - 1, {
          unicode: E,
          unicodeSets: D
        });
      } else if (ie >= he)
        this.raise("Empty");
      else {
        const De = String.fromCodePoint(this.currentCodePoint);
        this.raise(`Unexpected character '${De}'`);
      }
      this.onLiteralLeave(ie, he);
    }
    validateFlags(V, ie = 0, he = V.length) {
      this._srcCtx = { source: V, start: ie, end: he, kind: "flags" }, this.validateFlagsInternal(V, ie, he);
    }
    validatePattern(V, ie = 0, he = V.length, De = void 0) {
      this._srcCtx = { source: V, start: ie, end: he, kind: "pattern" }, this.validatePatternInternal(V, ie, he, De);
    }
    validatePatternInternal(V, ie = 0, he = V.length, De = void 0) {
      const E = this._parseFlagsOptionToMode(De, he);
      this._unicodeMode = E.unicodeMode, this._nFlag = E.nFlag, this._unicodeSetsMode = E.unicodeSetsMode, this.reset(V, ie, he), this.consumePattern(), !this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0 && (this._nFlag = !0, this.rewind(ie), this.consumePattern());
    }
    validateFlagsInternal(V, ie, he) {
      const De = /* @__PURE__ */ new Set();
      let E = !1, D = !1, K = !1, J = !1, me = !1, Le = !1, Fe = !1, ze = !1;
      for (let Qe = ie; Qe < he; ++Qe) {
        const pt = V.charCodeAt(Qe);
        De.has(pt) && this.raise(`Duplicated flag '${V[Qe]}'`, { index: ie }), De.add(pt), pt === vt ? E = !0 : pt === W ? D = !0 : pt === Ue ? K = !0 : pt === de && this.ecmaVersion >= 2015 ? me = !0 : pt === z && this.ecmaVersion >= 2015 ? J = !0 : pt === ae && this.ecmaVersion >= 2018 ? Le = !0 : pt === Ct && this.ecmaVersion >= 2022 ? Fe = !0 : pt === ee && this.ecmaVersion >= 2024 ? ze = !0 : this.raise(`Invalid flag '${V[Qe]}'`, { index: ie });
      }
      this.onRegExpFlags(ie, he, {
        global: E,
        ignoreCase: D,
        multiline: K,
        unicode: me,
        sticky: J,
        dotAll: Le,
        hasIndices: Fe,
        unicodeSets: ze
      });
    }
    _parseFlagsOptionToMode(V, ie) {
      let he = !1, De = !1;
      V && this.ecmaVersion >= 2015 && (typeof V == "object" ? (he = !!V.unicode, this.ecmaVersion >= 2024 && (De = !!V.unicodeSets)) : he = V), he && De && this.raise("Invalid regular expression flags", {
        index: ie + 1,
        unicode: he,
        unicodeSets: De
      });
      const E = he || De, D = he && this.ecmaVersion >= 2018 || De || !!(this._options.strict && this.ecmaVersion >= 2023);
      return { unicodeMode: E, nFlag: D, unicodeSetsMode: De };
    }
    get strict() {
      return !!this._options.strict || this._unicodeMode;
    }
    get ecmaVersion() {
      var V;
      return (V = this._options.ecmaVersion) !== null && V !== void 0 ? V : t;
    }
    onLiteralEnter(V) {
      this._options.onLiteralEnter && this._options.onLiteralEnter(V);
    }
    onLiteralLeave(V, ie) {
      this._options.onLiteralLeave && this._options.onLiteralLeave(V, ie);
    }
    onRegExpFlags(V, ie, he) {
      this._options.onRegExpFlags && this._options.onRegExpFlags(V, ie, he), this._options.onFlags && this._options.onFlags(V, ie, he.global, he.ignoreCase, he.multiline, he.unicode, he.sticky, he.dotAll, he.hasIndices);
    }
    onPatternEnter(V) {
      this._options.onPatternEnter && this._options.onPatternEnter(V);
    }
    onPatternLeave(V, ie) {
      this._options.onPatternLeave && this._options.onPatternLeave(V, ie);
    }
    onDisjunctionEnter(V) {
      this._options.onDisjunctionEnter && this._options.onDisjunctionEnter(V);
    }
    onDisjunctionLeave(V, ie) {
      this._options.onDisjunctionLeave && this._options.onDisjunctionLeave(V, ie);
    }
    onAlternativeEnter(V, ie) {
      this._options.onAlternativeEnter && this._options.onAlternativeEnter(V, ie);
    }
    onAlternativeLeave(V, ie, he) {
      this._options.onAlternativeLeave && this._options.onAlternativeLeave(V, ie, he);
    }
    onGroupEnter(V) {
      this._options.onGroupEnter && this._options.onGroupEnter(V);
    }
    onGroupLeave(V, ie) {
      this._options.onGroupLeave && this._options.onGroupLeave(V, ie);
    }
    onCapturingGroupEnter(V, ie) {
      this._options.onCapturingGroupEnter && this._options.onCapturingGroupEnter(V, ie);
    }
    onCapturingGroupLeave(V, ie, he) {
      this._options.onCapturingGroupLeave && this._options.onCapturingGroupLeave(V, ie, he);
    }
    onQuantifier(V, ie, he, De, E) {
      this._options.onQuantifier && this._options.onQuantifier(V, ie, he, De, E);
    }
    onLookaroundAssertionEnter(V, ie, he) {
      this._options.onLookaroundAssertionEnter && this._options.onLookaroundAssertionEnter(V, ie, he);
    }
    onLookaroundAssertionLeave(V, ie, he, De) {
      this._options.onLookaroundAssertionLeave && this._options.onLookaroundAssertionLeave(V, ie, he, De);
    }
    onEdgeAssertion(V, ie, he) {
      this._options.onEdgeAssertion && this._options.onEdgeAssertion(V, ie, he);
    }
    onWordBoundaryAssertion(V, ie, he, De) {
      this._options.onWordBoundaryAssertion && this._options.onWordBoundaryAssertion(V, ie, he, De);
    }
    onAnyCharacterSet(V, ie, he) {
      this._options.onAnyCharacterSet && this._options.onAnyCharacterSet(V, ie, he);
    }
    onEscapeCharacterSet(V, ie, he, De) {
      this._options.onEscapeCharacterSet && this._options.onEscapeCharacterSet(V, ie, he, De);
    }
    onUnicodePropertyCharacterSet(V, ie, he, De, E, D, K) {
      this._options.onUnicodePropertyCharacterSet && this._options.onUnicodePropertyCharacterSet(V, ie, he, De, E, D, K);
    }
    onCharacter(V, ie, he) {
      this._options.onCharacter && this._options.onCharacter(V, ie, he);
    }
    onBackreference(V, ie, he) {
      this._options.onBackreference && this._options.onBackreference(V, ie, he);
    }
    onCharacterClassEnter(V, ie, he) {
      this._options.onCharacterClassEnter && this._options.onCharacterClassEnter(V, ie, he);
    }
    onCharacterClassLeave(V, ie, he) {
      this._options.onCharacterClassLeave && this._options.onCharacterClassLeave(V, ie, he);
    }
    onCharacterClassRange(V, ie, he, De) {
      this._options.onCharacterClassRange && this._options.onCharacterClassRange(V, ie, he, De);
    }
    onClassIntersection(V, ie) {
      this._options.onClassIntersection && this._options.onClassIntersection(V, ie);
    }
    onClassSubtraction(V, ie) {
      this._options.onClassSubtraction && this._options.onClassSubtraction(V, ie);
    }
    onClassStringDisjunctionEnter(V) {
      this._options.onClassStringDisjunctionEnter && this._options.onClassStringDisjunctionEnter(V);
    }
    onClassStringDisjunctionLeave(V, ie) {
      this._options.onClassStringDisjunctionLeave && this._options.onClassStringDisjunctionLeave(V, ie);
    }
    onStringAlternativeEnter(V, ie) {
      this._options.onStringAlternativeEnter && this._options.onStringAlternativeEnter(V, ie);
    }
    onStringAlternativeLeave(V, ie, he) {
      this._options.onStringAlternativeLeave && this._options.onStringAlternativeLeave(V, ie, he);
    }
    get index() {
      return this._reader.index;
    }
    get currentCodePoint() {
      return this._reader.currentCodePoint;
    }
    get nextCodePoint() {
      return this._reader.nextCodePoint;
    }
    get nextCodePoint2() {
      return this._reader.nextCodePoint2;
    }
    get nextCodePoint3() {
      return this._reader.nextCodePoint3;
    }
    reset(V, ie, he) {
      this._reader.reset(V, ie, he, this._unicodeMode);
    }
    rewind(V) {
      this._reader.rewind(V);
    }
    advance() {
      this._reader.advance();
    }
    eat(V) {
      return this._reader.eat(V);
    }
    eat2(V, ie) {
      return this._reader.eat2(V, ie);
    }
    eat3(V, ie, he) {
      return this._reader.eat3(V, ie, he);
    }
    raise(V, ie) {
      var he, De, E;
      throw new Rt(this._srcCtx, {
        unicode: (he = ie == null ? void 0 : ie.unicode) !== null && he !== void 0 ? he : this._unicodeMode && !this._unicodeSetsMode,
        unicodeSets: (De = ie == null ? void 0 : ie.unicodeSets) !== null && De !== void 0 ? De : this._unicodeSetsMode
      }, (E = ie == null ? void 0 : ie.index) !== null && E !== void 0 ? E : this.index, V);
    }
    eatRegExpBody() {
      const V = this.index;
      let ie = !1, he = !1;
      for (; ; ) {
        const De = this.currentCodePoint;
        if (De === -1 || At(De)) {
          const E = ie ? "character class" : "regular expression";
          this.raise(`Unterminated ${E}`);
        }
        if (he)
          he = !1;
        else if (De === Be)
          he = !0;
        else if (De === ye)
          ie = !0;
        else if (De === we)
          ie = !1;
        else if (De === Q && !ie || De === q && this.index === V)
          break;
        this.advance();
      }
      return this.index !== V;
    }
    consumePattern() {
      const V = this.index;
      this._numCapturingParens = this.countCapturingParens(), this._groupNames.clear(), this._backreferenceNames.clear(), this.onPatternEnter(V), this.consumeDisjunction();
      const ie = this.currentCodePoint;
      if (this.currentCodePoint !== -1) {
        ie === U && this.raise("Unmatched ')'"), ie === Be && this.raise("\\ at end of pattern"), (ie === we || ie === je) && this.raise("Lone quantifier brackets");
        const he = String.fromCodePoint(ie);
        this.raise(`Unexpected character '${he}'`);
      }
      for (const he of this._backreferenceNames)
        this._groupNames.has(he) || this.raise("Invalid named capture referenced");
      this.onPatternLeave(V, this.index);
    }
    countCapturingParens() {
      const V = this.index;
      let ie = !1, he = !1, De = 0, E = 0;
      for (; (E = this.currentCodePoint) !== -1; )
        he ? he = !1 : E === Be ? he = !0 : E === ye ? ie = !0 : E === we ? ie = !1 : E === w && !ie && (this.nextCodePoint !== Ee || this.nextCodePoint2 === G && this.nextCodePoint3 !== M && this.nextCodePoint3 !== L) && (De += 1), this.advance();
      return this.rewind(V), De;
    }
    consumeDisjunction() {
      const V = this.index;
      let ie = 0;
      this.onDisjunctionEnter(V);
      do
        this.consumeAlternative(ie++);
      while (this.eat(_e));
      this.consumeQuantifier(!0) && this.raise("Nothing to repeat"), this.eat(We) && this.raise("Lone quantifier brackets"), this.onDisjunctionLeave(V, this.index);
    }
    consumeAlternative(V) {
      const ie = this.index;
      for (this.onAlternativeEnter(ie, V); this.currentCodePoint !== -1 && this.consumeTerm(); )
        ;
      this.onAlternativeLeave(ie, this.index, V);
    }
    consumeTerm() {
      return this._unicodeMode || this.strict ? this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier() : this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
    }
    consumeOptionalQuantifier() {
      return this.consumeQuantifier(), !0;
    }
    consumeAssertion() {
      const V = this.index;
      if (this._lastAssertionIsQuantifiable = !1, this.eat(Pe))
        return this.onEdgeAssertion(V, this.index, "start"), !0;
      if (this.eat(I))
        return this.onEdgeAssertion(V, this.index, "end"), !0;
      if (this.eat2(Be, Je))
        return this.onWordBoundaryAssertion(V, this.index, "word", !0), !0;
      if (this.eat2(Be, rt))
        return this.onWordBoundaryAssertion(V, this.index, "word", !1), !0;
      if (this.eat2(w, Ee)) {
        const ie = this.ecmaVersion >= 2018 && this.eat(G);
        let he = !1;
        if (this.eat(M) || (he = this.eat(L))) {
          const De = ie ? "lookbehind" : "lookahead";
          return this.onLookaroundAssertionEnter(V, De, he), this.consumeDisjunction(), this.eat(U) || this.raise("Unterminated group"), this._lastAssertionIsQuantifiable = !ie && !this.strict, this.onLookaroundAssertionLeave(V, this.index, De, he), !0;
        }
        this.rewind(V);
      }
      return !1;
    }
    consumeQuantifier(V = !1) {
      const ie = this.index;
      let he = 0, De = 0, E = !1;
      if (this.eat(q))
        he = 0, De = Number.POSITIVE_INFINITY;
      else if (this.eat(F))
        he = 1, De = Number.POSITIVE_INFINITY;
      else if (this.eat(Ee))
        he = 0, De = 1;
      else if (this.eatBracedQuantifier(V))
        ({ min: he, max: De } = this._lastRange);
      else
        return !1;
      return E = !this.eat(Ee), V || this.onQuantifier(ie, this.index, he, De, E), !0;
    }
    eatBracedQuantifier(V) {
      const ie = this.index;
      if (this.eat(We)) {
        if (this.eatDecimalDigits()) {
          const he = this._lastIntValue;
          let De = he;
          if (this.eat($) && (De = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY), this.eat(je))
            return !V && De < he && this.raise("numbers out of order in {} quantifier"), this._lastRange = { min: he, max: De }, !0;
        }
        !V && (this._unicodeMode || this.strict) && this.raise("Incomplete quantifier"), this.rewind(ie);
      }
      return !1;
    }
    consumeAtom() {
      return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || !!this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
    }
    consumeDot() {
      return this.eat(X) ? (this.onAnyCharacterSet(this.index - 1, this.index, "any"), !0) : !1;
    }
    consumeReverseSolidusAtomEscape() {
      const V = this.index;
      if (this.eat(Be)) {
        if (this.consumeAtomEscape())
          return !0;
        this.rewind(V);
      }
      return !1;
    }
    consumeUncapturingGroup() {
      const V = this.index;
      return this.eat3(w, Ee, H) ? (this.onGroupEnter(V), this.consumeDisjunction(), this.eat(U) || this.raise("Unterminated group"), this.onGroupLeave(V, this.index), !0) : !1;
    }
    consumeCapturingGroup() {
      const V = this.index;
      if (this.eat(w)) {
        let ie = null;
        return this.ecmaVersion >= 2018 ? this.consumeGroupSpecifier() && (ie = this._lastStrValue) : this.currentCodePoint === Ee && this.raise("Invalid group"), this.onCapturingGroupEnter(V, ie), this.consumeDisjunction(), this.eat(U) || this.raise("Unterminated group"), this.onCapturingGroupLeave(V, this.index, ie), !0;
      }
      return !1;
    }
    consumeExtendedAtom() {
      return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || !!this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
    }
    consumeReverseSolidusFollowedByC() {
      const V = this.index;
      return this.currentCodePoint === Be && this.nextCodePoint === ot ? (this._lastIntValue = this.currentCodePoint, this.advance(), this.onCharacter(V, this.index, Be), !0) : !1;
    }
    consumeInvalidBracedQuantifier() {
      return this.eatBracedQuantifier(!0) && this.raise("Nothing to repeat"), !1;
    }
    consumePatternCharacter() {
      const V = this.index, ie = this.currentCodePoint;
      return ie !== -1 && !Nt(ie) ? (this.advance(), this.onCharacter(V, this.index, ie), !0) : !1;
    }
    consumeExtendedPatternCharacter() {
      const V = this.index, ie = this.currentCodePoint;
      return ie !== -1 && ie !== Pe && ie !== I && ie !== Be && ie !== X && ie !== q && ie !== F && ie !== Ee && ie !== w && ie !== U && ie !== ye && ie !== _e ? (this.advance(), this.onCharacter(V, this.index, ie), !0) : !1;
    }
    consumeGroupSpecifier() {
      if (this.eat(Ee)) {
        if (this.eatGroupName()) {
          if (!this._groupNames.has(this._lastStrValue))
            return this._groupNames.add(this._lastStrValue), !0;
          this.raise("Duplicate capture group name");
        }
        this.raise("Invalid group");
      }
      return !1;
    }
    consumeAtomEscape() {
      return this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName() ? !0 : ((this.strict || this._unicodeMode) && this.raise("Invalid escape"), !1);
    }
    consumeBackreference() {
      const V = this.index;
      if (this.eatDecimalEscape()) {
        const ie = this._lastIntValue;
        if (ie <= this._numCapturingParens)
          return this.onBackreference(V - 1, this.index, ie), !0;
        (this.strict || this._unicodeMode) && this.raise("Invalid escape"), this.rewind(V);
      }
      return !1;
    }
    consumeCharacterClassEscape() {
      var V;
      const ie = this.index;
      if (this.eat(Ct))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "digit", !1), {};
      if (this.eat(at))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "digit", !0), {};
      if (this.eat(ae))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "space", !1), {};
      if (this.eat(Y))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "space", !0), {};
      if (this.eat(te))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "word", !1), {};
      if (this.eat(Te))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(ie - 1, this.index, "word", !0), {};
      let he = !1;
      if (this._unicodeMode && this.ecmaVersion >= 2018 && (this.eat(xe) || (he = this.eat(mt)))) {
        this._lastIntValue = -1;
        let De = null;
        if (this.eat(We) && (De = this.eatUnicodePropertyValueExpression()) && this.eat(je))
          return he && De.strings && this.raise("Invalid property name"), this.onUnicodePropertyCharacterSet(ie - 1, this.index, "property", De.key, De.value, he, (V = De.strings) !== null && V !== void 0 ? V : !1), { mayContainStrings: De.strings };
        this.raise("Invalid property name");
      }
      return null;
    }
    consumeCharacterEscape() {
      const V = this.index;
      return this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._unicodeMode && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape() ? (this.onCharacter(V - 1, this.index, this._lastIntValue), !0) : !1;
    }
    consumeKGroupName() {
      const V = this.index;
      if (this.eat(Ye)) {
        if (this.eatGroupName()) {
          const ie = this._lastStrValue;
          return this._backreferenceNames.add(ie), this.onBackreference(V - 1, this.index, ie), !0;
        }
        this.raise("Invalid named reference");
      }
      return !1;
    }
    consumeCharacterClass() {
      const V = this.index;
      if (this.eat(ye)) {
        const ie = this.eat(Pe);
        this.onCharacterClassEnter(V, ie, this._unicodeSetsMode);
        const he = this.consumeClassContents();
        return this.eat(we) || (this.currentCodePoint === -1 && this.raise("Unterminated character class"), this.raise("Invalid character in character class")), ie && he.mayContainStrings && this.raise("Negated character class may contain strings"), this.onCharacterClassLeave(V, this.index, ie), he;
      }
      return null;
    }
    consumeClassContents() {
      if (this._unicodeSetsMode)
        return this.currentCodePoint === we ? {} : this.consumeClassSetExpression();
      const V = this.strict || this._unicodeMode;
      for (; ; ) {
        const ie = this.index;
        if (!this.consumeClassAtom())
          break;
        const he = this._lastIntValue;
        if (!this.eat(P))
          continue;
        if (this.onCharacter(this.index - 1, this.index, P), !this.consumeClassAtom())
          break;
        const De = this._lastIntValue;
        if (he === -1 || De === -1) {
          V && this.raise("Invalid character class");
          continue;
        }
        he > De && this.raise("Range out of order in character class"), this.onCharacterClassRange(ie, this.index, he, De);
      }
      return {};
    }
    consumeClassAtom() {
      const V = this.index, ie = this.currentCodePoint;
      if (ie !== -1 && ie !== Be && ie !== we)
        return this.advance(), this._lastIntValue = ie, this.onCharacter(V, this.index, this._lastIntValue), !0;
      if (this.eat(Be)) {
        if (this.consumeClassEscape())
          return !0;
        if (!this.strict && this.currentCodePoint === ot)
          return this._lastIntValue = Be, this.onCharacter(V, this.index, this._lastIntValue), !0;
        (this.strict || this._unicodeMode) && this.raise("Invalid escape"), this.rewind(V);
      }
      return !1;
    }
    consumeClassEscape() {
      const V = this.index;
      if (this.eat(rt))
        return this._lastIntValue = b, this.onCharacter(V - 1, this.index, this._lastIntValue), !0;
      if (this._unicodeMode && this.eat(P))
        return this._lastIntValue = P, this.onCharacter(V - 1, this.index, this._lastIntValue), !0;
      let ie = 0;
      return !this.strict && !this._unicodeMode && this.currentCodePoint === ot && (Ze(ie = this.nextCodePoint) || ie === et) ? (this.advance(), this.advance(), this._lastIntValue = ie % 32, this.onCharacter(V - 1, this.index, this._lastIntValue), !0) : !!this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
    }
    consumeClassSetExpression() {
      const V = this.index;
      let ie = !1, he = null;
      if (this.consumeClassSetCharacter()) {
        if (this.consumeClassSetRangeFromOperator(V))
          return this.consumeClassUnionRight({}), {};
        ie = !1;
      } else if (he = this.consumeClassSetOperand())
        ie = he.mayContainStrings;
      else {
        const De = this.currentCodePoint;
        De === Be && (this.advance(), this.raise("Invalid escape")), De === this.nextCodePoint && $t(De) && this.raise("Invalid set operation in character class"), this.raise("Invalid character in character class");
      }
      if (this.eat2(k, k)) {
        for (; this.currentCodePoint !== k && (he = this.consumeClassSetOperand()); )
          if (this.onClassIntersection(V, this.index), he.mayContainStrings || (ie = !1), !this.eat2(k, k))
            return { mayContainStrings: ie };
        this.raise("Invalid character in character class");
      }
      if (this.eat2(P, P)) {
        for (; this.consumeClassSetOperand(); )
          if (this.onClassSubtraction(V, this.index), !this.eat2(P, P))
            return { mayContainStrings: ie };
        this.raise("Invalid character in character class");
      }
      return this.consumeClassUnionRight({ mayContainStrings: ie });
    }
    consumeClassUnionRight(V) {
      let ie = V.mayContainStrings;
      for (; ; ) {
        const he = this.index;
        if (this.consumeClassSetCharacter()) {
          this.consumeClassSetRangeFromOperator(he);
          continue;
        }
        const De = this.consumeClassSetOperand();
        if (De) {
          De.mayContainStrings && (ie = !0);
          continue;
        }
        break;
      }
      return { mayContainStrings: ie };
    }
    consumeClassSetRangeFromOperator(V) {
      const ie = this.index, he = this._lastIntValue;
      if (this.eat(P)) {
        if (this.consumeClassSetCharacter()) {
          const De = this._lastIntValue;
          return (he === -1 || De === -1) && this.raise("Invalid character class"), he > De && this.raise("Range out of order in character class"), this.onCharacterClassRange(V, this.index, he, De), !0;
        }
        this.rewind(ie);
      }
      return !1;
    }
    consumeClassSetOperand() {
      let V = null;
      return (V = this.consumeNestedClass()) || (V = this.consumeClassStringDisjunction()) ? V : this.consumeClassSetCharacter() ? {} : null;
    }
    consumeNestedClass() {
      const V = this.index;
      if (this.eat(ye)) {
        const ie = this.eat(Pe);
        this.onCharacterClassEnter(V, ie, !0);
        const he = this.consumeClassContents();
        return this.eat(we) || this.raise("Unterminated character class"), ie && he.mayContainStrings && this.raise("Negated character class may contain strings"), this.onCharacterClassLeave(V, this.index, ie), he;
      }
      if (this.eat(Be)) {
        const ie = this.consumeCharacterClassEscape();
        if (ie)
          return ie;
        this.rewind(V);
      }
      return null;
    }
    consumeClassStringDisjunction() {
      const V = this.index;
      if (this.eat3(Be, re, We)) {
        this.onClassStringDisjunctionEnter(V);
        let ie = 0, he = !1;
        do
          this.consumeClassString(ie++).mayContainStrings && (he = !0);
        while (this.eat(_e));
        if (this.eat(je))
          return this.onClassStringDisjunctionLeave(V, this.index), { mayContainStrings: he };
        this.raise("Unterminated class string disjunction");
      }
      return null;
    }
    consumeClassString(V) {
      const ie = this.index;
      let he = 0;
      for (this.onStringAlternativeEnter(ie, V); this.currentCodePoint !== -1 && this.consumeClassSetCharacter(); )
        he++;
      return this.onStringAlternativeLeave(ie, this.index, V), { mayContainStrings: he !== 1 };
    }
    consumeClassSetCharacter() {
      const V = this.index, ie = this.currentCodePoint;
      if ((ie !== this.nextCodePoint || !$t(ie)) && ie !== -1 && !nr(ie))
        return this._lastIntValue = ie, this.advance(), this.onCharacter(V, this.index, this._lastIntValue), !0;
      if (this.eat(Be)) {
        if (this.consumeCharacterEscape())
          return !0;
        if (Vt(this.currentCodePoint))
          return this._lastIntValue = this.currentCodePoint, this.advance(), this.onCharacter(V, this.index, this._lastIntValue), !0;
        if (this.eat(rt))
          return this._lastIntValue = b, this.onCharacter(V, this.index, this._lastIntValue), !0;
        this.rewind(V);
      }
      return !1;
    }
    eatGroupName() {
      if (this.eat(G)) {
        if (this.eatRegExpIdentifierName() && this.eat(Z))
          return !0;
        this.raise("Invalid capture group name");
      }
      return !1;
    }
    eatRegExpIdentifierName() {
      if (this.eatRegExpIdentifierStart()) {
        for (this._lastStrValue = String.fromCodePoint(this._lastIntValue); this.eatRegExpIdentifierPart(); )
          this._lastStrValue += String.fromCodePoint(this._lastIntValue);
        return !0;
      }
      return !1;
    }
    eatRegExpIdentifierStart() {
      const V = this.index, ie = !this._unicodeMode && this.ecmaVersion >= 2020;
      let he = this.currentCodePoint;
      return this.advance(), he === Be && this.eatRegExpUnicodeEscapeSequence(ie) ? he = this._lastIntValue : ie && He(he) && Xe(this.currentCodePoint) && (he = Me(he, this.currentCodePoint), this.advance()), Pt(he) ? (this._lastIntValue = he, !0) : (this.index !== V && this.rewind(V), !1);
    }
    eatRegExpIdentifierPart() {
      const V = this.index, ie = !this._unicodeMode && this.ecmaVersion >= 2020;
      let he = this.currentCodePoint;
      return this.advance(), he === Be && this.eatRegExpUnicodeEscapeSequence(ie) ? he = this._lastIntValue : ie && He(he) && Xe(this.currentCodePoint) && (he = Me(he, this.currentCodePoint), this.advance()), Yt(he) ? (this._lastIntValue = he, !0) : (this.index !== V && this.rewind(V), !1);
    }
    eatCControlLetter() {
      const V = this.index;
      if (this.eat(ot)) {
        if (this.eatControlLetter())
          return !0;
        this.rewind(V);
      }
      return !1;
    }
    eatZero() {
      return this.currentCodePoint === ue && !Ze(this.nextCodePoint) ? (this._lastIntValue = 0, this.advance(), !0) : !1;
    }
    eatControlEscape() {
      return this.eat(dt) ? (this._lastIntValue = A, !0) : this.eat(Ve) ? (this._lastIntValue = C, !0) : this.eat(ne) ? (this._lastIntValue = R, !0) : this.eat(fe) ? (this._lastIntValue = S, !0) : this.eat(ee) ? (this._lastIntValue = x, !0) : !1;
    }
    eatControlLetter() {
      const V = this.currentCodePoint;
      return Ge(V) ? (this.advance(), this._lastIntValue = V % 32, !0) : !1;
    }
    eatRegExpUnicodeEscapeSequence(V = !1) {
      const ie = this.index, he = V || this._unicodeMode;
      if (this.eat(de)) {
        if (he && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || he && this.eatRegExpUnicodeCodePointEscape())
          return !0;
        (this.strict || he) && this.raise("Invalid unicode escape"), this.rewind(ie);
      }
      return !1;
    }
    eatRegExpUnicodeSurrogatePairEscape() {
      const V = this.index;
      if (this.eatFixedHexDigits(4)) {
        const ie = this._lastIntValue;
        if (He(ie) && this.eat(Be) && this.eat(de) && this.eatFixedHexDigits(4)) {
          const he = this._lastIntValue;
          if (Xe(he))
            return this._lastIntValue = Me(ie, he), !0;
        }
        this.rewind(V);
      }
      return !1;
    }
    eatRegExpUnicodeCodePointEscape() {
      const V = this.index;
      return this.eat(We) && this.eatHexDigits() && this.eat(je) && ht(this._lastIntValue) ? !0 : (this.rewind(V), !1);
    }
    eatIdentityEscape() {
      const V = this.currentCodePoint;
      return this.isValidIdentityEscape(V) ? (this._lastIntValue = V, this.advance(), !0) : !1;
    }
    isValidIdentityEscape(V) {
      return V === -1 ? !1 : this._unicodeMode ? Nt(V) || V === Q : this.strict ? !u(V) : this._nFlag ? !(V === ot || V === Ye) : V !== ot;
    }
    eatDecimalEscape() {
      this._lastIntValue = 0;
      let V = this.currentCodePoint;
      if (V >= le && V <= j) {
        do
          this._lastIntValue = 10 * this._lastIntValue + (V - ue), this.advance();
        while ((V = this.currentCodePoint) >= ue && V <= j);
        return !0;
      }
      return !1;
    }
    eatUnicodePropertyValueExpression() {
      const V = this.index;
      if (this.eatUnicodePropertyName() && this.eat(M)) {
        const ie = this._lastStrValue;
        if (this.eatUnicodePropertyValue()) {
          const he = this._lastStrValue;
          if (v(this.ecmaVersion, ie, he))
            return {
              key: ie,
              value: he || null
            };
          this.raise("Invalid property name");
        }
      }
      if (this.rewind(V), this.eatLoneUnicodePropertyNameOrValue()) {
        const ie = this._lastStrValue;
        if (v(this.ecmaVersion, "General_Category", ie))
          return {
            key: "General_Category",
            value: ie || null
          };
        if (T(this.ecmaVersion, ie))
          return {
            key: ie,
            value: null
          };
        if (this._unicodeSetsMode && tt(this.ecmaVersion, ie))
          return {
            key: ie,
            value: null,
            strings: !0
          };
        this.raise("Invalid property name");
      }
      return null;
    }
    eatUnicodePropertyName() {
      for (this._lastStrValue = ""; Gt(this.currentCodePoint); )
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
      return this._lastStrValue !== "";
    }
    eatUnicodePropertyValue() {
      for (this._lastStrValue = ""; lr(this.currentCodePoint); )
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
      return this._lastStrValue !== "";
    }
    eatLoneUnicodePropertyNameOrValue() {
      return this.eatUnicodePropertyValue();
    }
    eatHexEscapeSequence() {
      const V = this.index;
      if (this.eat(B)) {
        if (this.eatFixedHexDigits(2))
          return !0;
        (this._unicodeMode || this.strict) && this.raise("Invalid escape"), this.rewind(V);
      }
      return !1;
    }
    eatDecimalDigits() {
      const V = this.index;
      for (this._lastIntValue = 0; Ze(this.currentCodePoint); )
        this._lastIntValue = 10 * this._lastIntValue + qe(this.currentCodePoint), this.advance();
      return this.index !== V;
    }
    eatHexDigits() {
      const V = this.index;
      for (this._lastIntValue = 0; gt(this.currentCodePoint); )
        this._lastIntValue = 16 * this._lastIntValue + qe(this.currentCodePoint), this.advance();
      return this.index !== V;
    }
    eatLegacyOctalEscapeSequence() {
      if (this.eatOctalDigit()) {
        const V = this._lastIntValue;
        if (this.eatOctalDigit()) {
          const ie = this._lastIntValue;
          V <= 3 && this.eatOctalDigit() ? this._lastIntValue = V * 64 + ie * 8 + this._lastIntValue : this._lastIntValue = V * 8 + ie;
        } else
          this._lastIntValue = V;
        return !0;
      }
      return !1;
    }
    eatOctalDigit() {
      const V = this.currentCodePoint;
      return ft(V) ? (this.advance(), this._lastIntValue = V - ue, !0) : (this._lastIntValue = 0, !1);
    }
    eatFixedHexDigits(V) {
      const ie = this.index;
      this._lastIntValue = 0;
      for (let he = 0; he < V; ++he) {
        const De = this.currentCodePoint;
        if (!gt(De))
          return this.rewind(ie), !1;
        this._lastIntValue = 16 * this._lastIntValue + qe(De), this.advance();
      }
      return !0;
    }
  }
  const zt = {}, ur = {}, er = {};
  function sr(Oe) {
    return Oe.type === "Character" || Oe.type === "CharacterSet" || Oe.type === "CharacterClass" || Oe.type === "ExpressionCharacterClass" || Oe.type === "ClassStringDisjunction";
  }
  class Ar {
    constructor(V) {
      var ie;
      this._node = zt, this._expressionBuffer = null, this._flags = ur, this._backreferences = [], this._capturingGroups = [], this.source = "", this.strict = !!(V != null && V.strict), this.ecmaVersion = (ie = V == null ? void 0 : V.ecmaVersion) !== null && ie !== void 0 ? ie : t;
    }
    get pattern() {
      if (this._node.type !== "Pattern")
        throw new Error("UnknownError");
      return this._node;
    }
    get flags() {
      if (this._flags.type !== "Flags")
        throw new Error("UnknownError");
      return this._flags;
    }
    onRegExpFlags(V, ie, { global: he, ignoreCase: De, multiline: E, unicode: D, sticky: K, dotAll: J, hasIndices: me, unicodeSets: Le }) {
      this._flags = {
        type: "Flags",
        parent: null,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        global: he,
        ignoreCase: De,
        multiline: E,
        unicode: D,
        sticky: K,
        dotAll: J,
        hasIndices: me,
        unicodeSets: Le
      };
    }
    onPatternEnter(V) {
      this._node = {
        type: "Pattern",
        parent: null,
        start: V,
        end: V,
        raw: "",
        alternatives: []
      }, this._backreferences.length = 0, this._capturingGroups.length = 0;
    }
    onPatternLeave(V, ie) {
      this._node.end = ie, this._node.raw = this.source.slice(V, ie);
      for (const he of this._backreferences) {
        const De = he.ref, E = typeof De == "number" ? this._capturingGroups[De - 1] : this._capturingGroups.find((D) => D.name === De);
        he.resolved = E, E.references.push(he);
      }
    }
    onAlternativeEnter(V) {
      const ie = this._node;
      if (ie.type !== "Assertion" && ie.type !== "CapturingGroup" && ie.type !== "Group" && ie.type !== "Pattern")
        throw new Error("UnknownError");
      this._node = {
        type: "Alternative",
        parent: ie,
        start: V,
        end: V,
        raw: "",
        elements: []
      }, ie.alternatives.push(this._node);
    }
    onAlternativeLeave(V, ie) {
      const he = this._node;
      if (he.type !== "Alternative")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
    onGroupEnter(V) {
      const ie = this._node;
      if (ie.type !== "Alternative")
        throw new Error("UnknownError");
      this._node = {
        type: "Group",
        parent: ie,
        start: V,
        end: V,
        raw: "",
        alternatives: []
      }, ie.elements.push(this._node);
    }
    onGroupLeave(V, ie) {
      const he = this._node;
      if (he.type !== "Group" || he.parent.type !== "Alternative")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
    onCapturingGroupEnter(V, ie) {
      const he = this._node;
      if (he.type !== "Alternative")
        throw new Error("UnknownError");
      this._node = {
        type: "CapturingGroup",
        parent: he,
        start: V,
        end: V,
        raw: "",
        name: ie,
        alternatives: [],
        references: []
      }, he.elements.push(this._node), this._capturingGroups.push(this._node);
    }
    onCapturingGroupLeave(V, ie) {
      const he = this._node;
      if (he.type !== "CapturingGroup" || he.parent.type !== "Alternative")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
    onQuantifier(V, ie, he, De, E) {
      const D = this._node;
      if (D.type !== "Alternative")
        throw new Error("UnknownError");
      const K = D.elements.pop();
      if (K == null || K.type === "Quantifier" || K.type === "Assertion" && K.kind !== "lookahead")
        throw new Error("UnknownError");
      const J = {
        type: "Quantifier",
        parent: D,
        start: K.start,
        end: ie,
        raw: this.source.slice(K.start, ie),
        min: he,
        max: De,
        greedy: E,
        element: K
      };
      D.elements.push(J), K.parent = J;
    }
    onLookaroundAssertionEnter(V, ie, he) {
      const De = this._node;
      if (De.type !== "Alternative")
        throw new Error("UnknownError");
      const E = this._node = {
        type: "Assertion",
        parent: De,
        start: V,
        end: V,
        raw: "",
        kind: ie,
        negate: he,
        alternatives: []
      };
      De.elements.push(E);
    }
    onLookaroundAssertionLeave(V, ie) {
      const he = this._node;
      if (he.type !== "Assertion" || he.parent.type !== "Alternative")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
    onEdgeAssertion(V, ie, he) {
      const De = this._node;
      if (De.type !== "Alternative")
        throw new Error("UnknownError");
      De.elements.push({
        type: "Assertion",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        kind: he
      });
    }
    onWordBoundaryAssertion(V, ie, he, De) {
      const E = this._node;
      if (E.type !== "Alternative")
        throw new Error("UnknownError");
      E.elements.push({
        type: "Assertion",
        parent: E,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        kind: he,
        negate: De
      });
    }
    onAnyCharacterSet(V, ie, he) {
      const De = this._node;
      if (De.type !== "Alternative")
        throw new Error("UnknownError");
      De.elements.push({
        type: "CharacterSet",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        kind: he
      });
    }
    onEscapeCharacterSet(V, ie, he, De) {
      const E = this._node;
      if (E.type !== "Alternative" && E.type !== "CharacterClass")
        throw new Error("UnknownError");
      E.elements.push({
        type: "CharacterSet",
        parent: E,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        kind: he,
        negate: De
      });
    }
    onUnicodePropertyCharacterSet(V, ie, he, De, E, D, K) {
      const J = this._node;
      if (J.type !== "Alternative" && J.type !== "CharacterClass" || K && (D || E))
        throw new Error("UnknownError");
      const me = {
        type: "CharacterSet",
        parent: J,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        kind: he,
        strings: K,
        key: De
      }, Le = K ? Object.assign(Object.assign({}, me), { value: null, negate: !1, strings: !0 }) : Object.assign(Object.assign({}, me), {
        value: E,
        negate: D,
        strings: !1
      });
      J.elements.push(Le);
    }
    onCharacter(V, ie, he) {
      const De = this._node;
      if (De.type !== "Alternative" && De.type !== "CharacterClass" && De.type !== "StringAlternative")
        throw new Error("UnknownError");
      De.elements.push({
        type: "Character",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        value: he
      });
    }
    onBackreference(V, ie, he) {
      const De = this._node;
      if (De.type !== "Alternative")
        throw new Error("UnknownError");
      const E = {
        type: "Backreference",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        ref: he,
        resolved: er
      };
      De.elements.push(E), this._backreferences.push(E);
    }
    onCharacterClassEnter(V, ie, he) {
      const De = this._node, E = {
        type: "CharacterClass",
        parent: De,
        start: V,
        end: V,
        raw: "",
        unicodeSets: he,
        negate: ie,
        elements: []
      };
      if (De.type === "Alternative") {
        const D = Object.assign(Object.assign({}, E), { parent: De });
        this._node = D, De.elements.push(D);
      } else if (De.type === "CharacterClass" && De.unicodeSets && he) {
        const D = Object.assign(Object.assign({}, E), {
          parent: De,
          unicodeSets: he
        });
        this._node = D, De.elements.push(D);
      } else
        throw new Error("UnknownError");
    }
    onCharacterClassLeave(V, ie) {
      const he = this._node;
      if (he.type !== "CharacterClass" || he.parent.type !== "Alternative" && he.parent.type !== "CharacterClass" || this._expressionBuffer && he.elements.length > 0)
        throw new Error("UnknownError");
      const De = he.parent;
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = De;
      const E = this._expressionBuffer;
      if (this._expressionBuffer = null, !E)
        return;
      const D = {
        type: "ExpressionCharacterClass",
        parent: De,
        start: he.start,
        end: he.end,
        raw: he.raw,
        negate: he.negate,
        expression: E
      };
      if (E.parent = D, he !== De.elements.pop())
        throw new Error("UnknownError");
      De.elements.push(D);
    }
    onCharacterClassRange(V, ie) {
      const he = this._node;
      if (he.type !== "CharacterClass")
        throw new Error("UnknownError");
      const De = he.elements, E = De.pop();
      if (!E || E.type !== "Character")
        throw new Error("UnknownError");
      if (!he.unicodeSets) {
        const J = De.pop();
        if (!J || J.type !== "Character" || J.value !== P)
          throw new Error("UnknownError");
      }
      const D = De.pop();
      if (!D || D.type !== "Character")
        throw new Error("UnknownError");
      const K = {
        type: "CharacterClassRange",
        parent: he,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        min: D,
        max: E
      };
      D.parent = K, E.parent = K, De.push(K);
    }
    onClassIntersection(V, ie) {
      var he;
      const De = this._node;
      if (De.type !== "CharacterClass" || !De.unicodeSets)
        throw new Error("UnknownError");
      const E = De.elements.pop(), D = (he = this._expressionBuffer) !== null && he !== void 0 ? he : De.elements.pop();
      if (!D || !E || D.type === "ClassSubtraction" || D.type !== "ClassIntersection" && !sr(D) || !sr(E))
        throw new Error("UnknownError");
      const K = {
        type: "ClassIntersection",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        left: D,
        right: E
      };
      D.parent = K, E.parent = K, this._expressionBuffer = K;
    }
    onClassSubtraction(V, ie) {
      var he;
      const De = this._node;
      if (De.type !== "CharacterClass" || !De.unicodeSets)
        throw new Error("UnknownError");
      const E = De.elements.pop(), D = (he = this._expressionBuffer) !== null && he !== void 0 ? he : De.elements.pop();
      if (!D || !E || D.type === "ClassIntersection" || D.type !== "ClassSubtraction" && !sr(D) || !sr(E))
        throw new Error("UnknownError");
      const K = {
        type: "ClassSubtraction",
        parent: De,
        start: V,
        end: ie,
        raw: this.source.slice(V, ie),
        left: D,
        right: E
      };
      D.parent = K, E.parent = K, this._expressionBuffer = K;
    }
    onClassStringDisjunctionEnter(V) {
      const ie = this._node;
      if (ie.type !== "CharacterClass" || !ie.unicodeSets)
        throw new Error("UnknownError");
      this._node = {
        type: "ClassStringDisjunction",
        parent: ie,
        start: V,
        end: V,
        raw: "",
        alternatives: []
      }, ie.elements.push(this._node);
    }
    onClassStringDisjunctionLeave(V, ie) {
      const he = this._node;
      if (he.type !== "ClassStringDisjunction" || he.parent.type !== "CharacterClass")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
    onStringAlternativeEnter(V) {
      const ie = this._node;
      if (ie.type !== "ClassStringDisjunction")
        throw new Error("UnknownError");
      this._node = {
        type: "StringAlternative",
        parent: ie,
        start: V,
        end: V,
        raw: "",
        elements: []
      }, ie.alternatives.push(this._node);
    }
    onStringAlternativeLeave(V, ie) {
      const he = this._node;
      if (he.type !== "StringAlternative")
        throw new Error("UnknownError");
      he.end = ie, he.raw = this.source.slice(V, ie), this._node = he.parent;
    }
  }
  class cr {
    constructor(V) {
      this._state = new Ar(V), this._validator = new Zt(this._state);
    }
    parseLiteral(V, ie = 0, he = V.length) {
      this._state.source = V, this._validator.validateLiteral(V, ie, he);
      const De = this._state.pattern, E = this._state.flags, D = {
        type: "RegExpLiteral",
        parent: null,
        start: ie,
        end: he,
        raw: V,
        pattern: De,
        flags: E
      };
      return De.parent = D, E.parent = D, D;
    }
    parseFlags(V, ie = 0, he = V.length) {
      return this._state.source = V, this._validator.validateFlags(V, ie, he), this._state.flags;
    }
    parsePattern(V, ie = 0, he = V.length, De = void 0) {
      return this._state.source = V, this._validator.validatePattern(V, ie, he, De), this._state.pattern;
    }
  }
  class fr {
    constructor(V) {
      this._handlers = V;
    }
    visit(V) {
      switch (V.type) {
        case "Alternative":
          this.visitAlternative(V);
          break;
        case "Assertion":
          this.visitAssertion(V);
          break;
        case "Backreference":
          this.visitBackreference(V);
          break;
        case "CapturingGroup":
          this.visitCapturingGroup(V);
          break;
        case "Character":
          this.visitCharacter(V);
          break;
        case "CharacterClass":
          this.visitCharacterClass(V);
          break;
        case "CharacterClassRange":
          this.visitCharacterClassRange(V);
          break;
        case "CharacterSet":
          this.visitCharacterSet(V);
          break;
        case "ClassIntersection":
          this.visitClassIntersection(V);
          break;
        case "ClassStringDisjunction":
          this.visitClassStringDisjunction(V);
          break;
        case "ClassSubtraction":
          this.visitClassSubtraction(V);
          break;
        case "ExpressionCharacterClass":
          this.visitExpressionCharacterClass(V);
          break;
        case "Flags":
          this.visitFlags(V);
          break;
        case "Group":
          this.visitGroup(V);
          break;
        case "Pattern":
          this.visitPattern(V);
          break;
        case "Quantifier":
          this.visitQuantifier(V);
          break;
        case "RegExpLiteral":
          this.visitRegExpLiteral(V);
          break;
        case "StringAlternative":
          this.visitStringAlternative(V);
          break;
        default:
          throw new Error(`Unknown type: ${V.type}`);
      }
    }
    visitAlternative(V) {
      this._handlers.onAlternativeEnter && this._handlers.onAlternativeEnter(V), V.elements.forEach(this.visit, this), this._handlers.onAlternativeLeave && this._handlers.onAlternativeLeave(V);
    }
    visitAssertion(V) {
      this._handlers.onAssertionEnter && this._handlers.onAssertionEnter(V), (V.kind === "lookahead" || V.kind === "lookbehind") && V.alternatives.forEach(this.visit, this), this._handlers.onAssertionLeave && this._handlers.onAssertionLeave(V);
    }
    visitBackreference(V) {
      this._handlers.onBackreferenceEnter && this._handlers.onBackreferenceEnter(V), this._handlers.onBackreferenceLeave && this._handlers.onBackreferenceLeave(V);
    }
    visitCapturingGroup(V) {
      this._handlers.onCapturingGroupEnter && this._handlers.onCapturingGroupEnter(V), V.alternatives.forEach(this.visit, this), this._handlers.onCapturingGroupLeave && this._handlers.onCapturingGroupLeave(V);
    }
    visitCharacter(V) {
      this._handlers.onCharacterEnter && this._handlers.onCharacterEnter(V), this._handlers.onCharacterLeave && this._handlers.onCharacterLeave(V);
    }
    visitCharacterClass(V) {
      this._handlers.onCharacterClassEnter && this._handlers.onCharacterClassEnter(V), V.elements.forEach(this.visit, this), this._handlers.onCharacterClassLeave && this._handlers.onCharacterClassLeave(V);
    }
    visitCharacterClassRange(V) {
      this._handlers.onCharacterClassRangeEnter && this._handlers.onCharacterClassRangeEnter(V), this.visitCharacter(V.min), this.visitCharacter(V.max), this._handlers.onCharacterClassRangeLeave && this._handlers.onCharacterClassRangeLeave(V);
    }
    visitCharacterSet(V) {
      this._handlers.onCharacterSetEnter && this._handlers.onCharacterSetEnter(V), this._handlers.onCharacterSetLeave && this._handlers.onCharacterSetLeave(V);
    }
    visitClassIntersection(V) {
      this._handlers.onClassIntersectionEnter && this._handlers.onClassIntersectionEnter(V), this.visit(V.left), this.visit(V.right), this._handlers.onClassIntersectionLeave && this._handlers.onClassIntersectionLeave(V);
    }
    visitClassStringDisjunction(V) {
      this._handlers.onClassStringDisjunctionEnter && this._handlers.onClassStringDisjunctionEnter(V), V.alternatives.forEach(this.visit, this), this._handlers.onClassStringDisjunctionLeave && this._handlers.onClassStringDisjunctionLeave(V);
    }
    visitClassSubtraction(V) {
      this._handlers.onClassSubtractionEnter && this._handlers.onClassSubtractionEnter(V), this.visit(V.left), this.visit(V.right), this._handlers.onClassSubtractionLeave && this._handlers.onClassSubtractionLeave(V);
    }
    visitExpressionCharacterClass(V) {
      this._handlers.onExpressionCharacterClassEnter && this._handlers.onExpressionCharacterClassEnter(V), this.visit(V.expression), this._handlers.onExpressionCharacterClassLeave && this._handlers.onExpressionCharacterClassLeave(V);
    }
    visitFlags(V) {
      this._handlers.onFlagsEnter && this._handlers.onFlagsEnter(V), this._handlers.onFlagsLeave && this._handlers.onFlagsLeave(V);
    }
    visitGroup(V) {
      this._handlers.onGroupEnter && this._handlers.onGroupEnter(V), V.alternatives.forEach(this.visit, this), this._handlers.onGroupLeave && this._handlers.onGroupLeave(V);
    }
    visitPattern(V) {
      this._handlers.onPatternEnter && this._handlers.onPatternEnter(V), V.alternatives.forEach(this.visit, this), this._handlers.onPatternLeave && this._handlers.onPatternLeave(V);
    }
    visitQuantifier(V) {
      this._handlers.onQuantifierEnter && this._handlers.onQuantifierEnter(V), this.visit(V.element), this._handlers.onQuantifierLeave && this._handlers.onQuantifierLeave(V);
    }
    visitRegExpLiteral(V) {
      this._handlers.onRegExpLiteralEnter && this._handlers.onRegExpLiteralEnter(V), this.visitPattern(V.pattern), this.visitFlags(V.flags), this._handlers.onRegExpLiteralLeave && this._handlers.onRegExpLiteralLeave(V);
    }
    visitStringAlternative(V) {
      this._handlers.onStringAlternativeEnter && this._handlers.onStringAlternativeEnter(V), V.elements.forEach(this.visit, this), this._handlers.onStringAlternativeLeave && this._handlers.onStringAlternativeLeave(V);
    }
  }
  function yt(Oe, V) {
    return new cr(V).parseLiteral(String(Oe));
  }
  function kr(Oe, V) {
    new Zt(V).validateLiteral(Oe);
  }
  function Er(Oe, V) {
    new fr(V).visit(Oe);
  }
  return ar.AST = i, ar.RegExpParser = cr, ar.RegExpValidator = Zt, ar.parseRegExpLiteral = yt, ar.validateRegExpLiteral = kr, ar.visitRegExpAST = Er, ar;
}
var lo, yd;
function Mb() {
  if (yd) return lo;
  yd = 1;
  const i = rr().RegExpValidator, t = new class {
    constructor() {
      this._source = "", this._controlChars = [], this._validator = new i(this);
    }
    onPatternEnter() {
      this._controlChars = [];
    }
    onCharacter(o, f, r) {
      r >= 0 && r <= 31 && (this._source.codePointAt(o) === r || this._source.slice(o, f).startsWith("\\x") || this._source.slice(o, f).startsWith("\\u")) && this._controlChars.push(`\\x${`0${r.toString(16)}`.slice(-2)}`);
    }
    collectControlChars(o, f) {
      const r = typeof f == "string" && f.includes("u"), u = typeof f == "string" && f.includes("v");
      this._controlChars = [], this._source = o;
      try {
        this._validator.validatePattern(o, void 0, void 0, { unicode: r, unicodeSets: u });
      } catch {
      }
      return this._controlChars;
    }
  }();
  return lo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow control characters in regular expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-control-regex"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
      }
    },
    create(o) {
      function f(r) {
        if (r.regex)
          return r.regex;
        if (typeof r.value == "string" && (r.parent.type === "NewExpression" || r.parent.type === "CallExpression") && r.parent.callee.type === "Identifier" && r.parent.callee.name === "RegExp" && r.parent.arguments[0] === r) {
          const u = r.value, e = r.parent.arguments.length > 1 && r.parent.arguments[1].type === "Literal" && typeof r.parent.arguments[1].value == "string" ? r.parent.arguments[1].value : null;
          return { pattern: u, flags: e };
        }
        return null;
      }
      return {
        Literal(r) {
          const u = f(r);
          if (u) {
            const { pattern: e, flags: a } = u, n = t.collectControlChars(e, a);
            n.length > 0 && o.report({
              node: r,
              messageId: "unexpected",
              data: {
                controlChars: n.join(", ")
              }
            });
          }
        }
      };
    }
  }, lo;
}
var uo, Cd;
function Kb() {
  return Cd || (Cd = 1, uo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow the use of `debugger`",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-debugger"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Unexpected 'debugger' statement."
      }
    },
    create(i) {
      return {
        DebuggerStatement(t) {
          i.report({
            node: t,
            messageId: "unexpected"
          });
        }
      };
    }
  }), uo;
}
var co, vd;
function jb() {
  return vd || (vd = 1, co = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow deleting variables",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-delete-var"
      },
      schema: [],
      messages: {
        unexpected: "Variables should not be deleted."
      }
    },
    create(i) {
      return {
        UnaryExpression(t) {
          t.operator === "delete" && t.argument.type === "Identifier" && i.report({ node: t, messageId: "unexpected" });
        }
      };
    }
  }), co;
}
var fo, Sd;
function qb() {
  return Sd || (Sd = 1, fo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow equal signs explicitly at the beginning of regular expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-div-regex"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "A regular expression literal can be confused with '/='."
      }
    },
    create(i) {
      const t = i.sourceCode;
      return {
        Literal(o) {
          const f = t.getFirstToken(o);
          f.type === "RegularExpression" && f.value[1] === "=" && i.report({
            node: o,
            messageId: "unexpected",
            fix(r) {
              return r.replaceTextRange([f.range[0] + 1, f.range[0] + 2], "[=]");
            }
          });
        }
      };
    }
  }), fo;
}
var po, Ad;
function $b() {
  return Ad || (Ad = 1, po = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate arguments in `function` definitions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-dupe-args"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate param '{{name}}'."
      }
    },
    create(i) {
      const t = i.sourceCode;
      function o(r) {
        return r.type === "Parameter";
      }
      function f(r) {
        const u = t.getDeclaredVariables(r);
        for (let e = 0; e < u.length; ++e) {
          const a = u[e];
          a.defs.filter(o).length >= 2 && i.report({
            node: r,
            messageId: "unexpected",
            data: { name: a.name }
          });
        }
      }
      return {
        FunctionDeclaration: f,
        FunctionExpression: f
      };
    }
  }), po;
}
var ho, Td;
function Gb() {
  if (Td) return ho;
  Td = 1;
  const i = Re();
  return ho = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate class members",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-dupe-class-members"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate name '{{name}}'."
      }
    },
    create(t) {
      let o = [];
      function f(r, u) {
        const e = o[o.length - 1], a = `$${r}`;
        return e[a] || (e[a] = {
          nonStatic: { init: !1, get: !1, set: !1 },
          static: { init: !1, get: !1, set: !1 }
        }), e[a][u ? "static" : "nonStatic"];
      }
      return {
        // Initializes the stack of state of member declarations.
        Program() {
          o = [];
        },
        // Initializes state of member declarations for the class.
        ClassBody() {
          o.push(/* @__PURE__ */ Object.create(null));
        },
        // Disposes the state for the class.
        "ClassBody:exit"() {
          o.pop();
        },
        // Reports the node if its name has been declared already.
        "MethodDefinition, PropertyDefinition"(r) {
          const u = i.getStaticPropertyName(r), e = r.type === "MethodDefinition" ? r.kind : "field";
          if (u === null || e === "constructor")
            return;
          const a = f(u, r.static);
          let n = !1;
          e === "get" ? (n = a.init || a.get, a.get = !0) : e === "set" ? (n = a.init || a.set, a.set = !0) : (n = a.init || a.get || a.set, a.init = !0), n && t.report({ node: r, messageId: "unexpected", data: { name: u } });
        }
      };
    }
  }, ho;
}
var mo, bd;
function Wb() {
  if (bd) return mo;
  bd = 1;
  const i = Re();
  function t(u, e, a) {
    return e.every((n) => a.some((p) => u(n, p)));
  }
  function o(u, e) {
    return e.type === "LogicalExpression" && e.operator === u ? [...o(u, e.left), ...o(u, e.right)] : [e];
  }
  const f = o.bind(null, "||"), r = o.bind(null, "&&");
  return mo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate conditions in if-else-if chains",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-dupe-else-if"
      },
      schema: [],
      messages: {
        unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
      }
    },
    create(u) {
      const e = u.sourceCode;
      function a(p, m) {
        return p.type !== m.type ? !1 : p.type === "LogicalExpression" && (p.operator === "||" || p.operator === "&&") && p.operator === m.operator ? a(p.left, m.left) && a(p.right, m.right) || a(p.left, m.right) && a(p.right, m.left) : i.equalTokens(p, m, e);
      }
      const n = t.bind(null, a);
      return {
        IfStatement(p) {
          const m = p.test, h = m.type === "LogicalExpression" && m.operator === "&&" ? [m, ...r(m)] : [m];
          let l = p, s = h.map((c) => f(c).map(r));
          for (; l.parent && l.parent.type === "IfStatement" && l.parent.alternate === l; ) {
            l = l.parent;
            const c = f(l.test).map(r);
            if (s = s.map((g) => g.filter(
              (d) => !c.some((y) => n(y, d))
            )), s.some((g) => g.length === 0)) {
              u.report({ node: m, messageId: "unexpected" });
              break;
            }
          }
        }
      };
    }
  }, mo;
}
var go, xd;
function Xb() {
  if (xd) return go;
  xd = 1;
  const i = Re(), t = /^(?:init|get)$/u, o = /^(?:init|set)$/u;
  class f {
    /**
     * @param {ObjectInfo|null} upper The information of the outer object.
     * @param {ASTNode} node The ObjectExpression node of this information.
     */
    constructor(u, e) {
      this.upper = u, this.node = e, this.properties = /* @__PURE__ */ new Map();
    }
    /**
     * Gets the information of the given Property node.
     * @param {ASTNode} node The Property node to get.
     * @returns {{get: boolean, set: boolean}} The information of the property.
     */
    getPropertyInfo(u) {
      const e = i.getStaticPropertyName(u);
      return this.properties.has(e) || this.properties.set(e, { get: !1, set: !1 }), this.properties.get(e);
    }
    /**
     * Checks whether the given property has been defined already or not.
     * @param {ASTNode} node The Property node to check.
     * @returns {boolean} `true` if the property has been defined.
     */
    isPropertyDefined(u) {
      const e = this.getPropertyInfo(u);
      return t.test(u.kind) && e.get || o.test(u.kind) && e.set;
    }
    /**
     * Defines the given property.
     * @param {ASTNode} node The Property node to define.
     * @returns {void}
     */
    defineProperty(u) {
      const e = this.getPropertyInfo(u);
      t.test(u.kind) && (e.get = !0), o.test(u.kind) && (e.set = !0);
    }
  }
  return go = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate keys in object literals",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-dupe-keys"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate key '{{name}}'."
      }
    },
    create(r) {
      let u = null;
      return {
        ObjectExpression(e) {
          u = new f(u, e);
        },
        "ObjectExpression:exit"() {
          u = u.upper;
        },
        Property(e) {
          const a = i.getStaticPropertyName(e);
          e.parent.type === "ObjectExpression" && a !== null && (u.isPropertyDefined(e) && r.report({
            node: u.node,
            loc: e.key.loc,
            messageId: "unexpected",
            data: { name: a }
          }), u.defineProperty(e));
        }
      };
    }
  }, go;
}
var Eo, Rd;
function zb() {
  if (Rd) return Eo;
  Rd = 1;
  const i = Re();
  return Eo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate case labels",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-duplicate-case"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate case label."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r, u) {
        return r.type !== u.type ? !1 : i.equalTokens(r, u, o);
      }
      return {
        SwitchStatement(r) {
          const u = [];
          for (const e of r.cases)
            if (e.test) {
              const a = e.test;
              u.some((n) => f(n, a)) ? t.report({ node: e, messageId: "unexpected" }) : u.push(a);
            }
        }
      };
    }
  }, Eo;
}
var yo, Dd;
function Hb() {
  if (Dd) return yo;
  Dd = 1;
  const i = ["ImportSpecifier", "ExportSpecifier"], t = [
    "ImportNamespaceSpecifier",
    "ExportNamespaceSpecifier"
  ];
  function o(m, h) {
    return (h === "named" ? i : t).includes(m);
  }
  function f(m) {
    if (m.specifiers && m.specifiers.length > 0) {
      const h = m.specifiers, l = h.findIndex(
        ({ type: c }) => o(c, "named") || o(c, "namespace")
      ), s = l > -1 ? l : 0;
      return h[s].type;
    }
    return m.type === "ExportAllDeclaration" ? m.exported ? "ExportNamespaceSpecifier" : "ExportAll" : "SideEffectImport";
  }
  function r(m, h) {
    const l = f(m), s = f(h);
    return !(l === "ExportAll" && s !== "ExportAll" && s !== "SideEffectImport" || l !== "ExportAll" && l !== "SideEffectImport" && s === "ExportAll" || o(l, "namespace") && o(s, "named") || o(s, "namespace") && o(l, "named"));
  }
  function u(m, h) {
    let l = 0;
    for (; l < h.length; ) {
      if (r(m, h[l]))
        return !0;
      l++;
    }
    return !1;
  }
  function e(m, h) {
    return m.filter(({ declarationType: l }) => l === h).map(({ node: l }) => l);
  }
  function a(m) {
    return m && m.source && m.source.value ? m.source.value.trim() : "";
  }
  function n(m, h, l, s, c) {
    const g = a(h);
    if (l.has(g)) {
      const d = l.get(g), y = [], v = e(d, "import");
      let T;
      c && (T = e(d, "export")), s === "import" ? (u(h, v) && y.push("import"), c && u(h, T) && y.push("importAs")) : s === "export" && (u(h, T) && y.push("export"), u(h, v) && y.push("exportAs")), y.forEach((b) => m.report({
        node: h,
        messageId: b,
        data: {
          module: g
        }
      }));
    }
  }
  function p(m, h, l, s) {
    return function(c) {
      const g = a(c);
      if (g) {
        n(
          m,
          c,
          h,
          l,
          s
        );
        const d = { node: c, declarationType: l };
        let y = [d];
        h.has(g) && (y = [...h.get(g), d]), h.set(g, y);
      }
    };
  }
  return yo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate module imports",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-duplicate-imports"
      },
      schema: [
        {
          type: "object",
          properties: {
            includeExports: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        import: "'{{module}}' import is duplicated.",
        importAs: "'{{module}}' import is duplicated as export.",
        export: "'{{module}}' export is duplicated.",
        exportAs: "'{{module}}' export is duplicated as import."
      }
    },
    create(m) {
      const h = (m.options[0] || {}).includeExports, l = /* @__PURE__ */ new Map(), s = {
        ImportDeclaration: p(
          m,
          l,
          "import",
          h
        )
      };
      return h && (s.ExportNamedDeclaration = p(
        m,
        l,
        "export",
        h
      ), s.ExportAllDeclaration = p(
        m,
        l,
        "export",
        h
      )), s;
    }
  }, yo;
}
var Co, Ld;
function Wr() {
  if (Ld) return Co;
  Ld = 1;
  const i = Re();
  class t {
    /**
     * Create a new FixTracker.
     * @param {ruleFixer} fixer A ruleFixer instance.
     * @param {SourceCode} sourceCode A SourceCode object for the current code.
     */
    constructor(f, r) {
      this.fixer = f, this.sourceCode = r, this.retainedRange = null;
    }
    /**
     * Mark the given range as "retained", meaning that other fixes may not
     * may not modify this region in the same pass.
     * @param {int[]} range The range to retain.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainRange(f) {
      return this.retainedRange = f, this;
    }
    /**
     * Given a node, find the function containing it (or the entire program) and
     * mark it as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that modify control
     * flow.
     * @param {ASTNode} node The node to use as a starting point.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainEnclosingFunction(f) {
      const r = i.getUpperFunction(f);
      return this.retainRange(r ? r.range : this.sourceCode.ast.range);
    }
    /**
     * Given a node or token, find the token before and afterward, and mark that
     * range as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that make a small
     * change to the code where the AST should not be changed.
     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting
     *      point. The token to the left and right are use in the range.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainSurroundingTokens(f) {
      const r = this.sourceCode.getTokenBefore(f) || f, u = this.sourceCode.getTokenAfter(f) || f;
      return this.retainRange([r.range[0], u.range[1]]);
    }
    /**
     * Create a fix command that replaces the given range with the given text,
     * accounting for any retained ranges.
     * @param {int[]} range The range to remove in the fix.
     * @param {string} text The text to insert in place of the range.
     * @returns {Object} The fix command.
     */
    replaceTextRange(f, r) {
      let u;
      return this.retainedRange ? u = [
        Math.min(this.retainedRange[0], f[0]),
        Math.max(this.retainedRange[1], f[1])
      ] : u = f, this.fixer.replaceTextRange(
        u,
        this.sourceCode.text.slice(u[0], f[0]) + r + this.sourceCode.text.slice(f[1], u[1])
      );
    }
    /**
     * Create a fix command that removes the given node or token, accounting for
     * any retained ranges.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @returns {Object} The fix command.
     */
    remove(f) {
      return this.replaceTextRange(f.range, "");
    }
  }
  return Co = t, Co;
}
var vo, _d;
function Jb() {
  if (_d) return vo;
  _d = 1;
  const i = Re(), t = Wr();
  return vo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `else` blocks after `return` statements in `if` statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-else-return"
      },
      schema: [{
        type: "object",
        properties: {
          allowElseIf: {
            type: "boolean",
            default: !0
          }
        },
        additionalProperties: !1
      }],
      fixable: "code",
      messages: {
        unexpected: "Unnecessary 'else' after 'return'."
      }
    },
    create(o) {
      const f = o.sourceCode;
      function r(d, y) {
        if (d.length === 0)
          return !0;
        const v = y.variableScope;
        if (y.variables.filter(({ defs: S }) => S.length > 0).some(({ name: S }) => d.includes(S)) || y !== v && y.upper.type === "catch" && y.upper.variables.some(({ name: S }) => d.includes(S)) || y.variables.filter(({ defs: S, references: C }) => S.length === 0 && C.length > 0).some(({ name: S }) => d.includes(S)) || y.through.some((S) => d.includes(S.identifier.name)))
          return !1;
        if (y !== v) {
          const S = y.block.range;
          if (v.variables.filter(({ name: x }) => d.includes(x)).some((x) => x.defs.some(({ node: { range: A } }) => S[0] <= A[0] && A[1] <= S[1])))
            return !1;
        }
        return !0;
      }
      function u(d, y) {
        if (d.type === "FunctionDeclaration")
          return !1;
        if (d.type !== "BlockStatement")
          return !0;
        const v = y.childScopes.find(({ block: b }) => b === d);
        if (!v)
          return !0;
        const T = v.variables.map(({ name: b }) => b);
        return r(T, y);
      }
      function e(d) {
        const y = f.getScope(d.parent);
        o.report({
          node: d,
          messageId: "unexpected",
          fix(v) {
            if (!u(d, y))
              return null;
            const T = f.getFirstToken(d), b = f.getTokenBefore(T), S = f.getText(d), C = f.getTokenBefore(b);
            let x, A;
            T.type === "Punctuator" && T.value === "{" ? A = f.getTokenAfter(T) : A = T;
            const R = d.parent.consequent.type !== "BlockStatement" && C.value !== ";", L = /^[([/+`-]/u.test(A.value);
            if (R && L)
              return null;
            const _ = f.getLastToken(d), I = f.getTokenBefore(_);
            if (I.value !== ";") {
              const O = f.getTokenAfter(_), k = O && /^[([/+`-]/u.test(O.value), w = O && O.loc.start.line === I.loc.start.line;
              if (k || w && O.value !== "}")
                return null;
            }
            return T.type === "Punctuator" && T.value === "{" ? x = S.slice(1, -1) : x = S, new t(v, f).retainEnclosingFunction(d).replaceTextRange([b.range[0], d.range[1]], x);
          }
        });
      }
      function a(d) {
        return d.type === "ReturnStatement";
      }
      function n(d) {
        if (d.type === "BlockStatement") {
          const y = d.body, v = y[y.length - 1];
          return v && a(v);
        }
        return a(d);
      }
      function p(d) {
        return d.alternate && d.consequent;
      }
      function m(d) {
        return d.type === "IfStatement" && p(d) && n(d.alternate) && n(d.consequent);
      }
      function h(d) {
        return a(d) || m(d);
      }
      function l(d) {
        return d.type === "BlockStatement" ? d.body.some(h) : h(d);
      }
      function s(d) {
        const y = d.parent;
        if (!i.STATEMENT_LIST_PARENTS.has(y.type))
          return;
        const v = [];
        let T;
        for (let b = d; b.type === "IfStatement"; b = b.alternate) {
          if (!b.alternate)
            return;
          v.push(b.consequent), T = b.alternate;
        }
        v.every(l) && e(T);
      }
      function c(d) {
        const y = d.parent;
        if (!i.STATEMENT_LIST_PARENTS.has(y.type))
          return;
        const v = d.alternate;
        v && l(d.consequent) && e(v);
      }
      return {
        "IfStatement:exit": !(o.options[0] && o.options[0].allowElseIf === !1) ? s : c
      };
    }
  }, vo;
}
var So, wd;
function Qb() {
  if (wd) return So;
  wd = 1;
  const i = Re();
  return So = {
    meta: {
      hasSuggestions: !0,
      type: "suggestion",
      docs: {
        description: "Disallow empty block statements",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-empty"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyCatch: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "Empty {{type}} statement.",
        suggestComment: "Add comment inside empty {{type}} statement."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.allowEmptyCatch || !1, r = t.sourceCode;
      return {
        BlockStatement(u) {
          u.body.length === 0 && (i.isFunction(u.parent) || f && u.parent.type === "CatchClause" || r.getCommentsInside(u).length > 0 || t.report({
            node: u,
            messageId: "unexpected",
            data: { type: "block" },
            suggest: [
              {
                messageId: "suggestComment",
                data: { type: "block" },
                fix(e) {
                  const a = [u.range[0] + 1, u.range[1] - 1];
                  return e.replaceTextRange(a, " /* empty */ ");
                }
              }
            ]
          }));
        },
        SwitchStatement(u) {
          (typeof u.cases > "u" || u.cases.length === 0) && t.report({ node: u, messageId: "unexpected", data: { type: "switch" } });
        }
      };
    }
  }, So;
}
var Ao, kd;
function Yb() {
  if (kd) return Ao;
  kd = 1;
  const { RegExpParser: i, visitRegExpAST: t } = rr(), o = new i(), f = /\[\]/u;
  return Ao = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow empty character classes in regular expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-empty-character-class"
      },
      schema: [],
      messages: {
        unexpected: "Empty class."
      }
    },
    create(r) {
      return {
        "Literal[regex]"(u) {
          const { pattern: e, flags: a } = u.regex;
          if (!f.test(e))
            return;
          let n;
          try {
            n = o.parsePattern(e, 0, e.length, {
              unicode: a.includes("u"),
              unicodeSets: a.includes("v")
            });
          } catch {
            return;
          }
          t(n, {
            onCharacterClassEnter(p) {
              !p.negate && p.elements.length === 0 && r.report({ node: u, messageId: "unexpected" });
            }
          });
        }
      };
    }
  }, Ao;
}
var To, Bd;
function Zb() {
  if (Bd) return To;
  Bd = 1;
  const i = Re(), t = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors",
    "asyncFunctions",
    "asyncMethods"
  ]);
  function o(f) {
    const r = f.parent;
    let u = "";
    if (f.type === "ArrowFunctionExpression")
      return "arrowFunctions";
    if (r.type === "Property") {
      if (r.kind === "get")
        return "getters";
      if (r.kind === "set")
        return "setters";
      u = r.method ? "methods" : "functions";
    } else if (r.type === "MethodDefinition") {
      if (r.kind === "get")
        return "getters";
      if (r.kind === "set")
        return "setters";
      if (r.kind === "constructor")
        return "constructors";
      u = "methods";
    } else
      u = "functions";
    let e = "";
    if (f.generator)
      e = "generator";
    else if (f.async)
      e = "async";
    else
      return u;
    return e + u[0].toUpperCase() + u.slice(1);
  }
  return To = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow empty functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-empty-function"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: { enum: t },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "Unexpected empty {{name}}."
      }
    },
    create(f) {
      const u = (f.options[0] || {}).allow || [], e = f.sourceCode;
      function a(n) {
        const p = o(n), m = i.getFunctionNameWithKind(n), h = e.getTokens(n.body, {
          includeComments: !0,
          filter: i.isCommentToken
        });
        !u.includes(p) && n.body.type === "BlockStatement" && n.body.body.length === 0 && h.length === 0 && f.report({
          node: n,
          loc: n.body.loc,
          messageId: "unexpected",
          data: { name: m }
        });
      }
      return {
        ArrowFunctionExpression: a,
        FunctionDeclaration: a,
        FunctionExpression: a
      };
    }
  }, To;
}
var bo, Pd;
function ex() {
  if (Pd) return bo;
  Pd = 1;
  const i = Re();
  return bo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow empty destructuring patterns",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-empty-pattern"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowObjectPatternsAsParameters: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "Unexpected empty {{type}} pattern."
      }
    },
    create(t) {
      const o = t.options[0] || {}, f = o.allowObjectPatternsAsParameters || !1;
      return {
        ObjectPattern(r) {
          r.properties.length > 0 || f && (i.isFunction(r.parent) || r.parent.type === "AssignmentPattern" && i.isFunction(r.parent.parent) && r.parent.right.type === "ObjectExpression" && r.parent.right.properties.length === 0) || t.report({ node: r, messageId: "unexpected", data: { type: "object" } });
        },
        ArrayPattern(r) {
          r.elements.length === 0 && t.report({ node: r, messageId: "unexpected", data: { type: "array" } });
        }
      };
    }
  }, bo;
}
var xo, Id;
function tx() {
  return Id || (Id = 1, xo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow empty static blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-empty-static-block"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected empty static block."
      }
    },
    create(i) {
      const t = i.sourceCode;
      return {
        StaticBlock(o) {
          if (o.body.length === 0) {
            const f = t.getLastToken(o);
            t.getCommentsBefore(f).length === 0 && i.report({
              node: o,
              messageId: "unexpected"
            });
          }
        }
      };
    }
  }), xo;
}
var Ro, Fd;
function rx() {
  return Fd || (Fd = 1, Ro = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `null` comparisons without type-checking operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-eq-null"
      },
      schema: [],
      messages: {
        unexpected: "Use '===' to compare with null."
      }
    },
    create(i) {
      return {
        BinaryExpression(t) {
          const o = t.operator === "==" || t.operator === "!=";
          (t.right.type === "Literal" && t.right.raw === "null" && o || t.left.type === "Literal" && t.left.raw === "null" && o) && i.report({ node: t, messageId: "unexpected" });
        }
      };
    }
  }), Ro;
}
var Do, Nd;
function nx() {
  if (Nd) return Do;
  Nd = 1;
  const i = Re(), t = Object.freeze([
    "global",
    "window",
    "globalThis"
  ]);
  function o(f, r) {
    return i.isSpecificMemberAccess(f, null, r);
  }
  return Do = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `eval()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-eval"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowIndirect: { type: "boolean", default: !1 }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "eval can be harmful."
      }
    },
    create(f) {
      const r = !!(f.options[0] && f.options[0].allowIndirect), u = f.sourceCode;
      let e = null;
      function a(l) {
        const s = u.getScope(l).isStrict;
        e = {
          upper: e,
          node: l,
          strict: s,
          isTopLevelOfScript: !1,
          defaultThis: !1,
          initialized: s
        };
      }
      function n() {
        e = e.upper;
      }
      function p(l) {
        const s = l.parent, c = l.type === "MemberExpression" ? l.property : l, g = s.type === "CallExpression" && s.callee === l ? s : l;
        f.report({
          node: g,
          loc: c.loc,
          messageId: "unexpected"
        });
      }
      function m(l) {
        for (let s = 0; s < t.length; ++s) {
          const c = t[s], g = i.getVariableByName(l, c);
          if (!g)
            continue;
          const d = g.references;
          for (let y = 0; y < d.length; ++y) {
            let T = d[y].identifier.parent;
            for (; o(T, c); )
              T = T.parent;
            o(T, "eval") && p(T);
          }
        }
      }
      function h(l) {
        const s = i.getVariableByName(l, "eval");
        if (!s)
          return;
        const c = s.references;
        for (let g = 0; g < c.length; ++g) {
          const y = c[g].identifier;
          y.name === "eval" && !i.isCallee(y) && p(y);
        }
      }
      return r ? {
        "CallExpression:exit"(l) {
          const s = l.callee;
          !l.optional && i.isSpecificId(s, "eval") && p(s);
        }
      } : {
        "CallExpression:exit"(l) {
          const s = l.callee;
          i.isSpecificId(s, "eval") && p(s);
        },
        Program(l) {
          const s = u.getScope(l), c = f.parserOptions.ecmaFeatures || {}, g = s.isStrict || l.sourceType === "module" || c.globalReturn && s.childScopes[0].isStrict, d = l.sourceType !== "module" && !c.globalReturn;
          e = {
            upper: null,
            node: l,
            strict: g,
            isTopLevelOfScript: d,
            defaultThis: !0,
            initialized: !0
          };
        },
        "Program:exit"(l) {
          const s = u.getScope(l);
          n(), h(s), m(s);
        },
        FunctionDeclaration: a,
        "FunctionDeclaration:exit": n,
        FunctionExpression: a,
        "FunctionExpression:exit": n,
        "PropertyDefinition > *.value": a,
        "PropertyDefinition > *.value:exit": n,
        StaticBlock: a,
        "StaticBlock:exit": n,
        ThisExpression(l) {
          o(l.parent, "eval") && (e.initialized || (e.initialized = !0, e.defaultThis = i.isDefaultThisBinding(
            e.node,
            u
          )), (e.isTopLevelOfScript || !e.strict && e.defaultThis) && p(l.parent));
        }
      };
    }
  }, Do;
}
var Lo, Od;
function sx() {
  if (Od) return Lo;
  Od = 1;
  const i = Re();
  return Lo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning exceptions in `catch` clauses",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-ex-assign"
      },
      schema: [],
      messages: {
        unexpected: "Do not assign to the exception parameter."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r) {
        i.getModifyingReferences(r.references).forEach((u) => {
          t.report({ node: u.identifier, messageId: "unexpected" });
        });
      }
      return {
        CatchClause(r) {
          o.getDeclaredVariables(r).forEach(f);
        }
      };
    }
  }, Lo;
}
var _o, Ud;
function ix() {
  if (Ud) return _o;
  Ud = 1;
  const i = Re(), t = jf();
  return _o = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow extending native types",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-extend-native"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpected: "{{builtin}} prototype is read only, properties should not be added."
      }
    },
    create(o) {
      const f = o.options[0] || {}, r = o.sourceCode, u = new Set(f.exceptions || []), e = new Set(
        Object.keys(t.builtin).filter((l) => l[0].toUpperCase() === l[0]).filter((l) => !u.has(l))
      );
      function a(l, s) {
        o.report({
          node: l,
          messageId: "unexpected",
          data: {
            builtin: s
          }
        });
      }
      function n(l) {
        return !!(l && l.parent && l.parent.type === "MemberExpression" && l.parent.object === l && i.getStaticPropertyName(l.parent) === "prototype");
      }
      function p(l) {
        return l.parent.type === "MemberExpression" && l.parent.object === l && l.parent.parent.type === "AssignmentExpression" && l.parent.parent.left === l.parent;
      }
      function m(l) {
        return l.parent.type === "CallExpression" && l.parent.arguments[0] === l && i.isSpecificMemberAccess(l.parent.callee, "Object", /^definePropert(?:y|ies)$/u);
      }
      function h(l) {
        if (!n(l))
          return;
        const s = l.parent.parent.type === "ChainExpression" ? l.parent.parent : l.parent;
        p(s) ? a(s.parent.parent, l.name) : m(s) && a(s.parent, l.name);
      }
      return {
        "Program:exit"(l) {
          const s = r.getScope(l);
          e.forEach((c) => {
            const g = s.set.get(c);
            g && g.references && g.references.map((d) => d.identifier).forEach(h);
          });
        }
      };
    }
  }, _o;
}
var wo, Vd;
function ax() {
  if (Vd) return wo;
  Vd = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);
  return wo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary calls to `.bind()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-extra-bind"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "The function binding is unnecessary."
      }
    },
    create(o) {
      const f = o.sourceCode;
      let r = null;
      function u(l) {
        return t.has(l.type);
      }
      function e(l) {
        const s = l.parent, c = s.parent.type === "ChainExpression" ? s.parent.parent : s.parent;
        o.report({
          node: c,
          messageId: "unexpected",
          loc: s.property.loc,
          fix(g) {
            if (!u(c.arguments[0]))
              return null;
            const d = [
              [
                // `.`, `?.`, or `[` token.
                f.getTokenAfter(
                  s.object,
                  i.isNotClosingParenToken
                ),
                // property name or `]` token.
                f.getLastToken(s)
              ],
              [
                // `?.` or `(` token of arguments.
                f.getTokenAfter(
                  s,
                  i.isNotClosingParenToken
                ),
                // `)` token of arguments.
                f.getLastToken(c)
              ]
            ], y = d[0][0], v = d[1][1];
            return f.commentsExistBetween(y, v) ? null : d.map(([T, b]) => g.removeRange([T.range[0], b.range[1]]));
          }
        });
      }
      function a(l) {
        if (!i.isSpecificMemberAccess(l.parent, null, "bind"))
          return !1;
        const s = l.parent.parent.type === "ChainExpression" ? l.parent.parent : l.parent;
        return s.parent.type === "CallExpression" && s.parent.callee === s && s.parent.arguments.length === 1 && s.parent.arguments[0].type !== "SpreadElement";
      }
      function n(l) {
        r = {
          isBound: a(l),
          thisFound: !1,
          upper: r
        };
      }
      function p(l) {
        r.isBound && !r.thisFound && e(l), r = r.upper;
      }
      function m(l) {
        a(l) && e(l);
      }
      function h() {
        r && (r.thisFound = !0);
      }
      return {
        "ArrowFunctionExpression:exit": m,
        FunctionDeclaration: n,
        "FunctionDeclaration:exit": p,
        FunctionExpression: n,
        "FunctionExpression:exit": p,
        ThisExpression: h
      };
    }
  }, wo;
}
var ko, Md;
function ox() {
  if (Md) return ko;
  Md = 1;
  const i = Re(), t = Ft(), o = i.getPrecedence;
  return ko = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary boolean casts",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-extra-boolean-cast"
      },
      schema: [{
        type: "object",
        properties: {
          enforceForLogicalOperands: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      fixable: "code",
      messages: {
        unexpectedCall: "Redundant Boolean call.",
        unexpectedNegation: "Redundant double negation."
      }
    },
    create(f) {
      const r = f.sourceCode, u = /* @__PURE__ */ new Set([
        "IfStatement",
        "DoWhileStatement",
        "WhileStatement",
        "ConditionalExpression",
        "ForStatement"
      ]);
      function e(s) {
        return (s.type === "CallExpression" || s.type === "NewExpression") && s.callee.type === "Identifier" && s.callee.name === "Boolean";
      }
      function a(s) {
        return s.type === "LogicalExpression" && (s.operator === "||" || s.operator === "&&") && f.options.length && f.options[0].enforceForLogicalOperands === !0;
      }
      function n(s) {
        return e(s.parent) && s === s.parent.arguments[0] || u.has(s.parent.type) && s === s.parent.test || // !<bool>
        s.parent.type === "UnaryExpression" && s.parent.operator === "!";
      }
      function p(s) {
        return s.parent.type === "ChainExpression" ? p(s.parent) : n(s) || a(s.parent) && // For nested logical statements
        p(s.parent);
      }
      function m(s) {
        return !!r.getCommentsInside(s).length;
      }
      function h(s) {
        return t.isParenthesized(1, s, r);
      }
      function l(s, c) {
        if (s.parent.type === "ChainExpression")
          return l(s.parent, c);
        if (h(s))
          return !1;
        const g = s.parent;
        switch (g.type) {
          case "CallExpression":
          case "NewExpression":
            return c.type === "SequenceExpression";
          case "IfStatement":
          case "DoWhileStatement":
          case "WhileStatement":
          case "ForStatement":
            return !1;
          case "ConditionalExpression":
            return o(c) <= o(g);
          case "UnaryExpression":
            return o(c) < o(g);
          case "LogicalExpression":
            return i.isMixedLogicalAndCoalesceExpressions(c, g) ? !0 : s === g.left ? o(c) < o(g) : o(c) <= o(g);
          default:
            throw new Error(`Unexpected parent type: ${g.type}`);
        }
      }
      return {
        UnaryExpression(s) {
          const c = s.parent;
          s.operator !== "!" || c.type !== "UnaryExpression" || c.operator !== "!" || p(c) && f.report({
            node: c,
            messageId: "unexpectedNegation",
            fix(g) {
              if (m(c))
                return null;
              if (l(c, s.argument))
                return g.replaceText(c, `(${r.getText(s.argument)})`);
              let d = "";
              const y = r.getTokenBefore(c), v = r.getFirstToken(s.argument);
              return y && y.range[1] === c.range[0] && !i.canTokensBeAdjacent(y, v) && (d = " "), g.replaceText(c, d + r.getText(s.argument));
            }
          });
        },
        CallExpression(s) {
          s.callee.type !== "Identifier" || s.callee.name !== "Boolean" || p(s) && f.report({
            node: s,
            messageId: "unexpectedCall",
            fix(c) {
              const g = s.parent;
              if (s.arguments.length === 0) {
                if (g.type === "UnaryExpression" && g.operator === "!") {
                  if (m(g))
                    return null;
                  const d = "true";
                  let y = "";
                  const v = r.getTokenBefore(g);
                  return v && v.range[1] === g.range[0] && !i.canTokensBeAdjacent(v, d) && (y = " "), c.replaceText(g, y + d);
                }
                return m(s) ? null : c.replaceText(s, "false");
              }
              if (s.arguments.length === 1) {
                const d = s.arguments[0];
                return d.type === "SpreadElement" || m(s) ? null : l(s, d) ? c.replaceText(s, `(${r.getText(d)})`) : c.replaceText(s, r.getText(d));
              }
              return null;
            }
          });
        }
      };
    }
  }, ko;
}
var Bo, Kd;
function lx() {
  if (Kd) return Bo;
  Kd = 1;
  const i = Re();
  return Bo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary labels",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-extra-label"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "This label '{{name}}' is unnecessary."
      }
    },
    create(t) {
      const o = t.sourceCode;
      let f = null;
      function r(p) {
        f = {
          label: p.parent.type === "LabeledStatement" ? p.parent.label : null,
          breakable: !0,
          upper: f
        };
      }
      function u() {
        f = f.upper;
      }
      function e(p) {
        i.isBreakableStatement(p.body) || (f = {
          label: p.label,
          breakable: !1,
          upper: f
        });
      }
      function a(p) {
        i.isBreakableStatement(p.body) || (f = f.upper);
      }
      function n(p) {
        if (!p.label)
          return;
        const m = p.label;
        for (let h = f; h !== null; h = h.upper)
          if (h.breakable || h.label && h.label.name === m.name) {
            h.breakable && h.label && h.label.name === m.name && t.report({
              node: m,
              messageId: "unexpected",
              data: m,
              fix(l) {
                const s = o.getFirstToken(p);
                return o.commentsExistBetween(s, m) ? null : l.removeRange([s.range[1], m.range[1]]);
              }
            });
            return;
          }
      }
      return {
        WhileStatement: r,
        "WhileStatement:exit": u,
        DoWhileStatement: r,
        "DoWhileStatement:exit": u,
        ForStatement: r,
        "ForStatement:exit": u,
        ForInStatement: r,
        "ForInStatement:exit": u,
        ForOfStatement: r,
        "ForOfStatement:exit": u,
        SwitchStatement: r,
        "SwitchStatement:exit": u,
        LabeledStatement: e,
        "LabeledStatement:exit": a,
        BreakStatement: n,
        ContinueStatement: n
      };
    }
  }, Bo;
}
var Po, jd;
function ux() {
  if (jd) return Po;
  jd = 1;
  const { isParenthesized: i } = Ft(), t = Re();
  return Po = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow unnecessary parentheses",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-extra-parens"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["functions"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              },
              {
                type: "object",
                properties: {
                  conditionalAssign: { type: "boolean" },
                  ternaryOperandBinaryExpressions: { type: "boolean" },
                  nestedBinaryExpressions: { type: "boolean" },
                  returnAssign: { type: "boolean" },
                  ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] },
                  enforceForArrowConditionals: { type: "boolean" },
                  enforceForSequenceExpressions: { type: "boolean" },
                  enforceForNewInMemberExpressions: { type: "boolean" },
                  enforceForFunctionPrototypeMethods: { type: "boolean" },
                  allowParensAfterCommentPattern: { type: "string" }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpected: "Unnecessary parentheses around expression."
      }
    },
    create(o) {
      const f = o.sourceCode, r = /* @__PURE__ */ new WeakSet(), u = t.getPrecedence, e = o.options[0] !== "functions", a = e && o.options[1] && o.options[1].conditionalAssign === !1, n = e && o.options[1] && o.options[1].ternaryOperandBinaryExpressions === !1, p = e && o.options[1] && o.options[1].nestedBinaryExpressions === !1, m = e && o.options[1] && o.options[1].returnAssign === !1, h = e && o.options[1] && o.options[1].ignoreJSX, l = e && o.options[1] && o.options[1].enforceForArrowConditionals === !1, s = e && o.options[1] && o.options[1].enforceForSequenceExpressions === !1, c = e && o.options[1] && o.options[1].enforceForNewInMemberExpressions === !1, g = e && o.options[1] && o.options[1].enforceForFunctionPrototypeMethods === !1, d = e && o.options[1] && o.options[1].allowParensAfterCommentPattern, y = u({ type: "AssignmentExpression" }), v = u({ type: "UpdateExpression" });
      let T;
      function b(Y) {
        const Te = t.skipChainExpression(Y);
        if (Te.type !== "CallExpression")
          return !1;
        const Ke = t.skipChainExpression(Te.callee);
        return Ke.type === "MemberExpression" && Ke.object.type === "FunctionExpression" && ["call", "apply"].includes(t.getStaticPropertyName(Ke));
      }
      function S(Y) {
        if (Y.type === "JSXElement" || Y.type === "JSXFragment") {
          const Te = Y.loc.start.line === Y.loc.end.line;
          switch (h) {
            case "all":
              return !1;
            case "multi-line":
              return Te;
            case "single-line":
              return !Te;
          }
        }
        return Y.type === "SequenceExpression" && s || b(Y) && g ? !1 : e || Y.type === "FunctionExpression" || Y.type === "ArrowFunctionExpression";
      }
      function C(Y) {
        return i(1, Y, f);
      }
      function x(Y) {
        return i(2, Y, f);
      }
      function A(Y) {
        return S(Y) && C(Y);
      }
      function R(Y) {
        return S(Y) && x(Y);
      }
      function L(Y, Te) {
        return !!(S(Y) && C(Y) && (u(Y) >= Te || x(Y)));
      }
      function _(Y) {
        return a && Y.test.type === "AssignmentExpression";
      }
      function I(Y) {
        for (let Te = Y; Te; Te = Te.parent)
          if (Te.type === "ReturnStatement" || Te.type === "ArrowFunctionExpression" && Te.body.type !== "BlockStatement")
            return !0;
        return !1;
      }
      function O(Y) {
        const Te = f.getLastToken(Y), Ke = f.getTokenBefore(Te);
        return Y.arguments.length > 0 || // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens
        t.isOpeningParenToken(Ke) && t.isClosingParenToken(Te) && Y.callee.range[1] < Y.range[1];
      }
      function k(Y) {
        return !!(Y.type === "AssignmentExpression" || Y.type === "ConditionalExpression" && (Y.consequent.type === "AssignmentExpression" || Y.alternate.type === "AssignmentExpression") || Y.left && Y.left.type === "AssignmentExpression" || Y.right && Y.right.type === "AssignmentExpression");
      }
      function w(Y) {
        return !m || !I(Y) ? !1 : Y.type === "ReturnStatement" ? Y.argument && k(Y.argument) : Y.type === "ArrowFunctionExpression" && Y.body.type !== "BlockStatement" ? k(Y.body) : k(Y);
      }
      function U(Y, Te) {
        return Y.loc.end.line === Te.loc.start.line ? A(Te) : R(Te);
      }
      function q(Y) {
        const Te = f.getTokenBefore(Y), Ke = f.getTokenBefore(Te, { includeComments: !0 }), et = f.getTokenAfter(Te, { includeComments: !0 });
        return Ke && Ke.range[1] === Te.range[0] && Te.range[1] === et.range[0] && !t.canTokensBeAdjacent(Ke, et);
      }
      function F(Y) {
        const Te = f.getTokensAfter(Y, { count: 2 }), Ke = Te[0], et = Te[1], nt = f.getLastToken(Y);
        return Ke && et && !f.isSpaceBetweenTokens(Ke, et) && !t.canTokensBeAdjacent(nt, et);
      }
      function $(Y) {
        const Te = t.skipChainExpression(Y);
        return Te.type === "CallExpression" && Te.callee.type === "FunctionExpression";
      }
      function P(Y) {
        return Y && (Y.type === "Identifier" || Y.type === "MemberExpression");
      }
      function X(Y) {
        return Y.type !== "Literal" || typeof Y.value != "string" || x(Y) ? !0 : !t.isTopLevelExpressionStatement(Y.parent);
      }
      function Q(Y) {
        const Te = f.getTokenBefore(Y), Ke = f.getTokenAfter(Y);
        if (!x(Y)) {
          if (r.has(f.getFirstToken(Y)) || $(Y) && !C(Y.callee))
            return;
          if (d) {
            const nt = f.getCommentsBefore(Te), rt = nt.length, ot = new RegExp(d, "u");
            if (rt > 0 && ot.test(nt[rt - 1].value))
              return;
          }
        }
        function et() {
          o.report({
            node: Y,
            loc: Te.loc,
            messageId: "unexpected",
            fix: X(Y) ? (nt) => {
              const rt = f.text.slice(Te.range[1], Ke.range[0]);
              return nt.replaceTextRange([
                Te.range[0],
                Ke.range[1]
              ], (q(Y) ? " " : "") + rt + (F(Y) ? " " : ""));
            } : null
          });
        }
        if (T) {
          T.reports.push({ node: Y, finishReport: et });
          return;
        }
        et();
      }
      function ue(Y) {
        L(Y.argument, u(Y)) && Q(Y.argument);
      }
      function le(Y) {
        let Te = Y.object, Ke = Y.object.type;
        for (; Ke === "MemberExpression"; )
          Te = Te.object, Ke = Te.type;
        return Ke === "CallExpression";
      }
      function Ce(Y) {
        const Te = Y.callee;
        L(Te, u(Y)) && (R(Te) || !($(Y) || // (new A)(); new (new A)();
        Te.type === "NewExpression" && !O(Te) && !(Y.type === "NewExpression" && !O(Y)) || // new (a().b)(); new (a.b().c);
        Y.type === "NewExpression" && Te.type === "MemberExpression" && le(Te) || // (a?.b)(); (a?.())();
        !Y.optional && Te.type === "ChainExpression")) && Q(Y.callee), Y.arguments.filter((Ke) => L(Ke, y)).forEach(Q);
      }
      function j(Y) {
        const Te = u(Y), Ke = u(Y.left), et = u(Y.right), nt = Y.operator === "**", rt = p && (Y.left.type === "BinaryExpression" || Y.left.type === "LogicalExpression"), ot = p && (Y.right.type === "BinaryExpression" || Y.right.type === "LogicalExpression");
        !rt && A(Y.left) && (!(["AwaitExpression", "UnaryExpression"].includes(Y.left.type) && nt) && !t.isMixedLogicalAndCoalesceExpressions(Y.left, Y) && (Ke > Te || Ke === Te && !nt) || x(Y.left)) && Q(Y.left), !ot && A(Y.right) && (!t.isMixedLogicalAndCoalesceExpressions(Y.right, Y) && (et > Te || et === Te && nt) || x(Y.right)) && Q(Y.right);
      }
      function H(Y) {
        if (!Y.superClass)
          return;
        (u(Y.superClass) > v ? A(Y.superClass) : R(Y.superClass)) && Q(Y.superClass);
      }
      function N(Y) {
        L(Y.argument, y) && Q(Y.argument);
      }
      function G(Y) {
        const Te = C(Y) ? f.getTokenBefore(Y) : f.getFirstToken(Y), Ke = f.getTokenAfter(Te, t.isNotOpeningParenToken), et = Ke ? f.getTokenAfter(Ke) : null, nt = Ke ? f.getTokenAfter(Ke, t.isNotClosingParenToken) : null;
        t.isOpeningParenToken(Te) && (t.isOpeningBraceToken(Ke) || Ke.type === "Keyword" && (Ke.value === "function" || Ke.value === "class" || Ke.value === "let" && nt && (t.isOpeningBracketToken(nt) || nt.type === "Identifier")) || Ke && Ke.type === "Identifier" && Ke.value === "async" && et && et.type === "Keyword" && et.value === "function") && r.add(Ke), (Y.parent.type === "ExportDefaultDeclaration" ? L(Y, y) : A(Y)) && Q(Y);
      }
      function M(Y, Te) {
        const Ke = [Y];
        let et = Y;
        for (; et !== Te; ) {
          if (et = et.parent, et === null)
            throw new Error("Nodes are not in the ancestor-descendant relationship.");
          Ke.push(et);
        }
        return Ke;
      }
      function Z(Y, Te) {
        return M(Te, Y).reverse();
      }
      function Ee(Y, Te) {
        switch (Y.type) {
          case "ArrayExpression":
          case "ArrayPattern":
          case "BlockStatement":
          case "ObjectExpression":
          case "ObjectPattern":
          case "TemplateLiteral":
            return !0;
          case "ArrowFunctionExpression":
          case "FunctionExpression":
            return Y.params.includes(Te);
          case "CallExpression":
          case "NewExpression":
            return Y.arguments.includes(Te);
          case "MemberExpression":
            return Y.computed && Y.property === Te;
          case "ConditionalExpression":
            return Y.consequent === Te;
          default:
            return !1;
        }
      }
      function ke() {
        T = {
          upper: T,
          inExpressionNodes: [],
          reports: []
        };
      }
      function Ie() {
        const { upper: Y, inExpressionNodes: Te, reports: Ke } = T;
        Y ? (Y.inExpressionNodes.push(...Te), Y.reports.push(...Ke)) : Ke.forEach(({ finishReport: et }) => et()), T = Y;
      }
      function Je(Y) {
        return T.reports.some((Te) => Te.node === Y);
      }
      function at(Y) {
        T.reports = T.reports.filter((Te) => Te.node !== Y);
      }
      function lt(Y) {
        return Y.type === "MemberExpression" ? Y.parent.type === "NewExpression" && Y.parent.callee === Y ? !0 : Y.parent.object === Y && lt(Y.parent) : !1;
      }
      function mt({ left: Y, operator: Te, right: Ke }) {
        if (Y.type === "Identifier" && ["=", "&&=", "||=", "??="].includes(Te)) {
          const et = Ke.type;
          if (et === "ArrowFunctionExpression" || (et === "FunctionExpression" || et === "ClassExpression") && !Ke.id)
            return !0;
        }
        return !1;
      }
      return {
        ArrayExpression(Y) {
          Y.elements.filter((Te) => Te && L(Te, y)).forEach(Q);
        },
        ArrayPattern(Y) {
          Y.elements.filter((Te) => P(Te) && A(Te)).forEach(Q);
        },
        ArrowFunctionExpression(Y) {
          if (!w(Y) && !(Y.body.type === "ConditionalExpression" && l) && Y.body.type !== "BlockStatement") {
            const Te = f.getFirstToken(Y.body, t.isNotOpeningParenToken), Ke = f.getTokenBefore(Te);
            t.isOpeningParenToken(Ke) && t.isOpeningBraceToken(Te) && r.add(Te), L(Y.body, y) && Q(Y.body);
          }
        },
        AssignmentExpression(Y) {
          P(Y.left) && A(Y.left) && (!mt(Y) || x(Y.left)) && Q(Y.left), !w(Y) && L(Y.right, u(Y)) && Q(Y.right);
        },
        BinaryExpression(Y) {
          T && Y.operator === "in" && T.inExpressionNodes.push(Y), j(Y);
        },
        CallExpression: Ce,
        ConditionalExpression(Y) {
          if (w(Y))
            return;
          const Te = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression"]);
          !(n && Te.has(Y.test.type)) && !_(Y) && L(Y.test, u({ type: "LogicalExpression", operator: "||" })) && Q(Y.test), !(n && Te.has(Y.consequent.type)) && L(Y.consequent, y) && Q(Y.consequent), !(n && Te.has(Y.alternate.type)) && L(Y.alternate, y) && Q(Y.alternate);
        },
        DoWhileStatement(Y) {
          A(Y.test) && !_(Y) && Q(Y.test);
        },
        ExportDefaultDeclaration: (Y) => G(Y.declaration),
        ExpressionStatement: (Y) => G(Y.expression),
        ForInStatement(Y) {
          if (Y.left.type !== "VariableDeclaration") {
            const Te = f.getFirstToken(Y.left, t.isNotOpeningParenToken);
            Te.value === "let" && t.isOpeningBracketToken(
              f.getTokenAfter(Te, t.isNotClosingParenToken)
            ) && r.add(Te);
          }
          A(Y.left) && Q(Y.left), A(Y.right) && Q(Y.right);
        },
        ForOfStatement(Y) {
          if (Y.left.type !== "VariableDeclaration") {
            const Te = f.getFirstToken(Y.left, t.isNotOpeningParenToken);
            Te.value === "let" && r.add(Te);
          }
          A(Y.left) && Q(Y.left), L(Y.right, y) && Q(Y.right);
        },
        ForStatement(Y) {
          if (Y.test && A(Y.test) && !_(Y) && Q(Y.test), Y.update && A(Y.update) && Q(Y.update), Y.init) {
            if (Y.init.type !== "VariableDeclaration") {
              const Te = f.getFirstToken(Y.init, t.isNotOpeningParenToken);
              Te.value === "let" && t.isOpeningBracketToken(
                f.getTokenAfter(Te, t.isNotClosingParenToken)
              ) && r.add(Te);
            }
            ke(), A(Y.init) && Q(Y.init);
          }
        },
        "ForStatement > *.init:exit"(Y) {
          T.reports.length && T.inExpressionNodes.forEach((Te) => {
            const Ke = Z(Y, Te);
            let et;
            for (let nt = 0; nt < Ke.length; nt++) {
              const rt = Ke[nt];
              if (nt < Ke.length - 1) {
                const ot = Ke[nt + 1];
                if (Ee(rt, ot))
                  return;
              }
              if (C(rt))
                if (Je(rt)) {
                  if (x(rt))
                    return;
                  et || (et = rt);
                } else
                  return;
            }
            at(et);
          }), Ie();
        },
        IfStatement(Y) {
          A(Y.test) && !_(Y) && Q(Y.test);
        },
        ImportExpression(Y) {
          const { source: Te } = Y;
          Te.type === "SequenceExpression" ? R(Te) && Q(Te) : A(Te) && Q(Te);
        },
        LogicalExpression: j,
        MemberExpression(Y) {
          const Ke = lt(Y) && le(Y) ? R(Y.object) : A(Y.object) && !(b(Y.parent) && Y.parent.callee === Y && g);
          Ke && u(Y.object) >= u(Y) && (Y.computed || !(t.isDecimalInteger(Y.object) || // RegExp literal is allowed to have parens (#1589)
          Y.object.type === "Literal" && Y.object.regex)) && Q(Y.object), Ke && Y.object.type === "CallExpression" && Q(Y.object), Ke && !c && Y.object.type === "NewExpression" && O(Y.object) && Q(Y.object), Ke && Y.optional && Y.object.type === "ChainExpression" && Q(Y.object), Y.computed && A(Y.property) && Q(Y.property);
        },
        "MethodDefinition[computed=true]"(Y) {
          L(Y.key, y) && Q(Y.key);
        },
        NewExpression: Ce,
        ObjectExpression(Y) {
          Y.properties.filter((Te) => Te.value && L(Te.value, y)).forEach((Te) => Q(Te.value));
        },
        ObjectPattern(Y) {
          Y.properties.filter((Te) => {
            const Ke = Te.value;
            return P(Ke) && A(Ke);
          }).forEach((Te) => Q(Te.value));
        },
        Property(Y) {
          if (Y.computed) {
            const { key: Te } = Y;
            Te && L(Te, y) && Q(Te);
          }
        },
        PropertyDefinition(Y) {
          Y.computed && L(Y.key, y) && Q(Y.key), Y.value && L(Y.value, y) && Q(Y.value);
        },
        RestElement(Y) {
          const Te = Y.argument;
          P(Te) && A(Te) && Q(Te);
        },
        ReturnStatement(Y) {
          const Te = f.getFirstToken(Y);
          w(Y) || Y.argument && U(Te, Y.argument) && // RegExp literal is allowed to have parens (#1589)
          !(Y.argument.type === "Literal" && Y.argument.regex) && Q(Y.argument);
        },
        SequenceExpression(Y) {
          const Te = u(Y);
          Y.expressions.filter((Ke) => L(Ke, Te)).forEach(Q);
        },
        SwitchCase(Y) {
          Y.test && A(Y.test) && Q(Y.test);
        },
        SwitchStatement(Y) {
          A(Y.discriminant) && Q(Y.discriminant);
        },
        ThrowStatement(Y) {
          const Te = f.getFirstToken(Y);
          U(Te, Y.argument) && Q(Y.argument);
        },
        UnaryExpression: ue,
        UpdateExpression(Y) {
          if (Y.prefix)
            ue(Y);
          else {
            const { argument: Te } = Y, Ke = f.getLastToken(Y);
            Te.loc.end.line === Ke.loc.start.line ? ue(Y) : R(Te) && Q(Te);
          }
        },
        AwaitExpression: ue,
        VariableDeclarator(Y) {
          Y.init && L(Y.init, y) && // RegExp literal is allowed to have parens (#1589)
          !(Y.init.type === "Literal" && Y.init.regex) && Q(Y.init);
        },
        WhileStatement(Y) {
          A(Y.test) && !_(Y) && Q(Y.test);
        },
        WithStatement(Y) {
          A(Y.object) && Q(Y.object);
        },
        YieldExpression(Y) {
          if (Y.argument) {
            const Te = f.getFirstToken(Y);
            (u(Y.argument) >= u(Y) && U(Te, Y.argument) || R(Y.argument)) && Q(Y.argument);
          }
        },
        ClassDeclaration: H,
        ClassExpression: H,
        SpreadElement: N,
        SpreadProperty: N,
        ExperimentalSpreadProperty: N,
        TemplateLiteral(Y) {
          Y.expressions.filter((Te) => Te && A(Te)).forEach(Q);
        },
        AssignmentPattern(Y) {
          const { left: Te, right: Ke } = Y;
          P(Te) && A(Te) && Q(Te), Ke && L(Ke, y) && Q(Ke);
        }
      };
    }
  }, Po;
}
var Io, qd;
function cx() {
  if (qd) return Io;
  qd = 1;
  const i = Wr(), t = Re();
  return Io = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary semicolons",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-extra-semi"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "Unnecessary semicolon."
      }
    },
    create(o) {
      const f = o.sourceCode;
      function r(a) {
        const n = f.getTokenAfter(a);
        if (!n || n.type !== "String")
          return !0;
        const p = f.getNodeByRangeIndex(n.range[0]);
        return !t.isTopLevelExpressionStatement(p.parent);
      }
      function u(a) {
        o.report({
          node: a,
          messageId: "unexpected",
          fix: r(a) ? (n) => (
            /*
             * Expand the replacement range to include the surrounding
             * tokens to avoid conflicting with semi.
             * https://github.com/eslint/eslint/issues/7928
             */
            new i(n, o.sourceCode).retainSurroundingTokens(a).remove(a)
          ) : null
        });
      }
      function e(a) {
        for (let n = a; n.type === "Punctuator" && !t.isClosingBraceToken(n); n = f.getTokenAfter(n))
          t.isSemicolonToken(n) && u(n);
      }
      return {
        /**
         * Reports this empty statement, except if the parent node is a loop.
         * @param {Node} node A EmptyStatement node to be reported.
         * @returns {void}
         */
        EmptyStatement(a) {
          const n = a.parent;
          [
            "ForStatement",
            "ForInStatement",
            "ForOfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "IfStatement",
            "LabeledStatement",
            "WithStatement"
          ].includes(n.type) || u(a);
        },
        /**
         * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
         * @param {Node} node A ClassBody node to check.
         * @returns {void}
         */
        ClassBody(a) {
          e(f.getFirstToken(a, 1));
        },
        /**
         * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
         * @param {Node} node A MethodDefinition node of the start point.
         * @returns {void}
         */
        "MethodDefinition, PropertyDefinition, StaticBlock"(a) {
          e(f.getTokenAfter(a));
        }
      };
    }
  }, Io;
}
var Fo, $d;
function fx() {
  if ($d) return Fo;
  $d = 1;
  const { directivesPattern: i } = gn(), t = /falls?\s?through/iu;
  function o(e) {
    for (const a of e)
      if (a.reachable)
        return !0;
    return !1;
  }
  function f(e, a) {
    return a.test(e) && !i.test(e.trim());
  }
  function r(e, a, n, p) {
    const m = n.sourceCode;
    if (e.consequent.length === 1 && e.consequent[0].type === "BlockStatement") {
      const l = m.getLastToken(e.consequent[0]), s = m.getCommentsBefore(l).pop();
      if (s && f(s.value, p))
        return !0;
    }
    const h = m.getCommentsBefore(a).pop();
    return !!(h && f(h.value, p));
  }
  function u(e, a) {
    return a.loc.start.line > e.loc.end.line + 1;
  }
  return Fo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow fallthrough of `case` statements",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-fallthrough"
      },
      schema: [
        {
          type: "object",
          properties: {
            commentPattern: {
              type: "string",
              default: ""
            },
            allowEmptyCase: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        case: "Expected a 'break' statement before 'case'.",
        default: "Expected a 'break' statement before 'default'."
      }
    },
    create(e) {
      const a = e.options[0] || {}, n = [];
      let p = /* @__PURE__ */ new Set();
      const m = e.sourceCode, h = a.allowEmptyCase || !1;
      let l = null, s = null;
      return a.commentPattern ? s = new RegExp(a.commentPattern, "u") : s = t, {
        onCodePathStart() {
          n.push(p), p = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          p = n.pop();
        },
        onUnreachableCodePathSegmentStart(c) {
          p.add(c);
        },
        onUnreachableCodePathSegmentEnd(c) {
          p.delete(c);
        },
        onCodePathSegmentStart(c) {
          p.add(c);
        },
        onCodePathSegmentEnd(c) {
          p.delete(c);
        },
        SwitchCase(c) {
          l && !r(l, c, e, s) && e.report({
            messageId: c.test ? "case" : "default",
            node: c
          }), l = null;
        },
        "SwitchCase:exit"(c) {
          const g = m.getTokenAfter(c);
          o(p) && (c.consequent.length > 0 || !h && u(c, g)) && c.parent.cases[c.parent.cases.length - 1] !== c && (l = c);
        }
      };
    }
  }, Fo;
}
var No, Gd;
function px() {
  if (Gd) return No;
  Gd = 1;
  const i = Re();
  return No = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow leading or trailing decimal points in numeric literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-floating-decimal"
      },
      schema: [],
      fixable: "code",
      messages: {
        leading: "A leading decimal point can be confused with a dot.",
        trailing: "A trailing decimal point can be confused with a dot."
      }
    },
    create(t) {
      const o = t.sourceCode;
      return {
        Literal(f) {
          typeof f.value == "number" && (f.raw.startsWith(".") && t.report({
            node: f,
            messageId: "leading",
            fix(r) {
              const u = o.getTokenBefore(f), e = u && u.range[1] === f.range[0] && !i.canTokensBeAdjacent(u, `0${f.raw}`);
              return r.insertTextBefore(f, e ? " 0" : "0");
            }
          }), f.raw.indexOf(".") === f.raw.length - 1 && t.report({
            node: f,
            messageId: "trailing",
            fix: (r) => r.insertTextAfter(f, "0")
          }));
        }
      };
    }
  }, No;
}
var Oo, Wd;
function hx() {
  if (Wd) return Oo;
  Wd = 1;
  const i = Re();
  return Oo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning `function` declarations",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-func-assign"
      },
      schema: [],
      messages: {
        isAFunction: "'{{name}}' is a function."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(e) {
        i.getModifyingReferences(e).forEach((a) => {
          t.report({
            node: a.identifier,
            messageId: "isAFunction",
            data: {
              name: a.identifier.name
            }
          });
        });
      }
      function r(e) {
        e.defs[0].type === "FunctionName" && f(e.references);
      }
      function u(e) {
        o.getDeclaredVariables(e).forEach(r);
      }
      return {
        FunctionDeclaration: u,
        FunctionExpression: u
      };
    }
  }, Oo;
}
var Uo, Xd;
function mx() {
  return Xd || (Xd = 1, Uo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow assignments to native objects or read-only global variables",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-global-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(i) {
      const t = i.options[0], o = i.sourceCode, f = t && t.exceptions || [];
      function r(e, a, n) {
        const p = e.identifier;
        e.init === !1 && e.isWrite() && /*
        * Destructuring assignments can have multiple default value,
        * so possibly there are multiple writeable references for the same identifier.
        */
        (a === 0 || n[a - 1].identifier !== p) && i.report({
          node: p,
          messageId: "globalShouldNotBeModified",
          data: {
            name: p.name
          }
        });
      }
      function u(e) {
        e.writeable === !1 && !f.includes(e.name) && e.references.forEach(r);
      }
      return {
        Program(e) {
          o.getScope(e).variables.forEach(u);
        }
      };
    }
  }), Uo;
}
var Vo, zd;
function gx() {
  if (zd) return Vo;
  zd = 1;
  const i = Re(), t = /^(?:i|lastI)ndexOf$/u, o = ["~", "!!", "+", "*"];
  function f(g) {
    return {
      boolean: "boolean" in g ? g.boolean : !0,
      number: "number" in g ? g.number : !0,
      string: "string" in g ? g.string : !0,
      disallowTemplateShorthand: "disallowTemplateShorthand" in g ? g.disallowTemplateShorthand : !1,
      allow: g.allow || []
    };
  }
  function r(g) {
    return g.operator === "!" && g.argument.type === "UnaryExpression" && g.argument.operator === "!";
  }
  function u(g) {
    if (g.operator !== "~")
      return !1;
    const d = i.skipChainExpression(g.argument);
    return d.type === "CallExpression" && i.isSpecificMemberAccess(d.callee, null, t);
  }
  function e(g) {
    return g.operator === "*" && (g.left.type === "Literal" && g.left.value === 1 || g.right.type === "Literal" && g.right.value === 1);
  }
  function a(g, d) {
    return g.type === "BinaryExpression" && g.operator === "*" && g.right.type === "Literal" && g.right.value === 1 && g.parent.type === "BinaryExpression" && g.parent.operator === "/" && g.parent.left === g && !i.isParenthesised(d, g);
  }
  function n(g) {
    return g.type === "Literal" && typeof g.value == "number" || g.type === "CallExpression" && (g.callee.name === "Number" || g.callee.name === "parseInt" || g.callee.name === "parseFloat");
  }
  function p(g) {
    const d = g.left, y = g.right;
    return y.type !== "BinaryExpression" && !n(y) ? y : d.type !== "BinaryExpression" && !n(d) ? d : null;
  }
  function m(g) {
    return i.isStringLiteral(g) || g.type === "CallExpression" && g.callee.type === "Identifier" && g.callee.name === "String";
  }
  function h(g) {
    return i.isStringLiteral(g) && (g.value === "" || g.type === "TemplateLiteral" && g.quasis.length === 1 && g.quasis[0].value.cooked === "");
  }
  function l(g) {
    return g.operator === "+" && (h(g.left) && !m(g.right) || h(g.right) && !m(g.left));
  }
  function s(g) {
    return g.operator === "+=" && h(g.right);
  }
  function c(g) {
    return h(g.left) ? g.right : g.left;
  }
  return Vo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow shorthand type conversions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-implicit-coercion"
      },
      fixable: "code",
      schema: [{
        type: "object",
        properties: {
          boolean: {
            type: "boolean",
            default: !0
          },
          number: {
            type: "boolean",
            default: !0
          },
          string: {
            type: "boolean",
            default: !0
          },
          disallowTemplateShorthand: {
            type: "boolean",
            default: !1
          },
          allow: {
            type: "array",
            items: {
              enum: o
            },
            uniqueItems: !0
          }
        },
        additionalProperties: !1
      }],
      messages: {
        useRecommendation: "use `{{recommendation}}` instead."
      }
    },
    create(g) {
      const d = f(g.options[0] || {}), y = g.sourceCode;
      function v(T, b, S) {
        g.report({
          node: T,
          messageId: "useRecommendation",
          data: {
            recommendation: b
          },
          fix(C) {
            if (!S)
              return null;
            const x = y.getTokenBefore(T);
            return x && x.range[1] === T.range[0] && !i.canTokensBeAdjacent(x, b) ? C.replaceText(T, ` ${b}`) : C.replaceText(T, b);
          }
        });
      }
      return {
        UnaryExpression(T) {
          let b;
          if (b = d.allow.includes("!!"), !b && d.boolean && r(T)) {
            const S = `Boolean(${y.getText(T.argument.argument)})`;
            v(T, S, !0);
          }
          if (b = d.allow.includes("~"), !b && d.boolean && u(T)) {
            const S = T.argument.type === "ChainExpression" ? ">= 0" : "!== -1", C = `${y.getText(T.argument)} ${S}`;
            v(T, C, !1);
          }
          if (b = d.allow.includes("+"), !b && d.number && T.operator === "+" && !n(T.argument)) {
            const S = `Number(${y.getText(T.argument)})`;
            v(T, S, !0);
          }
        },
        // Use `:exit` to prevent double reporting
        "BinaryExpression:exit"(T) {
          let b;
          b = d.allow.includes("*");
          const S = !b && d.number && e(T) && !a(T, y) && p(T);
          if (S) {
            const C = `Number(${y.getText(S)})`;
            v(T, C, !0);
          }
          if (b = d.allow.includes("+"), !b && d.string && l(T)) {
            const C = `String(${y.getText(c(T))})`;
            v(T, C, !0);
          }
        },
        AssignmentExpression(T) {
          if (!d.allow.includes("+") && d.string && s(T)) {
            const S = y.getText(c(T)), C = `${S} = String(${S})`;
            v(T, C, !0);
          }
        },
        TemplateLiteral(T) {
          if (!d.disallowTemplateShorthand || T.parent.type === "TaggedTemplateExpression" || T.expressions.length !== 1 || T.quasis[0].value.cooked !== "" || T.quasis[1].value.cooked !== "" || m(T.expressions[0]))
            return;
          const S = `String(${y.getText(T.expressions[0])})`;
          v(T, S, !0);
        }
      };
    }
  }, Vo;
}
var Mo, Hd;
function dx() {
  return Hd || (Hd = 1, Mo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow declarations in the global scope",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-implicit-globals"
      },
      schema: [{
        type: "object",
        properties: {
          lexicalBindings: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
        globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
        globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
        assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
        redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
      }
    },
    create(i) {
      const t = i.options[0] && i.options[0].lexicalBindings === !0, o = i.sourceCode;
      function f(r, u, e) {
        i.report({
          node: r,
          messageId: u,
          data: {
            kind: e
          }
        });
      }
      return {
        Program(r) {
          const u = o.getScope(r);
          u.variables.forEach((e) => {
            const a = e.writeable === !1;
            e.writeable !== !0 && (e.eslintExported || e.defs.forEach((p) => {
              const m = p.node;
              (p.type === "FunctionName" || p.type === "Variable" && p.parent.kind === "var") && (a ? f(m, "redeclarationOfReadonlyGlobal") : f(
                m,
                "globalNonLexicalBinding",
                p.type === "FunctionName" ? "function" : `'${p.parent.kind}'`
              )), t && (p.type === "ClassName" || p.type === "Variable" && (p.parent.kind === "let" || p.parent.kind === "const")) && (a ? f(m, "redeclarationOfReadonlyGlobal") : f(
                m,
                "globalLexicalBinding",
                p.type === "ClassName" ? "class" : `'${p.parent.kind}'`
              ));
            }));
          }), u.implicit.variables.forEach((e) => {
            const a = u.set.get(e.name);
            let n;
            if (a) {
              if (a.writeable)
                return;
              n = "assignmentToReadonlyGlobal";
            } else
              n = "globalVariableLeak";
            e.defs.forEach((p) => {
              f(p.node, n);
            });
          });
        }
      };
    }
  }), Mo;
}
var Ko, Jd;
function Ex() {
  if (Jd) return Ko;
  Jd = 1;
  const i = Re(), { getStaticValue: t } = Ft();
  return Ko = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `eval()`-like methods",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-implied-eval"
      },
      schema: [],
      messages: {
        impliedEval: "Implied eval. Consider passing a function instead of a string."
      }
    },
    create(o) {
      const f = Object.freeze(["global", "window", "globalThis"]), r = /^(?:set(?:Interval|Timeout)|execScript)$/u, u = o.sourceCode;
      function e(p) {
        return p.type === "Literal" && typeof p.value == "string" || p.type === "TemplateLiteral" ? !0 : p.type === "BinaryExpression" && p.operator === "+" ? e(p.left) || e(p.right) : !1;
      }
      function a(p) {
        const [m] = p.arguments;
        if (m) {
          const h = t(m, u.getScope(p));
          (h && typeof h.value == "string" || e(m)) && o.report({
            node: p,
            messageId: "impliedEval"
          });
        }
      }
      function n(p) {
        const { references: m, name: h } = p;
        m.forEach((l) => {
          let c = l.identifier.parent;
          for (; i.isSpecificMemberAccess(c, null, h); )
            c = c.parent;
          if (i.isSpecificMemberAccess(c, null, r)) {
            const g = c.parent.type === "ChainExpression" ? c.parent : c, d = g.parent;
            d.type === "CallExpression" && d.callee === g && a(d);
          }
        });
      }
      return {
        CallExpression(p) {
          i.isSpecificId(p.callee, r) && a(p);
        },
        "Program:exit"(p) {
          const m = u.getScope(p);
          f.map((h) => i.getVariableByName(m, h)).filter((h) => !!h && h.defs.length === 0).forEach(n);
        }
      };
    }
  }, Ko;
}
var jo, Qd;
function yx() {
  if (Qd) return jo;
  Qd = 1;
  const { findVariable: i } = Ft(), t = Re(), o = {
    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
  };
  function f(p) {
    const { parent: m } = p;
    return m.type === "AssignmentExpression" && m.left === p || // Destructuring assignments
    m.type === "ArrayPattern" || m.type === "Property" && m.value === p && m.parent.type === "ObjectPattern" || m.type === "RestElement" || m.type === "AssignmentPattern" && m.left === p;
  }
  function r(p) {
    const m = p.parent.type === "ChainExpression" ? p.parent : p, { parent: h } = m;
    return h.type === "UpdateExpression" && h.argument === m || h.type === "UnaryExpression" && h.operator === "delete" && h.argument === m;
  }
  function u(p) {
    const { parent: m } = p;
    return m.type === "ForInStatement" && m.left === p || m.type === "ForOfStatement" && m.left === p;
  }
  function e(p, m) {
    const { parent: h } = p;
    if (h.type !== "CallExpression" || h.arguments[0] !== p)
      return !1;
    const l = t.skipChainExpression(h.callee);
    if (!t.isSpecificMemberAccess(l, "Object", o.Object) && !t.isSpecificMemberAccess(l, "Reflect", o.Reflect))
      return !1;
    const s = i(m, l.object);
    return s !== null && s.scope.type === "global";
  }
  function a(p, m) {
    const { parent: h } = p;
    return h.type === "MemberExpression" && h.object === p && (f(h) || r(h) || u(h)) || e(p, m);
  }
  function n(p) {
    let m = p.parent;
    for (; m && m.type !== "AssignmentExpression" && m.type !== "UpdateExpression" && m.type !== "UnaryExpression" && m.type !== "CallExpression" && m.type !== "ForInStatement" && m.type !== "ForOfStatement"; )
      m = m.parent;
    return m || p;
  }
  return jo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow assigning to imported bindings",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-import-assign"
      },
      schema: [],
      messages: {
        readonly: "'{{name}}' is read-only.",
        readonlyMember: "The members of '{{name}}' are read-only."
      }
    },
    create(p) {
      const m = p.sourceCode;
      return {
        ImportDeclaration(h) {
          const l = m.getScope(h);
          for (const s of m.getDeclaredVariables(h)) {
            const c = s.defs.some(
              (d) => d.node.type === "ImportNamespaceSpecifier"
            );
            let g = null;
            for (const d of s.references) {
              const y = d.identifier;
              y !== g && (g = y, d.isWrite() ? p.report({
                node: n(y),
                messageId: "readonly",
                data: { name: y.name }
              }) : c && a(y, l) && p.report({
                node: n(y),
                messageId: "readonlyMember",
                data: { name: y.name }
              }));
            }
          }
        }
      };
    }
  }, jo;
}
var qo, Yd;
function Cx() {
  if (Yd) return qo;
  Yd = 1;
  const i = Re();
  return qo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow inline comments after code",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-inline-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignorePattern: {
              type: "string"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedInlineComment: "Unexpected comment inline with code."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0];
      let r;
      f && f.ignorePattern && (r = new RegExp(f.ignorePattern, "u"));
      function u(e) {
        const a = String(o.lines[e.loc.start.line - 1]), n = String(o.lines[e.loc.end.line - 1]), p = a.slice(0, e.loc.start.column).trim(), m = n.slice(e.loc.end.column).trim(), h = !p, l = !m;
        if (!(h && l) && !(r && r.test(e.value))) {
          if ((h || p === "{") && (l || m === "}")) {
            const s = o.getNodeByRangeIndex(e.range[0]);
            if (s && s.type === "JSXEmptyExpression")
              return;
          }
          i.isDirectiveComment(e) || t.report({
            node: e,
            messageId: "unexpectedInlineComment"
          });
        }
      }
      return {
        Program() {
          o.getAllComments().filter((e) => e.type !== "Shebang").forEach(u);
        }
      };
    }
  }, qo;
}
var $o, Zd;
function vx() {
  if (Zd) return $o;
  Zd = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["Program", "StaticBlock", "ExportNamedDeclaration", "ExportDefaultDeclaration"]), o = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);
  function f(r) {
    let { parent: u } = r;
    for (; u; ) {
      if (u.type === "StaticBlock")
        return "class static block body";
      if (i.isFunction(u))
        return "function body";
      ({ parent: u } = u);
    }
    return "program";
  }
  return $o = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow variable or `function` declarations in nested blocks",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-inner-declarations"
      },
      schema: [
        {
          enum: ["functions", "both"]
        }
      ],
      messages: {
        moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
      }
    },
    create(r) {
      function u(e) {
        const a = e.parent;
        a.type === "BlockStatement" && o.has(a.parent.type) || t.has(a.type) || r.report({
          node: e,
          messageId: "moveDeclToRoot",
          data: {
            type: e.type === "FunctionDeclaration" ? "function" : "variable",
            body: f(e)
          }
        });
      }
      return {
        FunctionDeclaration: u,
        VariableDeclaration(e) {
          r.options[0] === "both" && e.kind === "var" && u(e);
        }
      };
    }
  }, $o;
}
var Go, eE;
function Sx() {
  if (eE) return Go;
  eE = 1;
  const i = rr().RegExpValidator, t = new i(), o = /[dgimsuvy]/gu, f = void 0;
  return Go = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow invalid regular expression strings in `RegExp` constructors",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-invalid-regexp"
      },
      schema: [{
        type: "object",
        properties: {
          allowConstructorFlags: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        additionalProperties: !1
      }],
      messages: {
        regexMessage: "{{message}}."
      }
    },
    create(r) {
      const u = r.options[0];
      let e = null;
      if (u && u.allowConstructorFlags) {
        const l = u.allowConstructorFlags.join("").replace(o, "");
        l && (e = new RegExp(`[${l}]`, "giu"));
      }
      function a(l, s) {
        r.report({
          node: l,
          messageId: "regexMessage",
          data: { message: s }
        });
      }
      function n(l) {
        return l && l.type === "Literal" && typeof l.value == "string";
      }
      function p(l) {
        return l.arguments.length < 2 ? "" : n(l.arguments[1]) ? l.arguments[1].value : null;
      }
      function m(l, s) {
        try {
          return t.validatePattern(l, f, f, s), null;
        } catch (c) {
          return c.message;
        }
      }
      function h(l) {
        if (!l)
          return null;
        try {
          t.validateFlags(l);
        } catch {
          return `Invalid flags supplied to RegExp constructor '${l}'`;
        }
        return l.includes("u") && l.includes("v") ? "Regex 'u' and 'v' flags cannot be used together" : null;
      }
      return {
        "CallExpression, NewExpression"(l) {
          if (l.callee.type !== "Identifier" || l.callee.name !== "RegExp")
            return;
          let s = p(l);
          s && e && (s = s.replace(e, ""));
          let c = h(s);
          if (c) {
            a(l, c);
            return;
          }
          if (!n(l.arguments[0]))
            return;
          const g = l.arguments[0].value;
          c = // If flags are unknown, report the regex only if its pattern is invalid both with and without the "u" flag
          s === null ? m(g, { unicode: !0, unicodeSets: !1 }) && m(g, { unicode: !1, unicodeSets: !0 }) && m(g, { unicode: !1, unicodeSets: !1 }) : m(g, { unicode: s.includes("u"), unicodeSets: s.includes("v") }), c && a(l, c);
        }
      };
    }
  }, Go;
}
var Wo, tE;
function Ax() {
  if (tE) return Wo;
  tE = 1;
  const i = Re();
  function t(o, f) {
    return o.origin === "function" && f.type === "ArrowFunctionExpression";
  }
  return Wo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow use of `this` in contexts where the value of `this` is `undefined`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-invalid-this"
      },
      schema: [
        {
          type: "object",
          properties: {
            capIsConstructor: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedThis: "Unexpected 'this'."
      }
    },
    create(o) {
      const r = (o.options[0] || {}).capIsConstructor !== !1, u = [], e = o.sourceCode;
      return u.getCurrent = function() {
        const a = this[this.length - 1];
        return a.init || (a.init = !0, a.valid = !i.isDefaultThisBinding(
          a.node,
          e,
          { capIsConstructor: r }
        )), a;
      }, {
        onCodePathStart(a, n) {
          if (!t(a, n)) {
            if (a.origin === "program") {
              const p = e.getScope(n), m = o.languageOptions.parserOptions.ecmaFeatures || {};
              u.push({
                init: !0,
                node: n,
                valid: !(n.sourceType === "module" || m.globalReturn && p.childScopes[0].isStrict)
              });
              return;
            }
            u.push({
              init: !e.getScope(n).isStrict,
              node: n,
              valid: !0
            });
          }
        },
        onCodePathEnd(a, n) {
          t(a, n) || u.pop();
        },
        // Reports if `this` of the current context is invalid.
        ThisExpression(a) {
          const n = u.getCurrent();
          n && !n.valid && o.report({
            node: a,
            messageId: "unexpectedThis"
          });
        }
      };
    }
  }, Wo;
}
var Xo, rE;
function Tx() {
  if (rE) return Xo;
  rE = 1;
  const i = Re(), t = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u, o = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu, f = /[\u2028\u2029]/mgu, r = i.createGlobalLinebreakMatcher();
  return Xo = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow irregular whitespace",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-irregular-whitespace"
      },
      schema: [
        {
          type: "object",
          properties: {
            skipComments: {
              type: "boolean",
              default: !1
            },
            skipStrings: {
              type: "boolean",
              default: !0
            },
            skipTemplates: {
              type: "boolean",
              default: !1
            },
            skipRegExps: {
              type: "boolean",
              default: !1
            },
            skipJSXText: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        noIrregularWhitespace: "Irregular whitespace not allowed."
      }
    },
    create(u) {
      let e = [];
      const a = u.options[0] || {}, n = !!a.skipComments, p = a.skipStrings !== !1, m = !!a.skipRegExps, h = !!a.skipTemplates, l = !!a.skipJSXText, s = u.sourceCode, c = s.getAllComments();
      function g(A) {
        const R = A.loc.start, L = A.loc.end;
        e = e.filter(({ loc: { start: _ } }) => _.line < R.line || _.line === R.line && _.column < R.column || _.line === L.line && _.column >= L.column || _.line > L.line);
      }
      function d(A) {
        const R = p && typeof A.value == "string", L = m && !!A.regex;
        (R || L) && t.test(A.raw) && g(A);
      }
      function y(A) {
        typeof A.value.raw == "string" && t.test(A.value.raw) && g(A);
      }
      function v(A) {
        t.test(A.value) && g(A);
      }
      function T(A) {
        t.test(A.raw) && g(A);
      }
      function b(A) {
        s.lines.forEach((L, _) => {
          const I = _ + 1;
          let O;
          for (; (O = o.exec(L)) !== null; )
            e.push({
              node: A,
              messageId: "noIrregularWhitespace",
              loc: {
                start: {
                  line: I,
                  column: O.index
                },
                end: {
                  line: I,
                  column: O.index + O[0].length
                }
              }
            });
        });
      }
      function S(A) {
        const R = s.getText(), L = s.lines, _ = R.match(r);
        let I = -1, O;
        for (; (O = f.exec(R)) !== null; ) {
          const k = _.indexOf(O[0], I + 1) || 0;
          e.push({
            node: A,
            messageId: "noIrregularWhitespace",
            loc: {
              start: {
                line: k + 1,
                column: L[k].length
              },
              end: {
                line: k + 2,
                column: 0
              }
            }
          }), I = k;
        }
      }
      function C() {
      }
      const x = {};
      return t.test(s.getText()) ? (x.Program = function(A) {
        b(A), S(A);
      }, x.Literal = d, x.TemplateElement = h ? y : C, x.JSXText = l ? T : C, x["Program:exit"] = function() {
        n && c.forEach(v), e.forEach((A) => u.report(A));
      }) : x.Program = C, x;
    }
  }, Xo;
}
var zo, nE;
function bx() {
  if (nE) return zo;
  nE = 1;
  const { getStaticPropertyName: i } = Re();
  return zo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of the `__iterator__` property",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-iterator"
      },
      schema: [],
      messages: {
        noIterator: "Reserved name '__iterator__'."
      }
    },
    create(t) {
      return {
        MemberExpression(o) {
          i(o) === "__iterator__" && t.report({
            node: o,
            messageId: "noIterator"
          });
        }
      };
    }
  }, zo;
}
var Ho, sE;
function xx() {
  if (sE) return Ho;
  sE = 1;
  const i = Re();
  return Ho = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow labels that share a name with a variable",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-label-var"
      },
      schema: [],
      messages: {
        identifierClashWithLabel: "Found identifier with same name as label."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r, u) {
        return i.getVariableByName(r, u) !== null;
      }
      return {
        LabeledStatement(r) {
          const u = o.getScope(r);
          f(u, r.label.name) && t.report({
            node: r,
            messageId: "identifierClashWithLabel"
          });
        }
      };
    }
  }, Ho;
}
var Jo, iE;
function Rx() {
  if (iE) return Jo;
  iE = 1;
  const i = Re();
  return Jo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow labeled statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-labels"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowLoop: {
              type: "boolean",
              default: !1
            },
            allowSwitch: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedLabel: "Unexpected labeled statement.",
        unexpectedLabelInBreak: "Unexpected label in break statement.",
        unexpectedLabelInContinue: "Unexpected label in continue statement."
      }
    },
    create(t) {
      const o = t.options[0], f = o && o.allowLoop, r = o && o.allowSwitch;
      let u = null;
      function e(p) {
        return i.isLoop(p) ? "loop" : p.type === "SwitchStatement" ? "switch" : "other";
      }
      function a(p) {
        switch (p) {
          case "loop":
            return f;
          case "switch":
            return r;
          default:
            return !1;
        }
      }
      function n(p) {
        let m = u;
        for (; m; ) {
          if (m.label === p)
            return m.kind;
          m = m.upper;
        }
        return "other";
      }
      return {
        LabeledStatement(p) {
          u = {
            label: p.label.name,
            kind: e(p.body),
            upper: u
          };
        },
        "LabeledStatement:exit"(p) {
          a(u.kind) || t.report({
            node: p,
            messageId: "unexpectedLabel"
          }), u = u.upper;
        },
        BreakStatement(p) {
          p.label && !a(n(p.label.name)) && t.report({
            node: p,
            messageId: "unexpectedLabelInBreak"
          });
        },
        ContinueStatement(p) {
          p.label && !a(n(p.label.name)) && t.report({
            node: p,
            messageId: "unexpectedLabelInContinue"
          });
        }
      };
    }
  }, Jo;
}
var Qo, aE;
function Dx() {
  return aE || (aE = 1, Qo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary nested blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-lone-blocks"
      },
      schema: [],
      messages: {
        redundantBlock: "Block is redundant.",
        redundantNestedBlock: "Nested block is redundant."
      }
    },
    create(i) {
      const t = [];
      let o;
      const f = i.sourceCode;
      function r(a) {
        const n = a.parent.type === "BlockStatement" || a.parent.type === "StaticBlock" ? "redundantNestedBlock" : "redundantBlock";
        i.report({
          node: a,
          messageId: n
        });
      }
      function u(a) {
        return a.parent.type === "BlockStatement" || a.parent.type === "StaticBlock" || a.parent.type === "Program" || // Don't report blocks in switch cases if the block is the only statement of the case.
        a.parent.type === "SwitchCase" && !(a.parent.consequent[0] === a && a.parent.consequent.length === 1);
      }
      function e(a) {
        if (t.length === 0)
          return;
        const n = a.parent;
        t[t.length - 1] === n && t.pop();
      }
      return o = {
        BlockStatement(a) {
          u(a) && r(a);
        }
      }, i.languageOptions.ecmaVersion >= 2015 && (o = {
        BlockStatement(a) {
          u(a) && t.push(a);
        },
        "BlockStatement:exit"(a) {
          t.length > 0 && t[t.length - 1] === a ? (t.pop(), r(a)) : (a.parent.type === "BlockStatement" || a.parent.type === "StaticBlock") && a.parent.body.length === 1 && r(a);
        }
      }, o.VariableDeclaration = function(a) {
        (a.kind === "let" || a.kind === "const") && e(a);
      }, o.FunctionDeclaration = function(a) {
        f.getScope(a).isStrict && e(a);
      }, o.ClassDeclaration = e), o;
    }
  }), Qo;
}
var Yo, oE;
function Lx() {
  return oE || (oE = 1, Yo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `if` statements as the only statement in `else` blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-lonely-if"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
      }
    },
    create(i) {
      const t = i.sourceCode;
      return {
        IfStatement(o) {
          const f = o.parent, r = f.parent;
          f && f.type === "BlockStatement" && f.body.length === 1 && r && r.type === "IfStatement" && f === r.alternate && i.report({
            node: o,
            messageId: "unexpectedLonelyIf",
            fix(u) {
              const e = t.getFirstToken(f), a = t.getLastToken(f), n = t.getTokenBefore(e), p = t.getTokenAfter(a), m = t.getLastToken(o.consequent), h = t.getText();
              return h.slice(
                e.range[1],
                o.range[0]
              ).trim() || h.slice(o.range[1], a.range[0]).trim() || o.consequent.type !== "BlockStatement" && m.value !== ";" && p && (o.consequent.loc.end.line === p.loc.start.line || /^[([/+`-]/u.test(p.value) || m.value === "++" || m.value === "--") ? null : u.replaceTextRange(
                [e.range[0], a.range[1]],
                (n.range[1] === e.range[0] ? " " : "") + t.getText(o)
              );
            }
          });
        }
      };
    }
  }), Yo;
}
var Zo, lE;
function _x() {
  if (lE) return Zo;
  lE = 1;
  function i(f) {
    for (let r = f; r.parent; r = r.parent) {
      const u = r.parent;
      switch (u.type) {
        case "WhileStatement":
        case "DoWhileStatement":
          return u;
        case "ForStatement":
          if (u.init !== r)
            return u;
          break;
        case "ForInStatement":
        case "ForOfStatement":
          if (u.right !== r)
            return u;
          break;
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "FunctionDeclaration":
          return null;
      }
    }
    return null;
  }
  function t(f, r) {
    const u = r ? r.range[1] : 0;
    let e = f, a = f;
    for (; a && a.range[0] >= u; )
      e = a, a = i(a);
    return e;
  }
  function o(f, r) {
    const u = r.resolved, e = u && u.defs[0], a = e && e.parent, n = a && a.type === "VariableDeclaration" ? a.kind : "";
    if (n === "const" || n === "let" && a.range[0] > f.range[0] && a.range[1] < f.range[1])
      return !0;
    const p = t(
      f,
      n === "let" ? a : null
    ).range[0];
    function m(h) {
      const l = h.identifier;
      return !h.isWrite() || u.scope.variableScope === h.from.variableScope && l.range[0] < p;
    }
    return !!u && u.references.every(m);
  }
  return Zo = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow function declarations that contain unsafe references inside loop statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-loop-func"
      },
      schema: [],
      messages: {
        unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
      }
    },
    create(f) {
      const r = f.sourceCode;
      function u(e) {
        const a = i(e);
        if (!a)
          return;
        const p = r.getScope(e).through.filter((m) => m.resolved && !o(a, m)).map((m) => m.identifier.name);
        p.length > 0 && f.report({
          node: e,
          messageId: "unsafeRefs",
          data: { varNames: `'${p.join("', '")}'` }
        });
      }
      return {
        ArrowFunctionExpression: u,
        FunctionExpression: u,
        FunctionDeclaration: u
      };
    }
  }, Zo;
}
var el, uE;
function wx() {
  return uE || (uE = 1, el = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow literal numbers that lose precision",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-loss-of-precision"
      },
      schema: [],
      messages: {
        noLossOfPrecision: "This number literal will lose precision at runtime."
      }
    },
    create(i) {
      function t(s) {
        return typeof s.value == "number";
      }
      function o(s) {
        return s.raw.replace(/_/gu, "");
      }
      function f(s) {
        return ["0x", "0X", "0b", "0B", "0o", "0O"].every((g) => !s.raw.startsWith(g)) && !/^0[0-7]+$/u.test(s.raw);
      }
      function r(s) {
        const c = o(s).toUpperCase();
        let g = 0;
        return c.startsWith("0B") ? g = 2 : c.startsWith("0X") ? g = 16 : g = 8, !c.endsWith(s.value.toString(g).toUpperCase());
      }
      function u(s) {
        return `${s[0]}.${s.slice(1)}`;
      }
      function e(s) {
        for (let c = 0; c < s.length; c++)
          if (s[c] !== "0")
            return s.slice(c);
        return s;
      }
      function a(s) {
        for (let c = s.length - 1; c >= 0; c--)
          if (s[c] !== "0")
            return s.slice(0, c + 1);
        return s;
      }
      function n(s) {
        const c = a(e(s));
        return {
          magnitude: s.startsWith("0") ? s.length - 2 : s.length - 1,
          coefficient: u(c)
        };
      }
      function p(s) {
        const c = e(s);
        if (c.startsWith(".")) {
          const g = c.slice(1), d = e(g);
          return {
            magnitude: d.length - g.length - 1,
            coefficient: u(d)
          };
        }
        return {
          magnitude: c.indexOf(".") - 1,
          coefficient: u(c.replace(".", ""))
        };
      }
      function m(s) {
        const c = s.replace("E", "e").split("e"), g = c[0], d = s.includes(".") ? p(g) : n(g), y = d.coefficient, v = c.length > 1 ? parseInt(c[1], 10) + d.magnitude : d.magnitude;
        return `${y}e${v}`;
      }
      function h(s) {
        const c = m(o(s)), g = c.split("e")[0].replace(".", "").length;
        if (g > 100)
          return !0;
        const d = s.value.toPrecision(g), y = m(d);
        return c !== y;
      }
      function l(s) {
        return f(s) ? h(s) : r(s);
      }
      return {
        Literal(s) {
          s.value && t(s) && l(s) && i.report({
            messageId: "noLossOfPrecision",
            node: s
          });
        }
      };
    }
  }), el;
}
var tl, cE;
function kx() {
  if (cE) return tl;
  cE = 1;
  const i = Re(), t = 2 ** 32 - 1;
  function o(f) {
    return typeof f == "string" ? BigInt(f.slice(0, -1)) : f;
  }
  return tl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow magic numbers",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-magic-numbers"
      },
      schema: [{
        type: "object",
        properties: {
          detectObjects: {
            type: "boolean",
            default: !1
          },
          enforceConst: {
            type: "boolean",
            default: !1
          },
          ignore: {
            type: "array",
            items: {
              anyOf: [
                { type: "number" },
                { type: "string", pattern: "^[+-]?(?:0|[1-9][0-9]*)n$" }
              ]
            },
            uniqueItems: !0
          },
          ignoreArrayIndexes: {
            type: "boolean",
            default: !1
          },
          ignoreDefaultValues: {
            type: "boolean",
            default: !1
          },
          ignoreClassFieldInitialValues: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        useConst: "Number constants declarations must use 'const'.",
        noMagic: "No magic number: {{raw}}."
      }
    },
    create(f) {
      const r = f.options[0] || {}, u = !!r.detectObjects, e = !!r.enforceConst, a = new Set((r.ignore || []).map(o)), n = !!r.ignoreArrayIndexes, p = !!r.ignoreDefaultValues, m = !!r.ignoreClassFieldInitialValues, h = u ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
      function l(v) {
        return a.has(v);
      }
      function s(v) {
        const T = v.parent;
        return T.type === "AssignmentPattern" && T.right === v;
      }
      function c(v) {
        const T = v.parent;
        return T.type === "PropertyDefinition" && T.value === v;
      }
      function g(v) {
        const T = v.parent;
        return T.type === "CallExpression" && v === T.arguments[1] && (i.isSpecificId(T.callee, "parseInt") || i.isSpecificMemberAccess(T.callee, "Number", "parseInt"));
      }
      function d(v) {
        return v.parent.type.indexOf("JSX") === 0;
      }
      function y(v, T) {
        const b = v.parent;
        return b.type === "MemberExpression" && b.property === v && (Number.isInteger(T) || typeof T == "bigint") && T >= 0 && T < t;
      }
      return {
        Literal(v) {
          if (!i.isNumericLiteral(v))
            return;
          let T, b, S;
          v.parent.type === "UnaryExpression" && v.parent.operator === "-" ? (T = v.parent, b = -v.value, S = `-${v.raw}`) : (T = v, b = v.value, S = v.raw);
          const C = T.parent;
          l(b) || p && s(T) || m && c(T) || g(T) || d(T) || n && y(T, b) || (C.type === "VariableDeclarator" ? e && C.parent.kind !== "const" && f.report({
            node: T,
            messageId: "useConst"
          }) : (!h.includes(C.type) || C.type === "AssignmentExpression" && C.left.type === "Identifier") && f.report({
            node: T,
            messageId: "noMagic",
            data: {
              raw: S
            }
          }));
        }
      };
    }
  }, tl;
}
var rl, fE;
function Bx() {
  return fE || (fE = 1, rl = function(t) {
    return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(t));
  }), rl;
}
var nl, pE;
function Px() {
  return pE || (pE = 1, nl = function(t) {
    return t >= 127995 && t <= 127999;
  }), nl;
}
var sl, hE;
function Ix() {
  return hE || (hE = 1, sl = function(t) {
    return t >= 127462 && t <= 127487;
  }), sl;
}
var il, mE;
function Fx() {
  return mE || (mE = 1, il = function(t, o) {
    return t >= 55296 && t < 56320 && o >= 56320 && o < 57344;
  }), il;
}
var al, gE;
function Nx() {
  return gE || (gE = 1, al = {
    isCombiningCharacter: Bx(),
    isEmojiModifier: Px(),
    isRegionalIndicatorSymbol: Ix(),
    isSurrogatePair: Fx()
  }), al;
}
var ol, dE;
function Jf() {
  if (dE) return ol;
  dE = 1;
  const { RegExpValidator: i } = rr(), t = 2024;
  function o(f, r) {
    if (f <= 5)
      return !1;
    const u = new i({
      ecmaVersion: Math.min(f, t)
    });
    try {
      u.validatePattern(r, void 0, void 0, { unicode: (
        /* uFlag = */
        !0
      ) });
    } catch {
      return !1;
    }
    return !0;
  }
  return ol = {
    isValidWithUnicodeFlag: o,
    REGEXPP_LATEST_ECMA_VERSION: t
  }, ol;
}
var ll, EE;
function Ox() {
  if (EE) return ll;
  EE = 1;
  const { CALL: i, CONSTRUCT: t, ReferenceTracker: o, getStringIfConstant: f } = Ft(), { RegExpParser: r, visitRegExpAST: u } = rr(), { isCombiningCharacter: e, isEmojiModifier: a, isRegionalIndicatorSymbol: n, isSurrogatePair: p } = Nx(), m = Re(), { isValidWithUnicodeFlag: h } = Jf();
  function* l(d) {
    let y = [];
    for (const v of d)
      switch (v.type) {
        case "Character":
          y.push(v);
          break;
        case "CharacterClassRange":
          y.push(v.min), yield y, y = [v.max];
          break;
        case "CharacterSet":
        case "CharacterClass":
        case "ClassStringDisjunction":
        case "ExpressionCharacterClass":
          y.length > 0 && (yield y, y = []);
          break;
      }
    y.length > 0 && (yield y);
  }
  function s(d) {
    return /^\\u\{[\da-f]+\}$/iu.test(d.raw);
  }
  const c = {
    surrogatePairWithoutUFlag(d) {
      return d.some((y, v) => {
        if (v === 0)
          return !1;
        const T = d[v - 1];
        return p(T.value, y.value) && !s(T) && !s(y);
      });
    },
    surrogatePair(d) {
      return d.some((y, v) => {
        if (v === 0)
          return !1;
        const T = d[v - 1];
        return p(T.value, y.value) && (s(T) || s(y));
      });
    },
    combiningClass(d) {
      return d.some((y, v) => v !== 0 && e(y.value) && !e(d[v - 1].value));
    },
    emojiModifier(d) {
      return d.some((y, v) => v !== 0 && a(y.value) && !a(d[v - 1].value));
    },
    regionalIndicatorSymbol(d) {
      return d.some((y, v) => v !== 0 && n(y.value) && n(d[v - 1].value));
    },
    zwj(d) {
      const y = d.length - 1;
      return d.some((v, T) => T !== 0 && T !== y && v.value === 8205 && d[T - 1].value !== 8205 && d[T + 1].value !== 8205);
    }
  }, g = Object.keys(c);
  return ll = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow characters which are made with multiple code points in character class syntax",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-misleading-character-class"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
        surrogatePair: "Unexpected surrogate pair in character class.",
        combiningClass: "Unexpected combined character in character class.",
        emojiModifier: "Unexpected modified Emoji in character class.",
        regionalIndicatorSymbol: "Unexpected national flag in character class.",
        zwj: "Unexpected joined character sequence in character class.",
        suggestUnicodeFlag: "Add unicode 'u' flag to regex."
      }
    },
    create(d) {
      const y = d.sourceCode, v = new r();
      function T(b, S, C, x) {
        let A;
        try {
          A = v.parsePattern(
            S,
            0,
            S.length,
            {
              unicode: C.includes("u"),
              unicodeSets: C.includes("v")
            }
          );
        } catch {
          return;
        }
        const R = /* @__PURE__ */ new Set();
        u(A, {
          onCharacterClassEnter(L) {
            for (const _ of l(L.elements))
              for (const I of g)
                c[I](_) && R.add(I);
          }
        });
        for (const L of R) {
          let _;
          L === "surrogatePairWithoutUFlag" && (_ = [{
            messageId: "suggestUnicodeFlag",
            fix: x
          }]), d.report({
            node: b,
            messageId: L,
            suggest: _
          });
        }
      }
      return {
        "Literal[regex]"(b) {
          T(b, b.regex.pattern, b.regex.flags, (S) => h(d.languageOptions.ecmaVersion, b.regex.pattern) ? S.insertTextAfter(b, "u") : null);
        },
        Program(b) {
          const S = y.getScope(b), C = new o(S);
          for (const { node: x } of C.iterateGlobalReferences({
            RegExp: { [i]: !0, [t]: !0 }
          })) {
            const [A, R] = x.arguments, L = f(A, S), _ = f(R, S);
            typeof L == "string" && T(x, L, _ || "", (I) => {
              if (!h(d.languageOptions.ecmaVersion, L))
                return null;
              if (x.arguments.length === 1) {
                const O = y.getLastToken(x, { skip: 1 });
                return I.insertTextAfter(
                  O,
                  m.isCommaToken(O) ? ' "u",' : ', "u"'
                );
              }
              if (R.type === "Literal" && typeof R.value == "string" || R.type === "TemplateLiteral") {
                const O = [R.range[0], R.range[1] - 1];
                return I.insertTextAfterRange(O, "u");
              }
              return null;
            });
          }
        }
      };
    }
  }, ll;
}
var ul, yE;
function Ux() {
  if (yE) return ul;
  yE = 1;
  const i = Re(), t = ["+", "-", "*", "/", "%", "**"], o = ["&", "|", "^", "~", "<<", ">>", ">>>"], f = ["==", "!=", "===", "!==", ">", ">=", "<", "<="], r = ["&&", "||"], u = ["in", "instanceof"], e = ["?:"], a = ["??"], n = [].concat(
    t,
    o,
    f,
    r,
    u,
    e,
    a
  ), p = [
    t,
    o,
    f,
    r,
    u
  ], m = /^(?:Binary|Logical|Conditional)Expression$/u;
  function h(c = {}) {
    const d = c.groups && c.groups.length > 0 ? c.groups : p, y = c.allowSamePrecedence !== !1;
    return {
      groups: d,
      allowSamePrecedence: y
    };
  }
  function l(c, g, d) {
    return c.some((y) => y.includes(g) && y.includes(d));
  }
  function s(c) {
    return c.type === "ConditionalExpression" ? c.test : c.left;
  }
  return ul = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow mixed binary operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-mixed-operators"
      },
      schema: [
        {
          type: "object",
          properties: {
            groups: {
              type: "array",
              items: {
                type: "array",
                items: { enum: n },
                minItems: 2,
                uniqueItems: !0
              },
              uniqueItems: !0
            },
            allowSamePrecedence: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations."
      }
    },
    create(c) {
      const g = c.sourceCode, d = h(c.options[0]);
      function y(C) {
        const x = C, A = C.parent;
        return !l(d.groups, x.operator, A.type === "ConditionalExpression" ? "?:" : A.operator) || d.allowSamePrecedence && i.getPrecedence(x) === i.getPrecedence(A);
      }
      function v(C) {
        return C.operator !== C.parent.operator && !i.isParenthesised(g, C);
      }
      function T(C) {
        return g.getTokenAfter(s(C), i.isNotClosingParenToken);
      }
      function b(C) {
        const x = C.parent, A = s(x) === C ? C : x, R = s(x) !== C ? C : x, L = {
          leftOperator: A.operator || "?:",
          rightOperator: R.operator || "?:"
        };
        c.report({
          node: A,
          loc: T(A).loc,
          messageId: "unexpectedMixedOperator",
          data: L
        }), c.report({
          node: R,
          loc: T(R).loc,
          messageId: "unexpectedMixedOperator",
          data: L
        });
      }
      function S(C) {
        m.test(C.parent.type) && v(C) && !y(C) && b(C);
      }
      return {
        BinaryExpression: S,
        LogicalExpression: S
      };
    }
  }, ul;
}
var cl, CE;
function Vx() {
  return CE || (CE = 1, cl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow `require` calls to be mixed with regular variable declarations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-mixed-requires"
      },
      schema: [
        {
          oneOf: [
            {
              type: "boolean"
            },
            {
              type: "object",
              properties: {
                grouping: {
                  type: "boolean"
                },
                allowCall: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        noMixRequire: "Do not mix 'require' and other declarations.",
        noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
      }
    },
    create(i) {
      const t = i.options[0];
      let o = !1, f = !1;
      typeof t == "object" ? (o = t.grouping, f = t.allowCall) : o = !!t;
      function r() {
        return [
          "assert",
          "buffer",
          "child_process",
          "cluster",
          "crypto",
          "dgram",
          "dns",
          "domain",
          "events",
          "fs",
          "http",
          "https",
          "net",
          "os",
          "path",
          "punycode",
          "querystring",
          "readline",
          "repl",
          "smalloc",
          "stream",
          "string_decoder",
          "tls",
          "tty",
          "url",
          "util",
          "v8",
          "vm",
          "zlib"
        ];
      }
      const u = r(), e = "require", a = "uninitialized", n = "other", p = "core", m = "file", h = "module", l = "computed";
      function s(y) {
        return y ? y.type === "CallExpression" && y.callee.type === "Identifier" && y.callee.name === "require" ? e : f && y.type === "CallExpression" && y.callee.type === "CallExpression" ? s(y.callee) : y.type === "MemberExpression" ? s(y.object) : n : a;
      }
      function c(y) {
        if (y.type === "MemberExpression")
          return c(y.object);
        if (y.arguments.length === 0)
          return l;
        const v = y.arguments[0];
        return v.type !== "Literal" || typeof v.value != "string" ? l : u.includes(v.value) ? p : /^\.{0,2}\//u.test(v.value) ? m : h;
      }
      function g(y) {
        const v = {};
        return y.forEach((T) => {
          const b = s(T.init);
          v[b] = !0;
        }), !!(v[e] && (v[a] || v[n]));
      }
      function d(y) {
        const v = {};
        return y.forEach((T) => {
          s(T.init) === e && (v[c(T.init)] = !0);
        }), Object.keys(v).length <= 1;
      }
      return {
        VariableDeclaration(y) {
          g(y.declarations) ? i.report({
            node: y,
            messageId: "noMixRequire"
          }) : o && !d(y.declarations) && i.report({
            node: y,
            messageId: "noMixCoreModuleFileComputed"
          });
        }
      };
    }
  }), cl;
}
var fl, vE;
function Mx() {
  return vE || (vE = 1, fl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow mixed spaces and tabs for indentation",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-mixed-spaces-and-tabs"
      },
      schema: [
        {
          enum: ["smart-tabs", !0, !1]
        }
      ],
      messages: {
        mixedSpacesAndTabs: "Mixed spaces and tabs."
      }
    },
    create(i) {
      const t = i.sourceCode;
      let o;
      switch (i.options[0]) {
        case !0:
        case "smart-tabs":
          o = !0;
          break;
        default:
          o = !1;
      }
      return {
        "Program:exit"(f) {
          const r = t.lines, u = t.getAllComments(), e = /* @__PURE__ */ new Set();
          u.forEach((n) => {
            for (let p = n.loc.start.line + 1; p <= n.loc.end.line; p++)
              e.add(p);
          });
          let a = /^(?=( +|\t+))\1(?:\t| )/u;
          o && (a = /^(?=(\t*))\1(?=( +))\2\t/u), r.forEach((n, p) => {
            const m = a.exec(n);
            if (m) {
              const h = p + 1, l = {
                start: {
                  line: h,
                  column: m[0].length - 2
                },
                end: {
                  line: h,
                  column: m[0].length
                }
              };
              if (!e.has(h)) {
                const s = t.getNodeByRangeIndex(t.getIndexFromLoc(l.start));
                s && ["Literal", "TemplateElement"].includes(s.type) || i.report({
                  node: f,
                  loc: l,
                  messageId: "mixedSpacesAndTabs"
                });
              }
            }
          });
        }
      };
    }
  }), fl;
}
var pl, SE;
function Kx() {
  return SE || (SE = 1, pl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow use of chained assignment expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-multi-assign"
      },
      schema: [{
        type: "object",
        properties: {
          ignoreNonDeclaration: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        unexpectedChain: "Unexpected chained assignment."
      }
    },
    create(i) {
      const t = i.options[0] || {
        ignoreNonDeclaration: !1
      }, o = [
        "VariableDeclarator > AssignmentExpression.init",
        "PropertyDefinition > AssignmentExpression.value"
      ];
      return t.ignoreNonDeclaration || o.push("AssignmentExpression > AssignmentExpression.right"), {
        [o](f) {
          i.report({
            node: f,
            messageId: "unexpectedChain"
          });
        }
      };
    }
  }), pl;
}
var hl, AE;
function jx() {
  if (AE) return hl;
  AE = 1;
  const i = Re();
  return hl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow multiple spaces",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-multi-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              patternProperties: {
                "^([A-Z][a-z]*)+$": {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            },
            ignoreEOLComments: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || {}, r = f.ignoreEOLComments, u = Object.assign({ Property: !0 }, f.exceptions), e = Object.keys(u).some((n) => u[n]);
      function a(n) {
        const p = n.value.split(`
`), m = p[0], h = `${m.slice(0, 12)}...`;
        return p.length === 1 && m.length <= 12 ? m : h;
      }
      return {
        Program() {
          o.tokensAndComments.forEach((n, p, m) => {
            if (p === m.length - 1)
              return;
            const h = m[p + 1];
            if (!o.text.slice(n.range[1], h.range[0]).includes("  ") || n.loc.end.line < h.loc.start.line || r && i.isCommentToken(h) && (p === m.length - 2 || h.loc.end.line < m[p + 2].loc.start.line))
              return;
            if (e) {
              const s = o.getNodeByRangeIndex(h.range[0] - 1);
              if (s && u[s.type])
                return;
            }
            let l;
            h.type === "Block" ? l = `/*${a(h)}*/` : h.type === "Line" ? l = `//${a(h)}` : l = h.value, t.report({
              node: h,
              loc: { start: n.loc.end, end: h.loc.start },
              messageId: "multipleSpaces",
              data: { displayValue: l },
              fix: (s) => s.replaceTextRange([n.range[1], h.range[0]], " ")
            });
          });
        }
      };
    }
  }, hl;
}
var ml, TE;
function qx() {
  if (TE) return ml;
  TE = 1;
  const i = Re();
  return ml = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow multiline strings",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-multi-str"
      },
      schema: [],
      messages: {
        multilineString: "Multiline support is limited to browsers supporting ES5 only."
      }
    },
    create(t) {
      function o(f) {
        return f.type.indexOf("JSX") === 0;
      }
      return {
        Literal(f) {
          i.LINEBREAK_MATCHER.test(f.raw) && !o(f.parent) && t.report({
            node: f,
            messageId: "multilineString"
          });
        }
      };
    }
  }, ml;
}
var gl, bE;
function $x() {
  return bE || (bE = 1, gl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow multiple empty lines",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-multiple-empty-lines"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 0
            },
            maxEOF: {
              type: "integer",
              minimum: 0
            },
            maxBOF: {
              type: "integer",
              minimum: 0
            }
          },
          required: ["max"],
          additionalProperties: !1
        }
      ],
      messages: {
        blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
        blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
        consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
      }
    },
    create(i) {
      let t = 2, o = t, f = t;
      i.options.length && (t = i.options[0].max, o = typeof i.options[0].maxEOF < "u" ? i.options[0].maxEOF : t, f = typeof i.options[0].maxBOF < "u" ? i.options[0].maxBOF : t);
      const r = i.sourceCode, u = r.lines[r.lines.length - 1] === "" ? r.lines.slice(0, -1) : r.lines, e = /* @__PURE__ */ new Set();
      return {
        TemplateLiteral(a) {
          a.quasis.forEach((n) => {
            for (let p = n.loc.start.line; p < n.loc.end.line; p++)
              e.add(p);
          });
        },
        "Program:exit"(a) {
          return u.reduce((n, p, m) => ((p.trim() || e.has(m + 1)) && n.push(m + 1), n), []).concat(u.length + 1).reduce((n, p) => {
            let m, h;
            return n === 0 ? (m = "blankBeginningOfFile", h = f) : p === u.length + 1 ? (m = "blankEndOfFile", h = o) : (m = "consecutiveBlank", h = t), p - n - 1 > h && i.report({
              node: a,
              loc: {
                start: { line: n + h + 1, column: 0 },
                end: { line: p, column: 0 }
              },
              messageId: m,
              data: {
                max: h,
                pluralizedLines: h === 1 ? "line" : "lines"
              },
              fix(l) {
                const s = r.getIndexFromLoc({ line: n + 1, column: 0 }), c = p - h, g = c <= u.length ? r.getIndexFromLoc({ line: c, column: 0 }) : r.text.length;
                return l.removeRange([s, g]);
              }
            }), p;
          }, 0);
        }
      };
    }
  }), gl;
}
var dl, xE;
function Gx() {
  return xE || (xE = 1, dl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow assignments to native objects or read-only global variables",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-native-reassign"
      },
      deprecated: !0,
      replacedBy: ["no-global-assign"],
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        nativeReassign: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(i) {
      const t = i.options[0], o = t && t.exceptions || [], f = i.sourceCode;
      function r(e, a, n) {
        const p = e.identifier;
        e.init === !1 && e.isWrite() && /*
        * Destructuring assignments can have multiple default value,
        * so possibly there are multiple writeable references for the same identifier.
        */
        (a === 0 || n[a - 1].identifier !== p) && i.report({
          node: p,
          messageId: "nativeReassign",
          data: p
        });
      }
      function u(e) {
        e.writeable === !1 && !o.includes(e.name) && e.references.forEach(r);
      }
      return {
        Program(e) {
          f.getScope(e).variables.forEach(u);
        }
      };
    }
  }), dl;
}
var El, RE;
function Wx() {
  return RE || (RE = 1, El = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow negated conditions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-negated-condition"
      },
      schema: [],
      messages: {
        unexpectedNegated: "Unexpected negated condition."
      }
    },
    create(i) {
      function t(u) {
        return u.alternate && u.alternate.type !== "IfStatement";
      }
      function o(u) {
        return u.type === "UnaryExpression" && u.operator === "!";
      }
      function f(u) {
        return u.type === "BinaryExpression" && (u.operator === "!=" || u.operator === "!==");
      }
      function r(u) {
        return o(u.test) || f(u.test);
      }
      return {
        IfStatement(u) {
          t(u) && r(u) && i.report({
            node: u,
            messageId: "unexpectedNegated"
          });
        },
        ConditionalExpression(u) {
          r(u) && i.report({
            node: u,
            messageId: "unexpectedNegated"
          });
        }
      };
    }
  }), El;
}
var yl, DE;
function Xx() {
  return DE || (DE = 1, yl = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow negating the left operand in `in` expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-negated-in-lhs"
      },
      replacedBy: ["no-unsafe-negation"],
      deprecated: !0,
      schema: [],
      messages: {
        negatedLHS: "The 'in' expression's left operand is negated."
      }
    },
    create(i) {
      return {
        BinaryExpression(t) {
          t.operator === "in" && t.left.type === "UnaryExpression" && t.left.operator === "!" && i.report({ node: t, messageId: "negatedLHS" });
        }
      };
    }
  }), yl;
}
var Cl, LE;
function zx() {
  return LE || (LE = 1, Cl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow nested ternary expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-nested-ternary"
      },
      schema: [],
      messages: {
        noNestedTernary: "Do not nest ternary expressions."
      }
    },
    create(i) {
      return {
        ConditionalExpression(t) {
          (t.alternate.type === "ConditionalExpression" || t.consequent.type === "ConditionalExpression") && i.report({
            node: t,
            messageId: "noNestedTernary"
          });
        }
      };
    }
  }), Cl;
}
var vl, _E;
function Hx() {
  return _E || (_E = 1, vl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators outside of assignments or comparisons",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new"
      },
      schema: [],
      messages: {
        noNewStatement: "Do not use 'new' for side effects."
      }
    },
    create(i) {
      return {
        "ExpressionStatement > NewExpression"(t) {
          i.report({
            node: t.parent,
            messageId: "noNewStatement"
          });
        }
      };
    }
  }), vl;
}
var Sl, wE;
function Jx() {
  if (wE) return Sl;
  wE = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["apply", "bind", "call"]);
  return Sl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with the `Function` object",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new-func"
      },
      schema: [],
      messages: {
        noFunctionConstructor: "The Function constructor is eval."
      }
    },
    create(o) {
      const f = o.sourceCode;
      return {
        "Program:exit"(r) {
          const e = f.getScope(r).set.get("Function");
          e && e.defs.length === 0 && e.references.forEach((a) => {
            const n = a.identifier, { parent: p } = n;
            let m;
            if (p) {
              if (n === p.callee && (p.type === "NewExpression" || p.type === "CallExpression"))
                m = p;
              else if (p.type === "MemberExpression" && n === p.object && t.has(i.getStaticPropertyName(p))) {
                const h = p.parent.type === "ChainExpression" ? p.parent : p;
                h.parent.type === "CallExpression" && h.parent.callee === h && (m = h.parent);
              }
            }
            m && o.report({
              node: m,
              messageId: "noFunctionConstructor"
            });
          });
        }
      };
    }
  }, Sl;
}
var Al, kE;
function Qx() {
  if (kE) return Al;
  kE = 1;
  const i = ["Symbol", "BigInt"];
  return Al = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `new` operators with global non-constructor functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new-native-nonconstructor"
      },
      schema: [],
      messages: {
        noNewNonconstructor: "`{{name}}` cannot be called as a constructor."
      }
    },
    create(t) {
      const o = t.sourceCode;
      return {
        "Program:exit"(f) {
          const r = o.getScope(f);
          for (const u of i) {
            const e = r.set.get(u);
            e && e.defs.length === 0 && e.references.forEach((a) => {
              const n = a.identifier, p = n.parent;
              p && p.type === "NewExpression" && p.callee === n && t.report({
                node: n,
                messageId: "noNewNonconstructor",
                data: { name: u }
              });
            });
          }
        }
      };
    }
  }, Al;
}
var Tl, BE;
function Yx() {
  if (BE) return Tl;
  BE = 1;
  const i = Re();
  return Tl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `Object` constructors",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new-object"
      },
      deprecated: !0,
      replacedBy: [
        "no-object-constructor"
      ],
      schema: [],
      messages: {
        preferLiteral: "The object literal notation {} is preferable."
      }
    },
    create(t) {
      const o = t.sourceCode;
      return {
        NewExpression(f) {
          const r = i.getVariableByName(
            o.getScope(f),
            f.callee.name
          );
          r && r.identifiers.length > 0 || f.callee.name === "Object" && t.report({
            node: f,
            messageId: "preferLiteral"
          });
        }
      };
    }
  }, Tl;
}
var bl, PE;
function Zx() {
  return PE || (PE = 1, bl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with calls to `require`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new-require"
      },
      schema: [],
      messages: {
        noNewRequire: "Unexpected use of new with require."
      }
    },
    create(i) {
      return {
        NewExpression(t) {
          t.callee.type === "Identifier" && t.callee.name === "require" && i.report({
            node: t,
            messageId: "noNewRequire"
          });
        }
      };
    }
  }), bl;
}
var xl, IE;
function eR() {
  return IE || (IE = 1, xl = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `new` operators with the `Symbol` object",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-new-symbol"
      },
      schema: [],
      messages: {
        noNewSymbol: "`Symbol` cannot be called as a constructor."
      }
    },
    create(i) {
      const t = i.sourceCode;
      return {
        "Program:exit"(o) {
          const r = t.getScope(o).set.get("Symbol");
          r && r.defs.length === 0 && r.references.forEach((u) => {
            const e = u.identifier, a = e.parent;
            a && a.type === "NewExpression" && a.callee === e && i.report({
              node: e,
              messageId: "noNewSymbol"
            });
          });
        }
      };
    }
  }), xl;
}
var Rl, FE;
function tR() {
  if (FE) return Rl;
  FE = 1;
  const { getVariableByName: i } = Re();
  return Rl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-new-wrappers"
      },
      schema: [],
      messages: {
        noConstructor: "Do not use {{fn}} as a constructor."
      }
    },
    create(t) {
      const { sourceCode: o } = t;
      return {
        NewExpression(f) {
          const r = ["String", "Number", "Boolean"], { name: u } = f.callee;
          if (r.includes(u)) {
            const e = i(o.getScope(f), u);
            e && e.identifiers.length === 0 && t.report({
              node: f,
              messageId: "noConstructor",
              data: { fn: u }
            });
          }
        }
      };
    }
  }, Rl;
}
var Dl, NE;
function rR() {
  if (NE) return Dl;
  NE = 1;
  const i = /\\[89]/u;
  function t(o) {
    return `\\u${o.charCodeAt(0).toString(16).padStart(4, "0")}`;
  }
  return Dl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `\\8` and `\\9` escape sequences in string literals",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-nonoctal-decimal-escape"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
        // suggestions
        refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
        escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
      }
    },
    create(o) {
      const f = o.sourceCode;
      function r(u, e, a) {
        return {
          messageId: u,
          data: {
            original: f.getText().slice(...e),
            replacement: a
          },
          fix(n) {
            return n.replaceTextRange(e, a);
          }
        };
      }
      return {
        Literal(u) {
          if (typeof u.value != "string" || !i.test(u.raw))
            return;
          const e = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy;
          let a;
          for (; a = e.exec(u.raw); ) {
            const { previousEscape: n, decimalEscape: p } = a.groups, m = u.range[0] + a.index + a[0].length, h = m - p.length, l = [h, m], s = [];
            n === "\\0" ? s.push(
              r(
                // "\0\8" -> "\u00008"
                "refactor",
                [h - n.length, m],
                `${t("\0")}${p[1]}`
              ),
              r(
                // "\8" -> "\u0038"
                "refactor",
                l,
                t(p[1])
              )
            ) : s.push(
              r(
                // "\8" -> "8"
                "refactor",
                l,
                p[1]
              )
            ), s.push(
              r(
                // "\8" -> "\\8"
                "escapeBackslash",
                l,
                `\\${p}`
              )
            ), o.report({
              node: u,
              loc: {
                start: f.getLocFromIndex(h),
                end: f.getLocFromIndex(m)
              },
              messageId: "decimalEscape",
              data: {
                decimalEscape: p
              },
              suggest: s
            });
          }
        }
      };
    }
  }, Dl;
}
var Ll, OE;
function nR() {
  if (OE) return Ll;
  OE = 1;
  const { CALL: i, CONSTRUCT: t, ReferenceTracker: o } = Ft(), f = Re().getStaticPropertyName, r = ["Atomics", "JSON", "Math", "Reflect", "Intl"];
  function u(e) {
    return e.type === "ChainExpression" ? u(e.expression) : e.type === "MemberExpression" ? f(e) : e.name;
  }
  return Ll = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow calling global object properties as functions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-obj-calls"
      },
      schema: [],
      messages: {
        unexpectedCall: "'{{name}}' is not a function.",
        unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
      }
    },
    create(e) {
      const a = e.sourceCode;
      return {
        Program(n) {
          const p = a.getScope(n), m = new o(p), h = {};
          for (const l of r)
            h[l] = {
              [i]: !0,
              [t]: !0
            };
          for (const { node: l, path: s } of m.iterateGlobalReferences(h)) {
            const c = u(l.callee), g = s[0], d = c === g ? "unexpectedCall" : "unexpectedRefCall";
            e.report({ node: l, messageId: d, data: { name: c, ref: g } });
          }
        }
      };
    }
  }, Ll;
}
var _l, UE;
function sR() {
  if (UE) return _l;
  UE = 1;
  const {
    getVariableByName: i,
    isArrowToken: t,
    isStartOfExpressionStatement: o,
    needsPrecedingSemicolon: f
  } = Re();
  return _l = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow calls to the `Object` constructor without an argument",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-object-constructor"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        preferLiteral: "The object literal notation {} is preferable.",
        useLiteral: "Replace with '{{replacement}}'.",
        useLiteralAfterSemicolon: "Replace with '{{replacement}}', add preceding semicolon."
      }
    },
    create(r) {
      const u = r.sourceCode;
      function e(n) {
        if (o(n))
          return !0;
        const p = u.getTokenBefore(n);
        return !!(p && t(p));
      }
      function a(n) {
        if (n.callee.type !== "Identifier" || n.callee.name !== "Object" || n.arguments.length)
          return;
        const p = i(u.getScope(n), "Object");
        if (p && p.identifiers.length === 0) {
          let m, h, l = "useLiteral";
          e(n) ? (m = "({})", f(u, n) ? (h = ";({})", l = "useLiteralAfterSemicolon") : h = "({})") : m = h = "{}", r.report({
            node: n,
            messageId: "preferLiteral",
            suggest: [
              {
                messageId: l,
                data: { replacement: m },
                fix: (s) => s.replaceText(n, h)
              }
            ]
          });
        }
      }
      return {
        CallExpression: a,
        NewExpression: a
      };
    }
  }, _l;
}
var wl, VE;
function iR() {
  return VE || (VE = 1, wl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow octal literals",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-octal"
      },
      schema: [],
      messages: {
        noOctal: "Octal literals should not be used."
      }
    },
    create(i) {
      return {
        Literal(t) {
          typeof t.value == "number" && /^0[0-9]/u.test(t.raw) && i.report({
            node: t,
            messageId: "noOctal"
          });
        }
      };
    }
  }), wl;
}
var kl, ME;
function aR() {
  return ME || (ME = 1, kl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow octal escape sequences in string literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-octal-escape"
      },
      schema: [],
      messages: {
        octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
      }
    },
    create(i) {
      return {
        Literal(t) {
          if (typeof t.value != "string")
            return;
          const o = t.raw.match(
            /^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su
          );
          o && i.report({
            node: t,
            messageId: "octalEscapeSequence",
            data: { sequence: o[1] }
          });
        }
      };
    }
  }), kl;
}
var Bl, KE;
function oR() {
  if (KE) return Bl;
  KE = 1;
  const i = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
  return Bl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow reassigning `function` parameters",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-param-reassign"
      },
      schema: [
        {
          oneOf: [
            {
              type: "object",
              properties: {
                props: {
                  enum: [!1]
                }
              },
              additionalProperties: !1
            },
            {
              type: "object",
              properties: {
                props: {
                  enum: [!0]
                },
                ignorePropertyModificationsFor: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: !0
                },
                ignorePropertyModificationsForRegex: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: !0
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
        assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
      }
    },
    create(t) {
      const o = t.options[0] && t.options[0].props, f = t.options[0] && t.options[0].ignorePropertyModificationsFor || [], r = t.options[0] && t.options[0].ignorePropertyModificationsForRegex || [], u = t.sourceCode;
      function e(h) {
        let l = h.identifier, s = l.parent;
        for (; s && (!i.test(s.type) || s.type === "ForInStatement" || s.type === "ForOfStatement"); ) {
          switch (s.type) {
            case "AssignmentExpression":
              return s.left === l;
            case "UpdateExpression":
              return !0;
            case "UnaryExpression":
              if (s.operator === "delete")
                return !0;
              break;
            case "ForInStatement":
            case "ForOfStatement":
              return s.left === l;
            case "CallExpression":
              if (s.callee !== l)
                return !1;
              break;
            case "MemberExpression":
              if (s.property === l)
                return !1;
              break;
            case "Property":
              if (s.key === l)
                return !1;
              break;
            case "ConditionalExpression":
              if (s.test === l)
                return !1;
              break;
          }
          l = s, s = l.parent;
        }
        return !1;
      }
      function a(h) {
        return f.includes(h) || r.some((l) => new RegExp(l, "u").test(h));
      }
      function n(h, l, s) {
        const c = h.identifier;
        c && !h.init && /*
        * Destructuring assignments can have multiple default value,
        * so possibly there are multiple writeable references for the same identifier.
        */
        (l === 0 || s[l - 1].identifier !== c) && (h.isWrite() ? t.report({
          node: c,
          messageId: "assignmentToFunctionParam",
          data: { name: c.name }
        }) : o && e(h) && !a(c.name) && t.report({
          node: c,
          messageId: "assignmentToFunctionParamProp",
          data: { name: c.name }
        }));
      }
      function p(h) {
        h.defs[0].type === "Parameter" && h.references.forEach(n);
      }
      function m(h) {
        u.getDeclaredVariables(h).forEach(p);
      }
      return {
        // `:exit` is needed for the `node.parent` property of identifier nodes.
        "FunctionDeclaration:exit": m,
        "FunctionExpression:exit": m,
        "ArrowFunctionExpression:exit": m
      };
    }
  }, Bl;
}
var Pl, jE;
function lR() {
  return jE || (jE = 1, Pl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow string concatenation with `__dirname` and `__filename`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-path-concat"
      },
      schema: [],
      messages: {
        usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
      }
    },
    create(i) {
      const t = /^__(?:dir|file)name$/u;
      return {
        BinaryExpression(o) {
          const f = o.left, r = o.right;
          o.operator === "+" && (f.type === "Identifier" && t.test(f.name) || r.type === "Identifier" && t.test(r.name)) && i.report({
            node: o,
            messageId: "usePathFunctions"
          });
        }
      };
    }
  }), Pl;
}
var Il, qE;
function uR() {
  if (qE) return Il;
  qE = 1;
  function i(o) {
    const f = o.parent;
    return f.type === "ForStatement" && f.update === o;
  }
  function t(o) {
    const f = o.parent;
    return f.type === "SequenceExpression" ? t(f) : i(o);
  }
  return Il = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the unary operators `++` and `--`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-plusplus"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowForLoopAfterthoughts: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedUnaryOp: "Unary operator '{{operator}}' used."
      }
    },
    create(o) {
      const f = o.options[0];
      let r = !1;
      return typeof f == "object" && (r = f.allowForLoopAfterthoughts === !0), {
        UpdateExpression(u) {
          r && t(u) || o.report({
            node: u,
            messageId: "unexpectedUnaryOp",
            data: {
              operator: u.operator
            }
          });
        }
      };
    }
  }, Il;
}
var Fl, $E;
function cR() {
  return $E || ($E = 1, Fl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow the use of `process.env`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-process-env"
      },
      schema: [],
      messages: {
        unexpectedProcessEnv: "Unexpected use of process.env."
      }
    },
    create(i) {
      return {
        MemberExpression(t) {
          const o = t.object.name, f = t.property.name;
          o === "process" && !t.computed && f && f === "env" && i.report({ node: t, messageId: "unexpectedProcessEnv" });
        }
      };
    }
  }), Fl;
}
var Nl, GE;
function fR() {
  return GE || (GE = 1, Nl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow the use of `process.exit()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-process-exit"
      },
      schema: [],
      messages: {
        noProcessExit: "Don't use process.exit(); throw an error instead."
      }
    },
    create(i) {
      return {
        "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(t) {
          i.report({ node: t.parent, messageId: "noProcessExit" });
        }
      };
    }
  }), Nl;
}
var Ol, WE;
function pR() {
  if (WE) return Ol;
  WE = 1;
  const { findVariable: i } = Ft(), t = Re(), o = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]);
  function f(p, m) {
    const h = i(m, p);
    return h !== null && h.scope.type === "global" && h.defs.length === 0;
  }
  function r(p) {
    const m = p.upper;
    return m.type === "function-expression-name" ? m.upper : m;
  }
  function u(p, m) {
    const h = p.parent;
    return h.type === "NewExpression" && h.arguments[0] === p && h.callee.type === "Identifier" && h.callee.name === "Promise" && f(h.callee, r(m));
  }
  function e(p) {
    return p.type === "UnaryExpression" && p.operator === "void";
  }
  function a(p, m, h) {
    const l = (
      // prepending `void ` will fail if the node has a lower precedence than void
      t.getPrecedence(m) < t.getPrecedence({ type: "UnaryExpression", operator: "void" }) && // check if there are parentheses around the node to avoid redundant parentheses
      !t.isParenthesised(p, m)
    ), s = p.getTokenBefore(
      m,
      m.parent.type === "ArrowFunctionExpression" ? t.isArrowToken : (d) => d.type === "Keyword" && d.value === "return"
    ), c = p.getTokenAfter(s), g = (
      // is return token, as => allows void to be adjacent
      s.value === "return" && // If two tokens (return and "(") are adjacent
      s.range[1] === c.range[0]
    );
    return [
      h.insertTextBefore(c, `${g ? " " : ""}void ${l ? "(" : ""}`),
      h.insertTextAfter(m, l ? ")" : "")
    ];
  }
  function n(p, m, h) {
    const l = p.getTokenBefore(m.body, t.isArrowToken), s = p.getTokenAfter(l), c = p.getLastToken(m);
    return [
      h.insertTextBefore(s, "{"),
      h.insertTextAfter(c, "}")
    ];
  }
  return Ol = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow returning values from Promise executor functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-promise-executor-return"
      },
      hasSuggestions: !0,
      schema: [{
        type: "object",
        properties: {
          allowVoid: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        returnsValue: "Return values from promise executor functions cannot be read.",
        // arrow and function suggestions
        prependVoid: "Prepend `void` to the expression.",
        // only arrow suggestions
        wrapBraces: "Wrap the expression in `{}`."
      }
    },
    create(p) {
      let m = null;
      const h = p.sourceCode, {
        allowVoid: l = !1
      } = p.options[0] || {};
      return {
        onCodePathStart(s, c) {
          if (m = {
            upper: m,
            shouldCheck: o.has(c.type) && u(c, h.getScope(c))
          }, // Is a Promise executor
          m.shouldCheck && c.type === "ArrowFunctionExpression" && c.expression && // Except void
          !(l && e(c.body))) {
            const g = [];
            l && g.push({
              messageId: "prependVoid",
              fix(d) {
                return a(h, c.body, d);
              }
            }), c.body.type === "FunctionExpression" && !c.body.id || g.push({
              messageId: "wrapBraces",
              fix(d) {
                return n(h, c, d);
              }
            }), p.report({
              node: c.body,
              messageId: "returnsValue",
              suggest: g
            });
          }
        },
        onCodePathEnd() {
          m = m.upper;
        },
        ReturnStatement(s) {
          if (m.shouldCheck && s.argument) {
            if (!l) {
              p.report({ node: s, messageId: "returnsValue" });
              return;
            }
            e(s.argument) || p.report({
              node: s,
              messageId: "returnsValue",
              suggest: [{
                messageId: "prependVoid",
                fix(c) {
                  return a(h, s.argument, c);
                }
              }]
            });
          }
        }
      };
    }
  }, Ol;
}
var Ul, XE;
function hR() {
  if (XE) return Ul;
  XE = 1;
  const { getStaticPropertyName: i } = Re();
  return Ul = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of the `__proto__` property",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-proto"
      },
      schema: [],
      messages: {
        unexpectedProto: "The '__proto__' property is deprecated."
      }
    },
    create(t) {
      return {
        MemberExpression(o) {
          i(o) === "__proto__" && t.report({ node: o, messageId: "unexpectedProto" });
        }
      };
    }
  }, Ul;
}
var Vl, zE;
function mR() {
  if (zE) return Vl;
  zE = 1;
  const i = Re();
  function t(o) {
    let f;
    if (o.type === "MemberExpression")
      f = o.object;
    else if (o.type === "CallExpression")
      f = o.callee;
    else
      return !1;
    return o.optional ? !0 : t(f);
  }
  return Vl = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow calling some `Object.prototype` methods directly on objects",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-prototype-builtins"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object.",
        callObjectPrototype: "Call Object.prototype.{{prop}} explicitly."
      }
    },
    create(o) {
      const f = /* @__PURE__ */ new Set([
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable"
      ]);
      function r(u) {
        const e = i.skipChainExpression(u.callee);
        if (e.type !== "MemberExpression")
          return;
        const a = i.getStaticPropertyName(e);
        a !== null && f.has(a) && o.report({
          messageId: "prototypeBuildIn",
          loc: e.property.loc,
          data: { prop: a },
          node: u,
          suggest: [
            {
              messageId: "callObjectPrototype",
              data: { prop: a },
              fix(n) {
                const p = o.sourceCode;
                if (t(u) || u.callee.type === "ChainExpression")
                  return null;
                const m = i.getVariableByName(p.getScope(u), "Object");
                if (!m || m.scope.type !== "global" || m.defs.length > 0)
                  return null;
                let h = p.getText(e.object);
                i.getPrecedence(e.object) <= i.getPrecedence({ type: "SequenceExpression" }) && (h = `(${h})`);
                const l = p.getTokenAfter(
                  u.callee,
                  i.isOpeningParenToken
                ), c = u.arguments.length === 0 ? "" : ", ";
                return [
                  n.replaceText(e, `Object.prototype.${a}.call`),
                  n.insertTextAfter(l, h + c)
                ];
              }
            }
          ]
        });
      }
      return {
        CallExpression: r
      };
    }
  }, Vl;
}
var Ml, HE;
function gR() {
  if (HE) return Ml;
  HE = 1;
  const i = Re();
  return Ml = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow variable redeclaration",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-redeclare"
      },
      messages: {
        redeclared: "'{{id}}' is already defined.",
        redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
        redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: { type: "boolean", default: !0 }
          },
          additionalProperties: !1
        }
      ]
    },
    create(t) {
      const o = {
        builtinGlobals: !!(t.options.length === 0 || t.options[0].builtinGlobals)
      }, f = t.sourceCode;
      function* r(a) {
        o.builtinGlobals && (a.eslintImplicitGlobalSetting === "readonly" || a.eslintImplicitGlobalSetting === "writable") && (yield { type: "builtin" });
        for (const n of a.identifiers)
          yield { type: "syntax", node: n, loc: n.loc };
        if (a.eslintExplicitGlobalComments)
          for (const n of a.eslintExplicitGlobalComments)
            yield {
              type: "comment",
              node: n,
              loc: i.getNameLocationInGlobalDirectiveComment(
                f,
                n,
                a.name
              )
            };
      }
      function u(a) {
        for (const n of a.variables) {
          const [
            p,
            ...m
          ] = r(n);
          if (m.length === 0)
            continue;
          const h = p.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax", l = { id: n.name };
          for (const { type: s, node: c, loc: g } of m) {
            const d = s === p.type ? "redeclared" : h;
            t.report({ node: c, loc: g, messageId: d, data: l });
          }
        }
      }
      function e(a) {
        const n = f.getScope(a);
        n.block === a && u(n);
      }
      return {
        Program(a) {
          const n = f.getScope(a);
          u(n), n.type === "global" && n.childScopes[0] && // The special scope's block is the Program node.
          n.block === n.childScopes[0].block && u(n.childScopes[0]);
        },
        FunctionDeclaration: e,
        FunctionExpression: e,
        ArrowFunctionExpression: e,
        StaticBlock: e,
        BlockStatement: e,
        ForStatement: e,
        ForInStatement: e,
        ForOfStatement: e,
        SwitchStatement: e
      };
    }
  }, Ml;
}
var Kl, JE;
function dR() {
  if (JE) return Kl;
  JE = 1;
  const i = Re(), t = rr(), o = new t.RegExpParser(), f = / {2}/u;
  function r(u) {
    return u && u.type === "Literal" && typeof u.value == "string";
  }
  return Kl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow multiple spaces in regular expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-regex-spaces"
      },
      schema: [],
      fixable: "code",
      messages: {
        multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
      }
    },
    create(u) {
      const e = u.sourceCode;
      function a(m, h, l, s, c) {
        if (!f.test(l))
          return;
        const g = [];
        let d;
        try {
          d = o.parsePattern(h, 0, h.length, { unicode: c.includes("u"), unicodeSets: c.includes("v") });
        } catch {
          return;
        }
        t.visitRegExpAST(d, {
          onCharacterClassEnter(T) {
            g.push(T);
          }
        });
        const y = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;
        let v;
        for (; v = y.exec(h); ) {
          const { 1: { length: T }, index: b } = v;
          if (g.every(({ start: S, end: C }) => b < S || C <= b)) {
            u.report({
              node: m,
              messageId: "multipleSpaces",
              data: { length: T },
              fix(S) {
                return h !== l ? null : S.replaceTextRange(
                  [s + b, s + b + T],
                  ` {${T}}`
                );
              }
            });
            return;
          }
        }
      }
      function n(m) {
        if (m.regex) {
          const h = m.regex.pattern, l = m.raw.slice(1, m.raw.lastIndexOf("/")), s = m.range[0] + 1, c = m.regex.flags;
          a(
            m,
            h,
            l,
            s,
            c
          );
        }
      }
      function p(m) {
        const h = e.getScope(m), l = i.getVariableByName(h, "RegExp"), s = l && l.defs.length > 0, c = m.arguments[0];
        if (m.callee.type === "Identifier" && m.callee.name === "RegExp" && r(c) && !s) {
          const g = c.value, d = c.raw.slice(1, -1), y = c.range[0] + 1;
          let v;
          if (m.arguments.length < 2)
            v = "";
          else {
            const T = m.arguments[1];
            if (r(T))
              v = T.value;
            else
              return;
          }
          a(
            m,
            g,
            d,
            y,
            v
          );
        }
      }
      return {
        Literal: n,
        CallExpression: p,
        NewExpression: p
      };
    }
  }, Kl;
}
var jl, QE;
function ER() {
  if (QE) return jl;
  QE = 1;
  const i = Re();
  return jl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified names in exports",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-exports"
      },
      schema: [{
        anyOf: [
          {
            type: "object",
            properties: {
              restrictedNamedExports: {
                type: "array",
                items: {
                  type: "string"
                },
                uniqueItems: !0
              }
            },
            additionalProperties: !1
          },
          {
            type: "object",
            properties: {
              restrictedNamedExports: {
                type: "array",
                items: {
                  type: "string",
                  pattern: "^(?!default$)"
                },
                uniqueItems: !0
              },
              restrictDefaultExports: {
                type: "object",
                properties: {
                  // Allow/Disallow `export default foo; export default 42; export default function foo() {}` format
                  direct: {
                    type: "boolean"
                  },
                  // Allow/Disallow `export { foo as default };` declarations
                  named: {
                    type: "boolean"
                  },
                  //  Allow/Disallow `export { default } from "mod"; export { default as default } from "mod";` declarations
                  defaultFrom: {
                    type: "boolean"
                  },
                  //  Allow/Disallow `export { foo as default } from "mod";` declarations
                  namedFrom: {
                    type: "boolean"
                  },
                  //  Allow/Disallow `export * as default from "mod"`; declarations
                  namespaceFrom: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            },
            additionalProperties: !1
          }
        ]
      }],
      messages: {
        restrictedNamed: "'{{name}}' is restricted from being used as an exported name.",
        restrictedDefault: "Exporting 'default' is restricted."
      }
    },
    create(t) {
      const o = new Set(t.options[0] && t.options[0].restrictedNamedExports), f = t.options[0] && t.options[0].restrictDefaultExports, r = t.sourceCode;
      function u(e) {
        const a = i.getModuleExportName(e);
        if (o.has(a)) {
          t.report({
            node: e,
            messageId: "restrictedNamed",
            data: { name: a }
          });
          return;
        }
        if (a === "default")
          if (e.parent.type === "ExportAllDeclaration")
            f && f.namespaceFrom && t.report({
              node: e,
              messageId: "restrictedDefault"
            });
          else {
            const n = !!e.parent.parent.source, p = i.getModuleExportName(e.parent.local);
            if (!n && f && f.named) {
              t.report({
                node: e,
                messageId: "restrictedDefault"
              });
              return;
            }
            n && f && (p === "default" && f.defaultFrom || p !== "default" && f.namedFrom) && t.report({
              node: e,
              messageId: "restrictedDefault"
            });
          }
      }
      return {
        ExportAllDeclaration(e) {
          e.exported && u(e.exported);
        },
        ExportDefaultDeclaration(e) {
          f && f.direct && t.report({
            node: e,
            messageId: "restrictedDefault"
          });
        },
        ExportNamedDeclaration(e) {
          const a = e.declaration;
          a ? a.type === "FunctionDeclaration" || a.type === "ClassDeclaration" ? u(a.id) : a.type === "VariableDeclaration" && r.getDeclaredVariables(a).map((n) => n.defs.find((p) => p.parent === a)).map((n) => n.name).forEach(u) : e.specifiers.map((n) => n.exported).forEach(u);
        }
      };
    }
  }, jl;
}
var ql, YE;
function yR() {
  return YE || (YE = 1, ql = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified global variables",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-globals"
      },
      schema: {
        type: "array",
        items: {
          oneOf: [
            {
              type: "string"
            },
            {
              type: "object",
              properties: {
                name: { type: "string" },
                message: { type: "string" }
              },
              required: ["name"],
              additionalProperties: !1
            }
          ]
        },
        uniqueItems: !0,
        minItems: 0
      },
      messages: {
        defaultMessage: "Unexpected use of '{{name}}'.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
      }
    },
    create(i) {
      const t = i.sourceCode;
      if (i.options.length === 0)
        return {};
      const o = i.options.reduce((u, e) => (typeof e == "string" ? u[e] = null : u[e.name] = e.message, u), {});
      function f(u) {
        const e = u.identifier.name, a = o[e], n = a ? "customMessage" : "defaultMessage";
        i.report({
          node: u.identifier,
          messageId: n,
          data: {
            name: e,
            customMessage: a
          }
        });
      }
      function r(u) {
        return Object.prototype.hasOwnProperty.call(o, u);
      }
      return {
        Program(u) {
          const e = t.getScope(u);
          e.variables.forEach((a) => {
            !a.defs.length && r(a.name) && a.references.forEach(f);
          }), e.through.forEach((a) => {
            r(a.identifier.name) && f(a);
          });
        }
      };
    }
  }), ql;
}
var $l, ZE;
function Lv() {
  if (ZE) return $l;
  ZE = 1;
  function i(U) {
    return Array.isArray(U) ? U : [U];
  }
  const t = "", o = " ", f = "\\", r = /^\s+$/, u = /(?:[^\\]|^)\\$/, e = /^\\!/, a = /^\\#/, n = /\r?\n/g, p = /^\.*\/|^\.+$/, m = "/";
  let h = "node-ignore";
  typeof Symbol < "u" && (h = Symbol.for("node-ignore"));
  const l = h, s = (U, q, F) => Object.defineProperty(U, q, { value: F }), c = /([0-z])-([0-z])/g, g = () => !1, d = (U) => U.replace(
    c,
    (q, F, $) => F.charCodeAt(0) <= $.charCodeAt(0) ? q : t
  ), y = (U) => {
    const { length: q } = U;
    return U.slice(0, q - q % 2);
  }, v = [
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a \ ) -> (a  )
      /\\?\s+$/,
      (U) => U.indexOf("\\") === 0 ? o : t
    ],
    // replace (\ ) with ' '
    [
      /\\\s/g,
      () => o
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (U) => `\\${U}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      function() {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (U, q, F) => q + 6 < F.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (U, q, F) => {
        const $ = F.replace(/\\\*/g, "[^\\/]*");
        return q + $;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => f
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => f
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (U, q, F, $, P) => q === f ? `\\[${F}${y($)}${P}` : P === "]" && $.length % 2 === 0 ? `[${d(F)}${$}]` : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (U) => /\/$/.test(U) ? `${U}$` : `${U}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
      /(\^|\\\/)?\\\*$/,
      (U, q) => `${q ? `${q}[^/]+` : "[^/]*"}(?=$|\\/$)`
    ]
  ], T = /* @__PURE__ */ Object.create(null), b = (U, q) => {
    let F = T[U];
    return F || (F = v.reduce(
      ($, P) => $.replace(P[0], P[1].bind(U)),
      U
    ), T[U] = F), q ? new RegExp(F, "i") : new RegExp(F);
  }, S = (U) => typeof U == "string", C = (U) => U && S(U) && !r.test(U) && !u.test(U) && U.indexOf("#") !== 0, x = (U) => U.split(n);
  class A {
    constructor(q, F, $, P) {
      this.origin = q, this.pattern = F, this.negative = $, this.regex = P;
    }
  }
  const R = (U, q) => {
    const F = U;
    let $ = !1;
    U.indexOf("!") === 0 && ($ = !0, U = U.substr(1)), U = U.replace(e, "!").replace(a, "#");
    const P = b(U, q);
    return new A(
      F,
      U,
      $,
      P
    );
  }, L = (U, q) => {
    throw new q(U);
  }, _ = (U, q, F) => S(U) ? U ? _.isNotRelative(U) ? F(
    `path should be a \`path.relative()\`d string, but got "${q}"`,
    RangeError
  ) : !0 : F("path must not be empty", TypeError) : F(
    `path must be a string, but got \`${q}\``,
    TypeError
  ), I = (U) => p.test(U);
  _.isNotRelative = I, _.convert = (U) => U;
  class O {
    constructor({
      ignorecase: q = !0,
      ignoreCase: F = q,
      allowRelativePaths: $ = !1
    } = {}) {
      s(this, l, !0), this._rules = [], this._ignoreCase = F, this._allowRelativePaths = $, this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
    }
    _addPattern(q) {
      if (q && q[l]) {
        this._rules = this._rules.concat(q._rules), this._added = !0;
        return;
      }
      if (C(q)) {
        const F = R(q, this._ignoreCase);
        this._added = !0, this._rules.push(F);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(q) {
      return this._added = !1, i(
        S(q) ? x(q) : q
      ).forEach(this._addPattern, this), this._added && this._initCache(), this;
    }
    // legacy
    addPattern(q) {
      return this.add(q);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(q, F) {
      let $ = !1, P = !1;
      return this._rules.forEach((X) => {
        const { negative: Q } = X;
        if (P === Q && $ !== P || Q && !$ && !P && !F)
          return;
        X.regex.test(q) && ($ = !Q, P = Q);
      }), {
        ignored: $,
        unignored: P
      };
    }
    // @returns {TestResult}
    _test(q, F, $, P) {
      const X = q && _.convert(q);
      return _(
        X,
        q,
        this._allowRelativePaths ? g : L
      ), this._t(X, F, $, P);
    }
    _t(q, F, $, P) {
      if (q in F)
        return F[q];
      if (P || (P = q.split(m)), P.pop(), !P.length)
        return F[q] = this._testOne(q, $);
      const X = this._t(
        P.join(m) + m,
        F,
        $,
        P
      );
      return F[q] = X.ignored ? X : this._testOne(q, $);
    }
    ignores(q) {
      return this._test(q, this._ignoreCache, !1).ignored;
    }
    createFilter() {
      return (q) => !this.ignores(q);
    }
    filter(q) {
      return i(q).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(q) {
      return this._test(q, this._testCache, !0);
    }
  }
  const k = (U) => new O(U), w = (U) => _(U && _.convert(U), U, g);
  if (k.isPathValid = w, k.default = k, $l = k, // Detect `process` so that it can run in browsers.
  typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const U = (F) => /^\\\\\?\\/.test(F) || /["<>|\u0000-\u001F]+/u.test(F) ? F : F.replace(/\\/g, "/");
    _.convert = U;
    const q = /^[a-z]:\//i;
    _.isNotRelative = (F) => q.test(F) || I(F);
  }
  return $l;
}
var Gl, ey;
function CR() {
  if (ey) return Gl;
  ey = 1;
  const i = Re(), t = Lv(), o = {
    type: "array",
    items: {
      anyOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            name: { type: "string" },
            message: {
              type: "string",
              minLength: 1
            },
            importNames: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: !1,
          required: ["name"]
        }
      ]
    },
    uniqueItems: !0
  };
  return Gl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified modules when loaded by `import`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-imports"
      },
      messages: {
        path: "'{{importSource}}' import is restricted from being used.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
        patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        patternWithCustomMessage: "'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}",
        patternAndImportName: "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        patternAndImportNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}",
        patternAndEverything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.",
        patternAndEverythingWithRegexImportName: "* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        patternAndEverythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        patternAndEverythingWithRegexImportNameAndCustomMessage: "* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used. {{customMessage}}",
        everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",
        importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
      },
      schema: {
        anyOf: [
          o,
          {
            type: "array",
            items: [{
              type: "object",
              properties: {
                paths: o,
                patterns: {
                  anyOf: [
                    {
                      type: "array",
                      items: {
                        type: "string"
                      },
                      uniqueItems: !0
                    },
                    {
                      type: "array",
                      items: {
                        type: "object",
                        properties: {
                          importNames: {
                            type: "array",
                            items: {
                              type: "string"
                            },
                            minItems: 1,
                            uniqueItems: !0
                          },
                          group: {
                            type: "array",
                            items: {
                              type: "string"
                            },
                            minItems: 1,
                            uniqueItems: !0
                          },
                          importNamePattern: {
                            type: "string"
                          },
                          message: {
                            type: "string",
                            minLength: 1
                          },
                          caseSensitive: {
                            type: "boolean"
                          }
                        },
                        additionalProperties: !1,
                        required: ["group"]
                      },
                      uniqueItems: !0
                    }
                  ]
                }
              },
              additionalProperties: !1
            }],
            additionalItems: !1
          }
        ]
      }
    },
    create(r) {
      const u = r.sourceCode, e = Array.isArray(r.options) ? r.options : [], a = typeof e[0] == "object" && (Object.prototype.hasOwnProperty.call(e[0], "paths") || Object.prototype.hasOwnProperty.call(e[0], "patterns")), n = (a ? e[0].paths : r.options) || [], p = n.reduce((d, y) => (typeof y == "string" ? d[y] = { message: null } : d[y.name] = {
        message: y.message,
        importNames: y.importNames
      }, d), {});
      let m = (a ? e[0].patterns : []) || [];
      m.length > 0 && typeof m[0] == "string" && (m = [{ group: m }]);
      const h = m.map(({ group: d, message: y, caseSensitive: v, importNames: T, importNamePattern: b }) => ({
        matcher: t({ allowRelativePaths: !0, ignorecase: !v }).add(d),
        customMessage: y,
        importNames: T,
        importNamePattern: b
      }));
      if (Object.keys(n).length === 0 && h.length === 0)
        return {};
      function l(d, y, v) {
        if (!Object.prototype.hasOwnProperty.call(p, d))
          return;
        const T = p[d].message, b = p[d].importNames;
        if (b) {
          if (y.has("*")) {
            const S = y.get("*")[0];
            r.report({
              node: v,
              messageId: T ? "everythingWithCustomMessage" : "everything",
              loc: S.loc,
              data: {
                importSource: d,
                importNames: b,
                customMessage: T
              }
            });
          }
          b.forEach((S) => {
            y.has(S) && y.get(S).forEach((x) => {
              r.report({
                node: v,
                messageId: T ? "importNameWithCustomMessage" : "importName",
                loc: x.loc,
                data: {
                  importSource: d,
                  customMessage: T,
                  importName: S
                }
              });
            });
          });
        } else
          r.report({
            node: v,
            messageId: T ? "pathWithCustomMessage" : "path",
            data: {
              importSource: d,
              customMessage: T
            }
          });
      }
      function s(d, y, v) {
        const T = d.source.value.trim(), b = y.customMessage, S = y.importNames, C = y.importNamePattern ? new RegExp(y.importNamePattern, "u") : null;
        if (!S && !C) {
          r.report({
            node: d,
            messageId: b ? "patternWithCustomMessage" : "patterns",
            data: {
              importSource: T,
              customMessage: b
            }
          });
          return;
        }
        v.forEach((x, A) => {
          if (A === "*") {
            const [R] = x;
            S ? r.report({
              node: d,
              messageId: b ? "patternAndEverythingWithCustomMessage" : "patternAndEverything",
              loc: R.loc,
              data: {
                importSource: T,
                importNames: S,
                customMessage: b
              }
            }) : r.report({
              node: d,
              messageId: b ? "patternAndEverythingWithRegexImportNameAndCustomMessage" : "patternAndEverythingWithRegexImportName",
              loc: R.loc,
              data: {
                importSource: T,
                importNames: C,
                customMessage: b
              }
            });
            return;
          }
          (S && S.includes(A) || C && C.test(A)) && x.forEach((R) => {
            r.report({
              node: d,
              messageId: b ? "patternAndImportNameWithCustomMessage" : "patternAndImportName",
              loc: R.loc,
              data: {
                importSource: T,
                customMessage: b,
                importName: A
              }
            });
          });
        });
      }
      function c(d, y) {
        return y.matcher.ignores(d);
      }
      function g(d) {
        const y = d.source.value.trim(), v = /* @__PURE__ */ new Map();
        if (d.type === "ExportAllDeclaration") {
          const T = u.getFirstToken(d, 1);
          v.set("*", [{ loc: T.loc }]);
        } else if (d.specifiers)
          for (const T of d.specifiers) {
            let b;
            const S = { loc: T.loc };
            T.type === "ImportDefaultSpecifier" ? b = "default" : T.type === "ImportNamespaceSpecifier" ? b = "*" : T.imported ? b = i.getModuleExportName(T.imported) : T.local && (b = i.getModuleExportName(T.local)), typeof b == "string" && (v.has(b) ? v.get(b).push(S) : v.set(b, [S]));
          }
        l(y, v, d), h.forEach((T) => {
          c(y, T) && s(d, T, v);
        });
      }
      return {
        ImportDeclaration: g,
        ExportNamedDeclaration(d) {
          d.source && g(d);
        },
        ExportAllDeclaration: g
      };
    }
  }, Gl;
}
var Wl, ty;
function vR() {
  if (ty) return Wl;
  ty = 1;
  const i = Re(), t = Lv(), o = {
    type: "array",
    items: { type: "string" },
    uniqueItems: !0
  }, f = {
    type: "array",
    items: {
      anyOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            name: { type: "string" },
            message: {
              type: "string",
              minLength: 1
            }
          },
          additionalProperties: !1,
          required: ["name"]
        }
      ]
    },
    uniqueItems: !0
  };
  return Wl = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow specified modules when loaded by `require`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-modules"
      },
      schema: {
        anyOf: [
          f,
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                paths: f,
                patterns: o
              },
              additionalProperties: !1
            },
            additionalItems: !1
          }
        ]
      },
      messages: {
        defaultMessage: "'{{name}}' module is restricted from being used.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}",
        patternMessage: "'{{name}}' module is restricted from being used by a pattern."
      }
    },
    create(r) {
      const u = Array.isArray(r.options) ? r.options : [], e = typeof u[0] == "object" && (Object.prototype.hasOwnProperty.call(u[0], "paths") || Object.prototype.hasOwnProperty.call(u[0], "patterns")), a = (e ? u[0].paths : r.options) || [], n = (e ? u[0].patterns : []) || [], p = a.reduce((d, y) => (typeof y == "string" ? d[y] = null : d[y.name] = y.message, d), {});
      if (Object.keys(a).length === 0 && n.length === 0)
        return {};
      const m = t({ allowRelativePaths: !0 }).add(n);
      function h(d) {
        return d && d.type === "Literal" && typeof d.value == "string";
      }
      function l(d) {
        return d.callee.type === "Identifier" && d.callee.name === "require";
      }
      function s(d) {
        return h(d) ? d.value.trim() : i.isStaticTemplateLiteral(d) ? d.quasis[0].value.cooked.trim() : null;
      }
      function c(d, y) {
        const v = p[y], T = v ? "customMessage" : "defaultMessage";
        r.report({
          node: d,
          messageId: T,
          data: {
            name: y,
            customMessage: v
          }
        });
      }
      function g(d) {
        return Object.prototype.hasOwnProperty.call(p, d);
      }
      return {
        CallExpression(d) {
          if (l(d) && d.arguments.length) {
            const y = s(d.arguments[0]);
            y && (g(y) && c(d, y), n.length > 0 && m.ignores(y) && r.report({
              node: d,
              messageId: "patternMessage",
              data: { name: y }
            }));
          }
        }
      };
    }
  }, Wl;
}
var Xl, ry;
function SR() {
  if (ry) return Xl;
  ry = 1;
  const i = Re();
  return Xl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow certain properties on certain objects",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-properties"
      },
      schema: {
        type: "array",
        items: {
          anyOf: [
            // `object` and `property` are both optional, but at least one of them must be provided.
            {
              type: "object",
              properties: {
                object: {
                  type: "string"
                },
                property: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              },
              additionalProperties: !1,
              required: ["object"]
            },
            {
              type: "object",
              properties: {
                object: {
                  type: "string"
                },
                property: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              },
              additionalProperties: !1,
              required: ["property"]
            }
          ]
        },
        uniqueItems: !0
      },
      messages: {
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}"
      }
    },
    create(t) {
      const o = t.options;
      if (o.length === 0)
        return {};
      const f = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
      o.forEach((a) => {
        const n = a.object, p = a.property;
        typeof n > "u" ? u.set(p, { message: a.message }) : typeof p > "u" ? r.set(n, { message: a.message }) : (f.has(n) || f.set(n, /* @__PURE__ */ new Map()), f.get(n).set(p, {
          message: a.message
        }));
      });
      function e(a, n, p) {
        if (p === null)
          return;
        const m = f.get(n), h = m ? m.get(p) : r.get(n), l = u.get(p);
        if (h) {
          const s = h.message ? ` ${h.message}` : "";
          t.report({
            node: a,
            messageId: "restrictedObjectProperty",
            data: {
              objectName: n,
              propertyName: p,
              message: s
            }
          });
        } else if (l) {
          const s = l.message ? ` ${l.message}` : "";
          t.report({
            node: a,
            messageId: "restrictedProperty",
            data: {
              propertyName: p,
              message: s
            }
          });
        }
      }
      return {
        MemberExpression(a) {
          e(a, a.object && a.object.name, i.getStaticPropertyName(a));
        },
        ObjectPattern(a) {
          let n = null;
          a.parent.type === "VariableDeclarator" ? a.parent.init && a.parent.init.type === "Identifier" && (n = a.parent.init.name) : (a.parent.type === "AssignmentExpression" || a.parent.type === "AssignmentPattern") && a.parent.right.type === "Identifier" && (n = a.parent.right.name), a.properties.forEach((p) => {
            e(a, n, i.getStaticPropertyName(p));
          });
        }
      };
    }
  }, Xl;
}
var zl, ny;
function AR() {
  return ny || (ny = 1, zl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified syntax",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-restricted-syntax"
      },
      schema: {
        type: "array",
        items: {
          oneOf: [
            {
              type: "string"
            },
            {
              type: "object",
              properties: {
                selector: { type: "string" },
                message: { type: "string" }
              },
              required: ["selector"],
              additionalProperties: !1
            }
          ]
        },
        uniqueItems: !0,
        minItems: 0
      },
      messages: {
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        restrictedSyntax: "{{message}}"
      }
    },
    create(i) {
      return i.options.reduce((t, o) => {
        const f = typeof o == "string", r = !f && !!o.message, u = f ? o : o.selector, e = r ? o.message : `Using '${u}' is not allowed.`;
        return Object.assign(t, {
          [u](a) {
            i.report({
              node: a,
              messageId: "restrictedSyntax",
              data: { message: e }
            });
          }
        });
      }, {});
    }
  }), zl;
}
var Hl, sy;
function TR() {
  if (sy) return Hl;
  sy = 1;
  const i = Re(), t = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
  return Hl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow assignment operators in `return` statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-return-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        returnAssignment: "Return statement should not contain assignment.",
        arrowAssignment: "Arrow function should not return assignment."
      }
    },
    create(o) {
      const f = (o.options[0] || "except-parens") !== "except-parens", r = o.sourceCode;
      return {
        AssignmentExpression(u) {
          if (!f && i.isParenthesised(r, u))
            return;
          let e = u, a = e.parent;
          for (; a && !t.test(a.type); )
            e = a, a = a.parent;
          a && a.type === "ReturnStatement" ? o.report({
            node: a,
            messageId: "returnAssignment"
          }) : a && a.type === "ArrowFunctionExpression" && a.body === e && o.report({
            node: a,
            messageId: "arrowAssignment"
          });
        }
      };
    }
  }, Hl;
}
var Jl, iy;
function bR() {
  if (iy) return Jl;
  iy = 1;
  const i = Re();
  return Jl = {
    meta: {
      hasSuggestions: !0,
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary `return await`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-return-await"
      },
      fixable: null,
      deprecated: !0,
      replacedBy: [],
      schema: [],
      messages: {
        removeAwait: "Remove redundant `await`.",
        redundantUseOfAwait: "Redundant use of `await` on a return value."
      }
    },
    create(t) {
      function o(u) {
        t.report({
          node: t.sourceCode.getFirstToken(u),
          loc: u.loc,
          messageId: "redundantUseOfAwait",
          suggest: [
            {
              messageId: "removeAwait",
              fix(e) {
                const a = t.sourceCode, [n, p] = a.getFirstTokens(u, 2);
                if (!(n.loc.start.line === p.loc.start.line))
                  return null;
                const [h, l] = n.range, c = a.text[l] === " " ? 1 : 0, g = [h, l + c];
                return e.removeRange(g);
              }
            }
          ]
        });
      }
      function f(u) {
        let e = u;
        for (; !i.isFunction(e) && e.type !== "Program"; ) {
          if (e.parent.type === "TryStatement" && (e === e.parent.block || e === e.parent.handler && e.parent.finalizer))
            return !0;
          e = e.parent;
        }
        return !1;
      }
      function r(u) {
        return u.parent.type === "ArrowFunctionExpression" ? !0 : u.parent.type === "ReturnStatement" ? !f(u.parent) : u.parent.type === "ConditionalExpression" && (u === u.parent.consequent || u === u.parent.alternate) || u.parent.type === "LogicalExpression" && u === u.parent.right || u.parent.type === "SequenceExpression" && u === u.parent.expressions[u.parent.expressions.length - 1] ? r(u.parent) : !1;
      }
      return {
        AwaitExpression(u) {
          r(u) && !f(u) && o(u);
        }
      };
    }
  }, Jl;
}
var Ql, ay;
function xR() {
  if (ay) return Ql;
  ay = 1;
  const i = Re();
  return Ql = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `javascript:` urls",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-script-url"
      },
      schema: [],
      messages: {
        unexpectedScriptURL: "Script URL is a form of eval."
      }
    },
    create(t) {
      function o(f) {
        const r = i.getStaticStringValue(f);
        typeof r == "string" && r.toLowerCase().indexOf("javascript:") === 0 && t.report({ node: f, messageId: "unexpectedScriptURL" });
      }
      return {
        Literal(f) {
          f.value && typeof f.value == "string" && o(f);
        },
        TemplateLiteral(f) {
          f.parent && f.parent.type === "TaggedTemplateExpression" || o(f);
        }
      };
    }
  }, Ql;
}
var Yl, oy;
function RR() {
  if (oy) return Yl;
  oy = 1;
  const i = Re(), t = /\s+/gu;
  function o(f, r, u, e) {
    if (!(!f || !r)) if (f.type === "Identifier" && r.type === "Identifier" && f.name === r.name)
      e(r);
    else if (f.type === "ArrayPattern" && r.type === "ArrayExpression") {
      const a = Math.min(f.elements.length, r.elements.length);
      for (let n = 0; n < a; ++n) {
        const p = f.elements[n], m = r.elements[n];
        if (p && p.type === "RestElement" && n < r.elements.length - 1 || (o(p, m, u, e), m && m.type === "SpreadElement"))
          break;
      }
    } else if (f.type === "RestElement" && r.type === "SpreadElement")
      o(f.argument, r.argument, u, e);
    else if (f.type === "ObjectPattern" && r.type === "ObjectExpression" && r.properties.length >= 1) {
      let a = 0;
      for (let n = r.properties.length - 1; n >= 0; --n) {
        const p = r.properties[n].type;
        if (p === "SpreadElement" || p === "ExperimentalSpreadProperty") {
          a = n + 1;
          break;
        }
      }
      for (let n = 0; n < f.properties.length; ++n)
        for (let p = a; p < r.properties.length; ++p)
          o(
            f.properties[n],
            r.properties[p],
            u,
            e
          );
    } else if (f.type === "Property" && r.type === "Property" && r.kind === "init" && !r.method) {
      const a = i.getStaticPropertyName(f);
      a !== null && a === i.getStaticPropertyName(r) && o(f.value, r.value, u, e);
    } else u && i.skipChainExpression(f).type === "MemberExpression" && i.skipChainExpression(r).type === "MemberExpression" && i.isSameReference(f, r) && e(r);
  }
  return Yl = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow assignments where both sides are exactly the same",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-self-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            props: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        selfAssignment: "'{{name}}' is assigned to itself."
      }
    },
    create(f) {
      const r = f.sourceCode, [{ props: u = !0 } = {}] = f.options;
      function e(a) {
        f.report({
          node: a,
          messageId: "selfAssignment",
          data: {
            name: r.getText(a).replace(t, "")
          }
        });
      }
      return {
        AssignmentExpression(a) {
          ["=", "&&=", "||=", "??="].includes(a.operator) && o(a.left, a.right, u, e);
        }
      };
    }
  }, Yl;
}
var Zl, ly;
function DR() {
  return ly || (ly = 1, Zl = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow comparisons where both sides are exactly the same",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-self-compare"
      },
      schema: [],
      messages: {
        comparingToSelf: "Comparing to itself is potentially pointless."
      }
    },
    create(i) {
      const t = i.sourceCode;
      function o(f, r) {
        const u = t.getTokens(f), e = t.getTokens(r);
        return u.length === e.length && u.every((a, n) => a.type === e[n].type && a.value === e[n].value);
      }
      return {
        BinaryExpression(f) {
          (/* @__PURE__ */ new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="])).has(f.operator) && o(f.left, f.right) && i.report({ node: f, messageId: "comparingToSelf" });
        }
      };
    }
  }), Zl;
}
var eu, uy;
function LR() {
  if (uy) return eu;
  uy = 1;
  const i = Re(), t = {
    allowInParentheses: !0
  };
  return eu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow comma operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-sequences"
      },
      schema: [{
        properties: {
          allowInParentheses: {
            type: "boolean",
            default: !0
          }
        },
        additionalProperties: !1
      }],
      messages: {
        unexpectedCommaExpression: "Unexpected use of comma operator."
      }
    },
    create(o) {
      const f = Object.assign({}, t, o.options[0]), r = o.sourceCode, u = {
        DoWhileStatement: "test",
        IfStatement: "test",
        SwitchStatement: "discriminant",
        WhileStatement: "test",
        WithStatement: "object",
        ArrowFunctionExpression: "body"
        /*
         * Omitting CallExpression - commas are parsed as argument separators
         * Omitting NewExpression - commas are parsed as argument separators
         * Omitting ForInStatement - parts aren't individually parenthesised
         * Omitting ForStatement - parts aren't individually parenthesised
         */
      };
      function e(p) {
        return p.parent && u[p.parent.type] && p === p.parent[u[p.parent.type]];
      }
      function a(p) {
        return i.isParenthesised(r, p);
      }
      function n(p) {
        const m = r.getTokenBefore(p, 1), h = r.getTokenAfter(p, 1);
        return a(p) && m && h && i.isOpeningParenToken(m) && m.range[1] <= p.range[0] && i.isClosingParenToken(h) && h.range[0] >= p.range[1];
      }
      return {
        SequenceExpression(p) {
          if (p.parent.type === "ForStatement" && (p === p.parent.init || p === p.parent.update))
            return;
          if (f.allowInParentheses) {
            if (e(p)) {
              if (n(p))
                return;
            } else if (a(p))
              return;
          }
          const m = r.getTokenAfter(p.expressions[0], i.isCommaToken);
          o.report({ node: p, loc: m.loc, messageId: "unexpectedCommaExpression" });
        }
      };
    }
  }, eu;
}
var tu, cy;
function _R() {
  if (cy) return tu;
  cy = 1;
  const i = Re(), { findVariable: t } = Ft();
  function o(a, n) {
    const p = t(n, a);
    return p !== null && p.scope.type === "global" && p.defs.length === 0;
  }
  function f(a, n, p, m, h) {
    const l = a.parent;
    return l.type === "CallExpression" && l.arguments[h] === a && i.isSpecificMemberAccess(l.callee, p, m) && o(i.skipChainExpression(l.callee).object, n);
  }
  function r(a, n) {
    if (f(a, n, "Object", "defineProperty", 2) || f(a, n, "Reflect", "defineProperty", 2))
      return !0;
    const p = a.parent;
    if (p.type === "Property" && p.value === a) {
      const m = p.parent;
      if (m.type === "ObjectExpression" && (f(m, n, "Object", "create", 1) || f(m, n, "Object", "defineProperties", 1)))
        return !0;
    }
    return !1;
  }
  function u(a, n) {
    const p = a.parent;
    return !!((p.type === "Property" || p.type === "MethodDefinition") && p.kind === "set" && p.value === a || p.type === "Property" && p.value === a && i.getStaticPropertyName(p) === "set" && p.parent.type === "ObjectExpression" && r(p.parent, n));
  }
  function e(a) {
    const n = a.upper;
    return n.type === "function-expression-name" ? n.upper : n;
  }
  return tu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow returning values from setters",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-setter-return"
      },
      schema: [],
      messages: {
        returnsValue: "Setter cannot return a value."
      }
    },
    create(a) {
      let n = null;
      const p = a.sourceCode;
      function m(s) {
        const c = e(p.getScope(s));
        n = {
          upper: n,
          isSetter: u(s, c)
        };
      }
      function h() {
        n = n.upper;
      }
      function l(s) {
        a.report({ node: s, messageId: "returnsValue" });
      }
      return {
        /*
         * Function declarations cannot be setters, but we still have to track them in the `funcInfo` stack to avoid
         * false positives, because a ReturnStatement node can belong to a function declaration inside a setter.
         *
         * Note: A previously declared function can be referenced and actually used as a setter in a property descriptor,
         * but that's out of scope for this rule.
         */
        FunctionDeclaration: m,
        FunctionExpression: m,
        ArrowFunctionExpression(s) {
          m(s), n.isSetter && s.expression && l(s.body);
        },
        "FunctionDeclaration:exit": h,
        "FunctionExpression:exit": h,
        "ArrowFunctionExpression:exit": h,
        ReturnStatement(s) {
          n && n.isSetter && s.argument && l(s);
        }
      };
    }
  }, tu;
}
var ru, fy;
function wR() {
  if (fy) return ru;
  fy = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]), o = /* @__PURE__ */ new Set(["CallExpression"]), f = /^For(?:In|Of)Statement$/u, r = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
  return ru = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow variable declarations from shadowing variables declared in the outer scope",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-shadow"
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: { type: "boolean", default: !1 },
            hoist: { enum: ["all", "functions", "never"], default: "functions" },
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            },
            ignoreOnInitialization: { type: "boolean", default: !1 }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
        noShadowGlobal: "'{{name}}' is already a global variable."
      }
    },
    create(u) {
      const e = {
        builtinGlobals: u.options[0] && u.options[0].builtinGlobals,
        hoist: u.options[0] && u.options[0].hoist || "functions",
        allow: u.options[0] && u.options[0].allow || [],
        ignoreOnInitialization: u.options[0] && u.options[0].ignoreOnInitialization
      }, a = u.sourceCode;
      function n(T, b) {
        return T && T.range[0] <= b && b <= T.range[1];
      }
      function p(T, b) {
        let S = T;
        for (; S && !b(S); )
          S = S.parent;
        return S;
      }
      function m(T) {
        const b = T.upper;
        return b.type === "function-expression-name" ? b.upper : b;
      }
      function h(T, b) {
        const S = b.defs[0];
        if (!S)
          return !1;
        const { variableScope: C } = T.scope;
        if (!(t.has(C.block.type) && m(C) === b.scope))
          return !1;
        const x = C.block, { parent: A } = x, R = p(
          A,
          (I) => o.has(I.type)
        );
        if (!R)
          return !1;
        let L = S.name;
        const _ = R.range[1];
        for (; L; ) {
          if (L.type === "VariableDeclarator") {
            if (n(L.init, _) || f.test(L.parent.parent.type) && n(L.parent.parent.right, _))
              return !0;
            break;
          } else if (L.type === "AssignmentPattern") {
            if (n(L.right, _))
              return !0;
          } else if (r.test(L.type))
            break;
          L = L.parent;
        }
        return !1;
      }
      function l(T) {
        return e.allow.includes(T.name);
      }
      function s(T) {
        const b = T.scope.block;
        return b.type === "ClassDeclaration" && b.id === T.identifiers[0];
      }
      function c(T, b) {
        const S = b.scope, C = b.defs[0], x = C && C.parent && C.parent.range, A = T.scope, R = T.defs[0], L = R && R.name.range;
        return x && L && x[0] < L[0] && L[1] < x[1] && (R.type === "FunctionName" && R.node.type === "FunctionExpression" || R.node.type === "ClassExpression") && S === A.upper;
      }
      function g(T) {
        const b = T.defs[0];
        return b && b.name.range;
      }
      function d(T) {
        const b = T.identifiers[0];
        let S;
        return b ? S = {
          global: !1,
          line: b.loc.start.line,
          column: b.loc.start.column + 1
        } : S = {
          global: !0
        }, S;
      }
      function y(T, b) {
        const S = b.defs[0], C = g(T), x = g(b);
        return C && x && C[1] < x[0] && // Excepts FunctionDeclaration if is {"hoist":"function"}.
        (e.hoist !== "functions" || !S || S.node.type !== "FunctionDeclaration");
      }
      function v(T) {
        const b = T.variables;
        for (let S = 0; S < b.length; ++S) {
          const C = b[S];
          if (C.identifiers.length === 0 || s(C) || l(C))
            continue;
          const x = i.getVariableByName(T.upper, C.name);
          if (x && (x.identifiers.length > 0 || e.builtinGlobals && "writeable" in x) && !c(C, x) && !(e.ignoreOnInitialization && h(C, x)) && !(e.hoist !== "all" && y(C, x))) {
            const A = d(x), R = A.global ? "noShadowGlobal" : "noShadow", L = { name: C.name };
            A.global || (L.shadowedLine = A.line, L.shadowedColumn = A.column), u.report({
              node: C.identifiers[0],
              messageId: R,
              data: L
            });
          }
        }
      }
      return {
        "Program:exit"(T) {
          const S = a.getScope(T).childScopes.slice();
          for (; S.length; ) {
            const C = S.pop();
            S.push(...C.childScopes), v(C);
          }
        }
      };
    }
  }, ru;
}
var nu, py;
function kR() {
  if (py) return nu;
  py = 1;
  function i(t) {
    return t.name === "undefined" && t.references.every((o) => !o.isWrite()) && t.defs.every((o) => o.node.type === "VariableDeclarator" && o.node.init === null);
  }
  return nu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow identifiers from shadowing restricted names",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-shadow-restricted-names"
      },
      schema: [],
      messages: {
        shadowingRestrictedName: "Shadowing of global property '{{name}}'."
      }
    },
    create(t) {
      const o = /* @__PURE__ */ new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]), f = t.sourceCode;
      return {
        "VariableDeclaration, :function, CatchClause"(r) {
          for (const u of f.getDeclaredVariables(r))
            u.defs.length > 0 && o.has(u.name) && !i(u) && t.report({
              node: u.defs[0].name,
              messageId: "shadowingRestrictedName",
              data: {
                name: u.name
              }
            });
        }
      };
    }
  }, nu;
}
var su, hy;
function BR() {
  return hy || (hy = 1, su = {
    meta: {
      type: "layout",
      docs: {
        description: "Disallow spacing between function identifiers and their applications (deprecated)",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-spaced-func"
      },
      deprecated: !0,
      replacedBy: ["func-call-spacing"],
      fixable: "whitespace",
      schema: [],
      messages: {
        noSpacedFunction: "Unexpected space between function name and paren."
      }
    },
    create(i) {
      const t = i.sourceCode;
      function o(f) {
        const r = t.getLastToken(f.callee);
        let u = r, e = t.getTokenAfter(r);
        for (; e && e.range[1] < f.range[1] && e.value !== "("; )
          u = e, e = t.getTokenAfter(e);
        e && e.range[1] < f.range[1] && t.isSpaceBetweenTokens(u, e) && i.report({
          node: f,
          loc: r.loc.start,
          messageId: "noSpacedFunction",
          fix(a) {
            return a.removeRange([u.range[1], e.range[0]]);
          }
        });
      }
      return {
        CallExpression: o,
        NewExpression: o
      };
    }
  }), su;
}
var iu, my;
function PR() {
  return my || (my = 1, iu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow sparse arrays",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-sparse-arrays"
      },
      schema: [],
      messages: {
        unexpectedSparseArray: "Unexpected comma in middle of array."
      }
    },
    create(i) {
      return {
        ArrayExpression(t) {
          t.elements.includes(null) && i.report({ node: t, messageId: "unexpectedSparseArray" });
        }
      };
    }
  }), iu;
}
var au, gy;
function IR() {
  return gy || (gy = 1, au = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Disallow synchronous methods",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-sync"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAtRootLevel: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        noSync: "Unexpected sync method: '{{propertyName}}'."
      }
    },
    create(i) {
      return {
        [i.options[0] && i.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]"](o) {
          i.report({
            node: o,
            messageId: "noSync",
            data: {
              propertyName: o.property.name
            }
          });
        }
      };
    }
  }), au;
}
var ou, dy;
function FR() {
  if (dy) return ou;
  dy = 1;
  const i = /\t+/gu, t = /\S/u;
  return ou = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow all tabs",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-tabs"
      },
      schema: [{
        type: "object",
        properties: {
          allowIndentationTabs: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        unexpectedTab: "Unexpected tab character."
      }
    },
    create(o) {
      const f = o.sourceCode, r = o.options && o.options[0] && o.options[0].allowIndentationTabs;
      return {
        Program(u) {
          f.getLines().forEach((e, a) => {
            let n;
            for (; (n = i.exec(e)) !== null; )
              r && !t.test(e.slice(0, n.index)) || o.report({
                node: u,
                loc: {
                  start: {
                    line: a + 1,
                    column: n.index
                  },
                  end: {
                    line: a + 1,
                    column: n.index + n[0].length
                  }
                },
                messageId: "unexpectedTab"
              });
          });
        }
      };
    }
  }, ou;
}
var lu, Ey;
function NR() {
  return Ey || (Ey = 1, lu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow template literal placeholder syntax in regular strings",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-template-curly-in-string"
      },
      schema: [],
      messages: {
        unexpectedTemplateExpression: "Unexpected template string expression."
      }
    },
    create(i) {
      const t = /\$\{[^}]+\}/u;
      return {
        Literal(o) {
          typeof o.value == "string" && t.test(o.value) && i.report({
            node: o,
            messageId: "unexpectedTemplateExpression"
          });
        }
      };
    }
  }), lu;
}
var uu, yy;
function OR() {
  return yy || (yy = 1, uu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow ternary operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-ternary"
      },
      schema: [],
      messages: {
        noTernaryOperator: "Ternary operator used."
      }
    },
    create(i) {
      return {
        ConditionalExpression(t) {
          i.report({ node: t, messageId: "noTernaryOperator" });
        }
      };
    }
  }), uu;
}
var cu, Cy;
function UR() {
  if (Cy) return cu;
  Cy = 1;
  const i = Re();
  function t(o) {
    return o.type === "FunctionExpression" && o.parent.type === "MethodDefinition" && o.parent.kind === "constructor";
  }
  return cu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `this`/`super` before calling `super()` in constructors",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-this-before-super"
      },
      schema: [],
      messages: {
        noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
      }
    },
    create(o) {
      let f = null, r = /* @__PURE__ */ Object.create(null);
      function u(h) {
        return !h.reachable || r[h.id].superCalled;
      }
      function e() {
        return !!(f && f.isConstructor && f.hasExtends);
      }
      function a(h) {
        for (const l of h)
          if (!u(l))
            return !1;
        return !0;
      }
      function n() {
        return e() && !a(f.currentSegments);
      }
      function p(h) {
        const l = f.currentSegments;
        for (const s of l)
          s.reachable && r[s.id].invalidNodes.push(h);
      }
      function m() {
        const h = f.currentSegments;
        for (const l of h)
          l.reachable && (r[l.id].superCalled = !0);
      }
      return {
        /**
         * Adds information of a constructor into the stack.
         * @param {CodePath} codePath A code path which was started.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathStart(h, l) {
          if (t(l)) {
            const s = l.parent.parent.parent;
            f = {
              upper: f,
              isConstructor: !0,
              hasExtends: !!(s.superClass && !i.isNullOrUndefined(s.superClass)),
              codePath: h,
              currentSegments: /* @__PURE__ */ new Set()
            };
          } else
            f = {
              upper: f,
              isConstructor: !1,
              hasExtends: !1,
              codePath: h,
              currentSegments: /* @__PURE__ */ new Set()
            };
        },
        /**
         * Removes the top of stack item.
         *
         * And this traverses all segments of this code path then reports every
         * invalid node.
         * @param {CodePath} codePath A code path which was ended.
         * @returns {void}
         */
        onCodePathEnd(h) {
          const l = f.hasExtends;
          f = f.upper, l && h.traverseSegments((s, c) => {
            const g = r[s.id];
            for (let d = 0; d < g.invalidNodes.length; ++d) {
              const y = g.invalidNodes[d];
              o.report({
                messageId: "noBeforeSuper",
                node: y,
                data: {
                  kind: y.type === "Super" ? "super" : "this"
                }
              });
            }
            g.superCalled && c.skip();
          });
        },
        /**
         * Initialize information of a given code path segment.
         * @param {CodePathSegment} segment A code path segment to initialize.
         * @returns {void}
         */
        onCodePathSegmentStart(h) {
          f.currentSegments.add(h), e() && (r[h.id] = {
            superCalled: h.prevSegments.length > 0 && h.prevSegments.every(u),
            invalidNodes: []
          });
        },
        onUnreachableCodePathSegmentStart(h) {
          f.currentSegments.add(h);
        },
        onUnreachableCodePathSegmentEnd(h) {
          f.currentSegments.delete(h);
        },
        onCodePathSegmentEnd(h) {
          f.currentSegments.delete(h);
        },
        /**
         * Update information of the code path segment when a code path was
         * looped.
         * @param {CodePathSegment} fromSegment The code path segment of the
         *      end of a loop.
         * @param {CodePathSegment} toSegment A code path segment of the head
         *      of a loop.
         * @returns {void}
         */
        onCodePathSegmentLoop(h, l) {
          e() && f.codePath.traverseSegments(
            { first: l, last: h },
            (s, c) => {
              const g = r[s.id];
              g.superCalled ? (g.invalidNodes = [], c.skip()) : s.prevSegments.length > 0 && s.prevSegments.every(u) && (g.superCalled = !0, g.invalidNodes = []);
            }
          );
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        ThisExpression(h) {
          n() && p(h);
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        Super(h) {
          !i.isCallee(h) && n() && p(h);
        },
        /**
         * Marks `super()` called.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        "CallExpression:exit"(h) {
          h.callee.type === "Super" && n() && m();
        },
        /**
         * Resets state.
         * @returns {void}
         */
        "Program:exit"() {
          r = /* @__PURE__ */ Object.create(null);
        }
      };
    }
  }, cu;
}
var fu, vy;
function VR() {
  if (vy) return fu;
  vy = 1;
  const i = Re();
  return fu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow throwing literals as exceptions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-throw-literal"
      },
      schema: [],
      messages: {
        object: "Expected an error object to be thrown.",
        undef: "Do not throw undefined."
      }
    },
    create(t) {
      return {
        ThrowStatement(o) {
          i.couldBeError(o.argument) ? o.argument.type === "Identifier" && o.argument.name === "undefined" && t.report({ node: o, messageId: "undef" }) : t.report({ node: o, messageId: "object" });
        }
      };
    }
  }, fu;
}
var pu, Sy;
function MR() {
  if (Sy) return pu;
  Sy = 1;
  const i = Re();
  return pu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow trailing whitespace at the end of lines",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-trailing-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            skipBlankLines: {
              type: "boolean",
              default: !1
            },
            ignoreComments: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        trailingSpace: "Trailing spaces not allowed."
      }
    },
    create(t) {
      const o = t.sourceCode, f = "[ 	  -​　]", r = `^${f}*$`, u = `${f}+$`, e = t.options[0] || {}, a = e.skipBlankLines || !1, n = e.ignoreComments || !1;
      function p(h, l, s) {
        t.report({
          node: h,
          loc: l,
          messageId: "trailingSpace",
          fix(c) {
            return c.removeRange(s);
          }
        });
      }
      function m(h) {
        const l = /* @__PURE__ */ new Set();
        return h.forEach((s) => {
          const c = s.type === "Block" ? s.loc.end.line - 1 : s.loc.end.line;
          for (let g = s.loc.start.line; g <= c; g++)
            l.add(g);
        }), l;
      }
      return {
        Program: function(l) {
          const s = new RegExp(u, "u"), c = new RegExp(r, "u"), g = o.lines, d = o.getText().match(i.createGlobalLinebreakMatcher()), y = o.getAllComments(), v = m(y);
          let T = 0, b = [];
          for (let S = 0, C = g.length; S < C; S++) {
            const x = S + 1, A = d && d[S] ? d[S].length : 1, R = g[S].length + A, L = s.exec(g[S]);
            if (L) {
              const _ = {
                start: {
                  line: x,
                  column: L.index
                },
                end: {
                  line: x,
                  column: R - A
                }
              }, I = T + _.start.column, O = T + _.end.column, k = o.getNodeByRangeIndex(I);
              if (k && k.type === "TemplateElement" && I > k.parent.range[0] && O < k.parent.range[1]) {
                T += R;
                continue;
              }
              if (a && c.test(g[S])) {
                T += R;
                continue;
              }
              b = [I, O], (!n || !v.has(x)) && p(l, _, b);
            }
            T += R;
          }
        }
      };
    }
  }, pu;
}
var hu, Ay;
function KR() {
  if (Ay) return hu;
  Ay = 1;
  function i(t) {
    const o = t.parent;
    return o.type === "UnaryExpression" && o.operator === "typeof";
  }
  return hu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow the use of undeclared variables unless mentioned in `/*global */` comments",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-undef"
      },
      schema: [
        {
          type: "object",
          properties: {
            typeof: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        undef: "'{{name}}' is not defined."
      }
    },
    create(t) {
      const o = t.options[0], f = o && o.typeof === !0 || !1, r = t.sourceCode;
      return {
        "Program:exit"(u) {
          r.getScope(u).through.forEach((a) => {
            const n = a.identifier;
            !f && i(n) || t.report({
              node: n,
              messageId: "undef",
              data: n
            });
          });
        }
      };
    }
  }, hu;
}
var mu, Ty;
function jR() {
  if (Ty) return mu;
  Ty = 1;
  const i = Re();
  return mu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow initializing variables to `undefined`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-undef-init"
      },
      schema: [],
      fixable: "code",
      messages: {
        unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
      }
    },
    create(t) {
      const o = t.sourceCode;
      return {
        VariableDeclarator(f) {
          const r = o.getText(f.id), u = f.init && f.init.name, e = o.getScope(f), a = i.getVariableByName(e, "undefined"), n = a && a.defs.length > 0, p = o.getLastToken(f);
          u === "undefined" && f.parent.kind !== "const" && !n && t.report({
            node: f,
            messageId: "unnecessaryUndefinedInit",
            data: { name: r },
            fix(m) {
              return f.parent.kind === "var" || f.id.type === "ArrayPattern" || f.id.type === "ObjectPattern" || o.commentsExistBetween(f.id, p) ? null : m.removeRange([f.id.range[1], f.range[1]]);
            }
          });
        }
      };
    }
  }, mu;
}
var gu, by;
function qR() {
  return by || (by = 1, gu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `undefined` as an identifier",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-undefined"
      },
      schema: [],
      messages: {
        unexpectedUndefined: "Unexpected use of undefined."
      }
    },
    create(i) {
      const t = i.sourceCode;
      function o(r) {
        i.report({
          node: r,
          messageId: "unexpectedUndefined"
        });
      }
      function f(r) {
        const u = r.set.get("undefined");
        if (!u)
          return;
        const e = u.references, a = u.defs;
        e.filter((n) => !n.init).forEach((n) => o(n.identifier)), a.forEach((n) => o(n.name));
      }
      return {
        "Program:exit"(r) {
          const e = [t.getScope(r)];
          for (; e.length; ) {
            const a = e.pop();
            e.push(...a.childScopes), f(a);
          }
        }
      };
    }
  }), gu;
}
var du, xy;
function $R() {
  return xy || (xy = 1, du = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow dangling underscores in identifiers",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-underscore-dangle"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowAfterThis: {
              type: "boolean",
              default: !1
            },
            allowAfterSuper: {
              type: "boolean",
              default: !1
            },
            allowAfterThisConstructor: {
              type: "boolean",
              default: !1
            },
            enforceInMethodNames: {
              type: "boolean",
              default: !1
            },
            allowFunctionParams: {
              type: "boolean",
              default: !0
            },
            enforceInClassFields: {
              type: "boolean",
              default: !1
            },
            allowInArrayDestructuring: {
              type: "boolean",
              default: !0
            },
            allowInObjectDestructuring: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
      }
    },
    create(i) {
      const t = i.options[0] || {}, o = t.allow ? t.allow : [], f = typeof t.allowAfterThis < "u" ? t.allowAfterThis : !1, r = typeof t.allowAfterSuper < "u" ? t.allowAfterSuper : !1, u = typeof t.allowAfterThisConstructor < "u" ? t.allowAfterThisConstructor : !1, e = typeof t.enforceInMethodNames < "u" ? t.enforceInMethodNames : !1, a = typeof t.enforceInClassFields < "u" ? t.enforceInClassFields : !1, n = typeof t.allowFunctionParams < "u" ? t.allowFunctionParams : !0, p = typeof t.allowInArrayDestructuring < "u" ? t.allowInArrayDestructuring : !0, m = typeof t.allowInObjectDestructuring < "u" ? t.allowInObjectDestructuring : !0, h = i.sourceCode;
      function l(x) {
        return o.includes(x);
      }
      function s(x) {
        const A = x.length;
        return x !== "_" && (x[0] === "_" || x[A - 1] === "_");
      }
      function c(x) {
        return x === "__proto__";
      }
      function g(x) {
        return x === "_";
      }
      function d(x) {
        return x.object.type === "MemberExpression" && x.object.property.name === "constructor" && x.object.object.type === "ThisExpression";
      }
      function y(x) {
        n || x.params.forEach((A) => {
          const { type: R } = A;
          let L;
          if (R === "RestElement" ? L = A.argument : R === "AssignmentPattern" ? L = A.left : L = A, L.type === "Identifier") {
            const _ = L.name;
            s(_) && !l(_) && i.report({
              node: A,
              messageId: "unexpectedUnderscore",
              data: {
                identifier: _
              }
            });
          }
        });
      }
      function v(x) {
        if (x.type === "FunctionDeclaration" && x.id) {
          const A = x.id.name;
          typeof A < "u" && s(A) && !l(A) && i.report({
            node: x,
            messageId: "unexpectedUnderscore",
            data: {
              identifier: A
            }
          });
        }
        y(x);
      }
      function T(x) {
        h.getDeclaredVariables(x).forEach((A) => {
          const L = A.defs.find((O) => O.node === x).name, _ = L.name;
          let I = L.parent;
          for (; !["VariableDeclarator", "ArrayPattern", "ObjectPattern"].includes(I.type); )
            I = I.parent;
          s(_) && !g(_) && !l(_) && !(p && I.type === "ArrayPattern") && !(m && I.type === "ObjectPattern") && i.report({
            node: x,
            messageId: "unexpectedUnderscore",
            data: {
              identifier: _
            }
          });
        });
      }
      function b(x) {
        const A = x.property.name, R = x.object.type === "ThisExpression", L = x.object.type === "Super", _ = d(x);
        typeof A < "u" && s(A) && !(R && f) && !(L && r) && !(_ && u) && !c(A) && !l(A) && i.report({
          node: x,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: A
          }
        });
      }
      function S(x) {
        const A = x.key.name, R = x.type === "MethodDefinition" || x.type === "Property" && x.method;
        typeof A < "u" && e && R && s(A) && !l(A) && i.report({
          node: x,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: x.key.type === "PrivateIdentifier" ? `#${A}` : A
          }
        });
      }
      function C(x) {
        const A = x.key.name;
        typeof A < "u" && s(A) && a && !l(A) && i.report({
          node: x,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: x.key.type === "PrivateIdentifier" ? `#${A}` : A
          }
        });
      }
      return {
        FunctionDeclaration: v,
        VariableDeclarator: T,
        MemberExpression: b,
        MethodDefinition: S,
        PropertyDefinition: C,
        Property: S,
        FunctionExpression: v,
        ArrowFunctionExpression: v
      };
    }
  }), du;
}
var Eu, Ry;
function GR() {
  if (Ry) return Eu;
  Ry = 1;
  const i = Re();
  return Eu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow confusing multiline expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unexpected-multiline"
      },
      schema: [],
      messages: {
        function: "Unexpected newline between function and ( of function call.",
        property: "Unexpected newline between object and [ of property access.",
        taggedTemplate: "Unexpected newline between template tag and template literal.",
        division: "Unexpected newline between numerator and division operator."
      }
    },
    create(t) {
      const o = /^[gimsuy]+$/u, f = t.sourceCode;
      function r(u, e) {
        const a = f.getTokenAfter(u, i.isNotClosingParenToken), n = f.getTokenBefore(a);
        a.loc.start.line !== n.loc.end.line && t.report({
          node: u,
          loc: a.loc,
          messageId: e
        });
      }
      return {
        MemberExpression(u) {
          !u.computed || u.optional || r(u.object, "property");
        },
        TaggedTemplateExpression(u) {
          const { quasi: e } = u;
          f.getTokenBefore(e).loc.end.line !== e.loc.start.line && t.report({
            node: u,
            loc: {
              start: e.loc.start,
              end: {
                line: e.loc.start.line,
                column: e.loc.start.column + 1
              }
            },
            messageId: "taggedTemplate"
          });
        },
        CallExpression(u) {
          u.arguments.length === 0 || u.optional || r(u.callee, "function");
        },
        "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(u) {
          const e = f.getTokenAfter(u, (n) => n.value === "/"), a = f.getTokenAfter(e);
          a.type === "Identifier" && o.test(a.value) && e.range[1] === a.range[0] && r(u.left, "division");
        }
      };
    }
  }, Eu;
}
var yu, Dy;
function WR() {
  if (Dy) return yu;
  Dy = 1;
  const i = qf(), t = Re(), o = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u, f = /^(?:DoWhile|For|While)Statement$/u, r = /^(?:BinaryExpression|ConditionalExpression)$/u, u = /^(?:ArrowFunction|Class|Function)Expression$/u, e = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;
  function a(c) {
    if (c.init) {
      const g = c.resolved && c.resolved.defs[0];
      if (!g || g.type !== "Variable" || g.parent.kind !== "var")
        return !1;
    }
    return c.isWrite();
  }
  function n(c) {
    return !c.modified;
  }
  function p(c) {
    return !(c.modified || c.group);
  }
  function m(c, g) {
    const d = c.range, y = g.identifier.range;
    return d[0] <= y[0] && y[1] <= d[1];
  }
  const h = {
    WhileStatement: m,
    DoWhileStatement: m,
    ForStatement(c, g) {
      return m(c, g) && !(c.init && m(c.init, g));
    }
  };
  function l(c) {
    let g = c.identifier;
    for (; g; ) {
      if (g.type === "FunctionDeclaration")
        return g.id ? g : null;
      g = g.parent;
    }
    return null;
  }
  function s(c, g) {
    for (let d = 0; d < c.length; ++d) {
      const y = c[d];
      for (let v = 0; !y.modified && v < g.length; ++v) {
        const T = g[v];
        let b, S;
        const C = y.isInLoop(T) || !!((b = l(T)) && (S = t.getVariableByName(T.from.upper, b.id.name)) && S.references.some(y.isInLoop));
        y.modified = C;
      }
    }
  }
  return yu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unmodified loop conditions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-unmodified-loop-condition"
      },
      schema: [],
      messages: {
        loopConditionNotModified: "'{{name}}' is not modified in this loop."
      }
    },
    create(c) {
      const g = c.sourceCode;
      let d = null;
      function y(x) {
        const A = x.reference.identifier;
        c.report({
          node: A,
          messageId: "loopConditionNotModified",
          data: A
        });
      }
      function v(x) {
        for (let A = 0; A < x.length; ++A) {
          const R = x[A];
          if (R.group) {
            let L = d.get(R.group);
            L || (L = [], d.set(R.group, L)), L.push(R);
          }
        }
      }
      function T(x) {
        x.every(n) && x.forEach(y);
      }
      function b(x) {
        let A = !1;
        return i.traverse(x, {
          visitorKeys: g.visitorKeys,
          enter(R) {
            e.test(R.type) ? (A = !0, this.break()) : u.test(R.type) && this.skip();
          }
        }), A;
      }
      function S(x) {
        if (x.init)
          return null;
        let A = null, R = x.identifier, L = R.parent;
        for (; L; ) {
          if (o.test(L.type)) {
            if (f.test(L.type) && L.test === R)
              return {
                reference: x,
                group: A,
                isInLoop: h[L.type].bind(null, L),
                modified: !1
              };
            break;
          }
          if (r.test(L.type)) {
            if (b(L))
              break;
            A = L;
          }
          R = L, L = L.parent;
        }
        return null;
      }
      function C(x) {
        const A = x.references.map(S).filter(Boolean);
        if (A.length === 0)
          return;
        v(A);
        const R = x.references.filter(a);
        R.length > 0 && s(A, R), A.filter(p).forEach(y);
      }
      return {
        "Program:exit"(x) {
          const A = [g.getScope(x)];
          d = /* @__PURE__ */ new Map();
          let R;
          for (; R = A.pop(); )
            A.push(...R.childScopes), R.variables.forEach(C);
          d.forEach(T), d = null;
        }
      };
    }
  }, yu;
}
var Cu, Ly;
function XR() {
  if (Ly) return Cu;
  Ly = 1;
  const i = Re(), t = /* @__PURE__ */ new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]), o = {
    "==": "!=",
    "!=": "==",
    "===": "!==",
    "!==": "==="
    // Operators like < and >= are not true inverses, since both will return false with NaN.
  }, f = i.getPrecedence({ type: "LogicalExpression", operator: "||" });
  return Cu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow ternary operators when simpler alternatives exist",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-unneeded-ternary"
      },
      schema: [
        {
          type: "object",
          properties: {
            defaultAssignment: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
        unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
      }
    },
    create(r) {
      const e = (r.options[0] || {}).defaultAssignment !== !1, a = r.sourceCode;
      function n(l) {
        return l.type === "Literal" && typeof l.value == "boolean";
      }
      function p(l) {
        if (l.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(o, l.operator)) {
          const s = a.getFirstTokenBetween(
            l.left,
            l.right,
            (g) => g.value === l.operator
          ), c = a.getText();
          return c.slice(
            l.range[0],
            s.range[0]
          ) + o[l.operator] + c.slice(s.range[1], l.range[1]);
        }
        return i.getPrecedence(l) < i.getPrecedence({ type: "UnaryExpression" }) ? `!(${i.getParenthesisedText(a, l)})` : `!${i.getParenthesisedText(a, l)}`;
      }
      function m(l) {
        return l.type === "BinaryExpression" && t.has(l.operator) || l.type === "UnaryExpression" && l.operator === "!";
      }
      function h(l) {
        return l.test.type === "Identifier" && l.consequent.type === "Identifier" && l.test.name === l.consequent.name;
      }
      return {
        ConditionalExpression(l) {
          n(l.alternate) && n(l.consequent) ? r.report({
            node: l,
            messageId: "unnecessaryConditionalExpression",
            fix(s) {
              return l.consequent.value === l.alternate.value ? l.test.type === "Identifier" ? s.replaceText(l, l.consequent.value.toString()) : null : l.alternate.value ? s.replaceText(l, p(l.test)) : s.replaceText(l, m(l.test) ? i.getParenthesisedText(a, l.test) : `!${p(l.test)}`);
            }
          }) : !e && h(l) && r.report({
            node: l,
            messageId: "unnecessaryConditionalAssignment",
            fix(s) {
              const g = (i.getPrecedence(l.alternate) < f || i.isCoalesceExpression(l.alternate)) && !i.isParenthesised(a, l.alternate) ? `(${a.getText(l.alternate)})` : i.getParenthesisedText(a, l.alternate), d = i.getParenthesisedText(a, l.test);
              return s.replaceText(l, `${d} || ${g}`);
            }
          });
        }
      };
    }
  }, Cu;
}
var vu, _y;
function zR() {
  if (_y) return vu;
  _y = 1;
  function i(f) {
    return !!f.init;
  }
  function t(f) {
    for (const r of f)
      if (r.reachable)
        return !1;
    return !0;
  }
  class o {
    constructor(r) {
      this.sourceCode = r, this.startNode = null, this.endNode = null;
    }
    /**
     * The location object of this range.
     * @type {Object}
     */
    get location() {
      return {
        start: this.startNode.loc.start,
        end: this.endNode.loc.end
      };
    }
    /**
     * `true` if this range is empty.
     * @type {boolean}
     */
    get isEmpty() {
      return !(this.startNode && this.endNode);
    }
    /**
     * Checks whether the given node is inside of this range.
     * @param {ASTNode|Token} node The node to check.
     * @returns {boolean} `true` if the node is inside of this range.
     */
    contains(r) {
      return r.range[0] >= this.startNode.range[0] && r.range[1] <= this.endNode.range[1];
    }
    /**
     * Checks whether the given node is consecutive to this range.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} `true` if the node is consecutive to this range.
     */
    isConsecutive(r) {
      return this.contains(this.sourceCode.getTokenBefore(r));
    }
    /**
     * Merges the given node to this range.
     * @param {ASTNode} node The node to merge.
     * @returns {void}
     */
    merge(r) {
      this.endNode = r;
    }
    /**
     * Resets this range by the given node or null.
     * @param {ASTNode|null} node The node to reset, or null.
     * @returns {void}
     */
    reset(r) {
      this.startNode = this.endNode = r;
    }
  }
  return vu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unreachable"
      },
      schema: [],
      messages: {
        unreachableCode: "Unreachable code."
      }
    },
    create(f) {
      let r = null;
      const u = new o(f.sourceCode), e = [];
      let a = /* @__PURE__ */ new Set();
      function n(p) {
        let m = null;
        if (p && (p.type === "PropertyDefinition" || t(a))) {
          if (u.isEmpty) {
            u.reset(p);
            return;
          }
          if (u.contains(p))
            return;
          if (u.isConsecutive(p)) {
            u.merge(p);
            return;
          }
          m = p;
        }
        u.isEmpty || f.report({
          messageId: "unreachableCode",
          loc: u.location,
          node: u.startNode
        }), u.reset(m);
      }
      return {
        // Manages the current code path.
        onCodePathStart() {
          e.push(a), a = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          a = e.pop();
        },
        onUnreachableCodePathSegmentStart(p) {
          a.add(p);
        },
        onUnreachableCodePathSegmentEnd(p) {
          a.delete(p);
        },
        onCodePathSegmentEnd(p) {
          a.delete(p);
        },
        onCodePathSegmentStart(p) {
          a.add(p);
        },
        // Registers for all statement nodes (excludes FunctionDeclaration).
        BlockStatement: n,
        BreakStatement: n,
        ClassDeclaration: n,
        ContinueStatement: n,
        DebuggerStatement: n,
        DoWhileStatement: n,
        ExpressionStatement: n,
        ForInStatement: n,
        ForOfStatement: n,
        ForStatement: n,
        IfStatement: n,
        ImportDeclaration: n,
        LabeledStatement: n,
        ReturnStatement: n,
        SwitchStatement: n,
        ThrowStatement: n,
        TryStatement: n,
        VariableDeclaration(p) {
          (p.kind !== "var" || p.declarations.some(i)) && n(p);
        },
        WhileStatement: n,
        WithStatement: n,
        ExportNamedDeclaration: n,
        ExportDefaultDeclaration: n,
        ExportAllDeclaration: n,
        "Program:exit"() {
          n();
        },
        /*
         * Instance fields defined in a subclass are never created if the constructor of the subclass
         * doesn't call `super()`, so their definitions are unreachable code.
         */
        "MethodDefinition[kind='constructor']"() {
          r = {
            upper: r,
            hasSuperCall: !1
          };
        },
        "MethodDefinition[kind='constructor']:exit"(p) {
          const { hasSuperCall: m } = r;
          if (r = r.upper, !p.value.body)
            return;
          const h = p.parent.parent;
          if (h.superClass && !m)
            for (const l of h.body.body)
              l.type === "PropertyDefinition" && !l.static && n(l);
        },
        "CallExpression > Super.callee"() {
          r && (r.hasSuperCall = !0);
        }
      };
    }
  }, vu;
}
var Su, wy;
function HR() {
  if (wy) return Su;
  wy = 1;
  const i = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
  function t(r) {
    for (const u of r)
      if (u.reachable)
        return !0;
    return !1;
  }
  function o(r) {
    const u = r.parent;
    if (u)
      switch (u.type) {
        case "WhileStatement":
          return r === u.test;
        case "DoWhileStatement":
          return r === u.body;
        case "ForStatement":
          return r === (u.update || u.test || u.body);
        case "ForInStatement":
        case "ForOfStatement":
          return r === u.left;
      }
    return !1;
  }
  function f(r, u) {
    return r.filter((e) => !u.includes(e));
  }
  return Su = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow loops with a body that allows only one iteration",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-unreachable-loop"
      },
      schema: [{
        type: "object",
        properties: {
          ignore: {
            type: "array",
            items: {
              enum: i
            },
            uniqueItems: !0
          }
        },
        additionalProperties: !1
      }],
      messages: {
        invalid: "Invalid loop. Its body allows only one iteration."
      }
    },
    create(r) {
      const u = r.options[0] && r.options[0].ignore || [], e = f(i, u), a = e.join(","), n = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Set(), m = [];
      let h = /* @__PURE__ */ new Set();
      return {
        onCodePathStart() {
          m.push(h), h = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          h = m.pop();
        },
        onUnreachableCodePathSegmentStart(l) {
          h.add(l);
        },
        onUnreachableCodePathSegmentEnd(l) {
          h.delete(l);
        },
        onCodePathSegmentEnd(l) {
          h.delete(l);
        },
        onCodePathSegmentStart(l, s) {
          if (h.add(l), o(s)) {
            const c = s.parent;
            n.set(l, c);
          }
        },
        onCodePathSegmentLoop(l, s, c) {
          const g = n.get(s);
          (c === g || c.type === "ContinueStatement") && p.delete(g);
        },
        [a](l) {
          t(h) && p.add(l);
        },
        "Program:exit"() {
          p.forEach(
            (l) => r.report({ node: l, messageId: "invalid" })
          );
        }
      };
    }
  }, Su;
}
var Au, ky;
function JR() {
  if (ky) return Au;
  ky = 1;
  const i = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u, t = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u, o = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
  return Au = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow control flow statements in `finally` blocks",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-finally"
      },
      schema: [],
      messages: {
        unsafeUsage: "Unsafe usage of {{nodeType}}."
      }
    },
    create(f) {
      function r(a) {
        return a.parent.type === "TryStatement" && a.parent.finalizer === a;
      }
      function u(a, n) {
        let p = !1, m;
        a.type === "BreakStatement" && !a.label ? m = t : a.type === "ContinueStatement" ? m = o : m = i;
        for (let h = a; h && !m.test(h.type); h = h.parent)
          if (h.parent.label && n && h.parent.label.name === n.name && (p = !0), r(h))
            return !(n && p);
        return !1;
      }
      function e(a) {
        u(a, a.label) && f.report({
          messageId: "unsafeUsage",
          data: {
            nodeType: a.type
          },
          node: a,
          line: a.loc.line,
          column: a.loc.column
        });
      }
      return {
        ReturnStatement: e,
        ThrowStatement: e,
        BreakStatement: e,
        ContinueStatement: e
      };
    }
  }, Au;
}
var Tu, By;
function QR() {
  if (By) return Tu;
  By = 1;
  const i = Re();
  function t(r) {
    return r === "in" || r === "instanceof";
  }
  function o(r) {
    return r === "<" || r === ">" || r === ">=" || r === "<=";
  }
  function f(r) {
    return r.type === "UnaryExpression" && r.operator === "!";
  }
  return Tu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow negating the left operand of relational operators",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-negation"
      },
      hasSuggestions: !0,
      schema: [
        {
          type: "object",
          properties: {
            enforceForOrderingRelations: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: null,
      messages: {
        unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
        suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
        suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
      }
    },
    create(r) {
      const u = r.sourceCode, a = (r.options[0] || {}).enforceForOrderingRelations === !0;
      return {
        BinaryExpression(n) {
          const p = n.operator, m = a && o(p);
          (t(p) || m) && f(n.left) && !i.isParenthesised(u, n.left) && r.report({
            node: n,
            loc: n.left.loc,
            messageId: "unexpected",
            data: { operator: p },
            suggest: [
              {
                messageId: "suggestNegatedExpression",
                data: { operator: p },
                fix(h) {
                  const s = [u.getFirstToken(n.left).range[1], n.range[1]], c = u.text.slice(s[0], s[1]);
                  return h.replaceTextRange(s, `(${c})`);
                }
              },
              {
                messageId: "suggestParenthesisedNegation",
                fix(h) {
                  return h.replaceText(n.left, `(${u.getText(n.left)})`);
                }
              }
            ]
          });
        }
      };
    }
  }, Tu;
}
var bu, Py;
function YR() {
  if (Py) return bu;
  Py = 1;
  const i = /* @__PURE__ */ new Set(["+", "-", "/", "*", "%", "**"]), t = /* @__PURE__ */ new Set(["+=", "-=", "/=", "*=", "%=", "**="]), o = /* @__PURE__ */ new Set(["in", "instanceof"]);
  function f(r) {
    return r.type === "ObjectPattern" || r.type === "ArrayPattern";
  }
  return bu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow use of optional chaining in contexts where the `undefined` value is not allowed",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-optional-chaining"
      },
      schema: [{
        type: "object",
        properties: {
          disallowArithmeticOperators: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      fixable: null,
      messages: {
        unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
        unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
      }
    },
    create(r) {
      const e = (r.options[0] || {}).disallowArithmeticOperators || !1;
      function a(l) {
        r.report({
          messageId: "unsafeOptionalChain",
          node: l
        });
      }
      function n(l) {
        r.report({
          messageId: "unsafeArithmetic",
          node: l
        });
      }
      function p(l, s) {
        if (l)
          switch (l.type) {
            case "LogicalExpression":
              l.operator === "||" || l.operator === "??" ? p(l.right, s) : l.operator === "&&" && (p(l.left, s), p(l.right, s));
              break;
            case "SequenceExpression":
              p(
                l.expressions[l.expressions.length - 1],
                s
              );
              break;
            case "ConditionalExpression":
              p(l.consequent, s), p(l.alternate, s);
              break;
            case "AwaitExpression":
              p(l.argument, s);
              break;
            case "ChainExpression":
              s(l);
              break;
          }
      }
      function m(l) {
        p(l, a);
      }
      function h(l) {
        p(l, n);
      }
      return {
        "AssignmentExpression, AssignmentPattern"(l) {
          f(l.left) && m(l.right);
        },
        "ClassDeclaration, ClassExpression"(l) {
          m(l.superClass);
        },
        CallExpression(l) {
          l.optional || m(l.callee);
        },
        NewExpression(l) {
          m(l.callee);
        },
        VariableDeclarator(l) {
          f(l.id) && m(l.init);
        },
        MemberExpression(l) {
          l.optional || m(l.object);
        },
        TaggedTemplateExpression(l) {
          m(l.tag);
        },
        ForOfStatement(l) {
          m(l.right);
        },
        SpreadElement(l) {
          l.parent && l.parent.type !== "ObjectExpression" && m(l.argument);
        },
        BinaryExpression(l) {
          o.has(l.operator) && m(l.right), e && i.has(l.operator) && (h(l.right), h(l.left));
        },
        WithStatement(l) {
          m(l.object);
        },
        UnaryExpression(l) {
          e && i.has(l.operator) && h(l.argument);
        },
        AssignmentExpression(l) {
          e && t.has(l.operator) && h(l.right);
        }
      };
    }
  }, bu;
}
var xu, Iy;
function ZR() {
  if (Iy) return xu;
  Iy = 1;
  const i = Re();
  function t() {
    return !0;
  }
  function o() {
    return !1;
  }
  return xu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unused expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-unused-expressions"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowShortCircuit: {
              type: "boolean",
              default: !1
            },
            allowTernary: {
              type: "boolean",
              default: !1
            },
            allowTaggedTemplates: {
              type: "boolean",
              default: !1
            },
            enforceForJSX: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unusedExpression: "Expected an assignment or function call and instead saw an expression."
      }
    },
    create(f) {
      const r = f.options[0] || {}, u = r.allowShortCircuit || !1, e = r.allowTernary || !1, a = r.allowTaggedTemplates || !1, n = r.enforceForJSX || !1;
      function p(c) {
        return c.type === "ExpressionStatement" && c.expression.type === "Literal" && typeof c.expression.value == "string";
      }
      function m(c, g) {
        for (let d = 0; d < g.length; ++d)
          if (!c(g[d]))
            return g.slice(0, d);
        return g.slice();
      }
      function h(c) {
        return m(p, c.body);
      }
      function l(c) {
        return i.isTopLevelExpressionStatement(c) && h(c.parent).includes(c);
      }
      const s = Object.assign(/* @__PURE__ */ Object.create(null), {
        isDisallowed(c) {
          return (s[c.type] || o)(c);
        },
        ArrayExpression: t,
        ArrowFunctionExpression: t,
        BinaryExpression: t,
        ChainExpression(c) {
          return s.isDisallowed(c.expression);
        },
        ClassExpression: t,
        ConditionalExpression(c) {
          return e ? s.isDisallowed(c.consequent) || s.isDisallowed(c.alternate) : !0;
        },
        FunctionExpression: t,
        Identifier: t,
        JSXElement() {
          return n;
        },
        JSXFragment() {
          return n;
        },
        Literal: t,
        LogicalExpression(c) {
          return u ? s.isDisallowed(c.right) : !0;
        },
        MemberExpression: t,
        MetaProperty: t,
        ObjectExpression: t,
        SequenceExpression: t,
        TaggedTemplateExpression() {
          return !a;
        },
        TemplateLiteral: t,
        ThisExpression: t,
        UnaryExpression(c) {
          return c.operator !== "void" && c.operator !== "delete";
        }
      });
      return {
        ExpressionStatement(c) {
          s.isDisallowed(c.expression) && !l(c) && f.report({ node: c, messageId: "unusedExpression" });
        }
      };
    }
  }, xu;
}
var Ru, Fy;
function eD() {
  if (Fy) return Ru;
  Fy = 1;
  const i = Re();
  return Ru = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unused labels",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unused-labels"
      },
      schema: [],
      fixable: "code",
      messages: {
        unused: "'{{name}}:' is defined but never used."
      }
    },
    create(t) {
      const o = t.sourceCode;
      let f = null;
      function r(n) {
        f = {
          label: n.label.name,
          used: !1,
          upper: f
        };
      }
      function u(n) {
        if (o.getTokenAfter(n.label, { includeComments: !0 }) !== o.getTokenBefore(n.body, { includeComments: !0 }))
          return !1;
        let p = n.parent;
        for (; p.type === "LabeledStatement"; )
          p = p.parent;
        if (p.type === "Program" || p.type === "BlockStatement" && i.isFunction(p.parent)) {
          const { body: m } = n;
          if (m.type === "ExpressionStatement" && (m.expression.type === "Literal" && typeof m.expression.value == "string" || i.isStaticTemplateLiteral(m.expression)))
            return !1;
        }
        return !0;
      }
      function e(n) {
        f.used || t.report({
          node: n.label,
          messageId: "unused",
          data: n.label,
          fix: u(n) ? (p) => p.removeRange([n.range[0], n.body.range[0]]) : null
        }), f = f.upper;
      }
      function a(n) {
        if (!n.label)
          return;
        const p = n.label.name;
        let m = f;
        for (; m; ) {
          if (m.label === p) {
            m.used = !0;
            break;
          }
          m = m.upper;
        }
      }
      return {
        LabeledStatement: r,
        "LabeledStatement:exit": e,
        BreakStatement: a,
        ContinueStatement: a
      };
    }
  }, Ru;
}
var Du, Ny;
function tD() {
  return Ny || (Ny = 1, Du = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unused private class members",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-unused-private-class-members"
      },
      schema: [],
      messages: {
        unusedPrivateClassMember: "'{{classMemberName}}' is defined but never used."
      }
    },
    create(i) {
      const t = [];
      function o(f) {
        const r = f.parent.parent, u = r.type === "AssignmentExpression";
        return !u && r.type !== "ForInStatement" && r.type !== "ForOfStatement" && r.type !== "AssignmentPattern" || r.left !== f.parent ? !1 : u && r.operator !== "=" ? r.parent.type === "ExpressionStatement" : !0;
      }
      return {
        // Collect all declared members up front and assume they are all unused
        ClassBody(f) {
          const r = /* @__PURE__ */ new Map();
          t.unshift(r);
          for (const u of f.body)
            (u.type === "PropertyDefinition" || u.type === "MethodDefinition") && u.key.type === "PrivateIdentifier" && r.set(u.key.name, {
              declaredNode: u,
              isAccessor: u.type === "MethodDefinition" && (u.kind === "set" || u.kind === "get")
            });
        },
        /*
         * Process all usages of the private identifier and remove a member from
         * `declaredAndUnusedPrivateMembers` if we deem it used.
         */
        PrivateIdentifier(f) {
          const r = t.find((n) => n.has(f.name));
          if (!r)
            return;
          const u = r.get(f.name);
          if (u.isUsed || f.parent.type === "PropertyDefinition" || f.parent.type === "MethodDefinition")
            return;
          if (u.isAccessor) {
            u.isUsed = !0;
            return;
          }
          if (o(f))
            return;
          const e = f.parent.parent.type, a = f.parent.parent.parent.type;
          e === "UpdateExpression" && a === "ExpressionStatement" || e === "Property" && a === "ObjectPattern" && f.parent.parent.value === f.parent || e !== "RestElement" && e !== "ArrayPattern" && (u.isUsed = !0);
        },
        /*
         * Post-process the class members and report any remaining members.
         * Since private members can only be accessed in the current class context,
         * we can safely assume that all usages are within the current class body.
         */
        "ClassBody:exit"() {
          const f = t.shift();
          for (const [r, { declaredNode: u, isUsed: e }] of f.entries())
            e || i.report({
              node: u,
              loc: u.key.loc,
              messageId: "unusedPrivateClassMember",
              data: {
                classMemberName: `#${r}`
              }
            });
        }
      };
    }
  }), Du;
}
var Lu, Oy;
function rD() {
  if (Oy) return Lu;
  Oy = 1;
  const i = Re();
  return Lu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unused variables",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-unused-vars"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["all", "local"]
            },
            {
              type: "object",
              properties: {
                vars: {
                  enum: ["all", "local"]
                },
                varsIgnorePattern: {
                  type: "string"
                },
                args: {
                  enum: ["all", "after-used", "none"]
                },
                ignoreRestSiblings: {
                  type: "boolean"
                },
                argsIgnorePattern: {
                  type: "string"
                },
                caughtErrors: {
                  enum: ["all", "none"]
                },
                caughtErrorsIgnorePattern: {
                  type: "string"
                },
                destructuredArrayIgnorePattern: {
                  type: "string"
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
      }
    },
    create(t) {
      const o = t.sourceCode, f = /^(?:RestElement|(?:Experimental)?RestProperty)$/u, r = {
        vars: "all",
        args: "after-used",
        ignoreRestSiblings: !1,
        caughtErrors: "none"
      }, u = t.options[0];
      u && (typeof u == "string" ? r.vars = u : (r.vars = u.vars || r.vars, r.args = u.args || r.args, r.ignoreRestSiblings = u.ignoreRestSiblings || r.ignoreRestSiblings, r.caughtErrors = u.caughtErrors || r.caughtErrors, u.varsIgnorePattern && (r.varsIgnorePattern = new RegExp(u.varsIgnorePattern, "u")), u.argsIgnorePattern && (r.argsIgnorePattern = new RegExp(u.argsIgnorePattern, "u")), u.caughtErrorsIgnorePattern && (r.caughtErrorsIgnorePattern = new RegExp(u.caughtErrorsIgnorePattern, "u")), u.destructuredArrayIgnorePattern && (r.destructuredArrayIgnorePattern = new RegExp(u.destructuredArrayIgnorePattern, "u"))));
      function e(R) {
        const L = R.defs && R.defs[0] && R.defs[0].type;
        let _, I;
        L === "CatchClause" && r.caughtErrorsIgnorePattern ? (_ = "args", I = r.caughtErrorsIgnorePattern.toString()) : L === "Parameter" && r.argsIgnorePattern ? (_ = "args", I = r.argsIgnorePattern.toString()) : L !== "Parameter" && r.varsIgnorePattern && (_ = "vars", I = r.varsIgnorePattern.toString());
        const O = _ ? `. Allowed unused ${_} must match ${I}` : "";
        return {
          varName: R.name,
          action: "defined",
          additional: O
        };
      }
      function a(R) {
        const L = R.defs[0];
        let _ = "";
        return r.destructuredArrayIgnorePattern && L && L.name.parent.type === "ArrayPattern" ? _ = `. Allowed unused elements of array destructuring patterns must match ${r.destructuredArrayIgnorePattern.toString()}` : r.varsIgnorePattern && (_ = `. Allowed unused vars must match ${r.varsIgnorePattern.toString()}`), {
          varName: R.name,
          action: "assigned a value",
          additional: _
        };
      }
      const n = /(?:Statement|Declaration)$/u;
      function p(R) {
        const L = R.defs[0];
        if (L) {
          let _ = L.node;
          if (_.type === "VariableDeclarator")
            _ = _.parent;
          else if (L.type === "Parameter")
            return !1;
          return _.parent.type.indexOf("Export") === 0;
        }
        return !1;
      }
      function m(R) {
        return R.type === "Property" && R.parent.type === "ObjectPattern" && f.test(R.parent.properties[R.parent.properties.length - 1].type);
      }
      function h(R) {
        if (r.ignoreRestSiblings) {
          const L = R.defs.some((I) => m(I.name.parent)), _ = R.references.some((I) => m(I.identifier.parent));
          return L || _;
        }
        return !1;
      }
      function l(R) {
        return R.isRead();
      }
      function s(R, L) {
        let _ = R.from;
        for (; _; ) {
          if (L.includes(_.block))
            return !0;
          _ = _.upper;
        }
        return !1;
      }
      function c(R) {
        const L = [];
        return R.defs.forEach((_) => {
          const { type: I, node: O } = _;
          I === "FunctionName" && L.push(O), I === "Variable" && O.init && (O.init.type === "FunctionExpression" || O.init.type === "ArrowFunctionExpression") && L.push(O.init);
        }), L;
      }
      function g(R, L) {
        return R.range[0] >= L.range[0] && R.range[1] <= L.range[1];
      }
      function d(R) {
        const L = R.parent;
        return L.type === "ExpressionStatement" ? !0 : L.type === "SequenceExpression" ? L.expressions[L.expressions.length - 1] === R ? d(L) : !0 : !1;
      }
      function y(R, L) {
        const _ = R.identifier, I = _.parent, O = R.from.variableScope, k = R.resolved.scope.variableScope, w = O !== k || i.isInLoop(_);
        return L && g(_, L) ? L : I.type === "AssignmentExpression" && d(I) && _ === I.left && !w ? I.right : null;
      }
      function v(R, L) {
        let _ = R, I = R.parent;
        for (; I && g(I, L); ) {
          switch (I.type) {
            case "SequenceExpression":
              if (I.expressions[I.expressions.length - 1] !== _)
                return !1;
              break;
            case "CallExpression":
            case "NewExpression":
              return I.callee !== _;
            case "AssignmentExpression":
            case "TaggedTemplateExpression":
            case "YieldExpression":
              return !0;
            default:
              if (n.test(I.type))
                return !0;
          }
          _ = I, I = I.parent;
        }
        return !1;
      }
      function T(R, L) {
        const _ = i.getUpperFunction(R);
        return _ && g(_, L) && v(_, L);
      }
      function b(R, L) {
        const _ = R.identifier, I = _.parent;
        return R.isRead() && // self update. e.g. `a += 1`, `a++`
        (I.type === "AssignmentExpression" && I.left === _ && d(I) && !i.isLogicalAssignmentOperator(I.operator) || I.type === "UpdateExpression" && d(I) || // in RHS of an assignment for itself. e.g. `a = a + 1`
        L && g(_, L) && !T(_, L));
      }
      function S(R) {
        let L = R.identifier.parent;
        return L.type === "VariableDeclarator" && (L = L.parent.parent), L.type !== "ForInStatement" && L.type !== "ForOfStatement" || (L.body.type === "BlockStatement" ? L = L.body.body[0] : L = L.body, !L) ? !1 : L.type === "ReturnStatement";
      }
      function C(R) {
        const L = c(R), _ = L.length > 0;
        let I = null;
        return R.references.some((O) => {
          if (S(O))
            return !0;
          const k = b(O, I);
          return I = y(O, I), l(O) && !k && !(_ && s(O, L));
        });
      }
      function x(R) {
        const L = R.defs[0], _ = o.getDeclaredVariables(L.node);
        return !_.slice(_.indexOf(R) + 1).some((O) => O.references.length > 0 || O.eslintUsed);
      }
      function A(R, L) {
        const _ = R.variables, I = R.childScopes;
        let O, k;
        if (R.type !== "global" || r.vars === "all")
          for (O = 0, k = _.length; O < k; ++O) {
            const w = _[O];
            if (R.type === "class" && R.block.id === w.identifiers[0] || R.functionExpressionScope || w.eslintUsed || R.type === "function" && w.name === "arguments" && w.identifiers.length === 0)
              continue;
            const U = w.defs[0];
            if (U) {
              const q = U.type, F = w.references.some(($) => $.identifier.parent.type === "ArrayPattern");
              if ((U.name.parent.type === "ArrayPattern" || F) && r.destructuredArrayIgnorePattern && r.destructuredArrayIgnorePattern.test(U.name.name) || q === "CatchClause" && (r.caughtErrors === "none" || r.caughtErrorsIgnorePattern && r.caughtErrorsIgnorePattern.test(U.name.name)))
                continue;
              if (q === "Parameter") {
                if ((U.node.parent.type === "Property" || U.node.parent.type === "MethodDefinition") && U.node.parent.kind === "set" || r.args === "none" || r.argsIgnorePattern && r.argsIgnorePattern.test(U.name.name) || r.args === "after-used" && i.isFunction(U.name.parent) && !x(w))
                  continue;
              } else if (r.varsIgnorePattern && r.varsIgnorePattern.test(U.name.name))
                continue;
            }
            !C(w) && !p(w) && !h(w) && L.push(w);
          }
        for (O = 0, k = I.length; O < k; ++O)
          A(I[O], L);
        return L;
      }
      return {
        "Program:exit"(R) {
          const L = A(o.getScope(R), []);
          for (let _ = 0, I = L.length; _ < I; ++_) {
            const O = L[_];
            if (O.defs.length > 0) {
              const k = O.references.filter((U) => U.isWrite() && U.from.variableScope === O.scope.variableScope);
              let w;
              k.length > 0 && (w = k[k.length - 1]), t.report({
                node: w ? w.identifier : O.identifiers[0],
                messageId: "unusedVar",
                data: O.references.some((U) => U.isWrite()) ? a(O) : e(O)
              });
            } else if (O.eslintExplicitGlobalComments) {
              const k = O.eslintExplicitGlobalComments[0];
              t.report({
                node: R,
                loc: i.getNameLocationInGlobalDirectiveComment(o, k, O.name),
                messageId: "unusedVar",
                data: e(O)
              });
            }
          }
        }
      };
    }
  }, Lu;
}
var _u, Uy;
function nD() {
  if (Uy) return _u;
  Uy = 1;
  const i = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u, t = /^For(?:In|Of)Statement$/u;
  function o(n) {
    let p = !0, m = !0, h = !0, l = !1;
    return typeof n == "string" ? p = n !== "nofunc" : typeof n == "object" && n !== null && (p = n.functions !== !1, m = n.classes !== !1, h = n.variables !== !1, l = !!n.allowNamedExports), { functions: p, classes: m, variables: h, allowNamedExports: l };
  }
  function f(n, p) {
    return n && n.range[0] <= p && p <= n.range[1];
  }
  function r(n, p) {
    return n.body.some((m) => m.type === "StaticBlock" && f(m, p) || m.type === "PropertyDefinition" && m.static && m.value && f(m.value, p));
  }
  function u(n) {
    return n.type === "class-static-block" ? !0 : n.type === "class-field-initializer" ? n.block.parent.static : !1;
  }
  function e(n) {
    const p = n.resolved;
    let m = n.from;
    for (; p.scope.variableScope !== m.variableScope; )
      if (u(m.variableScope))
        m = m.variableScope.upper;
      else
        return !0;
    return !1;
  }
  function a(n) {
    if (e(n))
      return !1;
    const p = n.identifier.range[1], m = n.resolved.defs[0];
    if (m.type === "ClassName") {
      const l = m.node;
      return f(l, p) && /*
      * Class binding is initialized before running static initializers.
      * For example, `class C { static foo = C; static { bar = C; } }` is valid.
      */
      !r(l.body, p);
    }
    let h = m.name.parent;
    for (; h; ) {
      if (h.type === "VariableDeclarator") {
        if (f(h.init, p) || t.test(h.parent.parent.type) && f(h.parent.parent.right, p))
          return !0;
        break;
      } else if (h.type === "AssignmentPattern") {
        if (f(h.right, p))
          return !0;
      } else if (i.test(h.type))
        break;
      h = h.parent;
    }
    return !1;
  }
  return _u = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow the use of variables before they are defined",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-use-before-define"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["nofunc"]
            },
            {
              type: "object",
              properties: {
                functions: { type: "boolean" },
                classes: { type: "boolean" },
                variables: { type: "boolean" },
                allowNamedExports: { type: "boolean" }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        usedBeforeDefined: "'{{name}}' was used before it was defined."
      }
    },
    create(n) {
      const p = o(n.options[0]), m = n.sourceCode;
      function h(s) {
        if (s.init)
          return !1;
        const { identifier: c } = s;
        if (p.allowNamedExports && c.parent.type === "ExportSpecifier" && c.parent.local === c)
          return !1;
        const g = s.resolved;
        if (!g || g.defs.length === 0)
          return !1;
        const d = g.defs[0].type;
        return !(!p.functions && d === "FunctionName" || (!p.variables && d === "Variable" || !p.classes && d === "ClassName") && // don't skip checking the reference if it's in the same execution context, because of TDZ
        e(s));
      }
      function l(s) {
        s.references.filter(h).forEach((c) => {
          const d = c.resolved.defs[0].name;
          (c.identifier.range[1] < d.range[1] || a(c)) && n.report({
            node: c.identifier,
            messageId: "usedBeforeDefined",
            data: c.identifier
          });
        }), s.childScopes.forEach(l);
      }
      return {
        Program(s) {
          l(m.getScope(s));
        }
      };
    }
  }, _u;
}
var wu, Vy;
function sD() {
  if (Vy) return wu;
  Vy = 1;
  const { CALL: i, CONSTRUCT: t, ReferenceTracker: o, getStringIfConstant: f } = Ft(), { RegExpParser: r, visitRegExpAST: u } = rr(), e = new r();
  function a(m) {
    const h = [];
    let l = m;
    do
      h.push(l), l = l.parent;
    while (l);
    return h;
  }
  function n(m) {
    return m.type === "Assertion" && (m.kind === "lookahead" || m.kind === "lookbehind");
  }
  function p(m) {
    return n(m) && m.negate;
  }
  return wu = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow useless backreferences in regular expressions",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-useless-backreference"
      },
      schema: [],
      messages: {
        nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
        forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
        backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
        disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
        intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."
      }
    },
    create(m) {
      const h = m.sourceCode;
      function l(s, c, g) {
        let d;
        try {
          d = e.parsePattern(c, 0, c.length, { unicode: g.includes("u"), unicodeSets: g.includes("v") });
        } catch {
          return;
        }
        u(d, {
          onBackreferenceEnter(y) {
            const v = y.resolved, T = a(y), b = a(v);
            let S = null;
            if (T.includes(v))
              S = "nested";
            else {
              let C = T.length - 1, x = b.length - 1;
              do
                C--, x--;
              while (T[C] === b[x]);
              const A = x + 1, R = b.slice(0, A), L = b.slice(A), _ = L.find(n), I = _ && _.kind === "lookbehind";
              !I && y.end <= v.start ? S = "forward" : I && v.end <= y.start ? S = "backward" : R[R.length - 1].type === "Alternative" ? S = "disjunctive" : R.some(p) && (S = "intoNegativeLookaround");
            }
            S && m.report({
              node: s,
              messageId: S,
              data: {
                bref: y.raw,
                group: v.raw
              }
            });
          }
        });
      }
      return {
        "Literal[regex]"(s) {
          const { pattern: c, flags: g } = s.regex;
          l(s, c, g);
        },
        Program(s) {
          const c = h.getScope(s), g = new o(c), d = {
            RegExp: {
              [i]: !0,
              [t]: !0
            }
          };
          for (const { node: y } of g.iterateGlobalReferences(d)) {
            const [v, T] = y.arguments, b = f(v, c), S = f(T, c);
            typeof b == "string" && l(y, b, S || "");
          }
        }
      };
    }
  }, wu;
}
var ku, My;
function iD() {
  if (My) return ku;
  My = 1;
  const i = Re();
  function t(f) {
    const r = i.skipChainExpression(f.callee);
    return r.type === "MemberExpression" && r.property.type === "Identifier" && r.computed === !1 && (r.property.name === "call" && f.arguments.length >= 1 || r.property.name === "apply" && f.arguments.length === 2 && f.arguments[1].type === "ArrayExpression");
  }
  function o(f, r, u) {
    return f ? i.equalTokens(f, r, u) : i.isNullOrUndefined(r);
  }
  return ku = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary calls to `.call()` and `.apply()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-call"
      },
      schema: [],
      messages: {
        unnecessaryCall: "Unnecessary '.{{name}}()'."
      }
    },
    create(f) {
      const r = f.sourceCode;
      return {
        CallExpression(u) {
          if (!t(u))
            return;
          const e = i.skipChainExpression(u.callee), a = i.skipChainExpression(e.object), n = a.type === "MemberExpression" ? a.object : null, p = u.arguments[0];
          o(n, p, r) && f.report({ node: u, messageId: "unnecessaryCall", data: { name: e.property.name } });
        }
      };
    }
  }, ku;
}
var Bu, Ky;
function aD() {
  return Ky || (Ky = 1, Bu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary `catch` clauses",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-useless-catch"
      },
      schema: [],
      messages: {
        unnecessaryCatchClause: "Unnecessary catch clause.",
        unnecessaryCatch: "Unnecessary try/catch wrapper."
      }
    },
    create(i) {
      return {
        CatchClause(t) {
          t.param && t.param.type === "Identifier" && t.body.body.length && t.body.body[0].type === "ThrowStatement" && t.body.body[0].argument.type === "Identifier" && t.body.body[0].argument.name === t.param.name && (t.parent.finalizer ? i.report({
            node: t,
            messageId: "unnecessaryCatchClause"
          }) : i.report({
            node: t.parent,
            messageId: "unnecessaryCatch"
          }));
        }
      };
    }
  }), Bu;
}
var Pu, jy;
function oD() {
  if (jy) return Pu;
  jy = 1;
  const i = Re();
  function t(o) {
    if (!o.computed)
      return !1;
    const { key: f } = o;
    if (f.type !== "Literal")
      return !1;
    const { value: r } = f;
    if (typeof r != "number" && typeof r != "string")
      return !1;
    switch (o.type) {
      case "Property":
        return r !== "__proto__";
      case "PropertyDefinition":
        return o.static ? r !== "constructor" && r !== "prototype" : r !== "constructor";
      case "MethodDefinition":
        return o.static ? r !== "prototype" : r !== "constructor";
      default:
        throw new Error(`Unexpected node type: ${o.type}`);
    }
  }
  return Pu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary computed property keys in objects and classes",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-computed-key"
      },
      schema: [{
        type: "object",
        properties: {
          enforceForClassMembers: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      fixable: "code",
      messages: {
        unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
      }
    },
    create(o) {
      const f = o.sourceCode, r = o.options[0] && o.options[0].enforceForClassMembers;
      function u(a) {
        if (t(a)) {
          const { key: n } = a;
          o.report({
            node: a,
            messageId: "unnecessarilyComputedProperty",
            data: { property: f.getText(n) },
            fix(p) {
              const m = f.getTokenBefore(n, i.isOpeningBracketToken), h = f.getTokenAfter(n, i.isClosingBracketToken);
              if (f.commentsExistBetween(m, h))
                return null;
              const l = f.getTokenBefore(m), c = (l.range[1] === m.range[0] && !i.canTokensBeAdjacent(l, f.getFirstToken(n)) ? " " : "") + n.raw;
              return p.replaceTextRange([m.range[0], h.range[1]], c);
            }
          });
        }
      }
      function e() {
      }
      return {
        Property: u,
        MethodDefinition: r ? u : e,
        PropertyDefinition: r ? u : e
      };
    }
  }, Pu;
}
var Iu, qy;
function lD() {
  if (qy) return Iu;
  qy = 1;
  const i = Re();
  function t(u) {
    return u.type === "BinaryExpression" && u.operator === "+";
  }
  function o(u) {
    return u.value === "+" && u.type === "Punctuator";
  }
  function f(u) {
    let e = u.left;
    for (; t(e); )
      e = e.right;
    return e;
  }
  function r(u) {
    let e = u.right;
    for (; t(e); )
      e = e.left;
    return e;
  }
  return Iu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary concatenation of literals or template literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-concat"
      },
      schema: [],
      messages: {
        unexpectedConcat: "Unexpected string concatenation of literals."
      }
    },
    create(u) {
      const e = u.sourceCode;
      return {
        BinaryExpression(a) {
          if (a.operator !== "+")
            return;
          const n = f(a), p = r(a);
          if (i.isStringLiteral(n) && i.isStringLiteral(p) && i.isTokenOnSameLine(n, p)) {
            const m = e.getFirstTokenBetween(n, p, o);
            u.report({
              node: a,
              loc: m.loc,
              messageId: "unexpectedConcat"
            });
          }
        }
      };
    }
  }, Iu;
}
var Fu, $y;
function uD() {
  if ($y) return Fu;
  $y = 1;
  function i(n) {
    return n.length === 1 && n[0].type === "ExpressionStatement" && n[0].expression.type === "CallExpression" && n[0].expression.callee.type === "Super";
  }
  function t(n) {
    return n.type === "Identifier" || n.type === "RestElement";
  }
  function o(n) {
    return n.length === 1 && n[0].type === "SpreadElement" && n[0].argument.type === "Identifier" && n[0].argument.name === "arguments";
  }
  function f(n, p) {
    return n.type === "Identifier" && p.type === "Identifier" && n.name === p.name;
  }
  function r(n, p) {
    return n.type === "RestElement" && p.type === "SpreadElement" && f(n.argument, p.argument);
  }
  function u(n, p) {
    return f(n, p) || r(n, p);
  }
  function e(n, p) {
    if (n.length !== p.length)
      return !1;
    for (let m = 0; m < n.length; ++m)
      if (!u(n[m], p[m]))
        return !1;
    return !0;
  }
  function a(n, p) {
    return i(n) && p.every(t) && (o(n[0].expression.arguments) || e(p, n[0].expression.arguments));
  }
  return Fu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary constructors",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-constructor"
      },
      schema: [],
      messages: {
        noUselessConstructor: "Useless constructor."
      }
    },
    create(n) {
      function p(m) {
        if (m.kind !== "constructor" || !m.value.body)
          return;
        const h = m.value.body.body, l = m.value.params;
        (m.parent.parent.superClass ? a(h, l) : h.length === 0) && n.report({
          node: m,
          messageId: "noUselessConstructor"
        });
      }
      return {
        MethodDefinition: p
      };
    }
  }, Fu;
}
var Nu, Gy;
function cD() {
  if (Gy) return Nu;
  Gy = 1;
  const i = Re(), { RegExpParser: t, visitRegExpAST: o } = rr();
  function f(p, m) {
    return new Set(function* () {
      yield* p, yield* m;
    }());
  }
  const r = f(new Set("\\nrvtbfux"), i.LINEBREAKS), u = new Set("\\bcdDfnpPrsStvwWxu0123456789]"), e = f(u, new Set("^/.$*+?[{}|()Bk")), a = f(u, new Set("q/[{}|()-")), n = new Set("!#$%&*+,.:;<=>?@^`~");
  return Nu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary escape characters",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-useless-escape"
      },
      hasSuggestions: !0,
      messages: {
        unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
        removeEscape: "Remove the `\\`. This maintains the current functionality.",
        removeEscapeDoNotKeepSemantics: "Remove the `\\` if it was inserted by mistake.",
        escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
      },
      schema: []
    },
    create(p) {
      const m = p.sourceCode, h = new t();
      function l(d, y, v, T) {
        const b = d.range[0] + y, S = [b, b + 1], C = m.getLocFromIndex(b);
        p.report({
          node: d,
          loc: {
            start: C,
            end: { line: C.line, column: C.column + 1 }
          },
          messageId: "unnecessaryEscape",
          data: { character: v },
          suggest: [
            {
              // Removing unnecessary `\` characters in a directive is not guaranteed to maintain functionality.
              messageId: i.isDirective(d.parent) ? "removeEscapeDoNotKeepSemantics" : "removeEscape",
              fix(x) {
                return x.removeRange(S);
              }
            },
            ...T ? [] : [
              {
                messageId: "escapeBackslash",
                fix(x) {
                  return x.insertTextBeforeRange(S, "\\");
                }
              }
            ]
          ]
        });
      }
      function s(d, y) {
        const v = d.type === "TemplateElement", T = y[0][1];
        let b = !r.has(T), S;
        v ? (S = T === "`", T === "$" ? b = y.input[y.index + 2] !== "{" : T === "{" && (b = y.input[y.index - 1] !== "$")) : S = T === d.raw[0], b && !S && l(d, y.index, y[0].slice(1));
      }
      function c(d) {
        const { pattern: y, flags: v } = d.regex;
        let T;
        const b = v.includes("u"), S = v.includes("v");
        try {
          T = h.parsePattern(y, 0, y.length, { unicode: b, unicodeSets: S });
        } catch {
          return;
        }
        const C = [];
        o(T, {
          onCharacterClassEnter: (x) => C.unshift(x),
          onCharacterClassLeave: () => C.shift(),
          onExpressionCharacterClassEnter: (x) => C.unshift(x),
          onExpressionCharacterClassLeave: () => C.shift(),
          onCharacterEnter(x) {
            if (!x.raw.startsWith("\\"))
              return;
            const A = x.raw.slice(1);
            if (A !== String.fromCodePoint(x.value))
              return;
            let R;
            if (C.length ? R = S ? a : u : R = e, R.has(A))
              return;
            const L = x.start + 1;
            let _ = !1;
            if (C.length) {
              const I = C[0];
              if (A === "^" && I.start + 1 === x.start)
                return;
              if (S) {
                if (n.has(A) && (y[x.end] === A || y[x.start - 1] === A && (A !== "^" || !I.negate || I.start + 1 < x.start - 1)))
                  return;
                (x.parent.type === "ClassIntersection" || x.parent.type === "ClassSubtraction") && (_ = !0);
              } else if (A === "-" && I.start + 1 !== x.start && x.end !== I.end - 1)
                return;
            }
            l(
              d,
              L,
              A,
              _
            );
          }
        });
      }
      function g(d) {
        const y = d.type === "TemplateElement";
        if (!(y && d.parent && d.parent.parent && d.parent.parent.type === "TaggedTemplateExpression" && d.parent === d.parent.parent.quasi))
          if (typeof d.value == "string" || y) {
            if (d.parent.type === "JSXAttribute" || d.parent.type === "JSXElement" || d.parent.type === "JSXFragment")
              return;
            const v = y ? m.getText(d) : d.raw, T = /\\[^\d]/gu;
            let b;
            for (; b = T.exec(v); )
              s(d, b);
          } else d.regex && c(d);
      }
      return {
        Literal: g,
        TemplateElement: g
      };
    }
  }, Nu;
}
var Ou, Wy;
function fD() {
  if (Wy) return Ou;
  Wy = 1;
  const i = Re();
  return Ou = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow renaming import, export, and destructured assignments to the same name",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-rename"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: { type: "boolean", default: !1 },
            ignoreImport: { type: "boolean", default: !1 },
            ignoreExport: { type: "boolean", default: !1 }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || {}, r = f.ignoreDestructuring === !0, u = f.ignoreImport === !0, e = f.ignoreExport === !0;
      function a(h, l, s) {
        const c = l.type === "Identifier" ? l.name : l.value;
        return t.report({
          node: h,
          messageId: "unnecessarilyRenamed",
          data: {
            name: c,
            type: s
          },
          fix(g) {
            const d = h.type === "Property" ? h.value : h.local;
            return o.getCommentsInside(h).length > o.getCommentsInside(d).length || d.type === "AssignmentPattern" && i.isParenthesised(o, d.left) ? null : g.replaceText(h, o.getText(d));
          }
        });
      }
      function n(h) {
        if (!r)
          for (const l of h.properties) {
            if (l.type !== "Property" || l.shorthand || l.computed)
              continue;
            const s = l.key.type === "Identifier" && l.key.name || l.key.type === "Literal" && l.key.value, c = l.value.type === "AssignmentPattern" ? l.value.left.name : l.value.name;
            s === c && a(l, l.key, "Destructuring assignment");
          }
      }
      function p(h) {
        u || h.imported.range[0] !== h.local.range[0] && i.getModuleExportName(h.imported) === h.local.name && a(h, h.imported, "Import");
      }
      function m(h) {
        e || h.local.range[0] !== h.exported.range[0] && i.getModuleExportName(h.local) === i.getModuleExportName(h.exported) && a(h, h.local, "Export");
      }
      return {
        ObjectPattern: n,
        ImportSpecifier: p,
        ExportSpecifier: m
      };
    }
  }, Ou;
}
var Uu, Xy;
function pD() {
  if (Xy) return Uu;
  Xy = 1;
  const i = Re(), t = Wr();
  function o(e, a) {
    const n = e.indexOf(a);
    n !== -1 && e.splice(n, 1);
  }
  function f(e) {
    return i.STATEMENT_LIST_PARENTS.has(e.parent.type);
  }
  function r(e) {
    for (let a = e; a && a.parent && !i.isFunction(a); a = a.parent)
      if (a.parent.type === "TryStatement" && a.parent.finalizer === a)
        return !0;
    return !1;
  }
  function u(e) {
    for (const a of e)
      if (a.reachable)
        return !0;
    return !1;
  }
  return Uu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow redundant return statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-useless-return"
      },
      fixable: "code",
      schema: [],
      messages: {
        unnecessaryReturn: "Unnecessary return statement."
      }
    },
    create(e) {
      const a = /* @__PURE__ */ new WeakMap(), n = e.sourceCode;
      let p = null;
      function m(c) {
        const g = a.get(c);
        return !g || g.returned;
      }
      function h(c, g, d) {
        const y = d || /* @__PURE__ */ new WeakSet();
        for (const v of g) {
          if (!v.reachable) {
            y.has(v) || (y.add(v), h(
              c,
              v.allPrevSegments.filter(m),
              y
            ));
            continue;
          }
          c.push(...a.get(v).uselessReturns);
        }
        return c;
      }
      function l(c, g) {
        if (!c.reachable) {
          g.add(c), c.allPrevSegments.filter(m).filter((y) => !g.has(y)).forEach((y) => l(y, g));
          return;
        }
        const d = a.get(c);
        d.uselessReturns = d.uselessReturns.filter((y) => {
          if (p.traversedTryBlockStatements && p.traversedTryBlockStatements.length > 0) {
            const v = y.range[0], T = y.range[1];
            if (p.traversedTryBlockStatements.some((S) => {
              const C = S.range[0], x = S.range[1];
              return v >= C && T <= x;
            }))
              return !0;
          }
          return o(p.uselessReturns, y), !1;
        });
      }
      function s() {
        p.currentSegments.forEach((c) => l(c, /* @__PURE__ */ new Set()));
      }
      return {
        // Makes and pushes a new scope information.
        onCodePathStart(c) {
          p = {
            upper: p,
            uselessReturns: [],
            traversedTryBlockStatements: [],
            codePath: c,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Reports useless return statements if exist.
        onCodePathEnd() {
          for (const c of p.uselessReturns)
            e.report({
              node: c,
              loc: c.loc,
              messageId: "unnecessaryReturn",
              fix(g) {
                return f(c) && !n.getCommentsInside(c).length ? new t(g, n).retainEnclosingFunction(c).remove(c) : null;
              }
            });
          p = p.upper;
        },
        /*
         * Initializes segments.
         * NOTE: This event is notified for only reachable segments.
         */
        onCodePathSegmentStart(c) {
          p.currentSegments.add(c);
          const g = {
            uselessReturns: h([], c.allPrevSegments),
            returned: !1
          };
          a.set(c, g);
        },
        onUnreachableCodePathSegmentStart(c) {
          p.currentSegments.add(c);
        },
        onUnreachableCodePathSegmentEnd(c) {
          p.currentSegments.delete(c);
        },
        onCodePathSegmentEnd(c) {
          p.currentSegments.delete(c);
        },
        // Adds ReturnStatement node to check whether it's useless or not.
        ReturnStatement(c) {
          if (c.argument && s(), !(c.argument || i.isInLoop(c) || r(c) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
          !u(p.currentSegments))) {
            for (const g of p.currentSegments) {
              const d = a.get(g);
              d && (d.uselessReturns.push(c), d.returned = !0);
            }
            p.uselessReturns.push(c);
          }
        },
        "TryStatement > BlockStatement.block:exit"(c) {
          p.traversedTryBlockStatements.push(c);
        },
        "TryStatement:exit"() {
          p.traversedTryBlockStatements.pop();
        },
        /*
         * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
         * Removes return statements of the current segments from the useless return statement list.
         */
        ClassDeclaration: s,
        ContinueStatement: s,
        DebuggerStatement: s,
        DoWhileStatement: s,
        EmptyStatement: s,
        ExpressionStatement: s,
        ForInStatement: s,
        ForOfStatement: s,
        ForStatement: s,
        IfStatement: s,
        ImportDeclaration: s,
        LabeledStatement: s,
        SwitchStatement: s,
        ThrowStatement: s,
        TryStatement: s,
        VariableDeclaration: s,
        WhileStatement: s,
        WithStatement: s,
        ExportNamedDeclaration: s,
        ExportDefaultDeclaration: s,
        ExportAllDeclaration: s
      };
    }
  }, Uu;
}
var Vu, zy;
function hD() {
  if (zy) return Vu;
  zy = 1;
  const i = Re();
  function t(l) {
    return !!l.scope && l.scope.type === "global";
  }
  function o(l) {
    let s = l;
    for (; s.type !== "function" && s.type !== "global"; )
      s = s.upper;
    return s;
  }
  function f(l) {
    const s = o(l.scope);
    return l.references.some((c) => o(c.from) !== s);
  }
  function r(l) {
    return (l.parent.type === "ForOfStatement" || l.parent.type === "ForInStatement") && l === l.parent.left;
  }
  function u(l) {
    return l.declarations.every((s) => s.init !== null);
  }
  const e = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;
  function a(l) {
    for (let s = l; s; s = s.parent)
      if (e.test(s.type))
        return s;
    return null;
  }
  function n(l) {
    return l.defs.length >= 2;
  }
  function p(l) {
    function s(c) {
      const g = l.range, d = c.identifier.range;
      return d[0] < g[0] || d[1] > g[1];
    }
    return function(c) {
      return c.references.some(s);
    };
  }
  function m(l) {
    const s = l.range[0], c = l.range[1];
    return (g) => {
      const d = g.defs[0].name, y = d.range[0], v = d.parent.type === "AssignmentPattern" ? d.parent.right : null, T = v && v.range[0], b = v && v.range[1];
      return g.references.some((S) => {
        const C = S.identifier.range[0], x = S.identifier.range[1];
        return !S.init && (C < y || v !== null && C >= T && x <= b || !i.isFunction(l) && C >= s && x <= c);
      });
    };
  }
  function h(l) {
    return l.name === "let";
  }
  return Vu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `let` or `const` instead of `var`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-var"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedVar: "Unexpected var, use let or const instead."
      }
    },
    create(l) {
      const s = l.sourceCode;
      function c(y) {
        return y.init ? s.getDeclaredVariables(y).some(m(y.init)) : !1;
      }
      function g(y) {
        const v = s.getDeclaredVariables(y), T = a(y);
        return !(y.parent.type === "SwitchCase" || y.declarations.some(c) || v.some(t) || v.some(n) || v.some(p(T)) || v.some(h) || i.isInLoop(y) && (v.some(f) || !r(y) && !u(y)) || !r(y) && !(y.parent.type === "ForStatement" && y.parent.init === y) && !i.STATEMENT_LIST_PARENTS.has(y.parent.type));
      }
      function d(y) {
        l.report({
          node: y,
          messageId: "unexpectedVar",
          fix(v) {
            const T = s.getFirstToken(y, { filter: (b) => b.value === "var" });
            return g(y) ? v.replaceText(T, "let") : null;
          }
        });
      }
      return {
        "VariableDeclaration:exit"(y) {
          y.kind === "var" && d(y);
        }
      };
    }
  }, Vu;
}
var Mu, Hy;
function mD() {
  return Hy || (Hy = 1, Mu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `void` operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-void"
      },
      messages: {
        noVoid: "Expected 'undefined' and instead saw 'void'."
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAsStatement: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ]
    },
    create(i) {
      const t = i.options[0] && i.options[0].allowAsStatement;
      return {
        'UnaryExpression[operator="void"]'(o) {
          t && o.parent && o.parent.type === "ExpressionStatement" || i.report({
            node: o,
            messageId: "noVoid"
          });
        }
      };
    }
  }), Mu;
}
var Ku, Jy;
function gD() {
  if (Jy) return Ku;
  Jy = 1;
  const i = dn(), t = Re(), o = 40;
  return Ku = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified warning terms in comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-warning-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            terms: {
              type: "array",
              items: {
                type: "string"
              }
            },
            location: {
              enum: ["start", "anywhere"]
            },
            decoration: {
              type: "array",
              items: {
                type: "string",
                pattern: "^\\S$"
              },
              minItems: 1,
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
      }
    },
    create(f) {
      const r = f.sourceCode, u = f.options[0] || {}, e = u.terms || ["todo", "fixme", "xxx"], a = u.location || "start", n = [...u.decoration || []].join(""), p = /\bno-warning-comments\b/u;
      function m(c) {
        const g = i(c), d = i(n), y = "\\b";
        let v = "";
        a === "start" ? v = `^[\\s${d}]*` : /^\w/u.test(c) && (v = y);
        const T = /\w$/u.test(c) ? y : "", b = "iu";
        return new RegExp(`${v}${g}${T}`, b);
      }
      const h = e.map(m);
      function l(c) {
        const g = [];
        return h.forEach((d, y) => {
          d.test(c) && g.push(e[y]);
        }), g;
      }
      function s(c) {
        const g = c.value;
        if (t.isDirectiveComment(c) && p.test(g))
          return;
        l(g).forEach((y) => {
          let v = "", T = !1;
          for (const b of g.trim().split(/\s+/u)) {
            const S = v ? `${v} ${b}` : b;
            if (S.length <= o)
              v = S;
            else {
              T = !0;
              break;
            }
          }
          f.report({
            node: c,
            messageId: "unexpectedComment",
            data: {
              matchedTerm: y,
              comment: `${v}${T ? "..." : ""}`
            }
          });
        });
      }
      return {
        Program() {
          r.getAllComments().filter((g) => g.type !== "Shebang").forEach(s);
        }
      };
    }
  }, Ku;
}
var ju, Qy;
function dD() {
  if (Qy) return ju;
  Qy = 1;
  const i = Re();
  return ju = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Disallow whitespace before properties",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/no-whitespace-before-property"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r, u, e) {
        t.report({
          node: r,
          messageId: "unexpectedWhitespace",
          data: {
            propName: o.getText(r.property)
          },
          fix(a) {
            let n = "";
            return !r.computed && !r.optional && i.isDecimalInteger(r.object) || o.commentsExistBetween(u, e) ? null : (r.optional ? n = "?." : r.computed || (n = "."), a.replaceTextRange([u.range[1], e.range[0]], n));
          }
        });
      }
      return {
        MemberExpression(r) {
          let u, e;
          i.isTokenOnSameLine(r.object, r.property) && (r.computed ? (u = o.getTokenBefore(r.property, i.isOpeningBracketToken), e = o.getTokenBefore(u, r.optional ? 1 : 0)) : (u = o.getFirstToken(r.property), e = o.getTokenBefore(u, 1)), o.isSpaceBetweenTokens(e, u) && f(r, e, u));
        }
      };
    }
  }, ju;
}
var qu, Yy;
function ED() {
  return Yy || (Yy = 1, qu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `with` statements",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/no-with"
      },
      schema: [],
      messages: {
        unexpectedWith: "Unexpected use of 'with' statement."
      }
    },
    create(i) {
      return {
        WithStatement(t) {
          i.report({ node: t, messageId: "unexpectedWith" });
        }
      };
    }
  }), qu;
}
var $u, Zy;
function yD() {
  if (Zy) return $u;
  Zy = 1;
  const i = { enum: ["beside", "below", "any"] };
  return $u = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce the location of single-line statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/nonblock-statement-body-position"
      },
      fixable: "whitespace",
      schema: [
        i,
        {
          properties: {
            overrides: {
              properties: {
                if: i,
                else: i,
                while: i,
                do: i,
                for: i
              },
              additionalProperties: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        expectNoLinebreak: "Expected no linebreak before this statement.",
        expectLinebreak: "Expected a linebreak before this statement."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(u) {
        return t.options[1] && t.options[1].overrides && t.options[1].overrides[u] || t.options[0] || "beside";
      }
      function r(u, e) {
        const a = f(e);
        if (u.type === "BlockStatement" || a === "any")
          return;
        const n = o.getTokenBefore(u);
        n.loc.end.line === u.loc.start.line && a === "below" ? t.report({
          node: u,
          messageId: "expectLinebreak",
          fix: (p) => p.insertTextBefore(u, `
`)
        }) : n.loc.end.line !== u.loc.start.line && a === "beside" && t.report({
          node: u,
          messageId: "expectNoLinebreak",
          fix(p) {
            return o.getText().slice(n.range[1], u.range[0]).trim() ? null : p.replaceTextRange([n.range[1], u.range[0]], " ");
          }
        });
      }
      return {
        IfStatement(u) {
          r(u.consequent, "if"), u.alternate && u.alternate.type !== "IfStatement" && r(u.alternate, "else");
        },
        WhileStatement: (u) => r(u.body, "while"),
        DoWhileStatement: (u) => r(u.body, "do"),
        ForStatement: (u) => r(u.body, "for"),
        ForInStatement: (u) => r(u.body, "for"),
        ForOfStatement: (u) => r(u.body, "for")
      };
    }
  }, $u;
}
var Gu, e0;
function CD() {
  if (e0) return Gu;
  e0 = 1;
  const i = Re(), t = {
    oneOf: [
      {
        enum: ["always", "never"]
      },
      {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minProperties: {
            type: "integer",
            minimum: 0
          },
          consistent: {
            type: "boolean"
          }
        },
        additionalProperties: !1,
        minProperties: 1
      }
    ]
  };
  function o(a) {
    let n = !1, p = Number.POSITIVE_INFINITY, m = !1;
    return a ? a === "always" ? p = 0 : a === "never" ? p = Number.POSITIVE_INFINITY : (n = !!a.multiline, p = a.minProperties || Number.POSITIVE_INFINITY, m = !!a.consistent) : m = !0, { multiline: n, minProperties: p, consistent: m };
  }
  function f(a) {
    return typeof a == "object" && a !== null;
  }
  function r(a) {
    return f(a) || typeof a == "string";
  }
  function u(a) {
    if (f(a) && Object.values(a).some(r))
      return {
        ObjectExpression: o(a.ObjectExpression),
        ObjectPattern: o(a.ObjectPattern),
        ImportDeclaration: o(a.ImportDeclaration),
        ExportNamedDeclaration: o(a.ExportDeclaration)
      };
    const n = o(a);
    return { ObjectExpression: n, ObjectPattern: n, ImportDeclaration: n, ExportNamedDeclaration: n };
  }
  function e(a, n, p, m) {
    let h;
    return a.type === "ObjectExpression" || a.type === "ObjectPattern" ? h = a.properties : h = a.specifiers.filter((l) => l.type === "ImportSpecifier" || l.type === "ExportSpecifier"), h.length >= n.minProperties || n.multiline && h.length > 0 && p.loc.start.line !== m.loc.end.line;
  }
  return Gu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent line breaks after opening and before closing braces",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/object-curly-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            t,
            {
              type: "object",
              properties: {
                ObjectExpression: t,
                ObjectPattern: t,
                ImportDeclaration: t,
                ExportDeclaration: t
              },
              additionalProperties: !1,
              minProperties: 1
            }
          ]
        }
      ],
      messages: {
        unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
        unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
        expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
        expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
      }
    },
    create(a) {
      const n = a.sourceCode, p = u(a.options[0]);
      function m(h) {
        const l = p[h.type];
        if (h.type === "ImportDeclaration" && !h.specifiers.some((b) => b.type === "ImportSpecifier") || h.type === "ExportNamedDeclaration" && !h.specifiers.some((b) => b.type === "ExportSpecifier"))
          return;
        const s = n.getFirstToken(h, (b) => b.value === "{");
        let c;
        h.typeAnnotation ? c = n.getTokenBefore(h.typeAnnotation) : c = n.getLastToken(h, (b) => b.value === "}");
        let g = n.getTokenAfter(s, { includeComments: !0 }), d = n.getTokenBefore(c, { includeComments: !0 });
        const y = e(h, l, g, d), v = i.isCommentToken(g), T = i.isCommentToken(d);
        if (g = n.getTokenAfter(s), d = n.getTokenBefore(c), y)
          i.isTokenOnSameLine(s, g) && a.report({
            messageId: "expectedLinebreakAfterOpeningBrace",
            node: h,
            loc: s.loc,
            fix(b) {
              return v ? null : b.insertTextAfter(s, `
`);
            }
          }), i.isTokenOnSameLine(d, c) && a.report({
            messageId: "expectedLinebreakBeforeClosingBrace",
            node: h,
            loc: c.loc,
            fix(b) {
              return T ? null : b.insertTextBefore(c, `
`);
            }
          });
        else {
          const b = l.consistent, S = !i.isTokenOnSameLine(s, g), C = !i.isTokenOnSameLine(d, c);
          (!b && S || b && S && !C) && a.report({
            messageId: "unexpectedLinebreakAfterOpeningBrace",
            node: h,
            loc: s.loc,
            fix(x) {
              return v ? null : x.removeRange([
                s.range[1],
                g.range[0]
              ]);
            }
          }), (!b && C || b && !S && C) && a.report({
            messageId: "unexpectedLinebreakBeforeClosingBrace",
            node: h,
            loc: c.loc,
            fix(x) {
              return T ? null : x.removeRange([
                d.range[1],
                c.range[0]
              ]);
            }
          });
        }
      }
      return {
        ObjectExpression: m,
        ObjectPattern: m,
        ImportDeclaration: m,
        ExportNamedDeclaration: m
      };
    }
  }, Gu;
}
var Wu, t0;
function vD() {
  if (t0) return Wu;
  t0 = 1;
  const i = Re();
  return Wu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside braces",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/object-curly-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            arraysInObjects: {
              type: "boolean"
            },
            objectsInObjects: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        requireSpaceBefore: "A space is required before '{{token}}'.",
        requireSpaceAfter: "A space is required after '{{token}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{token}}'."
      }
    },
    create(t) {
      const o = t.options[0] === "always", f = t.sourceCode;
      function r(g) {
        return t.options[1] ? t.options[1][g] === !o : !1;
      }
      const u = {
        spaced: o,
        arraysInObjectsException: r("arraysInObjects"),
        objectsInObjectsException: r("objectsInObjects")
      };
      function e(g, d) {
        const y = t.sourceCode.getTokenAfter(d, { includeComments: !0 });
        t.report({
          node: g,
          loc: { start: d.loc.end, end: y.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            token: d.value
          },
          fix(v) {
            return v.removeRange([d.range[1], y.range[0]]);
          }
        });
      }
      function a(g, d) {
        const y = t.sourceCode.getTokenBefore(d, { includeComments: !0 });
        t.report({
          node: g,
          loc: { start: y.loc.end, end: d.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            token: d.value
          },
          fix(v) {
            return v.removeRange([y.range[1], d.range[0]]);
          }
        });
      }
      function n(g, d) {
        t.report({
          node: g,
          loc: d.loc,
          messageId: "requireSpaceAfter",
          data: {
            token: d.value
          },
          fix(y) {
            return y.insertTextAfter(d, " ");
          }
        });
      }
      function p(g, d) {
        t.report({
          node: g,
          loc: d.loc,
          messageId: "requireSpaceBefore",
          data: {
            token: d.value
          },
          fix(y) {
            return y.insertTextBefore(d, " ");
          }
        });
      }
      function m(g, d, y, v, T) {
        if (i.isTokenOnSameLine(d, y)) {
          const b = f.isSpaceBetweenTokens(d, y);
          u.spaced && !b && n(g, d), !u.spaced && b && y.type !== "Line" && e(g, d);
        }
        if (i.isTokenOnSameLine(v, T)) {
          const S = (u.arraysInObjectsException && i.isClosingBracketToken(v) || u.objectsInObjectsException && i.isClosingBraceToken(v)) && f.getNodeByRangeIndex(v.range[0]).type, C = u.arraysInObjectsException && S === "ArrayExpression" || u.objectsInObjectsException && (S === "ObjectExpression" || S === "ObjectPattern") ? !u.spaced : u.spaced, x = f.isSpaceBetweenTokens(v, T);
          C && !x && p(g, T), !C && x && a(g, T);
        }
      }
      function h(g) {
        const d = g.properties[g.properties.length - 1];
        return f.getTokenAfter(d, i.isClosingBraceToken);
      }
      function l(g) {
        if (g.properties.length === 0)
          return;
        const d = f.getFirstToken(g), y = h(g), v = f.getTokenAfter(d, { includeComments: !0 }), T = f.getTokenBefore(y, { includeComments: !0 });
        m(g, d, v, T, y);
      }
      function s(g) {
        if (g.specifiers.length === 0)
          return;
        let d = g.specifiers[0];
        const y = g.specifiers[g.specifiers.length - 1];
        if (y.type !== "ImportSpecifier")
          return;
        d.type !== "ImportSpecifier" && (d = g.specifiers[1]);
        const v = f.getTokenBefore(d), T = f.getTokenAfter(y, i.isNotCommaToken), b = f.getTokenAfter(v, { includeComments: !0 }), S = f.getTokenBefore(T, { includeComments: !0 });
        m(g, v, b, S, T);
      }
      function c(g) {
        if (g.specifiers.length === 0)
          return;
        const d = g.specifiers[0], y = g.specifiers[g.specifiers.length - 1], v = f.getTokenBefore(d), T = f.getTokenAfter(y, i.isNotCommaToken), b = f.getTokenAfter(v, { includeComments: !0 }), S = f.getTokenBefore(T, { includeComments: !0 });
        m(g, v, b, S, T);
      }
      return {
        // var {x} = y;
        ObjectPattern: l,
        // var y = {x: 'y'}
        ObjectExpression: l,
        // import {y} from 'x';
        ImportDeclaration: s,
        // export {name} from 'yo';
        ExportNamedDeclaration: c
      };
    }
  }, Wu;
}
var Xu, r0;
function SD() {
  return r0 || (r0 = 1, Xu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce placing object properties on separate lines",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/object-property-newline"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAllPropertiesOnSameLine: {
              type: "boolean",
              default: !1
            },
            allowMultiplePropertiesPerLine: {
              // Deprecated
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "whitespace",
      messages: {
        propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
        propertiesOnNewline: "Object properties must go on a new line."
      }
    },
    create(i) {
      const t = i.options[0] && (i.options[0].allowAllPropertiesOnSameLine || i.options[0].allowMultiplePropertiesPerLine), o = t ? "propertiesOnNewlineAll" : "propertiesOnNewline", f = i.sourceCode;
      return {
        ObjectExpression(r) {
          if (t && r.properties.length > 1) {
            const u = f.getFirstToken(r.properties[0]), e = f.getLastToken(r.properties[r.properties.length - 1]);
            if (u.loc.end.line === e.loc.start.line)
              return;
          }
          for (let u = 1; u < r.properties.length; u++) {
            const e = f.getLastToken(r.properties[u - 1]), a = f.getFirstToken(r.properties[u]);
            e.loc.end.line === a.loc.start.line && i.report({
              node: r,
              loc: a.loc,
              messageId: o,
              fix(n) {
                const m = [f.getTokenBefore(a).range[1], a.range[0]];
                return f.text.slice(m[0], m[1]).trim() ? null : n.replaceTextRange(m, `
`);
              }
            });
          }
        }
      };
    }
  }), Xu;
}
var zu, n0;
function AD() {
  if (n0) return zu;
  n0 = 1;
  const i = {
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties",
    consistent: "consistent",
    consistentAsNeeded: "consistent-as-needed"
  }, t = Re();
  return zu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow method and property shorthand syntax for object literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/object-shorthand"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods", "properties"]
              },
              {
                type: "object",
                properties: {
                  avoidQuotes: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods"]
              },
              {
                type: "object",
                properties: {
                  ignoreConstructors: {
                    type: "boolean"
                  },
                  methodsIgnorePattern: {
                    type: "string"
                  },
                  avoidQuotes: {
                    type: "boolean"
                  },
                  avoidExplicitReturnArrows: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
        expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
        expectedPropertyShorthand: "Expected property shorthand.",
        expectedPropertyLongform: "Expected longform property syntax.",
        expectedMethodShorthand: "Expected method shorthand.",
        expectedMethodLongform: "Expected longform method syntax.",
        unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
      }
    },
    create(o) {
      const f = o.options[0] || i.always, r = f === i.methods || f === i.always, u = f === i.properties || f === i.always, e = f === i.never, a = f === i.consistent, n = f === i.consistentAsNeeded, p = o.options[1] || {}, m = p.ignoreConstructors, h = p.methodsIgnorePattern ? new RegExp(p.methodsIgnorePattern, "u") : null, l = p.avoidQuotes, s = !!p.avoidExplicitReturnArrows, c = o.sourceCode, g = /[^_$0-9]/u;
      function d(k) {
        const w = g.exec(k);
        if (!w)
          return !1;
        const U = k.charAt(w.index);
        return U === U.toUpperCase();
      }
      function y(k) {
        return k.kind !== "set" && k.kind !== "get" && k.type !== "SpreadElement" && k.type !== "SpreadProperty" && k.type !== "ExperimentalSpreadProperty";
      }
      function v(k) {
        return k.type === "Literal" && typeof k.value == "string";
      }
      function T(k) {
        return k.shorthand || k.method;
      }
      function b(k) {
        const w = k.value;
        return w.type === "FunctionExpression" ? !w.id : w.type === "Identifier" ? t.getStaticPropertyName(k) === w.name : !1;
      }
      function S(k, w) {
        const U = k.properties.filter(y);
        if (U.length > 0) {
          const q = U.filter(T);
          q.length !== U.length && (q.length > 0 ? o.report({ node: k, messageId: "unexpectedMix" }) : w && U.every(b) && o.report({ node: k, messageId: "expectedAllPropertiesShorthanded" }));
        }
      }
      function C(k, w) {
        const U = w.computed ? c.getFirstToken(w, t.isOpeningBracketToken) : c.getFirstToken(w.key), q = w.computed ? c.getFirstTokenBetween(w.key, w.value, t.isClosingBracketToken) : c.getLastToken(w.key), F = c.text.slice(U.range[0], q.range[1]);
        let $ = "";
        if (c.commentsExistBetween(q, w.value))
          return null;
        w.value.async && ($ += "async "), w.value.generator && ($ += "*");
        const P = [U.range[0], w.range[1]], X = $ + F;
        if (w.value.type === "FunctionExpression") {
          const M = c.getTokens(w.value).find((Ee) => Ee.type === "Keyword" && Ee.value === "function"), Z = w.value.generator ? c.getTokenAfter(M) : M;
          return k.replaceTextRange(
            P,
            X + c.text.slice(Z.range[1], w.value.range[1])
          );
        }
        const Q = c.getTokenBefore(w.value.body, t.isArrowToken), ue = c.text.slice(Q.range[1], w.value.range[1]);
        let le = !1, Ce;
        if (w.value.params.length === 0 ? Ce = c.getFirstToken(w.value, t.isOpeningParenToken) : Ce = c.getTokenBefore(w.value.params[0]), w.value.params.length === 1) {
          const M = t.isOpeningParenToken(Ce), Z = Ce.range[0] < w.range[0];
          le = !M || Z;
        }
        const j = le ? w.value.params[0].range[0] : Ce.range[0], H = c.getTokenBefore(Q).range[1], N = c.text.slice(j, H), G = le ? `(${N})` : N;
        return k.replaceTextRange(
          P,
          X + G + ue
        );
      }
      function x(k, w) {
        const U = w.computed ? c.getTokens(w).find((P) => P.value === "[") : c.getFirstToken(w.key), q = w.computed ? c.getTokensBetween(w.key, w.value).find((P) => P.value === "]") : c.getLastToken(w.key), F = c.text.slice(U.range[0], q.range[1]);
        let $ = "function";
        return w.value.async && ($ = `async ${$}`), w.value.generator && ($ = `${$}*`), k.replaceTextRange([w.range[0], q.range[1]], `${F}: ${$}`);
      }
      const A = [], R = /* @__PURE__ */ new WeakSet(), L = /* @__PURE__ */ new WeakSet();
      function _(k) {
        A.unshift(/* @__PURE__ */ new Set()), c.getScope(k).variables.filter((w) => w.name === "arguments").forEach((w) => {
          w.references.map((U) => U.identifier).forEach((U) => L.add(U));
        });
      }
      function I() {
        A.shift();
      }
      function O() {
        A[0].forEach((k) => R.add(k));
      }
      return {
        Program: _,
        FunctionDeclaration: _,
        FunctionExpression: _,
        "Program:exit": I,
        "FunctionDeclaration:exit": I,
        "FunctionExpression:exit": I,
        ArrowFunctionExpression(k) {
          A[0].add(k);
        },
        "ArrowFunctionExpression:exit"(k) {
          A[0].delete(k);
        },
        ThisExpression: O,
        Super: O,
        MetaProperty(k) {
          k.meta.name === "new" && k.property.name === "target" && O();
        },
        Identifier(k) {
          L.has(k) && O();
        },
        ObjectExpression(k) {
          a ? S(k, !1) : n && S(k, !0);
        },
        "Property:exit"(k) {
          const w = k.method || k.shorthand;
          if (k.parent.type !== "ObjectPattern" && !(k.kind === "get" || k.kind === "set") && !(k.computed && k.value.type !== "FunctionExpression" && k.value.type !== "ArrowFunctionExpression")) {
            if (w)
              if (k.method && (e || l && v(k.key))) {
                const U = e ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
                o.report({
                  node: k,
                  messageId: U,
                  fix: (q) => x(q, k)
                });
              } else e && o.report({
                node: k,
                messageId: "expectedPropertyLongform",
                fix: (U) => U.insertTextAfter(k.key, `: ${k.key.name}`)
              });
            else if (r && !k.value.id && (k.value.type === "FunctionExpression" || k.value.type === "ArrowFunctionExpression")) {
              if (m && k.key.type === "Identifier" && d(k.key.name))
                return;
              if (h) {
                const U = t.getStaticPropertyName(k);
                if (U !== null && h.test(U))
                  return;
              }
              if (l && v(k.key))
                return;
              (k.value.type === "FunctionExpression" || k.value.type === "ArrowFunctionExpression" && k.value.body.type === "BlockStatement" && s && !R.has(k.value)) && o.report({
                node: k,
                messageId: "expectedMethodShorthand",
                fix: (U) => C(U, k)
              });
            } else if (k.value.type === "Identifier" && k.key.name === k.value.name && u)
              o.report({
                node: k,
                messageId: "expectedPropertyShorthand",
                fix(U) {
                  return U.replaceText(k, k.value.name);
                }
              });
            else if (k.value.type === "Identifier" && k.key.type === "Literal" && k.key.value === k.value.name && u) {
              if (l)
                return;
              o.report({
                node: k,
                messageId: "expectedPropertyShorthand",
                fix(U) {
                  return U.replaceText(k, k.value.name);
                }
              });
            }
          }
        }
      };
    }
  }, zu;
}
var Hu, s0;
function TD() {
  if (s0) return Hu;
  s0 = 1;
  const i = Re();
  function t(o) {
    return i.STATEMENT_LIST_PARENTS.has(o.parent.type);
  }
  return Hu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce variables to be declared either together or separately in functions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/one-var"
      },
      fixable: "code",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consecutive"]
            },
            {
              type: "object",
              properties: {
                separateRequires: {
                  type: "boolean"
                },
                var: {
                  enum: ["always", "never", "consecutive"]
                },
                let: {
                  enum: ["always", "never", "consecutive"]
                },
                const: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: !1
            },
            {
              type: "object",
              properties: {
                initialized: {
                  enum: ["always", "never", "consecutive"]
                },
                uninitialized: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
        combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
        splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
        splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
        splitRequires: "Split requires to be separated into a single block.",
        combine: "Combine this with the previous '{{type}}' statement.",
        split: "Split '{{type}}' declarations into multiple statements."
      }
    },
    create(o) {
      const f = "always", r = "never", u = "consecutive", e = o.options[0] || f, a = {};
      typeof e == "string" ? (a.var = { uninitialized: e, initialized: e }, a.let = { uninitialized: e, initialized: e }, a.const = { uninitialized: e, initialized: e }) : typeof e == "object" && (a.separateRequires = !!e.separateRequires, a.var = { uninitialized: e.var, initialized: e.var }, a.let = { uninitialized: e.let, initialized: e.let }, a.const = { uninitialized: e.const, initialized: e.const }, Object.prototype.hasOwnProperty.call(e, "uninitialized") && (a.var.uninitialized = e.uninitialized, a.let.uninitialized = e.uninitialized, a.const.uninitialized = e.uninitialized), Object.prototype.hasOwnProperty.call(e, "initialized") && (a.var.initialized = e.initialized, a.let.initialized = e.initialized, a.const.initialized = e.initialized));
      const n = o.sourceCode, p = [], m = [];
      function h() {
        m.push({
          let: { initialized: !1, uninitialized: !1 },
          const: { initialized: !1, uninitialized: !1 }
        });
      }
      function l() {
        p.push({ initialized: !1, uninitialized: !1 }), h();
      }
      function s() {
        m.pop();
      }
      function c() {
        p.pop(), s();
      }
      function g(x) {
        return x.init && x.init.type === "CallExpression" && x.init.callee.name === "require";
      }
      function d(x, A, R) {
        for (let L = 0; L < A.length; L++)
          A[L].init === null ? a[x] && a[x].uninitialized === f && (R.uninitialized = !0) : a[x] && a[x].initialized === f && (a.separateRequires && g(A[L]) ? R.required = !0 : R.initialized = !0);
      }
      function y(x) {
        let A;
        return x === "var" ? A = p[p.length - 1] : x === "let" ? A = m[m.length - 1].let : x === "const" && (A = m[m.length - 1].const), A;
      }
      function v(x) {
        const A = { uninitialized: 0, initialized: 0 };
        for (let R = 0; R < x.length; R++)
          x[R].init === null ? A.uninitialized++ : A.initialized++;
        return A;
      }
      function T(x, A) {
        const R = v(A), L = a[x] || {}, _ = y(x), I = A.some(g);
        return L.uninitialized === f && L.initialized === f && (_.uninitialized || _.initialized) && !I || R.uninitialized > 0 && L.uninitialized === f && _.uninitialized || R.initialized > 0 && L.initialized === f && _.initialized && !I || _.required && I ? !1 : (d(x, A, _), !0);
      }
      function b(x) {
        const A = x[0], R = Array.isArray(A.parent.parent.body) ? A.parent.parent.body : [], L = R.findIndex((I) => I.range[0] === A.parent.range[0]), _ = R[L - 1];
        return (I) => {
          const O = n.getTokenBefore(A), k = n.getTokenBefore(O), w = [];
          return _ && _.kind === n.getText(O) && (k.value === ";" ? w.push(I.replaceText(k, ",")) : w.push(I.insertTextAfter(k, ",")), w.push(I.replaceText(O, ""))), w;
        };
      }
      function S(x) {
        const { parent: A } = x;
        return t(A.type === "ExportNamedDeclaration" ? A : x) ? (R) => x.declarations.map((L) => {
          const _ = n.getTokenAfter(L);
          if (_ === null)
            return null;
          const I = n.getTokenAfter(_, { includeComments: !0 });
          if (_.value !== ",")
            return null;
          const O = x.parent.type === "ExportNamedDeclaration" ? "export " : "";
          if (I.range[0] === _.range[1])
            return R.replaceText(_, `; ${O}${x.kind} `);
          if (I.loc.start.line > _.loc.end.line || I.type === "Line" || I.type === "Block") {
            let k = I;
            for (; k.type === "Line" || k.type === "Block"; )
              k = n.getTokenAfter(k, { includeComments: !0 });
            return R.replaceTextRange(
              [_.range[0], k.range[0]],
              `;${n.text.slice(_.range[1], k.range[0])}${O}${x.kind} `
            );
          }
          return R.replaceText(_, `; ${O}${x.kind}`);
        }).filter((L) => L) : null;
      }
      function C(x) {
        const A = x.parent, R = x.kind;
        if (!a[R])
          return;
        const L = x.declarations, _ = v(L), I = L.some(g) && !L.every(g);
        a[R].initialized === f && a.separateRequires && I && o.report({
          node: x,
          messageId: "splitRequires"
        });
        const O = A.body && A.body.length > 0 && A.body.indexOf(x) || 0;
        if (O > 0) {
          const k = A.body[O - 1], w = k.type === "VariableDeclaration", U = L.concat(k.declarations || []);
          if (w && k.kind === R && !(U.some(g) && !U.every(g))) {
            const q = v(k.declarations);
            a[R].initialized === u && a[R].uninitialized === u ? o.report({
              node: x,
              messageId: "combine",
              data: {
                type: R
              },
              fix: b(L)
            }) : a[R].initialized === u && _.initialized > 0 && q.initialized > 0 ? o.report({
              node: x,
              messageId: "combineInitialized",
              data: {
                type: R
              },
              fix: b(L)
            }) : a[R].uninitialized === u && _.uninitialized > 0 && q.uninitialized > 0 && o.report({
              node: x,
              messageId: "combineUninitialized",
              data: {
                type: R
              },
              fix: b(L)
            });
          }
        }
        if (!T(R, L)) {
          if (a[R].initialized === f && a[R].uninitialized === f)
            o.report({
              node: x,
              messageId: "combine",
              data: {
                type: R
              },
              fix: b(L)
            });
          else if (a[R].initialized === f && _.initialized > 0 && o.report({
            node: x,
            messageId: "combineInitialized",
            data: {
              type: R
            },
            fix: b(L)
          }), a[R].uninitialized === f && _.uninitialized > 0) {
            if (x.parent.left === x && (x.parent.type === "ForInStatement" || x.parent.type === "ForOfStatement"))
              return;
            o.report({
              node: x,
              messageId: "combineUninitialized",
              data: {
                type: R
              },
              fix: b(L)
            });
          }
        }
        (A.type !== "ForStatement" || A.init !== x) && _.uninitialized + _.initialized > 1 && (a[R].initialized === r && a[R].uninitialized === r ? o.report({
          node: x,
          messageId: "split",
          data: {
            type: R
          },
          fix: S(x)
        }) : a[R].initialized === r && _.initialized > 0 ? o.report({
          node: x,
          messageId: "splitInitialized",
          data: {
            type: R
          },
          fix: S(x)
        }) : a[R].uninitialized === r && _.uninitialized > 0 && o.report({
          node: x,
          messageId: "splitUninitialized",
          data: {
            type: R
          },
          fix: S(x)
        }));
      }
      return {
        Program: l,
        FunctionDeclaration: l,
        FunctionExpression: l,
        ArrowFunctionExpression: l,
        StaticBlock: l,
        // StaticBlock creates a new scope for `var` variables
        BlockStatement: h,
        ForStatement: h,
        ForInStatement: h,
        ForOfStatement: h,
        SwitchStatement: h,
        VariableDeclaration: C,
        "ForStatement:exit": s,
        "ForOfStatement:exit": s,
        "ForInStatement:exit": s,
        "SwitchStatement:exit": s,
        "BlockStatement:exit": s,
        "Program:exit": c,
        "FunctionDeclaration:exit": c,
        "FunctionExpression:exit": c,
        "ArrowFunctionExpression:exit": c,
        "StaticBlock:exit": c
      };
    }
  }, Hu;
}
var Ju, i0;
function bD() {
  return i0 || (i0 = 1, Ju = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Require or disallow newlines around variable declarations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/one-var-declaration-per-line"
      },
      schema: [
        {
          enum: ["always", "initializations"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expectVarOnNewline: "Expected variable declaration to be on a new line."
      }
    },
    create(i) {
      const t = i.options[0] === "always";
      function o(r) {
        return r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
      }
      function f(r) {
        if (o(r.parent.type))
          return;
        const u = r.declarations;
        let e;
        u.forEach((a) => {
          e && e.loc.end.line === a.loc.start.line && (t || e.init || a.init) && i.report({
            node: r,
            messageId: "expectVarOnNewline",
            loc: a.loc,
            fix: (n) => n.insertTextBefore(a, `
`)
          }), e = a;
        });
      }
      return {
        VariableDeclaration: f
      };
    }
  }), Ju;
}
var Qu, a0;
function xD() {
  if (a0) return Qu;
  a0 = 1;
  const i = Re();
  function t(r) {
    return ["*", "&", "^", "|"].includes(r);
  }
  function o(r) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].includes(r);
  }
  function f(r) {
    return r.type === "Identifier" || r.type === "MemberExpression" && (r.object.type === "Identifier" || r.object.type === "ThisExpression") && (!r.computed || r.property.type === "Literal");
  }
  return Qu = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow assignment operator shorthand where possible",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/operator-assignment"
      },
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      fixable: "code",
      messages: {
        replaced: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
        unexpected: "Unexpected operator assignment ({{operator}}) shorthand."
      }
    },
    create(r) {
      const u = r.sourceCode;
      function e(p) {
        return u.getFirstTokenBetween(p.left, p.right, (m) => m.value === p.operator);
      }
      function a(p) {
        if (p.operator !== "=" || p.right.type !== "BinaryExpression")
          return;
        const m = p.left, h = p.right, l = h.operator;
        if (t(l) || o(l)) {
          const s = `${l}=`;
          i.isSameReference(m, h.left, !0) ? r.report({
            node: p,
            messageId: "replaced",
            data: { operator: s },
            fix(c) {
              if (f(m) && f(h.left)) {
                const g = e(p), d = e(h), y = u.getText().slice(p.range[0], g.range[0]), v = u.getText().slice(d.range[1], p.right.range[1]);
                return u.commentsExistBetween(g, d) ? null : c.replaceText(p, `${y}${s}${v}`);
              }
              return null;
            }
          }) : i.isSameReference(m, h.right, !0) && t(l) && r.report({
            node: p,
            messageId: "replaced",
            data: { operator: s }
          });
        }
      }
      function n(p) {
        p.operator !== "=" && !i.isLogicalAssignmentOperator(p.operator) && r.report({
          node: p,
          messageId: "unexpected",
          data: { operator: p.operator },
          fix(m) {
            if (f(p.left)) {
              const h = u.getFirstToken(p), l = e(p), s = u.getText().slice(p.range[0], l.range[0]), c = p.operator.slice(0, -1);
              let g;
              if (u.commentsExistBetween(h, l))
                return null;
              if (i.getPrecedence(p.right) <= i.getPrecedence({ type: "BinaryExpression", operator: c }) && !i.isParenthesised(u, p.right))
                g = `${u.text.slice(l.range[1], p.right.range[0])}(${u.getText(p.right)})`;
              else {
                const d = u.getTokenAfter(l, { includeComments: !0 });
                let y = "";
                l.range[1] === d.range[0] && !i.canTokensBeAdjacent({ type: "Punctuator", value: c }, d) && (y = " "), g = `${y}${u.text.slice(l.range[1], p.range[1])}`;
              }
              return m.replaceText(p, `${s}= ${s}${c}${g}`);
            }
            return null;
          }
        });
      }
      return {
        AssignmentExpression: r.options[0] !== "never" ? a : n
      };
    }
  }, Qu;
}
var Yu, o0;
function RD() {
  if (o0) return Yu;
  o0 = 1;
  const i = Re();
  return Yu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent linebreak style for operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/operator-linebreak"
      },
      schema: [
        {
          enum: ["after", "before", "none", null]
        },
        {
          type: "object",
          properties: {
            overrides: {
              type: "object",
              additionalProperties: {
                enum: ["after", "before", "none", "ignore"]
              }
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
        operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
        badLinebreak: "Bad line breaking before and after '{{operator}}'.",
        noLinebreak: "There should be no line break before or after '{{operator}}'."
      }
    },
    create(t) {
      const o = !t.options[0], f = t.options[0] || "after", r = t.options[1] || {}, u = r.overrides ? Object.assign({}, r.overrides) : {};
      o && !u["?"] && (u["?"] = "before"), o && !u[":"] && (u[":"] = "before");
      const e = t.sourceCode;
      function a(m, h) {
        return (l) => {
          const s = e.getTokenBefore(m), c = e.getTokenAfter(m), g = e.text.slice(s.range[1], m.range[0]), d = e.text.slice(m.range[1], c.range[0]), y = !i.isTokenOnSameLine(s, m), v = !i.isTokenOnSameLine(m, c);
          let T, b;
          if (y !== v && h !== "none") {
            if (e.getTokenBefore(m, { includeComments: !0 }) !== s && e.getTokenAfter(m, { includeComments: !0 }) !== c)
              return null;
            T = d, b = g;
          } else {
            const S = i.createGlobalLinebreakMatcher();
            if (T = h === "before" || g.trim() ? g : g.replace(S, ""), b = h === "after" || d.trim() ? d : d.replace(S, ""), T === g && b === d)
              return null;
          }
          return b === "" && c.type === "Punctuator" && "+-".includes(m.value) && c.value === m.value && (b += " "), l.replaceTextRange([s.range[1], c.range[0]], T + m.value + b);
        };
      }
      function n(m, h, l) {
        const s = e.getTokenBefore(h, (T) => T.value === l), c = e.getTokenBefore(s), g = e.getTokenAfter(s), d = u[l], y = d || f, v = a(s, y);
        i.isTokenOnSameLine(c, s) && i.isTokenOnSameLine(s, g) || (d !== "ignore" && !i.isTokenOnSameLine(c, s) && !i.isTokenOnSameLine(s, g) ? t.report({
          node: m,
          loc: s.loc,
          messageId: "badLinebreak",
          data: {
            operator: l
          },
          fix: v
        }) : y === "before" && i.isTokenOnSameLine(c, s) ? t.report({
          node: m,
          loc: s.loc,
          messageId: "operatorAtBeginning",
          data: {
            operator: l
          },
          fix: v
        }) : y === "after" && i.isTokenOnSameLine(s, g) ? t.report({
          node: m,
          loc: s.loc,
          messageId: "operatorAtEnd",
          data: {
            operator: l
          },
          fix: v
        }) : y === "none" && t.report({
          node: m,
          loc: s.loc,
          messageId: "noLinebreak",
          data: {
            operator: l
          },
          fix: v
        }));
      }
      function p(m) {
        n(m, m.right, m.operator);
      }
      return {
        BinaryExpression: p,
        LogicalExpression: p,
        AssignmentExpression: p,
        VariableDeclarator(m) {
          m.init && n(m, m.init, "=");
        },
        PropertyDefinition(m) {
          m.value && n(m, m.value, "=");
        },
        ConditionalExpression(m) {
          n(m, m.consequent, "?"), n(m, m.alternate, ":");
        }
      };
    }
  }, Yu;
}
var Zu, l0;
function DD() {
  if (l0) return Zu;
  l0 = 1;
  const i = Re();
  return Zu = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow padding within blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/padded-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                blocks: {
                  enum: ["always", "never"]
                },
                switches: {
                  enum: ["always", "never"]
                },
                classes: {
                  enum: ["always", "never"]
                }
              },
              additionalProperties: !1,
              minProperties: 1
            }
          ]
        },
        {
          type: "object",
          properties: {
            allowSingleLineBlocks: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        alwaysPadBlock: "Block must be padded by blank lines.",
        neverPadBlock: "Block must not be padded by blank lines."
      }
    },
    create(t) {
      const o = {}, f = t.options[0] || "always", r = t.options[1] || {};
      if (typeof f == "string") {
        const c = f === "always";
        o.blocks = c, o.switches = c, o.classes = c;
      } else
        Object.prototype.hasOwnProperty.call(f, "blocks") && (o.blocks = f.blocks === "always"), Object.prototype.hasOwnProperty.call(f, "switches") && (o.switches = f.switches === "always"), Object.prototype.hasOwnProperty.call(f, "classes") && (o.classes = f.classes === "always");
      Object.prototype.hasOwnProperty.call(r, "allowSingleLineBlocks") && (o.allowSingleLineBlocks = r.allowSingleLineBlocks === !0);
      const u = t.sourceCode;
      function e(c) {
        return c.type === "SwitchStatement" ? u.getTokenBefore(c.cases[0]) : c.type === "StaticBlock" ? u.getFirstToken(c, { skip: 1 }) : u.getFirstToken(c);
      }
      function a(c) {
        return c.type === "Line" || c.type === "Block";
      }
      function n(c, g) {
        return g.loc.start.line - c.loc.end.line >= 2;
      }
      function p(c) {
        let g, d = c;
        do
          g = d, d = u.getTokenAfter(d, { includeComments: !0 });
        while (a(d) && d.loc.start.line === g.loc.end.line);
        return d;
      }
      function m(c) {
        let g = c, d;
        do
          d = g, g = u.getTokenBefore(g, { includeComments: !0 });
        while (a(g) && g.loc.end.line === d.loc.start.line);
        return g;
      }
      function h(c) {
        switch (c.type) {
          case "BlockStatement":
          case "StaticBlock":
            return o.blocks;
          case "SwitchStatement":
            return o.switches;
          case "ClassBody":
            return o.classes;
          default:
            throw new Error("unreachable");
        }
      }
      function l(c) {
        const g = e(c), d = p(g), y = u.getTokenBefore(d, { includeComments: !0 }), v = u.getLastToken(c), T = m(v), b = u.getTokenAfter(T, { includeComments: !0 }), S = n(y, d), C = n(T, b);
        o.allowSingleLineBlocks && i.isTokenOnSameLine(y, b) || (h(c) ? (S || t.report({
          node: c,
          loc: {
            start: y.loc.start,
            end: d.loc.start
          },
          fix(x) {
            return x.insertTextAfter(y, `
`);
          },
          messageId: "alwaysPadBlock"
        }), C || t.report({
          node: c,
          loc: {
            end: b.loc.start,
            start: T.loc.end
          },
          fix(x) {
            return x.insertTextBefore(b, `
`);
          },
          messageId: "alwaysPadBlock"
        })) : (S && t.report({
          node: c,
          loc: {
            start: y.loc.start,
            end: d.loc.start
          },
          fix(x) {
            return x.replaceTextRange([y.range[1], d.range[0] - d.loc.start.column], `
`);
          },
          messageId: "neverPadBlock"
        }), C && t.report({
          node: c,
          loc: {
            end: b.loc.start,
            start: T.loc.end
          },
          messageId: "neverPadBlock",
          fix(x) {
            return x.replaceTextRange([T.range[1], b.range[0] - b.loc.start.column], `
`);
          }
        })));
      }
      const s = {};
      return Object.prototype.hasOwnProperty.call(o, "switches") && (s.SwitchStatement = function(c) {
        c.cases.length !== 0 && l(c);
      }), Object.prototype.hasOwnProperty.call(o, "blocks") && (s.BlockStatement = function(c) {
        c.body.length !== 0 && l(c);
      }, s.StaticBlock = s.BlockStatement), Object.prototype.hasOwnProperty.call(o, "classes") && (s.ClassBody = function(c) {
        c.body.length !== 0 && l(c);
      }), s;
    }
  }, Zu;
}
var ec, u0;
function LD() {
  if (u0) return ec;
  u0 = 1;
  const i = Re(), t = `[${Array.from(i.LINEBREAKS).join("")}]`, o = new RegExp(
    String.raw`^(\s*?${t})\s*${t}(\s*;?)$`,
    "u"
  ), f = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u, r = /^require\(/u;
  function u(v) {
    return {
      test: (T, b) => b.getFirstToken(T).value === v
    };
  }
  function e(v) {
    return {
      test: (T, b) => T.loc.start.line === T.loc.end.line && b.getFirstToken(T).value === v
    };
  }
  function a(v) {
    return {
      test: (T, b) => T.loc.start.line !== T.loc.end.line && b.getFirstToken(T).value === v
    };
  }
  function n(v) {
    return {
      test: (T) => T.type === v
    };
  }
  function p(v) {
    if (v.type === "ExpressionStatement") {
      let T = i.skipChainExpression(v.expression);
      return T.type === "UnaryExpression" && (T = i.skipChainExpression(T.argument)), T.type === "CallExpression" && i.isFunction(T.callee);
    }
    return !1;
  }
  function m(v, T) {
    if (T.type === "DoWhileStatement" && T.body.type === "BlockStatement" || p(T))
      return !0;
    const b = v.getLastToken(T, i.isNotSemicolonToken), S = b && i.isClosingBraceToken(b) ? v.getNodeByRangeIndex(b.range[0]) : null;
    return !!S && (S.type === "BlockStatement" || S.type === "SwitchStatement");
  }
  function h(v, T) {
    const b = v.getLastToken(T), S = v.getTokenBefore(b), C = v.getTokenAfter(b);
    return !!(S && C && S.range[0] >= T.range[0] && i.isSemicolonToken(b) && b.loc.start.line !== S.loc.end.line && b.loc.end.line === C.loc.start.line) ? S : b;
  }
  function l(v, T, b) {
    return T + b;
  }
  function s() {
  }
  function c(v, T, b, S) {
    S.length !== 0 && v.report({
      node: b,
      messageId: "unexpectedBlankLine",
      fix(C) {
        if (S.length >= 2)
          return null;
        const x = S[0][0], A = S[0][1], R = x.range[1], L = A.range[0], _ = v.sourceCode.text.slice(R, L).replace(o, l);
        return C.replaceTextRange([R, L], _);
      }
    });
  }
  function g(v, T, b, S) {
    S.length > 0 || v.report({
      node: b,
      messageId: "expectedBlankLine",
      fix(C) {
        const x = v.sourceCode;
        let A = h(x, T);
        const R = x.getFirstTokenBetween(
          A,
          b,
          {
            includeComments: !0,
            /**
             * Skip the trailing comments of the previous node.
             * This inserts a blank line after the last trailing comment.
             *
             * For example:
             *
             *     foo(); // trailing comment.
             *     // comment.
             *     bar();
             *
             * Get fixed to:
             *
             *     foo(); // trailing comment.
             *
             *     // comment.
             *     bar();
             * @param {Token} token The token to check.
             * @returns {boolean} `true` if the token is not a trailing comment.
             * @private
             */
            filter(_) {
              return i.isTokenOnSameLine(A, _) ? (A = _, !1) : !0;
            }
          }
        ) || b, L = i.isTokenOnSameLine(A, R) ? `

` : `
`;
        return C.insertTextAfter(A, L);
      }
    });
  }
  const d = {
    any: { verify: s },
    never: { verify: c },
    always: { verify: g }
  }, y = {
    "*": { test: () => !0 },
    "block-like": {
      test: (v, T) => m(T, v)
    },
    "cjs-export": {
      test: (v, T) => v.type === "ExpressionStatement" && v.expression.type === "AssignmentExpression" && f.test(T.getText(v.expression.left))
    },
    "cjs-import": {
      test: (v, T) => v.type === "VariableDeclaration" && v.declarations.length > 0 && !!v.declarations[0].init && r.test(T.getText(v.declarations[0].init))
    },
    directive: {
      test: i.isDirective
    },
    expression: {
      test: (v) => v.type === "ExpressionStatement" && !i.isDirective(v)
    },
    iife: {
      test: p
    },
    "multiline-block-like": {
      test: (v, T) => v.loc.start.line !== v.loc.end.line && m(T, v)
    },
    "multiline-expression": {
      test: (v) => v.loc.start.line !== v.loc.end.line && v.type === "ExpressionStatement" && !i.isDirective(v)
    },
    "multiline-const": a("const"),
    "multiline-let": a("let"),
    "multiline-var": a("var"),
    "singleline-const": e("const"),
    "singleline-let": e("let"),
    "singleline-var": e("var"),
    block: n("BlockStatement"),
    empty: n("EmptyStatement"),
    function: n("FunctionDeclaration"),
    break: u("break"),
    case: u("case"),
    class: u("class"),
    const: u("const"),
    continue: u("continue"),
    debugger: u("debugger"),
    default: u("default"),
    do: u("do"),
    export: u("export"),
    for: u("for"),
    if: u("if"),
    import: u("import"),
    let: u("let"),
    return: u("return"),
    switch: u("switch"),
    throw: u("throw"),
    try: u("try"),
    var: u("var"),
    while: u("while"),
    with: u("with")
  };
  return ec = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow padding lines between statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/padding-line-between-statements"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          paddingType: {
            enum: Object.keys(d)
          },
          statementType: {
            anyOf: [
              { enum: Object.keys(y) },
              {
                type: "array",
                items: { enum: Object.keys(y) },
                minItems: 1,
                uniqueItems: !0
              }
            ]
          }
        },
        type: "array",
        items: {
          type: "object",
          properties: {
            blankLine: { $ref: "#/definitions/paddingType" },
            prev: { $ref: "#/definitions/statementType" },
            next: { $ref: "#/definitions/statementType" }
          },
          additionalProperties: !1,
          required: ["blankLine", "prev", "next"]
        }
      },
      messages: {
        unexpectedBlankLine: "Unexpected blank line before this statement.",
        expectedBlankLine: "Expected blank line before this statement."
      }
    },
    create(v) {
      const T = v.sourceCode, b = v.options || [];
      let S = null;
      function C() {
        S = {
          upper: S,
          prevNode: null
        };
      }
      function x() {
        S = S.upper;
      }
      function A(O, k) {
        let w = O;
        for (; w.type === "LabeledStatement"; )
          w = w.body;
        return Array.isArray(k) ? k.some(A.bind(null, w)) : y[k].test(w, T);
      }
      function R(O, k) {
        for (let w = b.length - 1; w >= 0; --w) {
          const U = b[w];
          if (A(O, U.prev) && A(k, U.next))
            return d[U.blankLine];
        }
        return d.any;
      }
      function L(O, k) {
        const w = [];
        let U = h(T, O);
        if (k.loc.start.line - U.loc.end.line >= 2)
          do {
            const q = T.getTokenAfter(
              U,
              { includeComments: !0 }
            );
            q.loc.start.line - U.loc.end.line >= 2 && w.push([U, q]), U = q;
          } while (U.range[0] < k.range[0]);
        return w;
      }
      function _(O) {
        const k = O.parent.type;
        if (!(i.STATEMENT_LIST_PARENTS.has(k) || k === "SwitchStatement"))
          return;
        const U = S.prevNode;
        if (U) {
          const q = R(U, O), F = L(U, O);
          q.verify(v, U, O, F);
        }
        S.prevNode = O;
      }
      function I(O) {
        _(O), C();
      }
      return {
        Program: C,
        BlockStatement: C,
        SwitchStatement: C,
        StaticBlock: C,
        "Program:exit": x,
        "BlockStatement:exit": x,
        "SwitchStatement:exit": x,
        "StaticBlock:exit": x,
        ":statement": _,
        SwitchCase: I,
        "SwitchCase:exit": x
      };
    }
  }, ec;
}
var tc, c0;
function _D() {
  if (c0) return tc;
  c0 = 1;
  const i = Re();
  function t(e) {
    return e && e.defs[0].type === "FunctionName";
  }
  function o(e, a, n) {
    return e.meta.name === a && e.property.name === n;
  }
  function f(e) {
    const a = e.variables;
    for (let n = 0; n < a.length; ++n) {
      const p = a[n];
      if (p.name === "arguments")
        return p.identifiers.length === 0 ? p : null;
    }
    return null;
  }
  function r(e) {
    const a = { isCallback: !1, isLexicalThis: !1 };
    let n = e, p = e.parent, m = !1;
    for (; n; ) {
      switch (p.type) {
        case "LogicalExpression":
        case "ChainExpression":
        case "ConditionalExpression":
          break;
        case "MemberExpression":
          if (p.object === n && !p.property.computed && p.property.type === "Identifier" && p.property.name === "bind") {
            const h = p.parent.type === "ChainExpression" ? p.parent : p;
            if (i.isCallee(h))
              m || (m = !0, a.isLexicalThis = h.parent.arguments.length === 1 && h.parent.arguments[0].type === "ThisExpression"), p = h.parent;
            else
              return a;
          } else
            return a;
          break;
        case "CallExpression":
        case "NewExpression":
          return p.callee !== n && (a.isCallback = !0), a;
        default:
          return a;
      }
      n = p, p = p.parent;
    }
    throw new Error("unreachable");
  }
  function u(e) {
    return e.every((a) => a.type === "Identifier") && e.length !== new Set(e.map((a) => a.name)).size;
  }
  return tc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require using arrow functions for callbacks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowNamedFunctions: {
              type: "boolean",
              default: !1
            },
            allowUnboundThis: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        preferArrowCallback: "Unexpected function expression."
      }
    },
    create(e) {
      const a = e.options[0] || {}, n = a.allowUnboundThis !== !1, p = a.allowNamedFunctions, m = e.sourceCode;
      let h = [];
      function l() {
        h.push({ this: !1, super: !1, meta: !1 });
      }
      function s() {
        return h.pop();
      }
      return {
        // Reset internal state.
        Program() {
          h = [];
        },
        // If there are below, it cannot replace with arrow functions merely.
        ThisExpression() {
          const c = h[h.length - 1];
          c && (c.this = !0);
        },
        Super() {
          const c = h[h.length - 1];
          c && (c.super = !0);
        },
        MetaProperty(c) {
          const g = h[h.length - 1];
          g && o(c, "new", "target") && (g.meta = !0);
        },
        // To skip nested scopes.
        FunctionDeclaration: l,
        "FunctionDeclaration:exit": s,
        // Main.
        FunctionExpression: l,
        "FunctionExpression:exit"(c) {
          const g = s();
          if (p && c.id && c.id.name || c.generator)
            return;
          const d = m.getDeclaredVariables(c)[0];
          if (t(d) && d.references.length > 0)
            return;
          const y = f(m.getScope(c));
          if (y && y.references.length > 0)
            return;
          const v = r(c);
          v.isCallback && (!n || !g.this || v.isLexicalThis) && !g.super && !g.meta && e.report({
            node: c,
            messageId: "preferArrowCallback",
            *fix(T) {
              if (!v.isLexicalThis && g.this || u(c.params))
                return;
              if (v.isLexicalThis) {
                const A = c.parent;
                if (A.type !== "MemberExpression")
                  return;
                const R = A.parent, L = m.getTokenAfter(A.object, i.isNotClosingParenToken), _ = m.getLastToken(R);
                if (i.isParenthesised(m, A) || m.commentsExistBetween(L, _))
                  return;
                yield T.removeRange([L.range[0], _.range[1]]);
              }
              const b = m.getFirstToken(c, c.async ? 1 : 0), S = m.getTokenAfter(b, i.isOpeningParenToken), C = m.getTokenBefore(c.body);
              m.commentsExistBetween(b, S) ? (yield T.remove(b), c.id && (yield T.remove(c.id))) : yield T.removeRange([b.range[0], S.range[0]]), yield T.insertTextAfter(C, " =>");
              let x = v.isLexicalThis ? c.parent.parent : c;
              x.type === "ChainExpression" && (x = x.parent), x.parent.type !== "CallExpression" && x.parent.type !== "ConditionalExpression" && !i.isParenthesised(m, x) && !i.isParenthesised(m, c) && (yield T.insertTextBefore(x, "("), yield T.insertTextAfter(x, ")"));
            }
          });
        }
      };
    }
  }, tc;
}
var rc, f0;
function wD() {
  if (f0) return rc;
  f0 = 1;
  const i = Wr(), t = Re(), o = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u, f = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u, r = /^(?:VariableDeclarator|AssignmentExpression)$/u;
  function u(s) {
    return s.parent.type === "ForStatement" && s.parent.init === s;
  }
  function e(s) {
    let c = s.parent;
    for (; o.test(c.type); )
      c = c.parent;
    return c.type === "VariableDeclarator" || c.type === "AssignmentExpression" && c.parent.type === "ExpressionStatement" && f.test(c.parent.parent.type);
  }
  function a(s, c) {
    if (c.through.some((d) => d.resolved && d.resolved.name === s))
      return !0;
    const g = t.getVariableByName(c, s);
    return g !== null ? g.defs.some((d) => d.type === "Parameter") : !1;
  }
  function n(s) {
    if (!s.isWrite())
      return null;
    let c = s.identifier.parent;
    for (; o.test(c.type); )
      c = c.parent;
    return r.test(c.type) ? c : null;
  }
  function p(s) {
    switch (s.type) {
      case "ObjectPattern":
        return s.properties.some((c) => c ? p(c.argument || c.value) : !1);
      case "ArrayPattern":
        return s.elements.some((c) => c ? p(c) : !1);
      case "AssignmentPattern":
        return p(s.left);
      case "MemberExpression":
        return !0;
    }
    return !1;
  }
  function m(s, c) {
    if (s.eslintUsed && s.scope.type === "global")
      return null;
    let g = null, d = !1;
    const y = s.references;
    for (let T = 0; T < y.length; ++T) {
      const b = y[T];
      if (b.isWrite()) {
        if (g !== null && g.identifier !== b.identifier)
          return null;
        const C = n(b);
        if (C !== null && C.left !== void 0) {
          const x = C.left;
          let A = !1, R = !1;
          if (x.type === "ObjectPattern" ? (A = x.properties.filter((_) => _.value).map((_) => _.value.name).some((_) => a(_, s.scope)), R = p(x)) : x.type === "ArrayPattern" && (A = x.elements.map((_) => _ && _.name).some((_) => a(_, s.scope)), R = p(x)), A || R)
            return null;
        }
        g = b;
      } else if (b.isRead() && g === null) {
        if (c)
          return null;
        d = !0;
      }
    }
    return g !== null && g.from === s.scope && e(g.identifier) ? d ? s.defs[0].name : g.identifier : null;
  }
  function h(s, c) {
    const g = /* @__PURE__ */ new Map();
    for (let d = 0; d < s.length; ++d) {
      const y = s[d], v = y.references, T = m(y, c);
      let b = null;
      for (let S = 0; S < v.length; ++S) {
        const C = v[S], x = C.identifier;
        if (x === b)
          continue;
        b = x;
        const A = n(C);
        A && (g.has(A) ? g.get(A).push(T) : g.set(A, [T]));
      }
    }
    return g;
  }
  function l(s, c, g) {
    return !s || g(s) ? null : s.type === c ? s : l(s.parent, c, g);
  }
  return rc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `const` declarations for variables that are never reassigned after declared",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-const"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            destructuring: { enum: ["any", "all"], default: "any" },
            ignoreReadBeforeAssign: { type: "boolean", default: !1 }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        useConst: "'{{name}}' is never reassigned. Use 'const' instead."
      }
    },
    create(s) {
      const c = s.options[0] || {}, g = s.sourceCode, d = c.destructuring !== "all", y = c.ignoreReadBeforeAssign === !0, v = [];
      let T = 0, b = null, S = "";
      function C(x) {
        const A = x.filter(Boolean);
        if (x.length && (d || A.length === x.length)) {
          const R = l(x[0], "VariableDeclaration", (I) => I.type.endsWith("Statement")), L = R === null;
          if (!L && R.declarations.length > 0) {
            const I = R.declarations[0];
            if (I.init) {
              const O = I.init.parent;
              O.type === "VariableDeclarator" && (O.id.name !== S && (S = O.id.name, T = 0), O.id.type === "ObjectPattern" && O.init.name !== S && (S = O.init.name, T = 0), O.id !== b && (b = O.id, T = 0));
            }
          }
          let _ = R && // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)
          (R.parent.type === "ForInStatement" || R.parent.type === "ForOfStatement" || R.declarations.every((I) => I.init)) && /*
          * If options.destructuring is "all", then this warning will not occur unless
          * every assignment in the destructuring should be const. In that case, it's safe
          * to apply the fix.
          */
          A.length === x.length;
          if (!L && R.declarations && R.declarations.length !== 1 && R && R.declarations && R.declarations.length >= 1) {
            T += A.length;
            let I = 0;
            R.declarations.forEach((O) => {
              O.id.type === "ObjectPattern" ? I += O.id.properties.length : O.id.type === "ArrayPattern" ? I += O.id.elements.length : I += 1;
            }), _ = _ && T === I;
          }
          A.forEach((I) => {
            s.report({
              node: I,
              messageId: "useConst",
              data: I,
              fix: _ ? (O) => {
                const k = g.getFirstToken(R, (w) => w.value === R.kind);
                return new i(O, g).retainRange(R.range).replaceTextRange(k.range, "const");
              } : null
            });
          });
        }
      }
      return {
        "Program:exit"() {
          h(v, y).forEach(C);
        },
        VariableDeclaration(x) {
          x.kind === "let" && !u(x) && v.push(...g.getDeclaredVariables(x));
        }
      };
    }
  }, rc;
}
var nc, p0;
function kD() {
  if (p0) return nc;
  p0 = 1;
  const i = Re(), t = i.getPrecedence({ type: "AssignmentExpression" });
  return nc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require destructuring from arrays and/or objects",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-destructuring"
      },
      fixable: "code",
      schema: [
        {
          /*
           * old support {array: Boolean, object: Boolean}
           * new support {VariableDeclarator: {}, AssignmentExpression: {}}
           */
          oneOf: [
            {
              type: "object",
              properties: {
                VariableDeclarator: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: !1
                },
                AssignmentExpression: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: !1
                }
              },
              additionalProperties: !1
            },
            {
              type: "object",
              properties: {
                array: {
                  type: "boolean"
                },
                object: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ]
        },
        {
          type: "object",
          properties: {
            enforceForRenamedProperties: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        preferDestructuring: "Use {{type}} destructuring."
      }
    },
    create(o) {
      const f = o.options[0], r = o.options[1] && o.options[1].enforceForRenamedProperties;
      let u = {
        VariableDeclarator: { array: !0, object: !0 },
        AssignmentExpression: { array: !0, object: !0 }
      };
      f && (u = typeof f.array < "u" || typeof f.object < "u" ? { VariableDeclarator: f, AssignmentExpression: f } : f);
      function e(c, g) {
        return u && u[c] && u[c][g];
      }
      function a(c) {
        return Number.isInteger(c.property.value);
      }
      function n(c, g, d) {
        o.report({
          node: c,
          messageId: "preferDestructuring",
          data: { type: g },
          fix: d
        });
      }
      function p(c) {
        return c.type === "VariableDeclarator" && c.id.type === "Identifier" && c.init.type === "MemberExpression" && !c.init.computed && c.init.property.type === "Identifier" && c.id.name === c.init.property.name;
      }
      function m(c, g) {
        const d = g.init, y = o.sourceCode;
        if (y.getCommentsInside(g).length > y.getCommentsInside(d.object).length)
          return null;
        let v = y.getText(d.object);
        return i.getPrecedence(d.object) < t && (v = `(${v})`), c.replaceText(
          g,
          `{${d.property.name}} = ${v}`
        );
      }
      function h(c, g, d) {
        if (g.type !== "MemberExpression" || g.object.type === "Super" || g.property.type === "PrivateIdentifier")
          return;
        if (a(g)) {
          e(d.type, "array") && n(d, "array", null);
          return;
        }
        const y = p(d) ? (v) => m(v, d) : null;
        if (e(d.type, "object") && r) {
          n(d, "object", y);
          return;
        }
        if (e(d.type, "object")) {
          const v = g.property;
          (v.type === "Literal" && c.name === v.value || v.type === "Identifier" && c.name === v.name && !g.computed) && n(d, "object", y);
        }
      }
      function l(c) {
        c.init && c.init.type === "MemberExpression" && h(c.id, c.init, c);
      }
      function s(c) {
        c.operator === "=" && h(c.left, c.right, c);
      }
      return {
        VariableDeclarator: l,
        AssignmentExpression: s
      };
    }
  }, nc;
}
var sc, h0;
function BD() {
  if (h0) return sc;
  h0 = 1;
  const i = Re(), { CALL: t, ReferenceTracker: o } = Ft(), f = i.getPrecedence({ type: "BinaryExpression", operator: "**" });
  function r(n) {
    return (
      // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c
      i.getPrecedence(n) <= f || // An unary operator cannot be used immediately before an exponentiation expression
      n.type === "AwaitExpression" || n.type === "UnaryExpression"
    );
  }
  function u(n) {
    return i.getPrecedence(n) < f;
  }
  function e(n, p) {
    const m = n.parent.type === "ChainExpression" ? n.parent.parent : n.parent, h = i.getPrecedence(m);
    return (m.type === "ClassDeclaration" || m.type.endsWith("Expression") && (h === -1 || h >= f) && !(m.type === "BinaryExpression" && m.operator === "**" && m.right === n) && !((m.type === "CallExpression" || m.type === "NewExpression") && m.arguments.includes(n)) && !(m.type === "MemberExpression" && m.computed && m.property === n) && m.type !== "ArrayExpression") && !i.isParenthesised(p, n);
  }
  function a(n, p) {
    return p ? `(${n})` : n;
  }
  return sc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `Math.pow` in favor of the `**` operator",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-exponentiation-operator"
      },
      schema: [],
      fixable: "code",
      messages: {
        useExponentiation: "Use the '**' operator instead of 'Math.pow'."
      }
    },
    create(n) {
      const p = n.sourceCode;
      function m(h) {
        n.report({
          node: h,
          messageId: "useExponentiation",
          fix(l) {
            if (h.arguments.length !== 2 || h.arguments.some((R) => R.type === "SpreadElement") || p.getCommentsInside(h).length > 0)
              return null;
            const s = h.arguments[0], c = h.arguments[1], g = p.getText(s), d = p.getText(c), y = r(s), v = u(c), T = e(h, p);
            let b = "", S = "";
            if (!T) {
              if (!y) {
                const R = p.getFirstToken(s), L = p.getTokenBefore(h);
                L && L.range[1] === h.range[0] && !i.canTokensBeAdjacent(L, R) && (b = " ");
              }
              if (!v) {
                const R = p.getLastToken(c), L = p.getTokenAfter(h);
                L && h.range[1] === L.range[0] && !i.canTokensBeAdjacent(R, L) && (S = " ");
              }
            }
            const C = a(g, y), x = a(d, v), A = a(`${C}**${x}`, T);
            return l.replaceText(h, `${b}${A}${S}`);
          }
        });
      }
      return {
        Program(h) {
          const l = p.getScope(h), s = new o(l), c = {
            Math: {
              pow: { [t]: !0 }
            }
          };
          for (const { node: g } of s.iterateGlobalReferences(c))
            m(g);
        }
      };
    }
  }, sc;
}
var ic, m0;
function PD() {
  if (m0) return ic;
  m0 = 1;
  const {
    CALL: i,
    CONSTRUCT: t,
    ReferenceTracker: o,
    getStringIfConstant: f
  } = Ft(), r = rr(), u = new r.RegExpParser();
  function e(a, n, p, m) {
    switch (m.type) {
      case "Literal":
        if (typeof m.value == "string" && p.includes("\\"))
          return null;
        break;
      case "TemplateLiteral":
        if (m.expressions.length || p.slice(1, -1) !== n)
          return null;
        break;
      default:
        return null;
    }
    const h = m.range[0] + a + 2;
    return [
      {
        fix(l) {
          const c = (n.match(/temp\d+/gu) || []).reduce(
            (g, d) => Math.max(g, Number(d.slice(4))),
            0
          );
          return l.insertTextBeforeRange(
            [h, h],
            `?<temp${c + 1}>`
          );
        },
        messageId: "addGroupName"
      },
      {
        fix(l) {
          return l.insertTextBeforeRange(
            [h, h],
            "?:"
          );
        },
        messageId: "addNonCapture"
      }
    ];
  }
  return ic = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce using named capture group in regular expression",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-named-capture-group"
      },
      hasSuggestions: !0,
      schema: [],
      messages: {
        addGroupName: "Add name to capture group.",
        addNonCapture: "Convert group to non-capturing.",
        required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
      }
    },
    create(a) {
      const n = a.sourceCode;
      function p(m, h, l, s) {
        let c;
        try {
          c = u.parsePattern(m, 0, m.length, {
            unicode: !!(s && s.includes("u")),
            unicodeSets: !!(s && s.includes("v"))
          });
        } catch {
          return;
        }
        r.visitRegExpAST(c, {
          onCapturingGroupEnter(g) {
            if (!g.name) {
              const d = n.getText(l), y = e(g.start, m, d, l);
              a.report({
                node: h,
                messageId: "required",
                data: {
                  group: g.raw
                },
                suggest: y
              });
            }
          }
        });
      }
      return {
        Literal(m) {
          m.regex && p(m.regex.pattern, m, m, m.regex.flags);
        },
        Program(m) {
          const h = n.getScope(m), l = new o(h), s = {
            RegExp: {
              [i]: !0,
              [t]: !0
            }
          };
          for (const { node: c } of l.iterateGlobalReferences(s)) {
            const g = f(c.arguments[0]), d = f(c.arguments[1]);
            g && p(g, c, c.arguments[0], d);
          }
        }
      };
    }
  }, ic;
}
var ac, g0;
function ID() {
  if (g0) return ac;
  g0 = 1;
  const i = Re(), t = /* @__PURE__ */ new Map([
    [2, { system: "binary", literalPrefix: "0b" }],
    [8, { system: "octal", literalPrefix: "0o" }],
    [16, { system: "hexadecimal", literalPrefix: "0x" }]
  ]);
  function o(f) {
    return i.isSpecificId(f, "parseInt") || i.isSpecificMemberAccess(f, "Number", "parseInt");
  }
  return ac = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-numeric-literals"
      },
      schema: [],
      messages: {
        useLiteral: "Use {{system}} literals instead of {{functionName}}()."
      },
      fixable: "code"
    },
    create(f) {
      const r = f.sourceCode;
      return {
        "CallExpression[arguments.length=2]"(u) {
          const [e, a] = u.arguments, n = i.getStaticStringValue(e), p = a.value;
          if (n !== null && i.isStringLiteral(e) && a.type === "Literal" && typeof p == "number" && t.has(p) && o(u.callee)) {
            const { system: m, literalPrefix: h } = t.get(p);
            f.report({
              node: u,
              messageId: "useLiteral",
              data: {
                system: m,
                functionName: r.getText(u.callee)
              },
              fix(l) {
                if (r.getCommentsInside(u).length)
                  return null;
                const s = `${h}${n}`;
                if (+s !== parseInt(n, p))
                  return null;
                const c = r.getTokenBefore(u), g = r.getTokenAfter(u);
                let d = "", y = "";
                return c && c.range[1] === u.range[0] && !i.canTokensBeAdjacent(c, s) && (d = " "), g && u.range[1] === g.range[0] && !i.canTokensBeAdjacent(s, g) && (y = " "), l.replaceText(u, `${d}${s}${y}`);
              }
            });
          }
        }
      };
    }
  }, ac;
}
var oc, d0;
function FD() {
  if (d0) return oc;
  d0 = 1;
  const i = Re();
  function t(o) {
    if (o.object.type === "ObjectExpression" && o.object.properties.length === 0)
      return !0;
    const f = o.object.type === "MemberExpression" && i.getStaticPropertyName(o.object) === "prototype" ? o.object.object : o.object;
    return f.type === "Identifier" && f.name === "Object";
  }
  return oc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow use of `Object.prototype.hasOwnProperty.call()` and prefer use of `Object.hasOwn()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-object-has-own"
      },
      schema: [],
      messages: {
        useHasOwn: "Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'."
      },
      fixable: "code"
    },
    create(o) {
      const f = o.sourceCode;
      return {
        CallExpression(r) {
          if (!(r.callee.type === "MemberExpression" && r.callee.object.type === "MemberExpression"))
            return;
          const u = i.getStaticPropertyName(r.callee), e = i.getStaticPropertyName(r.callee.object), a = t(r.callee.object), n = f.getScope(r), p = i.getVariableByName(n, "Object");
          u === "call" && e === "hasOwnProperty" && a && p && p.scope.type === "global" && o.report({
            node: r,
            messageId: "useHasOwn",
            fix(m) {
              if (f.getCommentsInside(r.callee).length > 0)
                return null;
              const h = f.getTokenBefore(r.callee, { includeComments: !0 });
              return h && h.range[1] === r.callee.range[0] && !i.canTokensBeAdjacent(h, "Object.hasOwn") ? m.replaceText(r.callee, " Object.hasOwn") : m.replaceText(r.callee, "Object.hasOwn");
            }
          });
        }
      };
    }
  }, oc;
}
var lc, E0;
function ND() {
  if (E0) return lc;
  E0 = 1;
  const { CALL: i, ReferenceTracker: t } = Ft(), {
    isCommaToken: o,
    isOpeningParenToken: f,
    isClosingParenToken: r,
    isParenthesised: u
  } = Re(), e = /\s/u;
  function a(y) {
    return y.arguments.some((v) => v.type === "SpreadElement");
  }
  function n(y) {
    return y.type === "Property" && (y.kind === "get" || y.kind === "set");
  }
  function p(y) {
    return y.properties.some(n);
  }
  function m(y) {
    return y.arguments.filter((v) => v.type === "ObjectExpression").some(p);
  }
  function h(y, v) {
    const T = y.parent;
    switch (T.type) {
      case "VariableDeclarator":
      case "ArrayExpression":
      case "ReturnStatement":
      case "CallExpression":
      case "Property":
        return !1;
      case "AssignmentExpression":
        return T.left === y && !u(v, y);
      default:
        return !u(v, y);
    }
  }
  function l(y, v) {
    switch (y.type) {
      case "AssignmentExpression":
      case "ArrowFunctionExpression":
      case "ConditionalExpression":
        return !u(v, y);
      default:
        return !1;
    }
  }
  function s(y, v, T) {
    const b = [T.getFirstToken(y), T.getLastToken(y)];
    let S = T.getTokenBefore(y), C = T.getTokenAfter(y);
    for (; S && C && S.range[0] > v.range[0] && f(S) && r(C); )
      b.push(S, C), S = T.getTokenBefore(S), C = T.getTokenAfter(C);
    return b.sort((x, A) => x.range[0] - A.range[0]);
  }
  function c(y, v) {
    const T = v.text;
    let b = y.range[0];
    {
      const S = v.getTokenBefore(y, { includeComments: !0 });
      if (S && S.type === "Line")
        return b;
    }
    for (; e.test(T[b - 1] || ""); )
      b -= 1;
    return b;
  }
  function g(y, v) {
    const T = v.text;
    let b = y.range[1];
    for (; e.test(T[b] || ""); )
      b += 1;
    return b;
  }
  function d(y, v) {
    return function* (T) {
      const b = v.getTokenAfter(y.callee, f), S = v.getLastToken(y);
      yield T.removeRange([y.range[0], b.range[0]]), h(y, v) ? (yield T.replaceText(b, "({"), yield T.replaceText(S, "})")) : (yield T.replaceText(b, "{"), yield T.replaceText(S, "}"));
      for (const C of y.arguments) {
        const x = s(C, b, v), A = x.shift(), R = x.pop();
        if (C.type === "ObjectExpression") {
          const L = v.getLastToken(C, 1), _ = v.getTokenAfter(R);
          for (const k of x)
            yield T.remove(k);
          const I = [A.range[0], g(A, v)], O = [
            Math.max(c(R, v), I[1]),
            // Ensure ranges don't overlap
            R.range[1]
          ];
          yield T.removeRange(I), yield T.removeRange(O), (C.properties.length === 0 || o(L)) && o(_) && (yield T.remove(_));
        } else
          l(C, v) ? (yield T.insertTextBefore(A, "...("), yield T.insertTextAfter(R, ")")) : yield T.insertTextBefore(A, "...");
      }
    };
  }
  return lc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-object-spread"
      },
      schema: [],
      fixable: "code",
      messages: {
        useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
        useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
      }
    },
    create(y) {
      const v = y.sourceCode;
      return {
        Program(T) {
          const b = v.getScope(T), S = new t(b), C = {
            Object: {
              assign: { [i]: !0 }
            }
          };
          for (const { node: x } of S.iterateGlobalReferences(C))
            if (x.arguments.length >= 1 && x.arguments[0].type === "ObjectExpression" && !a(x) && !(x.arguments.length > 1 && m(x))) {
              const A = x.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage", R = d(x, v);
              y.report({ node: x, messageId: A, fix: R });
            }
        }
      };
    }
  }, lc;
}
var uc, y0;
function OD() {
  if (y0) return uc;
  y0 = 1;
  const i = Re();
  return uc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require using Error objects as Promise rejection reasons",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-promise-reject-errors"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyReject: { type: "boolean", default: !1 }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        rejectAnError: "Expected the Promise rejection reason to be an Error."
      }
    },
    create(t) {
      const o = t.options.length && t.options[0].allowEmptyReject, f = t.sourceCode;
      function r(e) {
        !e.arguments.length && o || (!e.arguments.length || !i.couldBeError(e.arguments[0]) || e.arguments[0].type === "Identifier" && e.arguments[0].name === "undefined") && t.report({
          node: e,
          messageId: "rejectAnError"
        });
      }
      function u(e) {
        return i.isSpecificMemberAccess(e.callee, "Promise", "reject");
      }
      return {
        // Check `Promise.reject(value)` calls.
        CallExpression(e) {
          u(e) && r(e);
        },
        /*
         * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.
         * This function is run on "NewExpression:exit" instead of "NewExpression" to ensure that
         * the nodes in the expression already have the `parent` property.
         */
        "NewExpression:exit"(e) {
          e.callee.type === "Identifier" && e.callee.name === "Promise" && e.arguments.length && i.isFunction(e.arguments[0]) && e.arguments[0].params.length > 1 && e.arguments[0].params[1].type === "Identifier" && f.getDeclaredVariables(e.arguments[0]).find((a) => a.name === e.arguments[0].params[1].name).references.filter((a) => a.isRead()).filter((a) => a.identifier.parent.type === "CallExpression" && a.identifier === a.identifier.parent.callee).forEach((a) => r(a.identifier.parent));
        }
      };
    }
  }, uc;
}
var cc, C0;
function UD() {
  return C0 || (C0 = 1, cc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `Reflect` methods where applicable",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-reflect"
      },
      deprecated: !0,
      replacedBy: [],
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: [
                  "apply",
                  "call",
                  "delete",
                  "defineProperty",
                  "getOwnPropertyDescriptor",
                  "getPrototypeOf",
                  "setPrototypeOf",
                  "isExtensible",
                  "getOwnPropertyNames",
                  "preventExtensions"
                ]
              },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
      }
    },
    create(i) {
      const t = {
        apply: "Function.prototype.apply",
        call: "Function.prototype.call",
        defineProperty: "Object.defineProperty",
        getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
        getPrototypeOf: "Object.getPrototypeOf",
        setPrototypeOf: "Object.setPrototypeOf",
        isExtensible: "Object.isExtensible",
        getOwnPropertyNames: "Object.getOwnPropertyNames",
        preventExtensions: "Object.preventExtensions"
      }, o = {
        apply: "Reflect.apply",
        call: "Reflect.apply",
        defineProperty: "Reflect.defineProperty",
        getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
        getPrototypeOf: "Reflect.getPrototypeOf",
        setPrototypeOf: "Reflect.setPrototypeOf",
        isExtensible: "Reflect.isExtensible",
        getOwnPropertyNames: "Reflect.getOwnPropertyNames",
        preventExtensions: "Reflect.preventExtensions"
      }, f = (i.options[0] || {}).exceptions || [];
      function r(u, e, a) {
        i.report({
          node: u,
          messageId: "preferReflect",
          data: {
            existing: e,
            substitute: a
          }
        });
      }
      return {
        CallExpression(u) {
          const e = (u.callee.property || {}).name, a = (u.callee.object || {}).name === "Reflect", n = Object.prototype.hasOwnProperty.call(o, e), p = f.includes(e);
          n && !a && !p && r(u, t[e], o[e]);
        },
        UnaryExpression(u) {
          const e = u.operator === "delete", a = u.argument.type === "Identifier", n = f.includes("delete");
          e && !a && !n && r(u, "the delete keyword", "Reflect.deleteProperty");
        }
      };
    }
  }), cc;
}
var fc, v0;
function VD() {
  if (v0) return fc;
  v0 = 1;
  const i = Re(), { CALL: t, CONSTRUCT: o, ReferenceTracker: f, findVariable: r } = Ft(), { RegExpValidator: u, visitRegExpAST: e, RegExpParser: a } = rr(), { canTokensBeAdjacent: n } = Re(), { REGEXPP_LATEST_ECMA_VERSION: p } = Jf();
  function m(s) {
    return s.type === "Literal" && typeof s.value == "string";
  }
  function h(s) {
    return s.type === "Literal" && Object.prototype.hasOwnProperty.call(s, "regex");
  }
  const l = /* @__PURE__ */ new Set([
    "(",
    ";",
    "[",
    ",",
    "=",
    "+",
    "*",
    "-",
    "?",
    "~",
    "%",
    "**",
    "!",
    "typeof",
    "instanceof",
    "&&",
    "||",
    "??",
    "return",
    "...",
    "delete",
    "void",
    "in",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "<<",
    ">>",
    ">>>",
    "&",
    "|",
    "^",
    ":",
    "{",
    "=>",
    "*=",
    "<<=",
    ">>=",
    ">>>=",
    "^=",
    "|=",
    "&=",
    "??=",
    "||=",
    "&&=",
    "**=",
    "+=",
    "-=",
    "/=",
    "%=",
    "/",
    "do",
    "break",
    "continue",
    "debugger",
    "case",
    "throw"
  ]);
  return fc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow use of the `RegExp` constructor in favor of regular expression literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-regex-literals"
      },
      hasSuggestions: !0,
      schema: [
        {
          type: "object",
          properties: {
            disallowRedundantWrapping: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
        replaceWithLiteral: "Replace with an equivalent regular expression literal.",
        replaceWithLiteralAndFlags: "Replace with an equivalent regular expression literal with flags '{{ flags }}'.",
        replaceWithIntendedLiteralAndFlags: "Replace with a regular expression literal with flags '{{ flags }}'.",
        unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
        unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
      }
    },
    create(s) {
      const [{ disallowRedundantWrapping: c = !1 } = {}] = s.options, g = s.sourceCode;
      function d(k) {
        const w = g.getScope(k), U = r(w, k);
        return U !== null && U.scope.type === "global" && U.defs.length === 0;
      }
      function y(k) {
        return k.type === "TaggedTemplateExpression" && i.isSpecificMemberAccess(k.tag, "String", "raw") && d(i.skipChainExpression(k.tag).object) && i.isStaticTemplateLiteral(k.quasi);
      }
      function v(k) {
        return m(k) ? k.value : i.isStaticTemplateLiteral(k) ? k.quasis[0].value.cooked : y(k) ? k.quasi.quasis[0].value.raw : null;
      }
      function T(k) {
        return m(k) || i.isStaticTemplateLiteral(k) || y(k);
      }
      function b(k) {
        const w = k.arguments;
        return !!((w.length === 1 || w.length === 2) && w.every(T));
      }
      function S(k) {
        const w = k.arguments;
        return !!(w.length === 1 && h(w[0]) || w.length === 2 && h(w[0]) && T(w[1]));
      }
      function C(k) {
        return k <= 5 ? 5 : Math.min(k, p);
      }
      const x = C(s.languageOptions.ecmaVersion);
      function A(k) {
        switch (k) {
          case `
`:
          case `\\
`:
            return "\\n";
          case "\r":
          case "\\\r":
            return "\\r";
          case "	":
          case "\\	":
            return "\\t";
          case "\v":
          case "\\\v":
            return "\\v";
          case "\f":
          case "\\\f":
            return "\\f";
          case "/":
            return "\\/";
          default:
            return null;
        }
      }
      function R(k, w) {
        const U = new u({ ecmaVersion: x });
        try {
          return U.validatePattern(k, 0, k.length, {
            unicode: w ? w.includes("u") : !1,
            unicodeSets: w ? w.includes("v") : !1
          }), w && U.validateFlags(w), !0;
        } catch {
          return !1;
        }
      }
      function L(k, w) {
        return [...k].sort().join("") === [...w].sort().join("");
      }
      function _(k, w) {
        return [.../* @__PURE__ */ new Set([
          ...k,
          ...w
        ])].join("");
      }
      function I(k, w, U) {
        const q = g.getTokenBefore(k);
        return g.getCommentsInside(k).length === 0 && (!q || l.has(q.value)) && R(w, U);
      }
      function O(k, w) {
        const U = g.getTokenBefore(k), q = g.getTokenAfter(k);
        return (U && !n(U, w) && U.range[1] === k.range[0] ? " " : "") + w + (q && !n(w, q) && k.range[1] === q.range[0] ? " " : "");
      }
      return {
        Program(k) {
          const w = g.getScope(k), U = new f(w), q = {
            RegExp: {
              [t]: !0,
              [o]: !0
            }
          };
          for (const { node: F } of U.iterateGlobalReferences(q))
            if (c && S(F)) {
              const $ = F.arguments[0];
              if (F.arguments.length === 2) {
                const P = [], X = v(F.arguments[1]) || "";
                I(F, $.regex.pattern, X) && P.push({
                  messageId: "replaceWithLiteralAndFlags",
                  pattern: $.regex.pattern,
                  flags: X
                });
                const Q = $.regex.flags || "", ue = _(Q, X);
                !L(ue, X) && I(F, $.regex.pattern, ue) && P.push({
                  messageId: "replaceWithIntendedLiteralAndFlags",
                  pattern: $.regex.pattern,
                  flags: ue
                }), s.report({
                  node: F,
                  messageId: "unexpectedRedundantRegExpWithFlags",
                  suggest: P.map(({ flags: le, pattern: Ce, messageId: j }) => ({
                    messageId: j,
                    data: {
                      flags: le
                    },
                    fix(H) {
                      return H.replaceText(F, O(F, `/${Ce}/${le}`));
                    }
                  }))
                });
              } else {
                const P = [];
                I(F, $.regex.pattern, $.regex.flags) && P.push(g.getText($)), s.report({
                  node: F,
                  messageId: "unexpectedRedundantRegExp",
                  suggest: P.map((X) => ({
                    messageId: "replaceWithLiteral",
                    fix(Q) {
                      return Q.replaceText(
                        F,
                        O(F, X)
                      );
                    }
                  }))
                });
              }
            } else if (b(F)) {
              let $ = v(F.arguments[0]), P = !1, X;
              if (F.arguments[1] && (X = v(F.arguments[1])), I(F, $, X) || (P = !0), /^[-a-zA-Z0-9\\[\](){} \t\r\n\v\f!@#$%^&*+^_=/~`.><?,'"|:;]*$/u.test($) || (P = !0), $ && !P) {
                let ue = 0;
                const le = new a({ ecmaVersion: x }).parsePattern($, 0, $.length, {
                  unicode: X ? X.includes("u") : !1,
                  unicodeSets: X ? X.includes("v") : !1
                });
                e(le, {
                  onCharacterEnter(Ce) {
                    const j = A(Ce.raw);
                    j && ($ = $.slice(0, Ce.start + ue) + j + $.slice(Ce.end + ue), Ce.raw.length === 1 && (ue += 1));
                  }
                });
              }
              const Q = `/${$ || "(?:)"}/${X || ""}`;
              s.report({
                node: F,
                messageId: "unexpectedRegExp",
                suggest: P ? [] : [{
                  messageId: "replaceWithLiteral",
                  fix(ue) {
                    return ue.replaceText(F, O(F, Q));
                  }
                }]
              });
            }
        }
      };
    }
  }, fc;
}
var pc, S0;
function MD() {
  if (S0) return pc;
  S0 = 1;
  function i(o) {
    const f = o.variables;
    for (let r = 0; r < f.length; ++r) {
      const u = f[r];
      if (u.name === "arguments")
        return u.identifiers.length === 0 ? u : null;
    }
    return null;
  }
  function t(o) {
    const f = o.identifier, r = f.parent;
    return !(r.type === "MemberExpression" && r.object === f && !r.computed);
  }
  return pc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require rest parameters instead of `arguments`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-rest-params"
      },
      schema: [],
      messages: {
        preferRestParams: "Use the rest parameters instead of 'arguments'."
      }
    },
    create(o) {
      const f = o.sourceCode;
      function r(e) {
        o.report({
          node: e.identifier,
          loc: e.identifier.loc,
          messageId: "preferRestParams"
        });
      }
      function u(e) {
        const a = i(f.getScope(e));
        a && a.references.filter(t).forEach(r);
      }
      return {
        "FunctionDeclaration:exit": u,
        "FunctionExpression:exit": u
      };
    }
  }, pc;
}
var hc, A0;
function KD() {
  if (A0) return hc;
  A0 = 1;
  const i = Re();
  function t(f) {
    return i.isSpecificMemberAccess(f.callee, null, "apply") && f.arguments.length === 2 && f.arguments[1].type !== "ArrayExpression" && f.arguments[1].type !== "SpreadElement";
  }
  function o(f, r, u) {
    return f ? i.equalTokens(f, r, u) : i.isNullOrUndefined(r);
  }
  return hc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require spread operators instead of `.apply()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-spread"
      },
      schema: [],
      fixable: null,
      messages: {
        preferSpread: "Use the spread operator instead of '.apply()'."
      }
    },
    create(f) {
      const r = f.sourceCode;
      return {
        CallExpression(u) {
          if (!t(u))
            return;
          const e = i.skipChainExpression(i.skipChainExpression(u.callee).object), a = e.type === "MemberExpression" ? e.object : null, n = u.arguments[0];
          o(a, n, r) && f.report({
            node: u,
            messageId: "preferSpread"
          });
        }
      };
    }
  }, hc;
}
var mc, T0;
function jD() {
  if (T0) return mc;
  T0 = 1;
  const i = Re();
  function t(n) {
    return n.type === "BinaryExpression" && n.operator === "+";
  }
  function o(n) {
    let p = n;
    for (; t(p.parent); )
      p = p.parent;
    return p;
  }
  function f(n) {
    return t(n) ? f(n.left) || f(n.right) : n.type === "Literal" && typeof n.value == "string" ? i.hasOctalOrNonOctalDecimalEscapeSequence(n.raw) : !1;
  }
  function r(n) {
    return t(n) ? r(n.right) || r(n.left) : i.isStringLiteral(n);
  }
  function u(n) {
    return t(n) ? u(n.right) || u(n.left) : !i.isStringLiteral(n);
  }
  function e(n) {
    return n.type === "BinaryExpression" ? e(n.left) : n.type === "TemplateLiteral" ? n.expressions.length && n.quasis.length && n.quasis[0].range[0] === n.quasis[0].range[1] : n.type !== "Literal" || typeof n.value != "string";
  }
  function a(n) {
    return n.type === "BinaryExpression" ? e(n.right) : n.type === "TemplateLiteral" ? n.expressions.length && n.quasis.length && n.quasis[n.quasis.length - 1].range[0] === n.quasis[n.quasis.length - 1].range[1] : n.type !== "Literal" || typeof n.value != "string";
  }
  return mc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require template literals instead of string concatenation",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/prefer-template"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedStringConcatenation: "Unexpected string concatenation."
      }
    },
    create(n) {
      const p = n.sourceCode;
      let m = /* @__PURE__ */ Object.create(null);
      function h(g, d) {
        const y = [g].concat(p.getTokensBetween(g, d)).concat(d), v = p.getText();
        return y.slice(0, -1).reduce((T, b, S) => T + v.slice(b.range[1], y[S + 1].range[0]), "");
      }
      function l(g, d, y) {
        if (g.type === "Literal" && typeof g.value == "string")
          return `\`${g.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, (v) => v.lastIndexOf("\\") % 2 ? `\\${v}` : v).replace(new RegExp(`\\\\${g.raw[0]}`, "gu"), g.raw[0])}\``;
        if (g.type === "TemplateLiteral")
          return p.getText(g);
        if (t(g) && r(g)) {
          const v = p.getFirstTokenBetween(g.left, g.right, (x) => x.value === "+"), T = h(g.left, v), b = h(v, g.right), S = a(g.left), C = e(g.right);
          return S ? l(g.left, d, T + b).slice(0, -1) + l(g.right, null, y).slice(1) : C ? l(g.left, d, null).slice(0, -1) + l(g.right, T + b, y).slice(1) : `${l(g.left, d, null)}${T}+${b}${l(g.right, y, null)}`;
        }
        return `\`\${${d || ""}${p.getText(g)}${y || ""}}\``;
      }
      function s(g, d) {
        const y = o(d.parent);
        return f(y) ? null : g.replaceText(y, l(y, null, null));
      }
      function c(g) {
        if (!i.isStringLiteral(g) || !t(g.parent))
          return;
        const d = o(g.parent);
        m[d.range[0]] || (m[d.range[0]] = !0, u(d) && n.report({
          node: d,
          messageId: "unexpectedStringConcatenation",
          fix: (y) => s(y, g)
        }));
      }
      return {
        Program() {
          m = /* @__PURE__ */ Object.create(null);
        },
        Literal: c,
        TemplateLiteral: c
      };
    }
  }, mc;
}
var gc, b0;
function qD() {
  if (b0) return gc;
  b0 = 1;
  const i = hn(), t = Re(), o = Hf();
  return gc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Require quotes around object literal property names",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/quote-props"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
              },
              {
                type: "object",
                properties: {
                  keywords: {
                    type: "boolean"
                  },
                  unnecessary: {
                    type: "boolean"
                  },
                  numbers: {
                    type: "boolean"
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
        inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
        unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
        unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
        unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
        unquotedPropertyFound: "Unquoted property '{{property}}' found.",
        redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
      }
    },
    create(f) {
      const r = f.options[0], u = f.options[1] && f.options[1].keywords, e = !f.options[1] || f.options[1].unnecessary !== !1, a = f.options[1] && f.options[1].numbers, n = f.sourceCode;
      function p(d) {
        return o.includes(d);
      }
      function m(d, y, v) {
        return y.length === 1 && y[0].start === 0 && y[0].end === d.length && (["Identifier", "Keyword", "Null", "Boolean"].includes(y[0].type) || y[0].type === "Numeric" && !v && String(+y[0].value) === y[0].value);
      }
      function h(d) {
        return d.type === "Identifier" ? d.name : d.value;
      }
      function l(d) {
        return d.type === "Literal" && typeof d.value == "string" ? n.getText(d) : `"${d.type === "Identifier" ? d.name : d.value}"`;
      }
      function s(d) {
        const y = d.key;
        if (!(d.method || d.computed || d.shorthand))
          if (y.type === "Literal" && typeof y.value == "string") {
            let v;
            try {
              v = i.tokenize(y.value);
            } catch {
              return;
            }
            if (v.length !== 1 || p(v[0].value) && u)
              return;
            e && m(y.value, v, a) && f.report({
              node: d,
              messageId: "unnecessarilyQuotedProperty",
              data: { property: y.value },
              fix: (b) => b.replaceText(y, h(y))
            });
          } else u && y.type === "Identifier" && p(y.name) ? f.report({
            node: d,
            messageId: "unquotedReservedProperty",
            data: { property: y.name },
            fix: (v) => v.replaceText(y, l(y))
          }) : a && y.type === "Literal" && t.isNumericLiteral(y) && f.report({
            node: d,
            messageId: "unquotedNumericProperty",
            data: { property: y.value },
            fix: (v) => v.replaceText(y, l(y))
          });
      }
      function c(d) {
        const y = d.key;
        !d.method && !d.computed && !d.shorthand && !(y.type === "Literal" && typeof y.value == "string") && f.report({
          node: d,
          messageId: "unquotedPropertyFound",
          data: { property: y.name || y.value },
          fix: (v) => v.replaceText(y, l(y))
        });
      }
      function g(d, y) {
        const v = [], T = [];
        let b = null, S = !1;
        d.properties.forEach((C) => {
          const x = C.key;
          if (!(!x || C.method || C.computed || C.shorthand))
            if (x.type === "Literal" && typeof x.value == "string") {
              if (v.push(C), y) {
                let A;
                try {
                  A = i.tokenize(x.value);
                } catch {
                  S = !0;
                  return;
                }
                S = S || !m(x.value, A) || u && p(A[0].value);
              }
            } else u && y && x.type === "Identifier" && p(x.name) ? (T.push(C), S = !0, b = x.name) : T.push(C);
        }), y && v.length && !S ? v.forEach((C) => {
          f.report({
            node: C,
            messageId: "redundantQuoting",
            fix: (x) => x.replaceText(C.key, h(C.key))
          });
        }) : T.length && b ? T.forEach((C) => {
          f.report({
            node: C,
            messageId: "requireQuotesDueToReservedWord",
            data: { property: b },
            fix: (x) => x.replaceText(C.key, l(C.key))
          });
        }) : v.length && T.length && T.forEach((C) => {
          f.report({
            node: C,
            messageId: "inconsistentlyQuotedProperty",
            data: { key: C.key.name || C.key.value },
            fix: (x) => x.replaceText(C.key, l(C.key))
          });
        });
      }
      return {
        Property(d) {
          (r === "always" || !r) && c(d), r === "as-needed" && s(d);
        },
        ObjectExpression(d) {
          r === "consistent" && g(d, !1), r === "consistent-as-needed" && g(d, !0);
        }
      };
    }
  }, gc;
}
var dc, x0;
function $D() {
  if (x0) return dc;
  x0 = 1;
  const i = Re(), t = {
    double: {
      quote: '"',
      alternateQuote: "'",
      description: "doublequote"
    },
    single: {
      quote: "'",
      alternateQuote: '"',
      description: "singlequote"
    },
    backtick: {
      quote: "`",
      alternateQuote: '"',
      description: "backtick"
    }
  }, o = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(i.LINEBREAKS).join("")}]`, "u");
  t.double.convert = t.single.convert = t.backtick.convert = function(r) {
    const u = this.quote, e = r[0];
    return u === e ? r : u + r.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (a, n, p) => n === e || e === "`" && n === "${" ? n : a === u || u === "`" && a === "${" ? `\\${a}` : p && e === "`" ? "\\n" : a) + u;
  };
  const f = "avoid-escape";
  return dc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce the consistent use of either backticks, double, or single quotes",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/quotes"
      },
      fixable: "code",
      schema: [
        {
          enum: ["single", "double", "backtick"]
        },
        {
          anyOf: [
            {
              enum: ["avoid-escape"]
            },
            {
              type: "object",
              properties: {
                avoidEscape: {
                  type: "boolean"
                },
                allowTemplateLiterals: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        wrongQuotes: "Strings must use {{description}}."
      }
    },
    create(r) {
      const u = r.options[0], e = t[u || "double"], a = r.options[1], n = a && a.allowTemplateLiterals === !0, p = r.sourceCode;
      let m = a && a.avoidEscape === !0;
      a === f && (m = !0);
      function h(d) {
        return d.parent.type === "JSXAttribute" || d.parent.type === "JSXElement" || d.parent.type === "JSXFragment";
      }
      function l(d) {
        return d.type === "ExpressionStatement" && d.expression.type === "Literal" && typeof d.expression.value == "string" && !i.isParenthesised(p, d.expression);
      }
      function s(d) {
        if (!i.isTopLevelExpressionStatement(d.parent))
          return !1;
        const y = d.parent.parent;
        for (let v = 0; v < y.body.length; ++v) {
          const T = y.body[v];
          if (T === d.parent)
            return !0;
          if (!l(T))
            break;
        }
        return !1;
      }
      function c(d) {
        const y = d.parent;
        switch (y.type) {
          case "ExpressionStatement":
            return !i.isParenthesised(p, d) && s(d);
          case "Property":
          case "PropertyDefinition":
          case "MethodDefinition":
            return y.key === d && !y.computed;
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
            return y.source === d;
          case "ExportAllDeclaration":
            return y.exported === d || y.source === d;
          case "ImportSpecifier":
            return y.imported === d;
          case "ExportSpecifier":
            return y.local === d || y.exported === d;
          default:
            return !1;
        }
      }
      function g(d) {
        return !!(d.parent.type === "TaggedTemplateExpression" && d === d.parent.quasi || d.expressions.length > 0 || d.quasis.length >= 1 && o.test(d.quasis[0].value.raw));
      }
      return {
        Literal(d) {
          const y = d.value, v = d.raw;
          if (e && typeof y == "string") {
            let T = u === "backtick" && c(d) || h(d) || i.isSurroundedBy(v, e.quote);
            !T && m && (T = i.isSurroundedBy(v, e.alternateQuote) && v.includes(e.quote)), T || r.report({
              node: d,
              messageId: "wrongQuotes",
              data: {
                description: e.description
              },
              fix(b) {
                return u === "backtick" && i.hasOctalOrNonOctalDecimalEscapeSequence(v) ? null : b.replaceText(d, e.convert(d.raw));
              }
            });
          }
        },
        TemplateLiteral(d) {
          n || u === "backtick" || g(d) || r.report({
            node: d,
            messageId: "wrongQuotes",
            data: {
              description: e.description
            },
            fix(y) {
              return i.isTopLevelExpressionStatement(d.parent) && !i.isParenthesised(p, d) ? null : y.replaceText(d, e.convert(p.getText(d)));
            }
          });
        }
      };
    }
  }, dc;
}
var Ec, R0;
function GD() {
  if (R0) return Ec;
  R0 = 1;
  const i = Re(), t = "always", o = "as-needed", f = new Set(Array.from({ length: 35 }, (n, p) => p + 2));
  function r(n) {
    return n.defs.length >= 1;
  }
  function u(n) {
    return n.type === "MemberExpression" && !n.computed && n.property.type === "Identifier" && n.property.name === "parseInt";
  }
  function e(n) {
    return !(n.type === "Literal" && !f.has(n.value) || n.type === "Identifier" && n.name === "undefined");
  }
  function a(n) {
    return n.type === "Literal" && n.value === 10;
  }
  return Ec = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce the consistent use of the radix argument when using `parseInt()`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/radix"
      },
      hasSuggestions: !0,
      schema: [
        {
          enum: ["always", "as-needed"]
        }
      ],
      messages: {
        missingParameters: "Missing parameters.",
        redundantRadix: "Redundant radix parameter.",
        missingRadix: "Missing radix parameter.",
        invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.",
        addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers."
      }
    },
    create(n) {
      const p = n.options[0] || t, m = n.sourceCode;
      function h(l) {
        const s = l.arguments;
        switch (s.length) {
          case 0:
            n.report({
              node: l,
              messageId: "missingParameters"
            });
            break;
          case 1:
            p === t && n.report({
              node: l,
              messageId: "missingRadix",
              suggest: [
                {
                  messageId: "addRadixParameter10",
                  fix(c) {
                    const g = m.getTokens(l), d = g[g.length - 1], y = g[g.length - 2], v = y.type === "Punctuator" && y.value === ",";
                    return c.insertTextBefore(d, v ? " 10," : ", 10");
                  }
                }
              ]
            });
            break;
          default:
            p === o && a(s[1]) ? n.report({
              node: l,
              messageId: "redundantRadix"
            }) : e(s[1]) || n.report({
              node: l,
              messageId: "invalidRadix"
            });
            break;
        }
      }
      return {
        "Program:exit"(l) {
          const s = m.getScope(l);
          let c;
          c = i.getVariableByName(s, "parseInt"), c && !r(c) && c.references.forEach((g) => {
            const d = g.identifier;
            i.isCallee(d) && h(d.parent);
          }), c = i.getVariableByName(s, "Number"), c && !r(c) && c.references.forEach((g) => {
            const d = g.identifier.parent, y = d.parent.type === "ChainExpression" ? d.parent : d;
            u(d) && i.isCallee(y) && h(y.parent);
          });
        }
      };
    }
  }, Ec;
}
var yc, D0;
function WD() {
  if (D0) return yc;
  D0 = 1;
  function i(r, u = /* @__PURE__ */ new Map()) {
    for (const e of r.references)
      e.resolved !== null && u.set(e.identifier, e);
    for (const e of r.childScopes)
      e.type !== "function" && i(e, u);
    return u;
  }
  function t(r) {
    if (r.writeExpr)
      return r.writeExpr;
    let u = r.identifier;
    for (; u; ) {
      const e = u.parent.type;
      if (e === "AssignmentExpression" && u.parent.left === u)
        return u.parent.right;
      if (e === "MemberExpression" && u.parent.object === u) {
        u = u.parent;
        continue;
      }
      break;
    }
    return null;
  }
  function o(r, u) {
    if (!r || u && r.defs.some((a) => a.type === "Parameter"))
      return !1;
    const e = r.scope.variableScope;
    return r.references.every((a) => a.from.variableScope === e);
  }
  class f {
    constructor() {
      this.info = /* @__PURE__ */ new WeakMap();
    }
    /**
     * Initialize the segment information.
     * @param {PathSegment} segment The segment to initialize.
     * @returns {void}
     */
    initialize(u) {
      const e = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
      for (const n of u.prevSegments) {
        const p = this.info.get(n);
        p && (p.outdatedReadVariables.forEach(Set.prototype.add, e), p.freshReadVariables.forEach(Set.prototype.add, a));
      }
      this.info.set(u, { outdatedReadVariables: e, freshReadVariables: a });
    }
    /**
     * Mark a given variable as read on given segments.
     * @param {PathSegment[]} segments The segments that it read the variable on.
     * @param {Variable} variable The variable to be read.
     * @returns {void}
     */
    markAsRead(u, e) {
      for (const a of u) {
        const n = this.info.get(a);
        n && (n.freshReadVariables.add(e), n.outdatedReadVariables.delete(e));
      }
    }
    /**
     * Move `freshReadVariables` to `outdatedReadVariables`.
     * @param {PathSegment[]} segments The segments to process.
     * @returns {void}
     */
    makeOutdated(u) {
      for (const e of u) {
        const a = this.info.get(e);
        a && (a.freshReadVariables.forEach(Set.prototype.add, a.outdatedReadVariables), a.freshReadVariables.clear());
      }
    }
    /**
     * Check if a given variable is outdated on the current segments.
     * @param {PathSegment[]} segments The current segments.
     * @param {Variable} variable The variable to check.
     * @returns {boolean} `true` if the variable is outdated on the segments.
     */
    isOutdated(u, e) {
      for (const a of u) {
        const n = this.info.get(a);
        if (n && n.outdatedReadVariables.has(e))
          return !0;
      }
      return !1;
    }
  }
  return yc = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/require-atomic-updates"
      },
      fixable: null,
      schema: [{
        type: "object",
        properties: {
          allowProperties: {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }],
      messages: {
        nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.",
        nonAtomicObjectUpdate: "Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`."
      }
    },
    create(r) {
      const u = !!r.options[0] && r.options[0].allowProperties, e = r.sourceCode, a = /* @__PURE__ */ new Map(), n = new f();
      let p = null;
      return {
        onCodePathStart(m, h) {
          const l = e.getScope(h), s = l.type === "function" && (l.block.async || l.block.generator);
          p = {
            upper: p,
            codePath: m,
            referenceMap: s ? i(l) : null,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        onCodePathEnd() {
          p = p.upper;
        },
        // Initialize the segment information.
        onCodePathSegmentStart(m) {
          n.initialize(m), p.currentSegments.add(m);
        },
        onUnreachableCodePathSegmentStart(m) {
          p.currentSegments.add(m);
        },
        onUnreachableCodePathSegmentEnd(m) {
          p.currentSegments.delete(m);
        },
        onCodePathSegmentEnd(m) {
          p.currentSegments.delete(m);
        },
        // Handle references to prepare verification.
        Identifier(m) {
          const { referenceMap: h } = p, l = h && h.get(m);
          if (!l)
            return;
          const s = l.resolved, c = t(l), g = l.identifier.parent.type === "MemberExpression";
          if (l.isRead() && !(c && c.parent.operator === "=") && n.markAsRead(p.currentSegments, s), c && c.parent.right === c && // ← exclude variable declarations.
          !o(s, g)) {
            let d = a.get(c);
            d || (d = [], a.set(c, d)), d.push(l);
          }
        },
        /*
         * Verify assignments.
         * If the reference exists in `outdatedReadVariables` list, report it.
         */
        ":expression:exit"(m) {
          if (!p.referenceMap)
            return;
          (m.type === "AwaitExpression" || m.type === "YieldExpression") && n.makeOutdated(p.currentSegments);
          const h = a.get(m);
          if (h) {
            a.delete(m);
            for (const l of h) {
              const s = l.resolved;
              n.isOutdated(p.currentSegments, s) && (m.parent.left === l.identifier ? r.report({
                node: m.parent,
                messageId: "nonAtomicUpdate",
                data: {
                  value: s.name
                }
              }) : u || r.report({
                node: m.parent,
                messageId: "nonAtomicObjectUpdate",
                data: {
                  value: e.getText(m.parent.left),
                  object: s.name
                }
              }));
            }
          }
        }
      };
    }
  }, yc;
}
var Cc, L0;
function XD() {
  if (L0) return Cc;
  L0 = 1;
  const i = Re();
  function t(o) {
    return o[0].toUpperCase() + o.slice(1);
  }
  return Cc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow async functions which have no `await` expression",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/require-await"
      },
      schema: [],
      messages: {
        missingAwait: "{{name}} has no 'await' expression."
      }
    },
    create(o) {
      const f = o.sourceCode;
      let r = null;
      function u() {
        r = {
          upper: r,
          hasAwait: !1
        };
      }
      function e(a) {
        !a.generator && a.async && !r.hasAwait && !i.isEmptyFunction(a) && o.report({
          node: a,
          loc: i.getFunctionHeadLoc(a, f),
          messageId: "missingAwait",
          data: {
            name: t(
              i.getFunctionNameWithKind(a)
            )
          }
        }), r = r.upper;
      }
      return {
        FunctionDeclaration: u,
        FunctionExpression: u,
        ArrowFunctionExpression: u,
        "FunctionDeclaration:exit": e,
        "FunctionExpression:exit": e,
        "ArrowFunctionExpression:exit": e,
        AwaitExpression() {
          r && (r.hasAwait = !0);
        },
        ForOfStatement(a) {
          r && a.await && (r.hasAwait = !0);
        }
      };
    }
  }, Cc;
}
var vc, _0;
function zD() {
  return _0 || (_0 = 1, vc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require JSDoc comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/require-jsdoc"
      },
      schema: [
        {
          type: "object",
          properties: {
            require: {
              type: "object",
              properties: {
                ClassDeclaration: {
                  type: "boolean",
                  default: !1
                },
                MethodDefinition: {
                  type: "boolean",
                  default: !1
                },
                FunctionDeclaration: {
                  type: "boolean",
                  default: !0
                },
                ArrowFunctionExpression: {
                  type: "boolean",
                  default: !1
                },
                FunctionExpression: {
                  type: "boolean",
                  default: !1
                }
              },
              additionalProperties: !1,
              default: {}
            }
          },
          additionalProperties: !1
        }
      ],
      deprecated: !0,
      replacedBy: [],
      messages: {
        missingJSDocComment: "Missing JSDoc comment."
      }
    },
    create(i) {
      const t = i.sourceCode, f = Object.assign({
        FunctionDeclaration: !0,
        MethodDefinition: !1,
        ClassDeclaration: !1,
        ArrowFunctionExpression: !1,
        FunctionExpression: !1
      }, i.options[0] && i.options[0].require);
      function r(e) {
        i.report({ node: e, messageId: "missingJSDocComment" });
      }
      function u(e) {
        t.getJSDocComment(e) || r(e);
      }
      return {
        FunctionDeclaration(e) {
          f.FunctionDeclaration && u(e);
        },
        FunctionExpression(e) {
          (f.MethodDefinition && e.parent.type === "MethodDefinition" || f.FunctionExpression && (e.parent.type === "VariableDeclarator" || e.parent.type === "Property" && e === e.parent.value)) && u(e);
        },
        ClassDeclaration(e) {
          f.ClassDeclaration && u(e);
        },
        ArrowFunctionExpression(e) {
          f.ArrowFunctionExpression && e.parent.type === "VariableDeclarator" && u(e);
        }
      };
    }
  }), vc;
}
var Sc, w0;
function HD() {
  if (w0) return Sc;
  w0 = 1;
  const {
    CALL: i,
    CONSTRUCT: t,
    ReferenceTracker: o,
    getStringIfConstant: f
  } = Ft(), r = Re(), { isValidWithUnicodeFlag: u } = Jf();
  return Sc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce the use of `u` or `v` flag on RegExp",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/require-unicode-regexp"
      },
      hasSuggestions: !0,
      messages: {
        addUFlag: "Add the 'u' flag.",
        requireUFlag: "Use the 'u' flag."
      },
      schema: []
    },
    create(e) {
      const a = e.sourceCode;
      return {
        "Literal[regex]"(n) {
          const p = n.regex.flags || "";
          !p.includes("u") && !p.includes("v") && e.report({
            messageId: "requireUFlag",
            node: n,
            suggest: u(e.languageOptions.ecmaVersion, n.regex.pattern) ? [
              {
                fix(m) {
                  return m.insertTextAfter(n, "u");
                },
                messageId: "addUFlag"
              }
            ] : null
          });
        },
        Program(n) {
          const p = a.getScope(n), m = new o(p), h = {
            RegExp: { [i]: !0, [t]: !0 }
          };
          for (const { node: l } of m.iterateGlobalReferences(h)) {
            const [s, c] = l.arguments;
            if (s && s.type === "SpreadElement")
              continue;
            const g = f(s, p), d = f(c, p);
            (!c || typeof d == "string" && !d.includes("u") && !d.includes("v")) && e.report({
              messageId: "requireUFlag",
              node: l,
              suggest: typeof g == "string" && u(e.languageOptions.ecmaVersion, g) ? [
                {
                  fix(y) {
                    if (c) {
                      if (c.type === "Literal" && typeof c.value == "string" || c.type === "TemplateLiteral") {
                        const T = a.getText(c);
                        return y.replaceText(c, [
                          T.slice(0, T.length - 1),
                          T.slice(T.length - 1)
                        ].join("u"));
                      }
                      return null;
                    }
                    const v = a.getLastToken(l, { skip: 1 });
                    return y.insertTextAfter(
                      v,
                      r.isCommaToken(v) ? ' "u",' : ', "u"'
                    );
                  },
                  messageId: "addUFlag"
                }
              ] : null
            });
          }
        }
      };
    }
  }, Sc;
}
var Ac, k0;
function JD() {
  return k0 || (k0 = 1, Ac = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require generator functions to contain `yield`",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/require-yield"
      },
      schema: [],
      messages: {
        missingYield: "This generator function does not have 'yield'."
      }
    },
    create(i) {
      const t = [];
      function o(r) {
        r.generator && t.push(0);
      }
      function f(r) {
        if (!r.generator)
          return;
        t.pop() === 0 && r.body.body.length > 0 && i.report({ node: r, messageId: "missingYield" });
      }
      return {
        FunctionDeclaration: o,
        "FunctionDeclaration:exit": f,
        FunctionExpression: o,
        "FunctionExpression:exit": f,
        // Increases the count of `yield` keyword.
        YieldExpression() {
          t.length > 0 && (t[t.length - 1] += 1);
        }
      };
    }
  }), Ac;
}
var Tc, B0;
function QD() {
  return B0 || (B0 = 1, Tc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce spacing between rest and spread operators and their expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/rest-spread-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
        expectedWhitespace: "Expected whitespace after {{type}} operator."
      }
    },
    create(i) {
      const t = i.sourceCode, o = i.options[0] === "always";
      function f(r) {
        const u = t.getFirstToken(r), e = t.getTokenAfter(u), a = t.isSpaceBetweenTokens(u, e);
        let n;
        switch (r.type) {
          case "SpreadElement":
            n = "spread", r.parent.type === "ObjectExpression" && (n += " property");
            break;
          case "RestElement":
            n = "rest", r.parent.type === "ObjectPattern" && (n += " property");
            break;
          case "ExperimentalSpreadProperty":
            n = "spread property";
            break;
          case "ExperimentalRestProperty":
            n = "rest property";
            break;
          default:
            return;
        }
        o && !a ? i.report({
          node: r,
          loc: u.loc,
          messageId: "expectedWhitespace",
          data: {
            type: n
          },
          fix(p) {
            return p.replaceTextRange([u.range[1], e.range[0]], " ");
          }
        }) : !o && a && i.report({
          node: r,
          loc: {
            start: u.loc.end,
            end: e.loc.start
          },
          messageId: "unexpectedWhitespace",
          data: {
            type: n
          },
          fix(p) {
            return p.removeRange([u.range[1], e.range[0]]);
          }
        });
      }
      return {
        SpreadElement: f,
        RestElement: f,
        ExperimentalSpreadProperty: f,
        ExperimentalRestProperty: f
      };
    }
  }), Tc;
}
var bc, P0;
function YD() {
  if (P0) return bc;
  P0 = 1;
  const i = Wr(), t = Re();
  return bc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow semicolons instead of ASI",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/semi"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  beforeStatementContinuationChars: {
                    enum: ["always", "any", "never"]
                  }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  omitLastInOneLineBlock: { type: "boolean" },
                  omitLastInOneLineClassBody: { type: "boolean" }
                },
                additionalProperties: !1
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        missingSemi: "Missing semicolon.",
        extraSemi: "Extra semicolon."
      }
    },
    create(o) {
      const f = /^[-[(/+`]/u, r = /* @__PURE__ */ new Set(["get", "set", "static"]), u = /* @__PURE__ */ new Set(["*", "in", "instanceof"]), e = o.options[1], a = o.options[0] === "never", n = !!(e && e.omitLastInOneLineBlock), p = !!(e && e.omitLastInOneLineClassBody), m = e && e.beforeStatementContinuationChars || "any", h = o.sourceCode;
      function l(A, R) {
        const L = h.getLastToken(A);
        let _, I, O;
        R ? (_ = "extraSemi", O = L.loc, I = function(k) {
          return new i(k, h).retainSurroundingTokens(L).remove(L);
        }) : (_ = "missingSemi", O = {
          start: L.loc.end,
          end: t.getNextLocation(h, L.loc.end)
        }, I = function(k) {
          return k.insertTextAfter(L, ";");
        }), o.report({
          node: A,
          loc: O,
          messageId: _,
          fix: I
        });
      }
      function s(A) {
        const R = h.getTokenAfter(A);
        return !R || t.isClosingBraceToken(R) || t.isSemicolonToken(R);
      }
      function c(A) {
        if (!t.isClosingBraceToken(A))
          return !1;
        const R = h.getNodeByRangeIndex(A.range[0]);
        return R.type === "BlockStatement" && R.parent.type === "ArrowFunctionExpression";
      }
      function g(A) {
        if (A.type !== "PropertyDefinition")
          return !1;
        if (!A.computed && A.key.type === "Identifier" && r.has(A.key.name) && !(A.static && A.key.name === "static") && !A.value)
          return !0;
        const L = h.getTokenAfter(A);
        return u.has(L.value);
      }
      function d(A) {
        const R = h.getLastToken(A, 1), L = h.getTokenAfter(A);
        return !!L && t.isTokenOnSameLine(R, L);
      }
      function y(A) {
        const R = A.type;
        return R === "DoWhileStatement" || R === "BreakStatement" || R === "ContinueStatement" || R === "DebuggerStatement" || R === "ImportDeclaration" || R === "ExportAllDeclaration" ? !1 : R === "ReturnStatement" ? !!A.argument : R === "ExportNamedDeclaration" ? !!A.declaration : !c(h.getLastToken(A, 1));
      }
      function v(A) {
        return !!A && f.test(A.value) && A.value !== "++" && A.value !== "--";
      }
      function T(A) {
        return s(h.getLastToken(A)) ? !0 : g(A) || d(A) ? !1 : A.type !== "PropertyDefinition" && m === "never" && !y(A) || !v(h.getTokenAfter(A));
      }
      function b(A) {
        const R = A.parent, L = h.getTokenAfter(A);
        return !L || L.value !== "}" ? !1 : R.type === "BlockStatement" ? R.loc.start.line === R.loc.end.line : R.type === "StaticBlock" ? h.getFirstToken(R, { skip: 1 }).loc.start.line === R.loc.end.line : !1;
      }
      function S(A) {
        const R = A.parent, L = h.getTokenAfter(A);
        return !L || L.value !== "}" ? !1 : R.type === "ClassBody" ? R.loc.start.line === R.loc.end.line : !1;
      }
      function C(A) {
        const R = t.isSemicolonToken(h.getLastToken(A));
        if (a)
          R && T(A) ? l(A, !0) : !R && m === "always" && A.type !== "PropertyDefinition" && v(h.getTokenAfter(A)) && l(A);
        else {
          const L = n && b(A), _ = p && S(A), I = L || _;
          R && I ? l(A, !0) : !R && !I && l(A);
        }
      }
      function x(A) {
        const R = A.parent;
        (R.type !== "ForStatement" || R.init !== A) && (!/^For(?:In|Of)Statement/u.test(R.type) || R.left !== A) && C(A);
      }
      return {
        VariableDeclaration: x,
        ExpressionStatement: C,
        ReturnStatement: C,
        ThrowStatement: C,
        DoWhileStatement: C,
        DebuggerStatement: C,
        BreakStatement: C,
        ContinueStatement: C,
        ImportDeclaration: C,
        ExportAllDeclaration: C,
        ExportNamedDeclaration(A) {
          A.declaration || C(A);
        },
        ExportDefaultDeclaration(A) {
          /(?:Class|Function)Declaration/u.test(A.declaration.type) || C(A);
        },
        PropertyDefinition: C
      };
    }
  }, bc;
}
var xc, I0;
function ZD() {
  if (I0) return xc;
  I0 = 1;
  const i = Re();
  return xc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after semicolons",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/semi-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: !1
            },
            after: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
        unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
        missingWhitespaceBefore: "Missing whitespace before semicolon.",
        missingWhitespaceAfter: "Missing whitespace after semicolon."
      }
    },
    create(t) {
      const o = t.options[0], f = t.sourceCode;
      let r = !1, u = !0;
      typeof o == "object" && (r = o.before, u = o.after);
      function e(s) {
        const c = f.getTokenBefore(s);
        return c && i.isTokenOnSameLine(c, s) && f.isSpaceBetweenTokens(c, s);
      }
      function a(s) {
        const c = f.getTokenAfter(s);
        return c && i.isTokenOnSameLine(s, c) && f.isSpaceBetweenTokens(s, c);
      }
      function n(s) {
        const c = f.getTokenAfter(s);
        return !(c && i.isTokenOnSameLine(s, c));
      }
      function p(s) {
        const c = f.getTokenBefore(s);
        return !(c && i.isTokenOnSameLine(s, c));
      }
      function m(s) {
        const c = f.getTokenAfter(s);
        return c && i.isClosingBraceToken(c) || i.isClosingParenToken(c);
      }
      function h(s, c) {
        if (i.isSemicolonToken(s)) {
          if (e(s)) {
            if (!r) {
              const g = f.getTokenBefore(s), d = {
                start: g.loc.end,
                end: s.loc.start
              };
              t.report({
                node: c,
                loc: d,
                messageId: "unexpectedWhitespaceBefore",
                fix(y) {
                  return y.removeRange([g.range[1], s.range[0]]);
                }
              });
            }
          } else if (r) {
            const g = s.loc;
            t.report({
              node: c,
              loc: g,
              messageId: "missingWhitespaceBefore",
              fix(d) {
                return d.insertTextBefore(s, " ");
              }
            });
          }
          if (!p(s) && !n(s) && !m(s)) {
            if (a(s)) {
              if (!u) {
                const g = f.getTokenAfter(s), d = {
                  start: s.loc.end,
                  end: g.loc.start
                };
                t.report({
                  node: c,
                  loc: d,
                  messageId: "unexpectedWhitespaceAfter",
                  fix(y) {
                    return y.removeRange([s.range[1], g.range[0]]);
                  }
                });
              }
            } else if (u) {
              const g = s.loc;
              t.report({
                node: c,
                loc: g,
                messageId: "missingWhitespaceAfter",
                fix(d) {
                  return d.insertTextAfter(s, " ");
                }
              });
            }
          }
        }
      }
      function l(s) {
        const c = f.getLastToken(s);
        h(c, s);
      }
      return {
        VariableDeclaration: l,
        ExpressionStatement: l,
        BreakStatement: l,
        ContinueStatement: l,
        DebuggerStatement: l,
        DoWhileStatement: l,
        ReturnStatement: l,
        ThrowStatement: l,
        ImportDeclaration: l,
        ExportNamedDeclaration: l,
        ExportAllDeclaration: l,
        ExportDefaultDeclaration: l,
        ForStatement(s) {
          s.init && h(f.getTokenAfter(s.init), s), s.test && h(f.getTokenAfter(s.test), s);
        },
        PropertyDefinition: l
      };
    }
  }, xc;
}
var Rc, F0;
function eL() {
  if (F0) return Rc;
  F0 = 1;
  const i = Re(), t = [
    "BreakStatement",
    "ContinueStatement",
    "DebuggerStatement",
    "DoWhileStatement",
    "ExportAllDeclaration",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExpressionStatement",
    "ImportDeclaration",
    "ReturnStatement",
    "ThrowStatement",
    "VariableDeclaration",
    "PropertyDefinition"
  ].join(",");
  function o(r) {
    const u = r.type;
    return u === "BlockStatement" || u === "StaticBlock" || u === "Program" || u === "ClassBody" ? r.body : u === "SwitchCase" ? r.consequent : null;
  }
  function f(r) {
    const u = r.parent.type;
    if (u === "IfStatement" && r.parent.consequent === r && r.parent.alternate || u === "DoWhileStatement")
      return !0;
    const e = o(r.parent);
    return e !== null && e[e.length - 1] === r;
  }
  return Rc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce location of semicolons",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/semi-style"
      },
      schema: [{ enum: ["last", "first"] }],
      fixable: "whitespace",
      messages: {
        expectedSemiColon: "Expected this semicolon to be at {{pos}}."
      }
    },
    create(r) {
      const u = r.sourceCode, e = r.options[0] || "last";
      function a(n, p) {
        const m = u.getTokenBefore(n), h = u.getTokenAfter(n), l = !m || i.isTokenOnSameLine(m, n), s = !h || i.isTokenOnSameLine(n, h);
        (p === "last" && !l || p === "first" && !s) && r.report({
          loc: n.loc,
          messageId: "expectedSemiColon",
          data: {
            pos: p === "last" ? "the end of the previous line" : "the beginning of the next line"
          },
          fix(c) {
            if (m && h && u.commentsExistBetween(m, h))
              return null;
            const g = m ? m.range[1] : n.range[0], d = h ? h.range[0] : n.range[1], y = p === "last" ? `;
` : `
;`;
            return c.replaceTextRange([g, d], y);
          }
        });
      }
      return {
        [t](n) {
          if (e === "first" && f(n))
            return;
          const p = u.getLastToken(n);
          i.isSemicolonToken(p) && a(p, e);
        },
        ForStatement(n) {
          const p = n.init && u.getTokenAfter(n.init, i.isSemicolonToken), m = n.test && u.getTokenAfter(n.test, i.isSemicolonToken);
          p && a(p, "last"), m && a(m, "last");
        }
      };
    }
  }, Rc;
}
var Dc, N0;
function tL() {
  return N0 || (N0 = 1, Dc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce sorted import declarations within modules",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/sort-imports"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean",
              default: !1
            },
            memberSyntaxSortOrder: {
              type: "array",
              items: {
                enum: ["none", "all", "multiple", "single"]
              },
              uniqueItems: !0,
              minItems: 4,
              maxItems: 4
            },
            ignoreDeclarationSort: {
              type: "boolean",
              default: !1
            },
            ignoreMemberSort: {
              type: "boolean",
              default: !1
            },
            allowSeparatedGroups: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        sortImportsAlphabetically: "Imports should be sorted alphabetically.",
        sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
        unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
      }
    },
    create(i) {
      const t = i.options[0] || {}, o = t.ignoreCase || !1, f = t.ignoreDeclarationSort || !1, r = t.ignoreMemberSort || !1, u = t.memberSyntaxSortOrder || ["none", "all", "multiple", "single"], e = t.allowSeparatedGroups || !1, a = i.sourceCode;
      let n = null;
      function p(s) {
        return s.specifiers.length === 0 ? "none" : s.specifiers[0].type === "ImportNamespaceSpecifier" ? "all" : s.specifiers.length === 1 ? "single" : "multiple";
      }
      function m(s) {
        return u.indexOf(p(s));
      }
      function h(s) {
        return s.specifiers[0] ? s.specifiers[0].local.name : null;
      }
      function l(s, c) {
        return Math.max(c.loc.start.line - s.loc.end.line - 1, 0);
      }
      return {
        ImportDeclaration(s) {
          if (!f) {
            if (n && e && l(n, s) > 0 && (n = null), n) {
              const c = m(s), g = m(n);
              let d = h(s), y = h(n);
              o && (y = y && y.toLowerCase(), d = d && d.toLowerCase()), c !== g ? c < g && i.report({
                node: s,
                messageId: "unexpectedSyntaxOrder",
                data: {
                  syntaxA: u[c],
                  syntaxB: u[g]
                }
              }) : y && d && d < y && i.report({
                node: s,
                messageId: "sortImportsAlphabetically"
              });
            }
            n = s;
          }
          if (!r) {
            const c = s.specifiers.filter((y) => y.type === "ImportSpecifier"), g = o ? (y) => y.local.name.toLowerCase() : (y) => y.local.name, d = c.map(g).findIndex((y, v, T) => T[v - 1] > y);
            d !== -1 && i.report({
              node: c[d],
              messageId: "sortMembersAlphabetically",
              data: { memberName: c[d].local.name },
              fix(y) {
                return c.some((v) => a.getCommentsBefore(v).length || a.getCommentsAfter(v).length) ? null : y.replaceTextRange(
                  [c[0].range[0], c[c.length - 1].range[1]],
                  c.slice().sort((v, T) => {
                    const b = g(v), S = g(T);
                    return b > S ? 1 : -1;
                  }).reduce((v, T, b) => {
                    const S = b === c.length - 1 ? "" : a.getText().slice(c[b].range[1], c[b + 1].range[0]);
                    return v + a.getText(T) + S;
                  }, "")
                );
              }
            });
          }
        }
      };
    }
  }), Dc;
}
var Lc = { exports: {} }, O0;
function rL() {
  if (O0) return Lc.exports;
  O0 = 1;
  /*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   */
  var i = function(t, o) {
    var f, r, u = 1, e = 0, a = 0, n = String.alphabet;
    function p(m, h, l) {
      if (l) {
        for (f = h; l = p(m, f), l < 76 && l > 65; ) ++f;
        return +m.slice(h - 1, f);
      }
      return l = n && n.indexOf(m.charAt(h)), l > -1 ? l + 76 : (l = m.charCodeAt(h) || 0, l < 45 || l > 127 ? l : l < 46 ? 65 : l < 48 ? l - 1 : l < 58 ? l + 18 : l < 65 ? l - 11 : l < 91 ? l + 11 : l < 97 ? l - 37 : l < 123 ? l + 5 : l - 63);
    }
    if ((t += "") != (o += "")) {
      for (; u; )
        if (r = p(t, e++), u = p(o, a++), r < 76 && u < 76 && r > 66 && u > 66 && (r = p(t, e, e), u = p(o, a, e = f), a = f), r != u) return r < u ? -1 : 1;
    }
    return 0;
  };
  try {
    Lc.exports = i;
  } catch {
    String.naturalCompare = i;
  }
  return Lc.exports;
}
var _c, U0;
function nL() {
  if (U0) return _c;
  U0 = 1;
  const i = Re(), t = rL();
  function o(r) {
    const u = i.getStaticPropertyName(r);
    return u !== null ? u : r.key.name || null;
  }
  const f = {
    asc(r, u) {
      return r <= u;
    },
    ascI(r, u) {
      return r.toLowerCase() <= u.toLowerCase();
    },
    ascN(r, u) {
      return t(r, u) <= 0;
    },
    ascIN(r, u) {
      return t(r.toLowerCase(), u.toLowerCase()) <= 0;
    },
    desc(r, u) {
      return f.asc(u, r);
    },
    descI(r, u) {
      return f.ascI(u, r);
    },
    descN(r, u) {
      return f.ascN(u, r);
    },
    descIN(r, u) {
      return f.ascIN(u, r);
    }
  };
  return _c = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require object keys to be sorted",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/sort-keys"
      },
      schema: [
        {
          enum: ["asc", "desc"]
        },
        {
          type: "object",
          properties: {
            caseSensitive: {
              type: "boolean",
              default: !0
            },
            natural: {
              type: "boolean",
              default: !1
            },
            minKeys: {
              type: "integer",
              minimum: 2,
              default: 2
            },
            allowLineSeparatedGroups: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
      }
    },
    create(r) {
      const u = r.options[0] || "asc", e = r.options[1], a = e && e.caseSensitive === !1, n = e && e.natural, p = e && e.minKeys, m = e && e.allowLineSeparatedGroups || !1, h = f[u + (a ? "I" : "") + (n ? "N" : "")];
      let l = null;
      const s = r.sourceCode;
      return {
        ObjectExpression(c) {
          l = {
            upper: l,
            prevNode: null,
            prevBlankLine: !1,
            prevName: null,
            numKeys: c.properties.length
          };
        },
        "ObjectExpression:exit"() {
          l = l.upper;
        },
        SpreadElement(c) {
          c.parent.type === "ObjectExpression" && (l.prevName = null);
        },
        Property(c) {
          if (c.parent.type === "ObjectPattern")
            return;
          const g = l.prevName, d = l.numKeys, y = o(c), v = l.prevNode && s.getTokensBetween(l.prevNode, c, { includeComments: !0 });
          let T = l.prevBlankLine;
          if (v && (v.forEach((b, S) => {
            const C = v[S - 1];
            C && b.loc.start.line - C.loc.end.line > 1 && (T = !0);
          }), !T && c.loc.start.line - v[v.length - 1].loc.end.line > 1 && (T = !0), !T && v[0].loc.start.line - l.prevNode.loc.end.line > 1 && (T = !0)), l.prevNode = c, y !== null && (l.prevName = y), m && T) {
            l.prevBlankLine = y === null;
            return;
          }
          g === null || y === null || d < p || h(g, y) || r.report({
            node: c,
            loc: c.key.loc,
            messageId: "sortKeys",
            data: {
              thisName: y,
              prevName: g,
              order: u,
              insensitive: a ? "insensitive " : "",
              natural: n ? "natural " : ""
            }
          });
        }
      };
    }
  }, _c;
}
var wc, V0;
function sL() {
  return V0 || (V0 = 1, wc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require variables within the same declaration block to be sorted",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/sort-vars"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        sortVars: "Variables within the same declaration block should be sorted alphabetically."
      }
    },
    create(i) {
      const t = i.options[0] || {}, o = t.ignoreCase || !1, f = i.sourceCode;
      return {
        VariableDeclaration(r) {
          const u = r.declarations.filter((p) => p.id.type === "Identifier"), e = o ? (p) => p.id.name.toLowerCase() : (p) => p.id.name, a = u.some((p) => p.init !== null && p.init.type !== "Literal");
          let n = !1;
          u.slice(1).reduce((p, m) => {
            const h = e(p);
            return e(m) < h ? (i.report({
              node: m,
              messageId: "sortVars",
              fix(s) {
                return a || n ? null : s.replaceTextRange(
                  [u[0].range[0], u[u.length - 1].range[1]],
                  u.slice().sort((c, g) => {
                    const d = e(c), y = e(g);
                    return d > y ? 1 : -1;
                  }).reduce((c, g, d) => {
                    const y = d === u.length - 1 ? "" : f.getText().slice(u[d].range[1], u[d + 1].range[0]);
                    return c + f.getText(g) + y;
                  }, "")
                );
              }
            }), n = !0, p) : m;
          }, u[0]);
        }
      };
    }
  }), wc;
}
var kc, M0;
function iL() {
  if (M0) return kc;
  M0 = 1;
  const i = Re();
  function t(o) {
    const f = o.parent;
    return o.type === "BlockStatement" && i.isFunction(f) && f.body === o;
  }
  return kc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before blocks",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/space-before-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                keywords: {
                  enum: ["always", "never", "off"]
                },
                functions: {
                  enum: ["always", "never", "off"]
                },
                classes: {
                  enum: ["always", "never", "off"]
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before opening brace.",
        missingSpace: "Missing space before opening brace."
      }
    },
    create(o) {
      const f = o.options[0], r = o.sourceCode;
      let u = !0, e = !0, a = !0, n = !1, p = !1, m = !1;
      typeof f == "object" ? (u = f.functions === "always", e = f.keywords === "always", a = f.classes === "always", n = f.functions === "never", p = f.keywords === "never", m = f.classes === "never") : f === "never" && (u = !1, e = !1, a = !1, n = !0, p = !0, m = !0);
      function h(c, g) {
        return i.isArrowToken(c) || i.isKeywordToken(c) && !t(g) || i.isColonToken(c) && g.parent && g.parent.type === "SwitchCase" && c === i.getSwitchCaseColonToken(g.parent, r);
      }
      function l(c) {
        const g = r.getTokenBefore(c);
        if (g && !h(g, c) && i.isTokenOnSameLine(g, c)) {
          const d = r.isSpaceBetweenTokens(g, c);
          let y, v;
          t(c) ? (y = u, v = n) : c.type === "ClassBody" ? (y = a, v = m) : (y = e, v = p), y && !d ? o.report({
            node: c,
            messageId: "missingSpace",
            fix(T) {
              return T.insertTextBefore(c, " ");
            }
          }) : v && d && o.report({
            node: c,
            messageId: "unexpectedSpace",
            fix(T) {
              return T.removeRange([g.range[1], c.range[0]]);
            }
          });
        }
      }
      function s(c) {
        const g = c.cases;
        let d;
        g.length > 0 ? d = r.getTokenBefore(g[0]) : d = r.getLastToken(c, 1), l(d);
      }
      return {
        BlockStatement: l,
        ClassBody: l,
        SwitchStatement: s
      };
    }
  }, kc;
}
var Bc, K0;
function aL() {
  if (K0) return Bc;
  K0 = 1;
  const i = Re();
  return Bc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before `function` definition opening parenthesis",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/space-before-function-paren"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                anonymous: {
                  enum: ["always", "never", "ignore"]
                },
                named: {
                  enum: ["always", "never", "ignore"]
                },
                asyncArrow: {
                  enum: ["always", "never", "ignore"]
                }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before function parentheses.",
        missingSpace: "Missing space before function parentheses."
      }
    },
    create(t) {
      const o = t.sourceCode, f = typeof t.options[0] == "string" ? t.options[0] : "always", r = typeof t.options[0] == "object" ? t.options[0] : {};
      function u(n) {
        if (n.id)
          return !0;
        const p = n.parent;
        return p.type === "MethodDefinition" || p.type === "Property" && (p.kind === "get" || p.kind === "set" || p.method);
      }
      function e(n) {
        if (n.type === "ArrowFunctionExpression") {
          if (n.async && i.isOpeningParenToken(o.getFirstToken(n, { skip: 1 })))
            return r.asyncArrow || f;
        } else {
          if (u(n))
            return r.named || f;
          if (!n.generator)
            return r.anonymous || f;
        }
        return "ignore";
      }
      function a(n) {
        const p = e(n);
        if (p === "ignore")
          return;
        const m = o.getFirstToken(n, i.isOpeningParenToken), h = o.getTokenBefore(m), l = o.isSpaceBetweenTokens(h, m);
        l && p === "never" ? t.report({
          node: n,
          loc: {
            start: h.loc.end,
            end: m.loc.start
          },
          messageId: "unexpectedSpace",
          fix(s) {
            const c = o.getCommentsBefore(m);
            return c.some((g) => g.type === "Line") ? null : s.replaceTextRange(
              [h.range[1], m.range[0]],
              c.reduce((g, d) => g + o.getText(d), "")
            );
          }
        }) : !l && p === "always" && t.report({
          node: n,
          loc: m.loc,
          messageId: "missingSpace",
          fix: (s) => s.insertTextAfter(h, " ")
        });
      }
      return {
        ArrowFunctionExpression: a,
        FunctionDeclaration: a,
        FunctionExpression: a
      };
    }
  }, Bc;
}
var Pc, j0;
function oL() {
  if (j0) return Pc;
  j0 = 1;
  const i = Re();
  return Pc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside parentheses",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/space-in-parens"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: ["{}", "[]", "()", "empty"]
              },
              uniqueItems: !0
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        missingOpeningSpace: "There must be a space after this paren.",
        missingClosingSpace: "There must be a space before this paren.",
        rejectedOpeningSpace: "There should be no space after this paren.",
        rejectedClosingSpace: "There should be no space before this paren."
      }
    },
    create(t) {
      const o = t.options[0] === "always", f = t.options[1] && t.options[1].exceptions || [], r = {};
      let u;
      f.length && (r.braceException = f.includes("{}"), r.bracketException = f.includes("[]"), r.parenException = f.includes("()"), r.empty = f.includes("empty"));
      function e() {
        const c = [], g = [];
        return r.braceException && (c.push("{"), g.push("}")), r.bracketException && (c.push("["), g.push("]")), r.parenException && (c.push("("), g.push(")")), r.empty && (c.push(")"), g.push("(")), {
          openers: c,
          closers: g
        };
      }
      const a = t.sourceCode;
      function n(c) {
        return u.openers.includes(c.value);
      }
      function p(c) {
        return u.closers.includes(c.value);
      }
      function m(c, g) {
        return a.isSpaceBetweenTokens(c, g) || !r.empty && i.isClosingParenToken(g) ? !1 : o ? !n(g) : n(g);
      }
      function h(c, g) {
        return !i.isTokenOnSameLine(c, g) || g.type === "Line" || !a.isSpaceBetweenTokens(c, g) ? !1 : o ? n(g) : !n(g);
      }
      function l(c, g) {
        return a.isSpaceBetweenTokens(c, g) || !r.empty && i.isOpeningParenToken(c) ? !1 : o ? !p(c) : p(c);
      }
      function s(c, g) {
        return !i.isTokenOnSameLine(c, g) || !a.isSpaceBetweenTokens(c, g) ? !1 : o ? p(c) : !p(c);
      }
      return {
        Program: function(g) {
          u = e();
          const d = a.tokensAndComments;
          d.forEach((y, v) => {
            const T = d[v - 1], b = d[v + 1];
            !i.isOpeningParenToken(y) && !i.isClosingParenToken(y) || (y.value === "(" && m(y, b) && t.report({
              node: g,
              loc: y.loc,
              messageId: "missingOpeningSpace",
              fix(S) {
                return S.insertTextAfter(y, " ");
              }
            }), y.value === "(" && h(y, b) && t.report({
              node: g,
              loc: { start: y.loc.end, end: b.loc.start },
              messageId: "rejectedOpeningSpace",
              fix(S) {
                return S.removeRange([y.range[1], b.range[0]]);
              }
            }), y.value === ")" && l(T, y) && t.report({
              node: g,
              loc: y.loc,
              messageId: "missingClosingSpace",
              fix(S) {
                return S.insertTextBefore(y, " ");
              }
            }), y.value === ")" && s(T, y) && t.report({
              node: g,
              loc: { start: T.loc.end, end: y.loc.start },
              messageId: "rejectedClosingSpace",
              fix(S) {
                return S.removeRange([T.range[1], y.range[0]]);
              }
            }));
          });
        }
      };
    }
  }, Pc;
}
var Ic, q0;
function lL() {
  if (q0) return Ic;
  q0 = 1;
  const { isEqToken: i } = Re();
  return Ic = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require spacing around infix operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/space-infix-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            int32Hint: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        missingSpace: "Operator '{{operator}}' must be spaced."
      }
    },
    create(t) {
      const o = t.options[0] ? t.options[0].int32Hint === !0 : !1, f = t.sourceCode;
      function r(p, m, h) {
        const l = f.getFirstTokenBetween(p, m, (g) => g.value === h), s = f.getTokenBefore(l), c = f.getTokenAfter(l);
        return !f.isSpaceBetweenTokens(s, l) || !f.isSpaceBetweenTokens(l, c) ? l : null;
      }
      function u(p, m) {
        t.report({
          node: p,
          loc: m.loc,
          messageId: "missingSpace",
          data: {
            operator: m.value
          },
          fix(h) {
            const l = f.getTokenBefore(m), s = f.getTokenAfter(m);
            let c = "";
            return m.range[0] - l.range[1] === 0 && (c = " "), c += m.value, s.range[0] - m.range[1] === 0 && (c += " "), h.replaceText(m, c);
          }
        });
      }
      function e(p) {
        const m = p.left.typeAnnotation ? p.left.typeAnnotation : p.left, h = p.right, l = p.operator || "=", s = r(m, h, l);
        s && (o && f.getText(p).endsWith("|0") || u(p, s));
      }
      function a(p) {
        const m = r(p.test, p.consequent, "?"), h = r(p.consequent, p.alternate, ":");
        m && u(p, m), h && u(p, h);
      }
      function n(p) {
        const m = p.id.typeAnnotation ? p.id.typeAnnotation : p.id, h = p.init;
        if (h) {
          const l = r(m, h, "=");
          l && u(p, l);
        }
      }
      return {
        AssignmentExpression: e,
        AssignmentPattern: e,
        BinaryExpression: e,
        LogicalExpression: e,
        ConditionalExpression: a,
        VariableDeclarator: n,
        PropertyDefinition(p) {
          if (!p.value)
            return;
          const m = f.getTokenBefore(p.value, i), h = f.getTokenBefore(m), l = f.getTokenAfter(m);
          (!f.isSpaceBetweenTokens(h, m) || !f.isSpaceBetweenTokens(m, l)) && u(p, m);
        }
      };
    }
  }, Ic;
}
var Fc, $0;
function uL() {
  if ($0) return Fc;
  $0 = 1;
  const i = Re();
  return Fc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before or after unary operators",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/space-unary-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            words: {
              type: "boolean",
              default: !0
            },
            nonwords: {
              type: "boolean",
              default: !1
            },
            overrides: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
        unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
        unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
        wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
        operator: "Unary operator '{{operator}}' must be followed by whitespace.",
        beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
      }
    },
    create(t) {
      const o = t.options[0] || { words: !0, nonwords: !1 }, f = t.sourceCode;
      function r(g) {
        return g && g.type === "UnaryExpression" && g.argument.operator === "!" && g.argument && g.argument.type === "UnaryExpression" && g.argument.operator === "!";
      }
      function u(g) {
        return o.overrides && Object.prototype.hasOwnProperty.call(o.overrides, g);
      }
      function e(g) {
        return o.overrides[g];
      }
      function a(g, d, y, v) {
        y.range[0] === d.range[1] && t.report({
          node: g,
          messageId: "wordOperator",
          data: {
            word: v
          },
          fix(T) {
            return T.insertTextAfter(d, " ");
          }
        });
      }
      function n(g, d, y, v) {
        i.canTokensBeAdjacent(d, y) && y.range[0] > d.range[1] && t.report({
          node: g,
          messageId: "unexpectedAfterWord",
          data: {
            word: v
          },
          fix(T) {
            return T.removeRange([d.range[1], y.range[0]]);
          }
        });
      }
      function p(g, d, y, v) {
        u(v) ? e(v) ? a(g, d, y, v) : n(g, d, y, v) : o.words ? a(g, d, y, v) : n(g, d, y, v);
      }
      function m(g) {
        const d = f.getFirstTokens(g, 3), y = "yield";
        !g.argument || g.delegate || p(g, d[0], d[1], y);
      }
      function h(g) {
        const d = f.getFirstTokens(g, 3);
        p(g, d[0], d[1], "await");
      }
      function l(g, d, y) {
        if (g.prefix) {
          if (r(g))
            return;
          d.range[1] === y.range[0] && t.report({
            node: g,
            messageId: "operator",
            data: {
              operator: d.value
            },
            fix(v) {
              return v.insertTextAfter(d, " ");
            }
          });
        } else
          d.range[1] === y.range[0] && t.report({
            node: g,
            messageId: "beforeUnaryExpressions",
            data: {
              token: y.value
            },
            fix(v) {
              return v.insertTextBefore(y, " ");
            }
          });
      }
      function s(g, d, y) {
        g.prefix ? y.range[0] > d.range[1] && t.report({
          node: g,
          messageId: "unexpectedAfter",
          data: {
            operator: d.value
          },
          fix(v) {
            return i.canTokensBeAdjacent(d, y) ? v.removeRange([d.range[1], y.range[0]]) : null;
          }
        }) : y.range[0] > d.range[1] && t.report({
          node: g,
          messageId: "unexpectedBefore",
          data: {
            operator: y.value
          },
          fix(v) {
            return v.removeRange([d.range[1], y.range[0]]);
          }
        });
      }
      function c(g) {
        const d = g.type === "UpdateExpression" && !g.prefix ? f.getLastTokens(g, 2) : f.getFirstTokens(g, 2), y = d[0], v = d[1];
        if ((g.type === "NewExpression" || g.prefix) && y.type === "Keyword") {
          p(g, y, v, y.value);
          return;
        }
        const T = g.prefix ? d[0].value : d[1].value;
        u(T) ? e(T) ? l(g, y, v) : s(g, y, v) : o.nonwords ? l(g, y, v) : s(g, y, v);
      }
      return {
        UnaryExpression: c,
        UpdateExpression: c,
        NewExpression: c,
        YieldExpression: m,
        AwaitExpression: h
      };
    }
  }, Fc;
}
var Nc, G0;
function cL() {
  if (G0) return Nc;
  G0 = 1;
  const i = dn(), t = Re();
  function o(n) {
    return `(?:${i(n)})`;
  }
  function f(n) {
    return `${o(n)}+`;
  }
  function r(n) {
    return n.includes("*") ? n : n.concat("*");
  }
  function u(n) {
    let p = "";
    return n.length === 0 ? p += "\\s" : (p += "(?:\\s|", n.length === 1 ? p += f(n[0]) : (p += "(?:", p += n.map(f).join("|"), p += ")"), p += `(?:$|[${Array.from(t.LINEBREAKS).join("")}]))`), p;
  }
  function e(n, p) {
    let m = "^";
    return n.length === 1 ? m += o(n[0]) : (m += "(?:", m += n.map(o).join("|"), m += ")"), m += "?", m += u(p), new RegExp(m, "u");
  }
  function a(n) {
    const p = `^(${n.map(o).join("|")})?[ 	]+`;
    return new RegExp(p, "u");
  }
  return Nc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "Enforce consistent spacing after the `//` or `/*` in a comment",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/spaced-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            line: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              },
              additionalProperties: !1
            },
            block: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                balanced: {
                  type: "boolean",
                  default: !1
                }
              },
              additionalProperties: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
        expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
        unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
        unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
        expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
        expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
      }
    },
    create(n) {
      const p = n.sourceCode, m = n.options[0] !== "never", h = n.options[1] || {}, l = h.block && h.block.balanced, s = ["block", "line"].reduce((y, v) => {
        const T = r(h[v] && h[v].markers || h.markers || []), b = h[v] && h[v].exceptions || h.exceptions || [], S = "[ 	]+$";
        return y[v] = {
          beginRegex: m ? e(T, b) : a(T),
          endRegex: l && m ? new RegExp(`${u(b)}$`, "u") : new RegExp(S, "u"),
          hasExceptions: b.length > 0,
          captureMarker: new RegExp(`^(${T.map(o).join("|")})`, "u"),
          markers: new Set(T)
        }, y;
      }, {});
      function c(y, v, T, b) {
        const S = y.type.toLowerCase(), C = S === "block" ? "/*" : "//";
        n.report({
          node: y,
          fix(x) {
            const A = y.range[0];
            let R = A + 2;
            return m ? (T && (R += T[0].length), x.insertTextAfterRange([A, R], " ")) : (R += T[0].length, x.replaceTextRange([A, R], C + (T[1] ? T[1] : "")));
          },
          messageId: v,
          data: { refChar: b }
        });
      }
      function g(y, v, T) {
        n.report({
          node: y,
          fix(b) {
            if (m)
              return b.insertTextAfterRange([y.range[0], y.range[1] - 2], " ");
            const S = y.range[1] - 2, C = S - T[0].length;
            return b.replaceTextRange([C, S], "");
          },
          messageId: v
        });
      }
      function d(y) {
        const v = y.type.toLowerCase(), T = s[v], b = v === "block" ? "/*" : "//";
        if (y.value.length === 0 || T.markers.has(y.value))
          return;
        const S = T.beginRegex.exec(y.value), C = T.endRegex.exec(y.value);
        if (m) {
          if (!S) {
            const x = T.captureMarker.exec(y.value), A = x ? b + x[0] : b;
            T.hasExceptions ? c(y, "expectedExceptionAfter", x, A) : c(y, "expectedSpaceAfter", x, A);
          }
          l && v === "block" && !C && g(y, "expectedSpaceBefore");
        } else
          S && (S[1] ? c(y, "unexpectedSpaceAfterMarker", S, S[1]) : c(y, "unexpectedSpaceAfter", S, b)), l && v === "block" && C && g(y, "unexpectedSpaceBefore", C);
      }
      return {
        Program() {
          p.getAllComments().filter((v) => v.type !== "Shebang").forEach(d);
        }
      };
    }
  }, Nc;
}
var Oc, W0;
function fL() {
  if (W0) return Oc;
  W0 = 1;
  const i = Re();
  function t(r) {
    const u = [];
    for (let e = 0; e < r.length; e++) {
      const a = r[e];
      if (a.type === "ExpressionStatement" && a.expression.type === "Literal" && a.expression.value === "use strict")
        u[e] = a;
      else
        break;
    }
    return u;
  }
  function o(r) {
    return r.type === "Identifier";
  }
  function f(r) {
    return r.every(o);
  }
  return Oc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow strict mode directives",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/strict"
      },
      schema: [
        {
          enum: ["never", "global", "function", "safe"]
        }
      ],
      fixable: "code",
      messages: {
        function: "Use the function form of 'use strict'.",
        global: "Use the global form of 'use strict'.",
        multiple: "Multiple 'use strict' directives.",
        never: "Strict mode is not permitted.",
        unnecessary: "Unnecessary 'use strict' directive.",
        module: "'use strict' is unnecessary inside of modules.",
        implied: "'use strict' is unnecessary when implied strict mode is enabled.",
        unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
        nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
        wrap: "Wrap {{name}} in a function with 'use strict' directive."
      }
    },
    create(r) {
      const u = r.parserOptions.ecmaFeatures || {}, e = [], a = [];
      let n = r.options[0] || "safe";
      u.impliedStrict ? n = "implied" : n === "safe" && (n = u.globalReturn || r.languageOptions.sourceType === "commonjs" ? "global" : "function");
      function p(v) {
        return v === "multiple" || v === "unnecessary" || v === "module" || v === "implied" || v === "unnecessaryInClasses";
      }
      function m(v) {
        return (T) => T.remove(v);
      }
      function h(v, T, b, S, C) {
        v.slice(T, b).forEach((x) => {
          r.report({ node: x, messageId: S, fix: C ? m(x) : null });
        });
      }
      function l(v, T, b) {
        h(v, 0, v.length, T, b);
      }
      function s(v, T, b) {
        h(v, 1, v.length, T, b);
      }
      function c(v, T) {
        const b = a.length > 0, S = e.length === 0 && a.length === 0, C = e.length > 0 && e[e.length - 1], x = T.length > 0;
        x ? (f(v.params) ? C ? r.report({ node: T[0], messageId: "unnecessary", fix: m(T[0]) }) : b && r.report({ node: T[0], messageId: "unnecessaryInClasses", fix: m(T[0]) }) : r.report({ node: T[0], messageId: "nonSimpleParameterList" }), s(T, "multiple", !0)) : S && (f(v.params) ? r.report({ node: v, messageId: "function" }) : r.report({
          node: v,
          messageId: "wrap",
          data: { name: i.getFunctionNameWithKind(v) }
        })), e.push(C || x);
      }
      function g() {
        e.pop();
      }
      function d(v) {
        const T = v.body.type === "BlockStatement", b = T ? t(v.body.body) : [];
        n === "function" ? c(v, b) : b.length > 0 && (f(v.params) ? l(b, n, p(n)) : (r.report({ node: b[0], messageId: "nonSimpleParameterList" }), s(b, "multiple", !0)));
      }
      const y = {
        Program(v) {
          const T = t(v.body);
          v.sourceType === "module" && (n = "module"), n === "global" ? (v.body.length > 0 && T.length === 0 && r.report({ node: v, messageId: "global" }), s(T, "multiple", !0)) : l(T, n, p(n));
        },
        FunctionDeclaration: d,
        FunctionExpression: d,
        ArrowFunctionExpression: d
      };
      return n === "function" && Object.assign(y, {
        // Inside of class bodies are always strict mode.
        ClassBody() {
          a.push(!0);
        },
        "ClassBody:exit"() {
          a.pop();
        },
        "FunctionDeclaration:exit": g,
        "FunctionExpression:exit": g,
        "ArrowFunctionExpression:exit": g
      }), y;
    }
  }, Oc;
}
var Uc, X0;
function pL() {
  if (X0) return Uc;
  X0 = 1;
  const i = Re();
  return Uc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Enforce spacing around colons of switch statements",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/switch-colon-spacing"
      },
      schema: [
        {
          type: "object",
          properties: {
            before: { type: "boolean", default: !1 },
            after: { type: "boolean", default: !0 }
          },
          additionalProperties: !1
        }
      ],
      fixable: "whitespace",
      messages: {
        expectedBefore: "Expected space(s) before this colon.",
        expectedAfter: "Expected space(s) after this colon.",
        unexpectedBefore: "Unexpected space(s) before this colon.",
        unexpectedAfter: "Unexpected space(s) after this colon."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] || {}, r = f.before === !0, u = f.after !== !1;
      function e(p, m, h) {
        return i.isClosingBraceToken(m) || !i.isTokenOnSameLine(p, m) || o.isSpaceBetweenTokens(p, m) === h;
      }
      function a(p, m) {
        return o.getFirstTokenBetween(
          p,
          m,
          {
            includeComments: !0,
            filter: i.isCommentToken
          }
        ) !== null;
      }
      function n(p, m, h, l) {
        return a(m, h) ? null : l ? p.insertTextAfter(m, " ") : p.removeRange([m.range[1], h.range[0]]);
      }
      return {
        SwitchCase(p) {
          const m = i.getSwitchCaseColonToken(p, o), h = o.getTokenBefore(m), l = o.getTokenAfter(m);
          e(h, m, r) || t.report({
            node: p,
            loc: m.loc,
            messageId: r ? "expectedBefore" : "unexpectedBefore",
            fix: (s) => n(s, h, m, r)
          }), e(m, l, u) || t.report({
            node: p,
            loc: m.loc,
            messageId: u ? "expectedAfter" : "unexpectedAfter",
            fix: (s) => n(s, m, l, u)
          });
        }
      };
    }
  }, Uc;
}
var Vc, z0;
function hL() {
  if (z0) return Vc;
  z0 = 1;
  const i = Re();
  return Vc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require symbol descriptions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/symbol-description"
      },
      fixable: null,
      schema: [],
      messages: {
        expected: "Expected Symbol to have a description."
      }
    },
    create(t) {
      const o = t.sourceCode;
      function f(r) {
        r.arguments.length === 0 && t.report({
          node: r,
          messageId: "expected"
        });
      }
      return {
        "Program:exit"(r) {
          const u = o.getScope(r), e = i.getVariableByName(u, "Symbol");
          e && e.defs.length === 0 && e.references.forEach((a) => {
            const n = a.identifier;
            i.isCallee(n) && f(n.parent);
          });
        }
      };
    }
  }, Vc;
}
var Mc, H0;
function mL() {
  if (H0) return Mc;
  H0 = 1;
  const i = Re();
  return Mc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow spacing around embedded expressions of template strings",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/template-curly-spacing"
      },
      fixable: "whitespace",
      schema: [
        { enum: ["always", "never"] }
      ],
      messages: {
        expectedBefore: "Expected space(s) before '}'.",
        expectedAfter: "Expected space(s) after '${'.",
        unexpectedBefore: "Unexpected space(s) before '}'.",
        unexpectedAfter: "Unexpected space(s) after '${'."
      }
    },
    create(t) {
      const o = t.sourceCode, f = t.options[0] === "always";
      function r(e) {
        if (!e.value.startsWith("}"))
          return;
        const a = o.getTokenBefore(e, { includeComments: !0 }), n = o.isSpaceBetween(a, e);
        i.isTokenOnSameLine(a, e) && (f && !n && t.report({
          loc: {
            start: e.loc.start,
            end: {
              line: e.loc.start.line,
              column: e.loc.start.column + 1
            }
          },
          messageId: "expectedBefore",
          fix: (p) => p.insertTextBefore(e, " ")
        }), !f && n && t.report({
          loc: {
            start: a.loc.end,
            end: e.loc.start
          },
          messageId: "unexpectedBefore",
          fix: (p) => p.removeRange([a.range[1], e.range[0]])
        }));
      }
      function u(e) {
        if (!e.value.endsWith("${"))
          return;
        const a = o.getTokenAfter(e, { includeComments: !0 }), n = o.isSpaceBetween(e, a);
        i.isTokenOnSameLine(e, a) && (f && !n && t.report({
          loc: {
            start: {
              line: e.loc.end.line,
              column: e.loc.end.column - 2
            },
            end: e.loc.end
          },
          messageId: "expectedAfter",
          fix: (p) => p.insertTextAfter(e, " ")
        }), !f && n && t.report({
          loc: {
            start: e.loc.end,
            end: a.loc.start
          },
          messageId: "unexpectedAfter",
          fix: (p) => p.removeRange([e.range[1], a.range[0]])
        }));
      }
      return {
        TemplateElement(e) {
          const a = o.getFirstToken(e);
          r(a), u(a);
        }
      };
    }
  }, Mc;
}
var Kc, J0;
function gL() {
  return J0 || (J0 = 1, Kc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow spacing between template tags and their literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/template-tag-spacing"
      },
      fixable: "whitespace",
      schema: [
        { enum: ["always", "never"] }
      ],
      messages: {
        unexpected: "Unexpected space between template tag and template literal.",
        missing: "Missing space between template tag and template literal."
      }
    },
    create(i) {
      const t = i.options[0] !== "always", o = i.sourceCode;
      function f(r) {
        const u = o.getTokenBefore(r.quasi), e = o.getFirstToken(r.quasi), a = o.isSpaceBetweenTokens(u, e);
        t && a ? i.report({
          node: r,
          loc: {
            start: u.loc.end,
            end: e.loc.start
          },
          messageId: "unexpected",
          fix(n) {
            const p = o.getCommentsBefore(r.quasi);
            return p.some((m) => m.type === "Line") ? null : n.replaceTextRange(
              [u.range[1], e.range[0]],
              p.reduce((m, h) => m + o.getText(h), "")
            );
          }
        }) : !t && !a && i.report({
          node: r,
          loc: {
            start: r.loc.start,
            end: e.loc.start
          },
          messageId: "missing",
          fix(n) {
            return n.insertTextAfter(u, " ");
          }
        });
      }
      return {
        TaggedTemplateExpression: f
      };
    }
  }), Kc;
}
var jc, Q0;
function dL() {
  return Q0 || (Q0 = 1, jc = {
    meta: {
      type: "layout",
      docs: {
        description: "Require or disallow Unicode byte order mark (BOM)",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/unicode-bom"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        expected: "Expected Unicode BOM (Byte Order Mark).",
        unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
      }
    },
    create(i) {
      return {
        Program: function(o) {
          const f = i.sourceCode, r = { column: 0, line: 1 }, u = i.options[0] || "never";
          !f.hasBOM && u === "always" ? i.report({
            node: o,
            loc: r,
            messageId: "expected",
            fix(e) {
              return e.insertTextBeforeRange([0, 1], "\uFEFF");
            }
          }) : f.hasBOM && u === "never" && i.report({
            node: o,
            loc: r,
            messageId: "unexpected",
            fix(e) {
              return e.removeRange([-1, 0]);
            }
          });
        }
      };
    }
  }), jc;
}
var qc, Y0;
function EL() {
  if (Y0) return qc;
  Y0 = 1;
  const i = Re();
  function t(o) {
    return !!o && (i.isSpecificId(o, "NaN") || i.isSpecificMemberAccess(o, "Number", "NaN"));
  }
  return qc = {
    meta: {
      type: "problem",
      docs: {
        description: "Require calls to `isNaN()` when checking for `NaN`",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/use-isnan"
      },
      schema: [
        {
          type: "object",
          properties: {
            enforceForSwitchCase: {
              type: "boolean",
              default: !0
            },
            enforceForIndexOf: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        comparisonWithNaN: "Use the isNaN function to compare with NaN.",
        switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
        caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
        indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN."
      }
    },
    create(o) {
      const f = !o.options[0] || o.options[0].enforceForSwitchCase, r = o.options[0] && o.options[0].enforceForIndexOf;
      function u(p) {
        /^(?:[<>]|[!=]=)=?$/u.test(p.operator) && (t(p.left) || t(p.right)) && o.report({ node: p, messageId: "comparisonWithNaN" });
      }
      function e(p) {
        t(p.discriminant) && o.report({ node: p, messageId: "switchNaN" });
        for (const m of p.cases)
          t(m.test) && o.report({ node: m, messageId: "caseNaN" });
      }
      function a(p) {
        const m = i.skipChainExpression(p.callee);
        if (m.type === "MemberExpression") {
          const h = i.getStaticPropertyName(m);
          (h === "indexOf" || h === "lastIndexOf") && p.arguments.length === 1 && t(p.arguments[0]) && o.report({ node: p, messageId: "indexOfNaN", data: { methodName: h } });
        }
      }
      const n = {
        BinaryExpression: u
      };
      return f && (n.SwitchStatement = e), r && (n.CallExpression = a), n;
    }
  }, qc;
}
var $c = {}, br = {}, xr = {}, yL = "3.0.0", CL = {
  version: yL
}, Z0;
function _v() {
  return Z0 || (Z0 = 1, function() {
    var i;
    i = CL.version, xr.VERSION = i;
    function t(f) {
      this.name = "DoctrineError", this.message = f;
    }
    t.prototype = function() {
      var f = function() {
      };
      return f.prototype = Error.prototype, new f();
    }(), t.prototype.constructor = t, xr.DoctrineError = t;
    function o(f) {
      throw new t(f);
    }
    xr.throwError = o, xr.assert = It;
  }()), xr;
}
var eC;
function vL() {
  return eC || (eC = 1, function() {
    var i, t, o, f, r, u, e, a, n, p, m, h;
    n = En(), p = _v(), i = {
      NullableLiteral: "NullableLiteral",
      AllLiteral: "AllLiteral",
      NullLiteral: "NullLiteral",
      UndefinedLiteral: "UndefinedLiteral",
      VoidLiteral: "VoidLiteral",
      UnionType: "UnionType",
      ArrayType: "ArrayType",
      RecordType: "RecordType",
      FieldType: "FieldType",
      FunctionType: "FunctionType",
      ParameterType: "ParameterType",
      RestType: "RestType",
      NonNullableType: "NonNullableType",
      OptionalType: "OptionalType",
      NullableType: "NullableType",
      NameExpression: "NameExpression",
      TypeApplication: "TypeApplication",
      StringLiteralType: "StringLiteralType",
      NumericLiteralType: "NumericLiteralType",
      BooleanLiteralType: "BooleanLiteralType"
    }, t = {
      ILLEGAL: 0,
      // ILLEGAL
      DOT_LT: 1,
      // .<
      REST: 2,
      // ...
      LT: 3,
      // <
      GT: 4,
      // >
      LPAREN: 5,
      // (
      RPAREN: 6,
      // )
      LBRACE: 7,
      // {
      RBRACE: 8,
      // }
      LBRACK: 9,
      // [
      RBRACK: 10,
      // ]
      COMMA: 11,
      // ,
      COLON: 12,
      // :
      STAR: 13,
      // *
      PIPE: 14,
      // |
      QUESTION: 15,
      // ?
      BANG: 16,
      // !
      EQUAL: 17,
      // =
      NAME: 18,
      // name token
      STRING: 19,
      // string
      NUMBER: 20,
      // number
      EOF: 21
    };
    function l(j) {
      return "><(){}[],:*|?!=".indexOf(String.fromCharCode(j)) === -1 && !n.code.isWhiteSpace(j) && !n.code.isLineTerminator(j);
    }
    function s(j, H, N, G) {
      this._previous = j, this._index = H, this._token = N, this._value = G;
    }
    s.prototype.restore = function() {
      u = this._previous, r = this._index, e = this._token, a = this._value;
    }, s.save = function() {
      return new s(u, r, e, a);
    };
    function c(j, H) {
      return h && (j.range = [H[0] + m, H[1] + m]), j;
    }
    function g() {
      var j = o.charAt(r);
      return r += 1, j;
    }
    function d(j) {
      var H, N, G, M = 0;
      for (N = j === "u" ? 4 : 2, H = 0; H < N; ++H)
        if (r < f && n.code.isHexDigit(o.charCodeAt(r)))
          G = g(), M = M * 16 + "0123456789abcdef".indexOf(G.toLowerCase());
        else
          return "";
      return String.fromCharCode(M);
    }
    function y() {
      var j = "", H, N, G, M, Z;
      for (H = o.charAt(r), ++r; r < f; )
        if (N = g(), N === H) {
          H = "";
          break;
        } else if (N === "\\")
          if (N = g(), n.code.isLineTerminator(N.charCodeAt(0)))
            N === "\r" && o.charCodeAt(r) === 10 && ++r;
          else
            switch (N) {
              case "n":
                j += `
`;
                break;
              case "r":
                j += "\r";
                break;
              case "t":
                j += "	";
                break;
              case "u":
              case "x":
                Z = r, M = d(N), M ? j += M : (r = Z, j += N);
                break;
              case "b":
                j += "\b";
                break;
              case "f":
                j += "\f";
                break;
              case "v":
                j += "\v";
                break;
              default:
                n.code.isOctalDigit(N.charCodeAt(0)) ? (G = "01234567".indexOf(N), r < f && n.code.isOctalDigit(o.charCodeAt(r)) && (G = G * 8 + "01234567".indexOf(g()), "0123".indexOf(N) >= 0 && r < f && n.code.isOctalDigit(o.charCodeAt(r)) && (G = G * 8 + "01234567".indexOf(g()))), j += String.fromCharCode(G)) : j += N;
                break;
            }
        else {
          if (n.code.isLineTerminator(N.charCodeAt(0)))
            break;
          j += N;
        }
      return H !== "" && p.throwError("unexpected quote"), a = j, t.STRING;
    }
    function v() {
      var j, H;
      if (j = "", H = o.charCodeAt(r), H !== 46) {
        if (j = g(), H = o.charCodeAt(r), j === "0") {
          if (H === 120 || H === 88) {
            for (j += g(); r < f && (H = o.charCodeAt(r), !!n.code.isHexDigit(H)); )
              j += g();
            return j.length <= 2 && p.throwError("unexpected token"), r < f && (H = o.charCodeAt(r), n.code.isIdentifierStartES5(H) && p.throwError("unexpected token")), a = parseInt(j, 16), t.NUMBER;
          }
          if (n.code.isOctalDigit(H)) {
            for (j += g(); r < f && (H = o.charCodeAt(r), !!n.code.isOctalDigit(H)); )
              j += g();
            return r < f && (H = o.charCodeAt(r), (n.code.isIdentifierStartES5(H) || n.code.isDecimalDigit(H)) && p.throwError("unexpected token")), a = parseInt(j, 8), t.NUMBER;
          }
          n.code.isDecimalDigit(H) && p.throwError("unexpected token");
        }
        for (; r < f && (H = o.charCodeAt(r), !!n.code.isDecimalDigit(H)); )
          j += g();
      }
      if (H === 46)
        for (j += g(); r < f && (H = o.charCodeAt(r), !!n.code.isDecimalDigit(H)); )
          j += g();
      if (H === 101 || H === 69)
        if (j += g(), H = o.charCodeAt(r), (H === 43 || H === 45) && (j += g()), H = o.charCodeAt(r), n.code.isDecimalDigit(H))
          for (j += g(); r < f && (H = o.charCodeAt(r), !!n.code.isDecimalDigit(H)); )
            j += g();
        else
          p.throwError("unexpected token");
      return r < f && (H = o.charCodeAt(r), n.code.isIdentifierStartES5(H) && p.throwError("unexpected token")), a = parseFloat(j), t.NUMBER;
    }
    function T() {
      var j, H;
      for (a = g(); r < f && l(o.charCodeAt(r)); ) {
        if (j = o.charCodeAt(r), j === 46) {
          if (r + 1 >= f)
            return t.ILLEGAL;
          if (H = o.charCodeAt(r + 1), H === 60)
            break;
        }
        a += g();
      }
      return t.NAME;
    }
    function b() {
      var j;
      for (u = r; r < f && n.code.isWhiteSpace(o.charCodeAt(r)); )
        g();
      if (r >= f)
        return e = t.EOF, e;
      switch (j = o.charCodeAt(r), j) {
        case 39:
        case 34:
          return e = y(), e;
        case 58:
          return g(), e = t.COLON, e;
        case 44:
          return g(), e = t.COMMA, e;
        case 40:
          return g(), e = t.LPAREN, e;
        case 41:
          return g(), e = t.RPAREN, e;
        case 91:
          return g(), e = t.LBRACK, e;
        case 93:
          return g(), e = t.RBRACK, e;
        case 123:
          return g(), e = t.LBRACE, e;
        case 125:
          return g(), e = t.RBRACE, e;
        case 46:
          if (r + 1 < f) {
            if (j = o.charCodeAt(r + 1), j === 60)
              return g(), g(), e = t.DOT_LT, e;
            if (j === 46 && r + 2 < f && o.charCodeAt(r + 2) === 46)
              return g(), g(), g(), e = t.REST, e;
            if (n.code.isDecimalDigit(j))
              return e = v(), e;
          }
          return e = t.ILLEGAL, e;
        case 60:
          return g(), e = t.LT, e;
        case 62:
          return g(), e = t.GT, e;
        case 42:
          return g(), e = t.STAR, e;
        case 124:
          return g(), e = t.PIPE, e;
        case 63:
          return g(), e = t.QUESTION, e;
        case 33:
          return g(), e = t.BANG, e;
        case 61:
          return g(), e = t.EQUAL, e;
        case 45:
          return e = v(), e;
        default:
          return n.code.isDecimalDigit(j) ? (e = v(), e) : (p.assert(l(j)), e = T(), e);
      }
    }
    function S(j, H) {
      p.assert(e === j, H || "consumed token not matched"), b();
    }
    function C(j, H) {
      e !== j && p.throwError(H || "unexpected token"), b();
    }
    function x() {
      var j, H = r - 1;
      if (S(t.LPAREN, "UnionType should start with ("), j = [], e !== t.RPAREN)
        for (; j.push($()), e !== t.RPAREN; )
          C(t.PIPE);
      return S(t.RPAREN, "UnionType should end with )"), c({
        type: i.UnionType,
        elements: j
      }, [H, u]);
    }
    function A() {
      var j, H = r - 1, N;
      for (S(t.LBRACK, "ArrayType should start with ["), j = []; e !== t.RBRACK; ) {
        if (e === t.REST) {
          N = r - 3, S(t.REST), j.push(c({
            type: i.RestType,
            expression: $()
          }, [N, u]));
          break;
        } else
          j.push($());
        e !== t.RBRACK && C(t.COMMA);
      }
      return C(t.RBRACK), c({
        type: i.ArrayType,
        elements: j
      }, [H, u]);
    }
    function R() {
      var j = a;
      if (e === t.NAME || e === t.STRING)
        return b(), j;
      if (e === t.NUMBER)
        return S(t.NUMBER), String(j);
      p.throwError("unexpected token");
    }
    function L() {
      var j, H = u;
      return j = R(), e === t.COLON ? (S(t.COLON), c({
        type: i.FieldType,
        key: j,
        value: $()
      }, [H, u])) : c({
        type: i.FieldType,
        key: j,
        value: null
      }, [H, u]);
    }
    function _() {
      var j, H = r - 1, N;
      if (S(t.LBRACE, "RecordType should start with {"), j = [], e === t.COMMA)
        S(t.COMMA);
      else
        for (; e !== t.RBRACE; )
          j.push(L()), e !== t.RBRACE && C(t.COMMA);
      return N = r, C(t.RBRACE), c({
        type: i.RecordType,
        fields: j
      }, [H, N]);
    }
    function I() {
      var j = a, H = r - j.length;
      return C(t.NAME), e === t.COLON && (j === "module" || j === "external" || j === "event") && (S(t.COLON), j += ":" + a, C(t.NAME)), c({
        type: i.NameExpression,
        name: j
      }, [H, u]);
    }
    function O() {
      var j = [];
      for (j.push(P()); e === t.COMMA; )
        S(t.COMMA), j.push(P());
      return j;
    }
    function k() {
      var j, H, N = r - a.length;
      return j = I(), e === t.DOT_LT || e === t.LT ? (b(), H = O(), C(t.GT), c({
        type: i.TypeApplication,
        expression: j,
        applications: H
      }, [N, u])) : j;
    }
    function w() {
      return S(t.COLON, "ResultType should start with :"), e === t.NAME && a === "void" ? (S(t.NAME), {
        type: i.VoidLiteral
      }) : $();
    }
    function U() {
      for (var j = [], H = !1, N, G = !1, M, Z = r - 3, Ee; e !== t.RPAREN; )
        e === t.REST && (S(t.REST), G = !0), M = u, N = $(), N.type === i.NameExpression && e === t.COLON && (Ee = u - N.name.length, S(t.COLON), N = c({
          type: i.ParameterType,
          name: N.name,
          expression: $()
        }, [Ee, u])), e === t.EQUAL ? (S(t.EQUAL), N = c({
          type: i.OptionalType,
          expression: N
        }, [M, u]), H = !0) : H && p.throwError("unexpected token"), G && (N = c({
          type: i.RestType,
          expression: N
        }, [Z, u])), j.push(N), e !== t.RPAREN && C(t.COMMA);
      return j;
    }
    function q() {
      var j, H, N, G, M, Z = r - a.length;
      return p.assert(e === t.NAME && a === "function", "FunctionType should start with 'function'"), S(t.NAME), C(t.LPAREN), j = !1, N = [], H = null, e !== t.RPAREN && (e === t.NAME && (a === "this" || a === "new") ? (j = a === "new", S(t.NAME), C(t.COLON), H = k(), e === t.COMMA && (S(t.COMMA), N = U())) : N = U()), C(t.RPAREN), G = null, e === t.COLON && (G = w()), M = c({
        type: i.FunctionType,
        params: N,
        result: G
      }, [Z, u]), H && (M.this = H, j && (M.new = !0)), M;
    }
    function F() {
      var j, H;
      switch (e) {
        case t.STAR:
          return S(t.STAR), c({
            type: i.AllLiteral
          }, [u - 1, u]);
        case t.LPAREN:
          return x();
        case t.LBRACK:
          return A();
        case t.LBRACE:
          return _();
        case t.NAME:
          if (H = r - a.length, a === "null")
            return S(t.NAME), c({
              type: i.NullLiteral
            }, [H, u]);
          if (a === "undefined")
            return S(t.NAME), c({
              type: i.UndefinedLiteral
            }, [H, u]);
          if (a === "true" || a === "false")
            return S(t.NAME), c({
              type: i.BooleanLiteralType,
              value: a === "true"
            }, [H, u]);
          if (j = s.save(), a === "function")
            try {
              return q();
            } catch {
              j.restore();
            }
          return k();
        case t.STRING:
          return b(), c({
            type: i.StringLiteralType,
            value: a
          }, [u - a.length - 2, u]);
        case t.NUMBER:
          return b(), c({
            type: i.NumericLiteralType,
            value: a
          }, [u - String(a).length, u]);
        default:
          p.throwError("unexpected token");
      }
    }
    function $() {
      var j, H;
      return e === t.QUESTION ? (H = r - 1, S(t.QUESTION), e === t.COMMA || e === t.EQUAL || e === t.RBRACE || e === t.RPAREN || e === t.PIPE || e === t.EOF || e === t.RBRACK || e === t.GT ? c({
        type: i.NullableLiteral
      }, [H, u]) : c({
        type: i.NullableType,
        expression: F(),
        prefix: !0
      }, [H, u])) : e === t.BANG ? (H = r - 1, S(t.BANG), c({
        type: i.NonNullableType,
        expression: F(),
        prefix: !0
      }, [H, u])) : (H = u, j = F(), e === t.BANG ? (S(t.BANG), c({
        type: i.NonNullableType,
        expression: j,
        prefix: !1
      }, [H, u])) : e === t.QUESTION ? (S(t.QUESTION), c({
        type: i.NullableType,
        expression: j,
        prefix: !1
      }, [H, u])) : e === t.LBRACK ? (S(t.LBRACK), C(t.RBRACK, "expected an array-style type declaration (" + a + "[])"), c({
        type: i.TypeApplication,
        expression: c({
          type: i.NameExpression,
          name: "Array"
        }, [H, u]),
        applications: [j]
      }, [H, u])) : j);
    }
    function P() {
      var j, H;
      if (j = $(), e !== t.PIPE)
        return j;
      for (H = [j], S(t.PIPE); H.push($()), e === t.PIPE; )
        S(t.PIPE);
      return c({
        type: i.UnionType,
        elements: H
      }, [0, r]);
    }
    function X() {
      var j;
      return e === t.REST ? (S(t.REST), c({
        type: i.RestType,
        expression: P()
      }, [0, r])) : (j = P(), e === t.EQUAL ? (S(t.EQUAL), c({
        type: i.OptionalType,
        expression: j
      }, [0, r])) : j);
    }
    function Q(j, H) {
      var N;
      return o = j, f = o.length, r = 0, u = 0, h = H && H.range, m = H && H.startIndex || 0, b(), N = P(), H && H.midstream ? {
        expression: N,
        index: u
      } : (e !== t.EOF && p.throwError("not reach to EOF"), N);
    }
    function ue(j, H) {
      var N;
      return o = j, f = o.length, r = 0, u = 0, h = H && H.range, m = H && H.startIndex || 0, b(), N = X(), H && H.midstream ? {
        expression: N,
        index: u
      } : (e !== t.EOF && p.throwError("not reach to EOF"), N);
    }
    function le(j, H, N) {
      var G, M, Z;
      switch (j.type) {
        case i.NullableLiteral:
          G = "?";
          break;
        case i.AllLiteral:
          G = "*";
          break;
        case i.NullLiteral:
          G = "null";
          break;
        case i.UndefinedLiteral:
          G = "undefined";
          break;
        case i.VoidLiteral:
          G = "void";
          break;
        case i.UnionType:
          for (N ? G = "" : G = "(", M = 0, Z = j.elements.length; M < Z; ++M)
            G += le(j.elements[M], H), M + 1 !== Z && (G += H ? "|" : " | ");
          N || (G += ")");
          break;
        case i.ArrayType:
          for (G = "[", M = 0, Z = j.elements.length; M < Z; ++M)
            G += le(j.elements[M], H), M + 1 !== Z && (G += H ? "," : ", ");
          G += "]";
          break;
        case i.RecordType:
          for (G = "{", M = 0, Z = j.fields.length; M < Z; ++M)
            G += le(j.fields[M], H), M + 1 !== Z && (G += H ? "," : ", ");
          G += "}";
          break;
        case i.FieldType:
          j.value ? G = j.key + (H ? ":" : ": ") + le(j.value, H) : G = j.key;
          break;
        case i.FunctionType:
          for (G = H ? "function(" : "function (", j.this && (j.new ? G += H ? "new:" : "new: " : G += H ? "this:" : "this: ", G += le(j.this, H), j.params.length !== 0 && (G += H ? "," : ", ")), M = 0, Z = j.params.length; M < Z; ++M)
            G += le(j.params[M], H), M + 1 !== Z && (G += H ? "," : ", ");
          G += ")", j.result && (G += (H ? ":" : ": ") + le(j.result, H));
          break;
        case i.ParameterType:
          G = j.name + (H ? ":" : ": ") + le(j.expression, H);
          break;
        case i.RestType:
          G = "...", j.expression && (G += le(j.expression, H));
          break;
        case i.NonNullableType:
          j.prefix ? G = "!" + le(j.expression, H) : G = le(j.expression, H) + "!";
          break;
        case i.OptionalType:
          G = le(j.expression, H) + "=";
          break;
        case i.NullableType:
          j.prefix ? G = "?" + le(j.expression, H) : G = le(j.expression, H) + "?";
          break;
        case i.NameExpression:
          G = j.name;
          break;
        case i.TypeApplication:
          for (G = le(j.expression, H) + ".<", M = 0, Z = j.applications.length; M < Z; ++M)
            G += le(j.applications[M], H), M + 1 !== Z && (G += H ? "," : ", ");
          G += ">";
          break;
        case i.StringLiteralType:
          G = '"' + j.value + '"';
          break;
        case i.NumericLiteralType:
          G = String(j.value);
          break;
        case i.BooleanLiteralType:
          G = String(j.value);
          break;
        default:
          p.throwError("Unknown type " + j.type);
      }
      return G;
    }
    function Ce(j, H) {
      return H == null && (H = {}), le(j, H.compact, H.topLevel);
    }
    br.parseType = Q, br.parseParamType = ue, br.stringify = Ce, br.Syntax = i;
  }()), br;
}
var tC;
function SL() {
  return tC || (tC = 1, function(i) {
    (function() {
      var t, o, f, r, u;
      r = En(), t = vL(), o = _v();
      function e(C, x, A) {
        return C.slice(x, A);
      }
      u = /* @__PURE__ */ function() {
        var C = Object.prototype.hasOwnProperty;
        return function(A, R) {
          return C.call(A, R);
        };
      }();
      function a(C) {
        var x = {}, A;
        for (A in C)
          C.hasOwnProperty(A) && (x[A] = C[A]);
        return x;
      }
      function n(C) {
        return C >= 97 && C <= 122 || C >= 65 && C <= 90 || C >= 48 && C <= 57;
      }
      function p(C) {
        return C === "param" || C === "argument" || C === "arg";
      }
      function m(C) {
        return C === "return" || C === "returns";
      }
      function h(C) {
        return C === "property" || C === "prop";
      }
      function l(C) {
        return p(C) || h(C) || C === "alias" || C === "this" || C === "mixes" || C === "requires";
      }
      function s(C) {
        return l(C) || C === "const" || C === "constant";
      }
      function c(C) {
        return h(C) || p(C);
      }
      function g(C) {
        return h(C) || p(C);
      }
      function d(C) {
        return p(C) || m(C) || C === "define" || C === "enum" || C === "implements" || C === "this" || C === "type" || C === "typedef" || h(C);
      }
      function y(C) {
        return d(C) || C === "throws" || C === "const" || C === "constant" || C === "namespace" || C === "member" || C === "var" || C === "module" || C === "constructor" || C === "class" || C === "extends" || C === "augments" || C === "public" || C === "private" || C === "protected";
      }
      var v = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]", T = "(" + v + "*(?:\\*" + v + `?)?)(.+|[\r
\u2028\u2029])`;
      function b(C) {
        return C.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(T, "g"), "$2").replace(/\s*$/, "");
      }
      function S(C, x) {
        for (var A = C.replace(/^\/\*\*?/, ""), R = 0, L = new RegExp(T, "g"), _; _ = L.exec(A); )
          if (R += _[1].length, _.index + _[0].length > x + R)
            return x + R + C.length - A.length;
        return C.replace(/\*\/$/, "").replace(/\s*$/, "").length;
      }
      (function(C) {
        var x, A, R, L, _, I, O, k, w;
        function U() {
          var G = _.charCodeAt(A);
          return A += 1, r.code.isLineTerminator(G) && !(G === 13 && _.charCodeAt(A) === 10) && (R += 1), String.fromCharCode(G);
        }
        function q() {
          var G = "";
          for (U(); A < L && n(_.charCodeAt(A)); )
            G += U();
          return G;
        }
        function F() {
          var G, M, Z = A;
          for (M = !1; Z < L; ) {
            if (G = _.charCodeAt(Z), r.code.isLineTerminator(G) && !(G === 13 && _.charCodeAt(Z + 1) === 10))
              M = !0;
            else if (M) {
              if (G === 64)
                break;
              r.code.isWhiteSpace(G) || (M = !1);
            }
            Z += 1;
          }
          return Z;
        }
        function $(G, M, Z) {
          for (var Ee, ke, Ie, Je, at = !1; A < M; )
            if (Ee = _.charCodeAt(A), r.code.isWhiteSpace(Ee))
              U();
            else if (Ee === 123) {
              U();
              break;
            } else {
              at = !0;
              break;
            }
          if (at)
            return null;
          for (ke = 1, Ie = ""; A < M; )
            if (Ee = _.charCodeAt(A), r.code.isLineTerminator(Ee))
              U();
            else {
              if (Ee === 125) {
                if (ke -= 1, ke === 0) {
                  U();
                  break;
                }
              } else Ee === 123 && (ke += 1);
              Ie === "" && (Je = A), Ie += U();
            }
          return ke !== 0 ? o.throwError("Braces are not balanced") : g(G) ? t.parseParamType(Ie, { startIndex: le(Je), range: Z }) : t.parseType(Ie, { startIndex: le(Je), range: Z });
        }
        function P(G) {
          var M;
          if (!r.code.isIdentifierStartES5(_.charCodeAt(A)) && !_[A].match(/[0-9]/))
            return null;
          for (M = U(); A < G && r.code.isIdentifierPartES5(_.charCodeAt(A)); )
            M += U();
          return M;
        }
        function X(G) {
          for (; A < G && (r.code.isWhiteSpace(_.charCodeAt(A)) || r.code.isLineTerminator(_.charCodeAt(A))); )
            U();
        }
        function Q(G, M, Z) {
          var Ee = "", ke, Ie;
          if (X(G), A >= G)
            return null;
          if (_.charCodeAt(A) === 91)
            if (M)
              ke = !0, Ee = U();
            else
              return null;
          if (Ee += P(G), Z)
            for (_.charCodeAt(A) === 58 && (Ee === "module" || Ee === "external" || Ee === "event") && (Ee += U(), Ee += P(G)), _.charCodeAt(A) === 91 && _.charCodeAt(A + 1) === 93 && (Ee += U(), Ee += U()); _.charCodeAt(A) === 46 || _.charCodeAt(A) === 47 || _.charCodeAt(A) === 35 || _.charCodeAt(A) === 45 || _.charCodeAt(A) === 126; )
              Ee += U(), Ee += P(G);
          if (ke) {
            if (X(G), _.charCodeAt(A) === 61) {
              Ee += U(), X(G);
              for (var Je, at = 1; A < G; ) {
                if (Je = _.charCodeAt(A), r.code.isWhiteSpace(Je) && (Ie || (X(G), Je = _.charCodeAt(A))), Je === 39 && (Ie ? Ie === "'" && (Ie = "") : Ie = "'"), Je === 34 && (Ie ? Ie === '"' && (Ie = "") : Ie = '"'), Je === 91)
                  at++;
                else if (Je === 93 && --at === 0)
                  break;
                Ee += U();
              }
            }
            if (X(G), A >= G || _.charCodeAt(A) !== 93)
              return null;
            Ee += U();
          }
          return Ee;
        }
        function ue() {
          for (; A < L && _.charCodeAt(A) !== 64; )
            U();
          return A >= L ? !1 : (o.assert(
            _.charCodeAt(A) === 64
            /* '@' */
          ), !0);
        }
        function le(G) {
          return _ === I ? G : S(I, G);
        }
        function Ce(G, M) {
          this._options = G, this._title = M.toLowerCase(), this._tag = {
            title: M,
            description: null
          }, this._options.lineNumbers && (this._tag.lineNumber = R), this._first = A - M.length - 1, this._last = 0, this._extra = {};
        }
        Ce.prototype.addError = function(M) {
          var Z = Array.prototype.slice.call(arguments, 1), Ee = M.replace(
            /%(\d)/g,
            function(ke, Ie) {
              return o.assert(Ie < Z.length, "Message reference must be in range"), Z[Ie];
            }
          );
          return this._tag.errors || (this._tag.errors = []), w && o.throwError(Ee), this._tag.errors.push(Ee), O;
        }, Ce.prototype.parseType = function() {
          if (d(this._title))
            try {
              if (this._tag.type = $(this._title, this._last, this._options.range), !this._tag.type && !p(this._title) && !m(this._title) && !this.addError("Missing or invalid tag type"))
                return !1;
            } catch (G) {
              if (this._tag.type = null, !this.addError(G.message))
                return !1;
            }
          else if (y(this._title))
            try {
              this._tag.type = $(this._title, this._last, this._options.range);
            } catch {
            }
          return !0;
        }, Ce.prototype._parseNamePath = function(G) {
          var M;
          return M = Q(this._last, k && g(this._title), !0), !M && !G && !this.addError("Missing or invalid tag name") ? !1 : (this._tag.name = M, !0);
        }, Ce.prototype.parseNamePath = function() {
          return this._parseNamePath(!1);
        }, Ce.prototype.parseNamePathOptional = function() {
          return this._parseNamePath(!0);
        }, Ce.prototype.parseName = function() {
          var G, M;
          if (s(this._title))
            if (this._tag.name = Q(this._last, k && g(this._title), c(this._title)), this._tag.name)
              M = this._tag.name, M.charAt(0) === "[" && M.charAt(M.length - 1) === "]" && (G = M.substring(1, M.length - 1).split("="), G.length > 1 && (this._tag.default = G.slice(1).join("=")), this._tag.name = G[0], this._tag.type && this._tag.type.type !== "OptionalType" && (this._tag.type = {
                type: "OptionalType",
                expression: this._tag.type
              }));
            else {
              if (!l(this._title))
                return !0;
              if (p(this._title) && this._tag.type && this._tag.type.name)
                this._extra.name = this._tag.type, this._tag.name = this._tag.type.name, this._tag.type = null;
              else if (!this.addError("Missing or invalid tag name"))
                return !1;
            }
          return !0;
        }, Ce.prototype.parseDescription = function() {
          var M = e(_, A, this._last).trim();
          return M && (/^-\s+/.test(M) && (M = M.substring(2)), this._tag.description = M), !0;
        }, Ce.prototype.parseCaption = function() {
          var M = e(_, A, this._last).trim(), Z = "<caption>", Ee = "</caption>", ke = M.indexOf(Z), Ie = M.indexOf(Ee);
          return ke >= 0 && Ie >= 0 ? (this._tag.caption = M.substring(
            ke + Z.length,
            Ie
          ).trim(), this._tag.description = M.substring(Ie + Ee.length).trim()) : this._tag.description = M, !0;
        }, Ce.prototype.parseKind = function() {
          var M, Z;
          return Z = {
            class: !0,
            constant: !0,
            event: !0,
            external: !0,
            file: !0,
            function: !0,
            member: !0,
            mixin: !0,
            module: !0,
            namespace: !0,
            typedef: !0
          }, M = e(_, A, this._last).trim(), this._tag.kind = M, !(!u(Z, M) && !this.addError("Invalid kind name '%0'", M));
        }, Ce.prototype.parseAccess = function() {
          var M;
          return M = e(_, A, this._last).trim(), this._tag.access = M, !(M !== "private" && M !== "protected" && M !== "public" && !this.addError("Invalid access name '%0'", M));
        }, Ce.prototype.parseThis = function() {
          var M = e(_, A, this._last).trim();
          if (M && M.charAt(0) === "{") {
            var Z = this.parseType();
            return Z && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType" ? (this._tag.name = this._tag.type.name, !0) : this.addError("Invalid name for this");
          } else
            return this.parseNamePath();
        }, Ce.prototype.parseVariation = function() {
          var M, Z;
          return Z = e(_, A, this._last).trim(), M = parseFloat(Z, 10), this._tag.variation = M, !(isNaN(M) && !this.addError("Invalid variation '%0'", Z));
        }, Ce.prototype.ensureEnd = function() {
          var G = e(_, A, this._last).trim();
          return !(G && !this.addError("Unknown content '%0'", G));
        }, Ce.prototype.epilogue = function() {
          var M;
          return M = this._tag.description, !(g(this._title) && !this._tag.type && M && M.charAt(0) === "[" && (this._tag.type = this._extra.name, this._tag.name || (this._tag.name = void 0), !k && !this.addError("Missing or invalid tag name")));
        }, x = {
          // http://usejsdoc.org/tags-access.html
          access: ["parseAccess"],
          // http://usejsdoc.org/tags-alias.html
          alias: ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-augments.html
          augments: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-constructor.html
          constructor: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-constructor.html
          class: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-extends.html
          extends: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-example.html
          example: ["parseCaption"],
          // http://usejsdoc.org/tags-deprecated.html
          deprecated: ["parseDescription"],
          // http://usejsdoc.org/tags-global.html
          global: ["ensureEnd"],
          // http://usejsdoc.org/tags-inner.html
          inner: ["ensureEnd"],
          // http://usejsdoc.org/tags-instance.html
          instance: ["ensureEnd"],
          // http://usejsdoc.org/tags-kind.html
          kind: ["parseKind"],
          // http://usejsdoc.org/tags-mixes.html
          mixes: ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-mixin.html
          mixin: ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-member.html
          member: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-method.html
          method: ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-module.html
          module: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          func: ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          function: ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-member.html
          var: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-name.html
          name: ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-namespace.html
          namespace: ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-private.html
          private: ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-protected.html
          protected: ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-public.html
          public: ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-readonly.html
          readonly: ["ensureEnd"],
          // http://usejsdoc.org/tags-requires.html
          requires: ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-since.html
          since: ["parseDescription"],
          // http://usejsdoc.org/tags-static.html
          static: ["ensureEnd"],
          // http://usejsdoc.org/tags-summary.html
          summary: ["parseDescription"],
          // http://usejsdoc.org/tags-this.html
          this: ["parseThis", "ensureEnd"],
          // http://usejsdoc.org/tags-todo.html
          todo: ["parseDescription"],
          // http://usejsdoc.org/tags-typedef.html
          typedef: ["parseType", "parseNamePathOptional"],
          // http://usejsdoc.org/tags-variation.html
          variation: ["parseVariation"],
          // http://usejsdoc.org/tags-version.html
          version: ["parseDescription"]
        }, Ce.prototype.parse = function() {
          var M, Z, Ee, ke;
          if (!this._title && !this.addError("Missing or invalid title"))
            return null;
          for (this._last = F(this._title), this._options.range && (this._tag.range = [this._first, _.slice(0, this._last).replace(/\s*$/, "").length].map(le)), u(x, this._title) ? Ee = x[this._title] : Ee = ["parseType", "parseName", "parseDescription", "epilogue"], M = 0, Z = Ee.length; M < Z; ++M)
            if (ke = Ee[M], !this[ke]())
              return null;
          return this._tag;
        };
        function j(G) {
          var M, Z, Ee;
          if (!ue())
            return null;
          for (M = q(), Z = new Ce(G, M), Ee = Z.parse(); A < Z._last; )
            U();
          return Ee;
        }
        function H(G) {
          var M = "", Z, Ee;
          for (Ee = !0; A < L && (Z = _.charCodeAt(A), !(Ee && Z === 64)); )
            r.code.isLineTerminator(Z) ? Ee = !0 : Ee && !r.code.isWhiteSpace(Z) && (Ee = !1), M += U();
          return G ? M : M.trim();
        }
        function N(G, M) {
          var Z = [], Ee, ke, Ie, Je, at;
          if (M === void 0 && (M = {}), typeof M.unwrap == "boolean" && M.unwrap ? _ = b(G) : _ = G, I = G, M.tags)
            if (Array.isArray(M.tags))
              for (Ie = {}, Je = 0, at = M.tags.length; Je < at; Je++)
                typeof M.tags[Je] == "string" ? Ie[M.tags[Je]] = !0 : o.throwError('Invalid "tags" parameter: ' + M.tags);
            else
              o.throwError('Invalid "tags" parameter: ' + M.tags);
          for (L = _.length, A = 0, R = 0, O = M.recoverable, k = M.sloppy, w = M.strict, ke = H(M.preserveWhitespace); Ee = j(M), !!Ee; )
            (!Ie || Ie.hasOwnProperty(Ee.title)) && Z.push(Ee);
          return {
            description: ke,
            tags: Z
          };
        }
        C.parse = N;
      })(f = {}), i.version = o.VERSION, i.parse = f.parse, i.parseType = t.parseType, i.parseParamType = t.parseParamType, i.unwrapComment = b, i.Syntax = a(t.Syntax), i.Error = o.DoctrineError, i.type = {
        Syntax: i.Syntax,
        parseType: t.parseType,
        parseParamType: t.parseParamType,
        stringify: t.stringify
      };
    })();
  }($c)), $c;
}
var Gc, rC;
function AL() {
  if (rC) return Gc;
  rC = 1;
  const i = SL();
  return Gc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce valid JSDoc comments",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/valid-jsdoc"
      },
      schema: [
        {
          type: "object",
          properties: {
            prefer: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            },
            preferType: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            },
            requireReturn: {
              type: "boolean",
              default: !0
            },
            requireParamDescription: {
              type: "boolean",
              default: !0
            },
            requireReturnDescription: {
              type: "boolean",
              default: !0
            },
            matchDescription: {
              type: "string"
            },
            requireReturnType: {
              type: "boolean",
              default: !0
            },
            requireParamType: {
              type: "boolean",
              default: !0
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
        expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
        use: "Use @{{name}} instead.",
        useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
        syntaxError: "JSDoc syntax error.",
        missingBrace: "JSDoc type missing brace.",
        missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
        missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
        missingReturnType: "Missing JSDoc return type.",
        missingReturnDesc: "Missing JSDoc return description.",
        missingReturn: "Missing JSDoc @{{returns}} for function.",
        missingParam: "Missing JSDoc for parameter '{{name}}'.",
        duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
        unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
      },
      deprecated: !0,
      replacedBy: []
    },
    create(t) {
      const o = t.options[0] || {}, f = o.prefer || {}, r = t.sourceCode, u = o.requireReturn !== !1, e = o.requireParamDescription !== !1, a = o.requireReturnDescription !== !1, n = o.requireReturnType !== !1, p = o.requireParamType !== !1, m = o.preferType || {}, h = Object.keys(m).length !== 0, l = [];
      function s(C) {
        return C.type === "ClassExpression" || C.type === "ClassDeclaration";
      }
      function c(C) {
        l.push({
          returnPresent: C.type === "ArrowFunctionExpression" && C.body.type !== "BlockStatement" || s(C) || C.async
        });
      }
      function g(C) {
        const x = l[l.length - 1];
        x && C.argument !== null && (x.returnPresent = !0);
      }
      function d(C) {
        return C.type === null || C.type.name === "void" || C.type.type === "UndefinedLiteral";
      }
      function y(C) {
        return C !== "UndefinedLiteral" && // {undefined} as there is no name property available.
        C !== "NullLiteral" && // {null}
        C !== "NullableLiteral" && // {?}
        C !== "FunctionType" && // {function(a)}
        C !== "AllLiteral";
      }
      function v(C) {
        let x;
        return C.name ? x = C : C.expression && (x = C.expression), {
          currentType: x,
          expectedTypeName: x && m[x.name]
        };
      }
      function T(C, x) {
        return {
          start: r.getLocFromIndex(C.range[0] + 2 + x.range[0]),
          end: r.getLocFromIndex(C.range[0] + 2 + x.range[1])
        };
      }
      function b(C, x) {
        if (!x || !y(x.type))
          return;
        const A = [];
        let R = [];
        switch (x.type) {
          case "TypeApplication":
            R = x.applications[0].type === "UnionType" ? x.applications[0].elements : x.applications, A.push(v(x));
            break;
          case "RecordType":
            R = x.fields;
            break;
          case "UnionType":
          case "ArrayType":
            R = x.elements;
            break;
          case "FieldType":
            x.value && A.push(v(x.value));
            break;
          default:
            A.push(v(x));
        }
        R.forEach(b.bind(null, C)), A.forEach((L) => {
          L.expectedTypeName && L.expectedTypeName !== L.currentType.name && t.report({
            node: C,
            messageId: "useType",
            loc: T(C, L.currentType),
            data: {
              currentTypeName: L.currentType.name,
              expectedTypeName: L.expectedTypeName
            },
            fix(_) {
              return _.replaceTextRange(
                L.currentType.range.map((I) => C.range[0] + 2 + I),
                L.expectedTypeName
              );
            }
          });
        });
      }
      function S(C) {
        const x = r.getJSDocComment(C), A = l.pop(), R = /* @__PURE__ */ Object.create(null), L = [];
        let _ = !1, I, O = !1, k = !1, w = !1, U = !1;
        if (x) {
          let q;
          try {
            q = i.parse(x.value, {
              strict: !0,
              unwrap: !0,
              sloppy: !0,
              range: !0
            });
          } catch ($) {
            /braces/iu.test($.message) ? t.report({ node: x, messageId: "missingBrace" }) : t.report({ node: x, messageId: "syntaxError" });
            return;
          }
          q.tags.forEach(($) => {
            switch ($.title.toLowerCase()) {
              case "param":
              case "arg":
              case "argument":
                L.push($);
                break;
              case "return":
              case "returns":
                _ = !0, I = $;
                break;
              case "constructor":
              case "class":
                O = !0;
                break;
              case "override":
              case "inheritdoc":
                w = !0;
                break;
              case "abstract":
              case "virtual":
                U = !0;
                break;
              case "interface":
                k = !0;
                break;
            }
            if (Object.prototype.hasOwnProperty.call(f, $.title) && $.title !== f[$.title]) {
              const P = T(x, $);
              t.report({
                node: x,
                messageId: "use",
                loc: {
                  start: P.start,
                  end: {
                    line: P.start.line,
                    column: P.start.column + `@${$.title}`.length
                  }
                },
                data: { name: f[$.title] },
                fix(X) {
                  return X.replaceTextRange(
                    [
                      x.range[0] + $.range[0] + 3,
                      x.range[0] + $.range[0] + $.title.length + 3
                    ],
                    f[$.title]
                  );
                }
              });
            }
            h && $.type && b(x, $.type);
          }), L.forEach(($) => {
            p && !$.type && t.report({
              node: x,
              messageId: "missingParamType",
              loc: T(x, $),
              data: { name: $.name }
            }), !$.description && e && t.report({
              node: x,
              messageId: "missingParamDesc",
              loc: T(x, $),
              data: { name: $.name }
            }), R[$.name] ? t.report({
              node: x,
              messageId: "duplicateParam",
              loc: T(x, $),
              data: { name: $.name }
            }) : $.name.includes(".") || (R[$.name] = $);
          }), _ && (!u && !A.returnPresent && (I.type === null || !d(I)) && !U ? t.report({
            node: x,
            messageId: "unexpectedTag",
            loc: T(x, I),
            data: {
              title: I.title
            }
          }) : (n && !I.type && t.report({ node: x, messageId: "missingReturnType" }), !d(I) && !I.description && a && t.report({ node: x, messageId: "missingReturnDesc" }))), !w && !_ && !O && !k && C.parent.kind !== "get" && C.parent.kind !== "constructor" && C.parent.kind !== "set" && !s(C) && (u || A.returnPresent && !C.async) && t.report({
            node: x,
            messageId: "missingReturn",
            data: {
              returns: f.returns || "returns"
            }
          });
          const F = Object.keys(R);
          C.params && C.params.forEach(($, P) => {
            const X = $.type === "AssignmentPattern" ? $.left : $;
            if (X.type === "Identifier") {
              const Q = X.name;
              F[P] && Q !== F[P] ? t.report({
                node: x,
                messageId: "expected",
                loc: T(x, R[F[P]]),
                data: {
                  name: Q,
                  jsdocName: F[P]
                }
              }) : !R[Q] && !w && t.report({
                node: x,
                messageId: "missingParam",
                data: {
                  name: Q
                }
              });
            }
          }), o.matchDescription && (new RegExp(o.matchDescription, "u").test(q.description) || t.report({ node: x, messageId: "unsatisfiedDesc" }));
        }
      }
      return {
        ArrowFunctionExpression: c,
        FunctionExpression: c,
        FunctionDeclaration: c,
        ClassExpression: c,
        ClassDeclaration: c,
        "ArrowFunctionExpression:exit": S,
        "FunctionExpression:exit": S,
        "FunctionDeclaration:exit": S,
        "ClassExpression:exit": S,
        "ClassDeclaration:exit": S,
        ReturnStatement: g
      };
    }
  }, Gc;
}
var Wc, nC;
function TL() {
  if (nC) return Wc;
  nC = 1;
  const i = Re();
  return Wc = {
    meta: {
      type: "problem",
      docs: {
        description: "Enforce comparing `typeof` expressions against valid strings",
        recommended: !0,
        url: "https://eslint.org/docs/latest/rules/valid-typeof"
      },
      hasSuggestions: !0,
      schema: [
        {
          type: "object",
          properties: {
            requireStringLiterals: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      messages: {
        invalidValue: "Invalid typeof comparison value.",
        notString: "Typeof comparisons should be to string literals.",
        suggestString: 'Use `"{{type}}"` instead of `{{type}}`.'
      }
    },
    create(t) {
      const o = /* @__PURE__ */ new Set(["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"]), f = /* @__PURE__ */ new Set(["==", "===", "!=", "!=="]), r = t.sourceCode, u = t.options[0] && t.options[0].requireStringLiterals;
      let e;
      function a(p) {
        const m = e.set.get(p.name);
        return m && m.defs.length === 0 && m.references.some((h) => h.identifier === p);
      }
      function n(p) {
        return p.type === "UnaryExpression" && p.operator === "typeof";
      }
      return {
        Program(p) {
          e = r.getScope(p);
        },
        UnaryExpression(p) {
          if (n(p)) {
            const { parent: m } = p;
            if (m.type === "BinaryExpression" && f.has(m.operator)) {
              const h = m.left === p ? m.right : m.left;
              if (h.type === "Literal" || i.isStaticTemplateLiteral(h)) {
                const l = h.type === "Literal" ? h.value : h.quasis[0].value.cooked;
                o.has(l) || t.report({ node: h, messageId: "invalidValue" });
              } else h.type === "Identifier" && h.name === "undefined" && a(h) ? t.report({
                node: h,
                messageId: u ? "notString" : "invalidValue",
                suggest: [
                  {
                    messageId: "suggestString",
                    data: { type: "undefined" },
                    fix(l) {
                      return l.replaceText(h, '"undefined"');
                    }
                  }
                ]
              }) : u && !n(h) && t.report({ node: h, messageId: "notString" });
            }
          }
        }
      };
    }
  }, Wc;
}
var Xc, sC;
function bL() {
  return sC || (sC = 1, Xc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `var` declarations be placed at the top of their containing scope",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/vars-on-top"
      },
      schema: [],
      messages: {
        top: "All 'var' declarations must be at the top of the function scope."
      }
    },
    create(i) {
      function t(a) {
        return a.type === "ExpressionStatement" && a.expression.type === "Literal" && typeof a.expression.value == "string";
      }
      function o(a) {
        return a.type === "ImportDeclaration" || a.type === "ImportSpecifier" || a.type === "ImportDefaultSpecifier" || a.type === "ImportNamespaceSpecifier";
      }
      function f(a) {
        return a.type === "VariableDeclaration" || a.type === "ExportNamedDeclaration" && a.declaration && a.declaration.type === "VariableDeclaration";
      }
      function r(a, n) {
        const p = n.length;
        let m = 0;
        if (a.parent.type !== "StaticBlock")
          for (; m < p && !(!t(n[m]) && !o(n[m])); ++m)
            ;
        for (; m < p; ++m) {
          if (!f(n[m]))
            return !1;
          if (n[m] === a)
            return !0;
        }
        return !1;
      }
      function u(a, n) {
        r(a, n.body) || i.report({ node: a, messageId: "top" });
      }
      function e(a) {
        const { parent: n } = a;
        n.type === "BlockStatement" && /Function/u.test(n.parent.type) && r(a, n.body) || n.type === "StaticBlock" && r(a, n.body) || i.report({ node: a, messageId: "top" });
      }
      return {
        "VariableDeclaration[kind='var']"(a) {
          a.parent.type === "ExportNamedDeclaration" ? u(a.parent, a.parent.parent) : a.parent.type === "Program" ? u(a, a.parent) : e(a);
        }
      };
    }
  }), Xc;
}
var zc, iC;
function xL() {
  if (iC) return zc;
  iC = 1;
  const i = Re(), t = Ft();
  function o(f) {
    const r = f.parent.type === "ChainExpression" ? f.parent : f;
    return r.parent.type === "NewExpression" && r.parent.callee === r;
  }
  return zc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require parentheses around immediate `function` invocations",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/wrap-iife"
      },
      schema: [
        {
          enum: ["outside", "inside", "any"]
        },
        {
          type: "object",
          properties: {
            functionPrototypeMethods: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        wrapInvocation: "Wrap an immediate function invocation in parentheses.",
        wrapExpression: "Wrap only the function expression in parens.",
        moveInvocation: "Move the invocation into the parens that contain the function."
      }
    },
    create(f) {
      const r = f.options[0] || "outside", u = f.options[1] && f.options[1].functionPrototypeMethods, e = f.sourceCode;
      function a(m) {
        return i.isParenthesised(e, m);
      }
      function n(m) {
        return t.isParenthesized(1, m, e);
      }
      function p(m) {
        const h = i.skipChainExpression(m.callee);
        return h.type === "FunctionExpression" ? h : u && h.type === "MemberExpression" && h.object.type === "FunctionExpression" && (i.getStaticPropertyName(h) === "call" || i.getStaticPropertyName(h) === "apply") ? h.object : null;
      }
      return {
        CallExpression(m) {
          const h = p(m);
          if (!h)
            return;
          const l = a(m), s = a(h);
          !l && !s ? f.report({
            node: m,
            messageId: "wrapInvocation",
            fix(c) {
              const g = r === "inside" ? h : m;
              return c.replaceText(g, `(${e.getText(g)})`);
            }
          }) : r === "inside" && !s ? f.report({
            node: m,
            messageId: "wrapExpression",
            fix(c) {
              if (n(m) && !o(m)) {
                const g = e.getTokenAfter(m);
                return c.replaceTextRange(
                  [h.range[1], g.range[1]],
                  `)${e.getText().slice(h.range[1], g.range[0])}`
                );
              }
              return c.replaceText(h, `(${e.getText(h)})`);
            }
          }) : r === "outside" && !l && f.report({
            node: m,
            messageId: "moveInvocation",
            fix(c) {
              const g = e.getTokenAfter(h);
              return c.replaceTextRange(
                [g.range[0], m.range[1]],
                `${e.getText().slice(g.range[1], m.range[1])})`
              );
            }
          });
        }
      };
    }
  }, zc;
}
var Hc, aC;
function RL() {
  return aC || (aC = 1, Hc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require parenthesis around regex literals",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/wrap-regex"
      },
      schema: [],
      fixable: "code",
      messages: {
        requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
      }
    },
    create(i) {
      const t = i.sourceCode;
      return {
        Literal(o) {
          if (t.getFirstToken(o).type === "RegularExpression") {
            const u = t.getTokenBefore(o), e = t.getTokenAfter(o), { parent: a } = o;
            a.type === "MemberExpression" && a.object === o && !(u && u.value === "(" && e && e.value === ")") && i.report({
              node: o,
              messageId: "requireParens",
              fix: (n) => n.replaceText(o, `(${t.getText(o)})`)
            });
          }
        }
      };
    }
  }), Hc;
}
var Jc, oC;
function DL() {
  return oC || (oC = 1, Jc = {
    meta: {
      deprecated: !0,
      replacedBy: [],
      type: "layout",
      docs: {
        description: "Require or disallow spacing around the `*` in `yield*` expressions",
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/yield-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: { type: "boolean" },
                after: { type: "boolean" }
              },
              additionalProperties: !1
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(i) {
      const t = i.sourceCode, o = function(u) {
        return !u || typeof u == "string" ? {
          before: { before: !0, after: !1 },
          after: { before: !1, after: !0 },
          both: { before: !0, after: !0 },
          neither: { before: !1, after: !1 }
        }[u || "after"] : u;
      }(i.options[0]);
      function f(u, e, a) {
        if (t.isSpaceBetweenTokens(e, a) !== o[u]) {
          const n = e.value === "*", p = o[u], m = n ? e : a;
          let h = "";
          p ? h = u === "before" ? "missingBefore" : "missingAfter" : h = u === "before" ? "unexpectedBefore" : "unexpectedAfter", i.report({
            node: m,
            messageId: h,
            fix(l) {
              return p ? n ? l.insertTextAfter(m, " ") : l.insertTextBefore(m, " ") : l.removeRange([e.range[1], a.range[0]]);
            }
          });
        }
      }
      function r(u) {
        if (!u.delegate)
          return;
        const e = t.getFirstTokens(u, 3), a = e[0], n = e[1], p = e[2];
        f("before", a, n), f("after", n, p);
      }
      return {
        YieldExpression: r
      };
    }
  }), Jc;
}
var Qc, lC;
function LL() {
  if (lC) return Qc;
  lC = 1;
  const i = Re();
  function t(a) {
    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(a);
  }
  function o(a) {
    return /^(==|===)$/u.test(a);
  }
  function f(a) {
    return ["<", "<="].includes(a);
  }
  function r(a) {
    return a.type === "UnaryExpression" && a.operator === "-" && a.prefix && i.isNumericLiteral(a.argument);
  }
  function u(a) {
    return r(a) || i.isStaticTemplateLiteral(a);
  }
  function e(a) {
    return a.type === "Literal" ? a : r(a) ? {
      type: "Literal",
      value: -a.argument.value,
      raw: `-${a.argument.value}`
    } : i.isStaticTemplateLiteral(a) ? {
      type: "Literal",
      value: a.quasis[0].value.cooked,
      raw: a.quasis[0].value.raw
    } : null;
  }
  return Qc = {
    meta: {
      type: "suggestion",
      docs: {
        description: 'Require or disallow "Yoda" conditions',
        recommended: !1,
        url: "https://eslint.org/docs/latest/rules/yoda"
      },
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptRange: {
              type: "boolean",
              default: !1
            },
            onlyEquality: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      ],
      fixable: "code",
      messages: {
        expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
      }
    },
    create(a) {
      const n = a.options[0] === "always", p = a.options[1] && a.options[1].exceptRange, m = a.options[1] && a.options[1].onlyEquality, h = a.sourceCode;
      function l(g) {
        const d = g.left, y = g.right;
        function v() {
          if (g.operator === "&&" && i.isSameReference(d.right, y.left)) {
            const S = e(d.left), C = e(y.right);
            if (S === null && C === null)
              return !1;
            if (C === null || S === null || S.value <= C.value)
              return !0;
          }
          return !1;
        }
        function T() {
          if (g.operator === "||" && i.isSameReference(d.left, y.right)) {
            const S = e(d.right), C = e(y.left);
            if (S === null && C === null)
              return !1;
            if (C === null || S === null || S.value <= C.value)
              return !0;
          }
          return !1;
        }
        function b() {
          return i.isParenthesised(h, g);
        }
        return g.type === "LogicalExpression" && d.type === "BinaryExpression" && y.type === "BinaryExpression" && f(d.operator) && f(y.operator) && (v() || T()) && b();
      }
      const s = {
        "===": "===",
        "!==": "!==",
        "==": "==",
        "!=": "!=",
        "<": ">",
        ">": "<",
        "<=": ">=",
        ">=": "<="
      };
      function c(g) {
        const d = h.getFirstTokenBetween(
          g.left,
          g.right,
          (I) => I.value === g.operator
        ), y = h.getTokenBefore(d), v = h.getTokenAfter(d), T = h.getText(), b = T.slice(
          g.range[0],
          y.range[1]
        ), S = T.slice(
          y.range[1],
          d.range[0]
        ), C = T.slice(
          d.range[1],
          v.range[0]
        ), x = T.slice(
          v.range[0],
          g.range[1]
        ), A = h.getTokenBefore(g), R = h.getTokenAfter(g);
        let L = "", _ = "";
        return A && A.range[1] === g.range[0] && !i.canTokensBeAdjacent(A, v) && (L = " "), R && g.range[1] === R.range[0] && !i.canTokensBeAdjacent(y, R) && (_ = " "), L + x + S + s[d.value] + C + b + _;
      }
      return {
        BinaryExpression(g) {
          const d = n ? g.left : g.right, y = n ? g.right : g.left;
          (y.type === "Literal" || u(y)) && !(d.type === "Literal" || u(d)) && !(!o(g.operator) && m) && t(g.operator) && !(p && l(g.parent)) && a.report({
            node: g,
            messageId: "expected",
            data: {
              operator: g.operator,
              expectedSide: n ? "left" : "right"
            },
            fix: (v) => v.replaceText(g, c(g))
          });
        }
      };
    }
  }, Qc;
}
var Yc, uC;
function wv() {
  if (uC) return Yc;
  uC = 1;
  const { LazyLoadingRuleMap: i } = $A();
  return Yc = new i(Object.entries({
    "accessor-pairs": () => XA(),
    "array-bracket-newline": () => zA(),
    "array-bracket-spacing": () => HA(),
    "array-callback-return": () => JA(),
    "array-element-newline": () => QA(),
    "arrow-body-style": () => YA(),
    "arrow-parens": () => ZA(),
    "arrow-spacing": () => eT(),
    "block-scoped-var": () => tT(),
    "block-spacing": () => rT(),
    "brace-style": () => nT(),
    "callback-return": () => sT(),
    camelcase: () => iT(),
    "capitalized-comments": () => oT(),
    "class-methods-use-this": () => lT(),
    "comma-dangle": () => uT(),
    "comma-spacing": () => cT(),
    "comma-style": () => fT(),
    complexity: () => dT(),
    "computed-property-spacing": () => ET(),
    "consistent-return": () => yT(),
    "consistent-this": () => CT(),
    "constructor-super": () => vT(),
    curly: () => ST(),
    "default-case": () => AT(),
    "default-case-last": () => TT(),
    "default-param-last": () => bT(),
    "dot-location": () => xT(),
    "dot-notation": () => RT(),
    "eol-last": () => DT(),
    eqeqeq: () => LT(),
    "for-direction": () => _T(),
    "func-call-spacing": () => wT(),
    "func-name-matching": () => kT(),
    "func-names": () => BT(),
    "func-style": () => PT(),
    "function-call-argument-newline": () => IT(),
    "function-paren-newline": () => FT(),
    "generator-star-spacing": () => NT(),
    "getter-return": () => OT(),
    "global-require": () => UT(),
    "grouped-accessor-pairs": () => VT(),
    "guard-for-in": () => MT(),
    "handle-callback-err": () => KT(),
    "id-blacklist": () => jT(),
    "id-denylist": () => qT(),
    "id-length": () => $T(),
    "id-match": () => GT(),
    "implicit-arrow-linebreak": () => WT(),
    indent: () => XT(),
    "indent-legacy": () => zT(),
    "init-declarations": () => HT(),
    "jsx-quotes": () => JT(),
    "key-spacing": () => QT(),
    "keyword-spacing": () => YT(),
    "line-comment-position": () => ZT(),
    "linebreak-style": () => eb(),
    "lines-around-comment": () => tb(),
    "lines-around-directive": () => rb(),
    "lines-between-class-members": () => nb(),
    "logical-assignment-operators": () => sb(),
    "max-classes-per-file": () => ib(),
    "max-depth": () => ab(),
    "max-len": () => ob(),
    "max-lines": () => lb(),
    "max-lines-per-function": () => ub(),
    "max-nested-callbacks": () => cb(),
    "max-params": () => fb(),
    "max-statements": () => pb(),
    "max-statements-per-line": () => hb(),
    "multiline-comment-style": () => mb(),
    "multiline-ternary": () => gb(),
    "new-cap": () => db(),
    "new-parens": () => Eb(),
    "newline-after-var": () => yb(),
    "newline-before-return": () => Cb(),
    "newline-per-chained-call": () => vb(),
    "no-alert": () => Sb(),
    "no-array-constructor": () => Ab(),
    "no-async-promise-executor": () => Tb(),
    "no-await-in-loop": () => bb(),
    "no-bitwise": () => xb(),
    "no-buffer-constructor": () => Rb(),
    "no-caller": () => Db(),
    "no-case-declarations": () => Lb(),
    "no-catch-shadow": () => _b(),
    "no-class-assign": () => wb(),
    "no-compare-neg-zero": () => kb(),
    "no-cond-assign": () => Bb(),
    "no-confusing-arrow": () => Pb(),
    "no-console": () => Ib(),
    "no-const-assign": () => Fb(),
    "no-constant-binary-expression": () => Nb(),
    "no-constant-condition": () => Ob(),
    "no-constructor-return": () => Ub(),
    "no-continue": () => Vb(),
    "no-control-regex": () => Mb(),
    "no-debugger": () => Kb(),
    "no-delete-var": () => jb(),
    "no-div-regex": () => qb(),
    "no-dupe-args": () => $b(),
    "no-dupe-class-members": () => Gb(),
    "no-dupe-else-if": () => Wb(),
    "no-dupe-keys": () => Xb(),
    "no-duplicate-case": () => zb(),
    "no-duplicate-imports": () => Hb(),
    "no-else-return": () => Jb(),
    "no-empty": () => Qb(),
    "no-empty-character-class": () => Yb(),
    "no-empty-function": () => Zb(),
    "no-empty-pattern": () => ex(),
    "no-empty-static-block": () => tx(),
    "no-eq-null": () => rx(),
    "no-eval": () => nx(),
    "no-ex-assign": () => sx(),
    "no-extend-native": () => ix(),
    "no-extra-bind": () => ax(),
    "no-extra-boolean-cast": () => ox(),
    "no-extra-label": () => lx(),
    "no-extra-parens": () => ux(),
    "no-extra-semi": () => cx(),
    "no-fallthrough": () => fx(),
    "no-floating-decimal": () => px(),
    "no-func-assign": () => hx(),
    "no-global-assign": () => mx(),
    "no-implicit-coercion": () => gx(),
    "no-implicit-globals": () => dx(),
    "no-implied-eval": () => Ex(),
    "no-import-assign": () => yx(),
    "no-inline-comments": () => Cx(),
    "no-inner-declarations": () => vx(),
    "no-invalid-regexp": () => Sx(),
    "no-invalid-this": () => Ax(),
    "no-irregular-whitespace": () => Tx(),
    "no-iterator": () => bx(),
    "no-label-var": () => xx(),
    "no-labels": () => Rx(),
    "no-lone-blocks": () => Dx(),
    "no-lonely-if": () => Lx(),
    "no-loop-func": () => _x(),
    "no-loss-of-precision": () => wx(),
    "no-magic-numbers": () => kx(),
    "no-misleading-character-class": () => Ox(),
    "no-mixed-operators": () => Ux(),
    "no-mixed-requires": () => Vx(),
    "no-mixed-spaces-and-tabs": () => Mx(),
    "no-multi-assign": () => Kx(),
    "no-multi-spaces": () => jx(),
    "no-multi-str": () => qx(),
    "no-multiple-empty-lines": () => $x(),
    "no-native-reassign": () => Gx(),
    "no-negated-condition": () => Wx(),
    "no-negated-in-lhs": () => Xx(),
    "no-nested-ternary": () => zx(),
    "no-new": () => Hx(),
    "no-new-func": () => Jx(),
    "no-new-native-nonconstructor": () => Qx(),
    "no-new-object": () => Yx(),
    "no-new-require": () => Zx(),
    "no-new-symbol": () => eR(),
    "no-new-wrappers": () => tR(),
    "no-nonoctal-decimal-escape": () => rR(),
    "no-obj-calls": () => nR(),
    "no-object-constructor": () => sR(),
    "no-octal": () => iR(),
    "no-octal-escape": () => aR(),
    "no-param-reassign": () => oR(),
    "no-path-concat": () => lR(),
    "no-plusplus": () => uR(),
    "no-process-env": () => cR(),
    "no-process-exit": () => fR(),
    "no-promise-executor-return": () => pR(),
    "no-proto": () => hR(),
    "no-prototype-builtins": () => mR(),
    "no-redeclare": () => gR(),
    "no-regex-spaces": () => dR(),
    "no-restricted-exports": () => ER(),
    "no-restricted-globals": () => yR(),
    "no-restricted-imports": () => CR(),
    "no-restricted-modules": () => vR(),
    "no-restricted-properties": () => SR(),
    "no-restricted-syntax": () => AR(),
    "no-return-assign": () => TR(),
    "no-return-await": () => bR(),
    "no-script-url": () => xR(),
    "no-self-assign": () => RR(),
    "no-self-compare": () => DR(),
    "no-sequences": () => LR(),
    "no-setter-return": () => _R(),
    "no-shadow": () => wR(),
    "no-shadow-restricted-names": () => kR(),
    "no-spaced-func": () => BR(),
    "no-sparse-arrays": () => PR(),
    "no-sync": () => IR(),
    "no-tabs": () => FR(),
    "no-template-curly-in-string": () => NR(),
    "no-ternary": () => OR(),
    "no-this-before-super": () => UR(),
    "no-throw-literal": () => VR(),
    "no-trailing-spaces": () => MR(),
    "no-undef": () => KR(),
    "no-undef-init": () => jR(),
    "no-undefined": () => qR(),
    "no-underscore-dangle": () => $R(),
    "no-unexpected-multiline": () => GR(),
    "no-unmodified-loop-condition": () => WR(),
    "no-unneeded-ternary": () => XR(),
    "no-unreachable": () => zR(),
    "no-unreachable-loop": () => HR(),
    "no-unsafe-finally": () => JR(),
    "no-unsafe-negation": () => QR(),
    "no-unsafe-optional-chaining": () => YR(),
    "no-unused-expressions": () => ZR(),
    "no-unused-labels": () => eD(),
    "no-unused-private-class-members": () => tD(),
    "no-unused-vars": () => rD(),
    "no-use-before-define": () => nD(),
    "no-useless-backreference": () => sD(),
    "no-useless-call": () => iD(),
    "no-useless-catch": () => aD(),
    "no-useless-computed-key": () => oD(),
    "no-useless-concat": () => lD(),
    "no-useless-constructor": () => uD(),
    "no-useless-escape": () => cD(),
    "no-useless-rename": () => fD(),
    "no-useless-return": () => pD(),
    "no-var": () => hD(),
    "no-void": () => mD(),
    "no-warning-comments": () => gD(),
    "no-whitespace-before-property": () => dD(),
    "no-with": () => ED(),
    "nonblock-statement-body-position": () => yD(),
    "object-curly-newline": () => CD(),
    "object-curly-spacing": () => vD(),
    "object-property-newline": () => SD(),
    "object-shorthand": () => AD(),
    "one-var": () => TD(),
    "one-var-declaration-per-line": () => bD(),
    "operator-assignment": () => xD(),
    "operator-linebreak": () => RD(),
    "padded-blocks": () => DD(),
    "padding-line-between-statements": () => LD(),
    "prefer-arrow-callback": () => _D(),
    "prefer-const": () => wD(),
    "prefer-destructuring": () => kD(),
    "prefer-exponentiation-operator": () => BD(),
    "prefer-named-capture-group": () => PD(),
    "prefer-numeric-literals": () => ID(),
    "prefer-object-has-own": () => FD(),
    "prefer-object-spread": () => ND(),
    "prefer-promise-reject-errors": () => OD(),
    "prefer-reflect": () => UD(),
    "prefer-regex-literals": () => VD(),
    "prefer-rest-params": () => MD(),
    "prefer-spread": () => KD(),
    "prefer-template": () => jD(),
    "quote-props": () => qD(),
    quotes: () => $D(),
    radix: () => GD(),
    "require-atomic-updates": () => WD(),
    "require-await": () => XD(),
    "require-jsdoc": () => zD(),
    "require-unicode-regexp": () => HD(),
    "require-yield": () => JD(),
    "rest-spread-spacing": () => QD(),
    semi: () => YD(),
    "semi-spacing": () => ZD(),
    "semi-style": () => eL(),
    "sort-imports": () => tL(),
    "sort-keys": () => nL(),
    "sort-vars": () => sL(),
    "space-before-blocks": () => iL(),
    "space-before-function-paren": () => aL(),
    "space-in-parens": () => oL(),
    "space-infix-ops": () => lL(),
    "space-unary-ops": () => uL(),
    "spaced-comment": () => cL(),
    strict: () => fL(),
    "switch-colon-spacing": () => pL(),
    "symbol-description": () => hL(),
    "template-curly-spacing": () => mL(),
    "template-tag-spacing": () => gL(),
    "unicode-bom": () => dL(),
    "use-isnan": () => EL(),
    "valid-jsdoc": () => AL(),
    "valid-typeof": () => TL(),
    "vars-on-top": () => bL(),
    "wrap-iife": () => xL(),
    "wrap-regex": () => RL(),
    "yield-star-spacing": () => DL(),
    yoda: () => LL()
  })), Yc;
}
var Zc, cC;
function _L() {
  if (cC) return Zc;
  cC = 1;
  const i = wv();
  function t(f) {
    return typeof f == "function" ? Object.assign({ create: f }, f) : f;
  }
  class o {
    constructor() {
      this._rules = /* @__PURE__ */ Object.create(null);
    }
    /**
     * Registers a rule module for rule id in storage.
     * @param {string} ruleId Rule id (file name).
     * @param {Function} ruleModule Rule handler.
     * @returns {void}
     */
    define(r, u) {
      this._rules[r] = t(u);
    }
    /**
     * Access rule handler by id (file name).
     * @param {string} ruleId Rule id (file name).
     * @returns {{create: Function, schema: JsonSchema[]}}
     * A rule. This is normalized to always have the new-style shape with a `create` method.
     */
    get(r) {
      return typeof this._rules[r] == "string" && this.define(r, qA(this._rules[r])), this._rules[r] ? this._rules[r] : i.has(r) ? i.get(r) : null;
    }
    *[Symbol.iterator]() {
      yield* i;
      for (const r of Object.keys(this._rules))
        yield [r, this.get(r)];
    }
  }
  return Zc = o, Zc;
}
var ef, fC;
function wL() {
  return fC || (fC = 1, ef = () => {
    const i = /* @__PURE__ */ Object.create(null);
    return Object.freeze({
      on(t, o) {
        t in i ? i[t].push(o) : i[t] = [o];
      },
      emit(t, ...o) {
        t in i && i[t].forEach((f) => f(...o));
      },
      eventNames() {
        return Object.keys(i);
      }
    });
  }), ef;
}
var tf, pC;
function kL() {
  if (pC) return tf;
  pC = 1;
  const i = vr()("eslint:source-code-fixer"), t = "\uFEFF";
  function o(u, e) {
    return u.fix.range[0] - e.fix.range[0] || u.fix.range[1] - e.fix.range[1];
  }
  function f(u, e) {
    return u.line - e.line || u.column - e.column;
  }
  function r() {
    Object.freeze(this);
  }
  return r.applyFixes = function(u, e, a) {
    if (i("Applying fixes"), a === !1)
      return i("shouldFix parameter was false, not attempting fixes"), {
        fixed: !1,
        messages: e,
        output: u
      };
    const n = [], p = [], m = u.startsWith(t) ? t : "", h = m ? u.slice(1) : u;
    let l = Number.NEGATIVE_INFINITY, s = m;
    function c(g) {
      const d = g.fix, y = d.range[0], v = d.range[1];
      return l >= y || y > v ? (n.push(g), !1) : ((y < 0 && v >= 0 || y === 0 && d.text.startsWith(t)) && (s = ""), s += h.slice(Math.max(0, l), Math.max(0, y)), s += d.text, l = v, !0);
    }
    if (e.forEach((g) => {
      Object.prototype.hasOwnProperty.call(g, "fix") ? p.push(g) : n.push(g);
    }), p.length) {
      i("Found fixes to apply");
      let g = !1;
      for (const d of p.sort(o))
        typeof a != "function" || a(d) ? (c(d), g = !0) : n.push(d);
      return s += h.slice(Math.max(0, l)), {
        fixed: g,
        messages: n.sort(f),
        output: s
      };
    }
    return i("No fixes to apply"), {
      fixed: !1,
      messages: e,
      output: m + h
    };
  }, tf = r, tf;
}
var rf, hC;
function BL() {
  if (hC) return rf;
  hC = 1;
  function i(a, n, p) {
    return a + new Array(n - a.length + 1).join(p || " ");
  }
  function t(a, n, p) {
    return new Array(n - a.length + 1).join(p || " ") + a;
  }
  const o = !!process.env.TIMING, f = ["Rule", "Time (ms)", "Relative"], r = [i, t, t];
  function u() {
    if (typeof process.env.TIMING != "string")
      return 10;
    if (process.env.TIMING.toLowerCase() === "all")
      return Number.POSITIVE_INFINITY;
    const n = Number.parseInt(process.env.TIMING, 10);
    return n > 10 ? n : 10;
  }
  function e(a) {
    let n = 0;
    const p = Object.keys(a).map((l) => {
      const s = a[l];
      return n += s, [l, s];
    }).sort((l, s) => s[1] - l[1]).slice(0, u());
    p.forEach((l) => {
      l.push(`${(l[1] * 100 / n).toFixed(1)}%`), l[1] = l[1].toFixed(3);
    }), p.unshift(f);
    const m = [];
    p.forEach((l) => {
      const s = l.length;
      for (let c = 0; c < s; c++) {
        const g = l[c].length;
        (!m[c] || g > m[c]) && (m[c] = g);
      }
    });
    const h = p.map((l) => l.map((s, c) => r[c](s, m[c])).join(" | "));
    h.splice(1, 0, m.map((l, s) => {
      const c = s !== 0 && s !== m.length - 1 ? 2 : 1;
      return r[s](":", l + c, "-");
    }).join("|")), console.log(h.join(`
`));
  }
  return rf = function() {
    const a = /* @__PURE__ */ Object.create(null);
    function n(p, m) {
      return typeof a[p] > "u" && (a[p] = 0), function(...h) {
        let l = process.hrtime();
        const s = m(...h);
        return l = process.hrtime(l), a[p] += l[0] * 1e3 + l[1] / 1e6, s;
      };
    }
    return o && process.on("exit", () => {
      e(a);
    }), {
      time: n,
      enabled: o,
      getListSize: u
    };
  }(), rf;
}
var PL = {
  "generator-star": [
    "generator-star-spacing"
  ],
  "global-strict": [
    "strict"
  ],
  "no-arrow-condition": [
    "no-confusing-arrow",
    "no-constant-condition"
  ],
  "no-comma-dangle": [
    "comma-dangle"
  ],
  "no-empty-class": [
    "no-empty-character-class"
  ],
  "no-empty-label": [
    "no-labels"
  ],
  "no-extra-strict": [
    "strict"
  ],
  "no-reserved-keys": [
    "quote-props"
  ],
  "no-space-before-semi": [
    "semi-spacing"
  ],
  "no-wrap-func": [
    "no-extra-parens"
  ],
  "space-after-function-name": [
    "space-before-function-paren"
  ],
  "space-after-keywords": [
    "keyword-spacing"
  ],
  "space-before-function-parentheses": [
    "space-before-function-paren"
  ],
  "space-before-keywords": [
    "keyword-spacing"
  ],
  "space-in-brackets": [
    "object-curly-spacing",
    "array-bracket-spacing",
    "computed-property-spacing"
  ],
  "space-return-throw-case": [
    "keyword-spacing"
  ],
  "space-unary-word-ops": [
    "space-unary-ops"
  ],
  "spaced-line-comment": [
    "spaced-comment"
  ]
}, kv = {
  rules: PL
}, nf, mC;
function Bv() {
  if (mC) return nf;
  mC = 1;
  function i(f) {
    let r, u;
    return f.includes("/") ? (f.startsWith("@") ? r = f.slice(0, f.lastIndexOf("/")) : r = f.slice(0, f.indexOf("/")), u = f.slice(r.length + 1)) : (r = "@", u = f), {
      pluginName: r,
      ruleName: u
    };
  }
  function t(f, r) {
    const { pluginName: u, ruleName: e } = i(f), a = r.plugins && r.plugins[u];
    let n = a && a.rules && a.rules[e];
    return n && typeof n == "function" && (n = {
      create: n
    }), n;
  }
  function o(f) {
    if (!f)
      return null;
    const r = f.schema || f.meta && f.meta.schema;
    return Array.isArray(r) ? r.length ? {
      type: "array",
      items: r,
      minItems: 0,
      maxItems: r.length
    } : {
      type: "array",
      minItems: 0,
      maxItems: 0
    } : r || null;
  }
  return nf = {
    parseRuleId: i,
    getRuleFromConfig: t,
    getRuleOptionsSchema: o
  }, nf;
}
var sf = {}, an = {}, af, gC;
function IL() {
  if (gC) return af;
  gC = 1, af = function(t, o) {
    for (var f = [], r = 0; r < t.length; r++) {
      var u = o(t[r], r);
      i(u) ? f.push.apply(f, u) : f.push(u);
    }
    return f;
  };
  var i = Array.isArray || function(t) {
    return Object.prototype.toString.call(t) === "[object Array]";
  };
  return af;
}
var of, dC;
function FL() {
  if (dC) return of;
  dC = 1, of = i;
  function i(f, r, u) {
    f instanceof RegExp && (f = t(f, u)), r instanceof RegExp && (r = t(r, u));
    var e = o(f, r, u);
    return e && {
      start: e[0],
      end: e[1],
      pre: u.slice(0, e[0]),
      body: u.slice(e[0] + f.length, e[1]),
      post: u.slice(e[1] + r.length)
    };
  }
  function t(f, r) {
    var u = r.match(f);
    return u ? u[0] : null;
  }
  i.range = o;
  function o(f, r, u) {
    var e, a, n, p, m, h = u.indexOf(f), l = u.indexOf(r, h + 1), s = h;
    if (h >= 0 && l > 0) {
      for (e = [], n = u.length; s >= 0 && !m; )
        s == h ? (e.push(s), h = u.indexOf(f, s + 1)) : e.length == 1 ? m = [e.pop(), l] : (a = e.pop(), a < n && (n = a, p = l), l = u.indexOf(r, s + 1)), s = h < l && h >= 0 ? h : l;
      e.length && (m = [n, p]);
    }
    return m;
  }
  return of;
}
var lf, EC;
function NL() {
  if (EC) return lf;
  EC = 1;
  var i = IL(), t = FL();
  lf = h;
  var o = "\0SLASH" + Math.random() + "\0", f = "\0OPEN" + Math.random() + "\0", r = "\0CLOSE" + Math.random() + "\0", u = "\0COMMA" + Math.random() + "\0", e = "\0PERIOD" + Math.random() + "\0";
  function a(y) {
    return parseInt(y, 10) == y ? parseInt(y, 10) : y.charCodeAt(0);
  }
  function n(y) {
    return y.split("\\\\").join(o).split("\\{").join(f).split("\\}").join(r).split("\\,").join(u).split("\\.").join(e);
  }
  function p(y) {
    return y.split(o).join("\\").split(f).join("{").split(r).join("}").split(u).join(",").split(e).join(".");
  }
  function m(y) {
    if (!y)
      return [""];
    var v = [], T = t("{", "}", y);
    if (!T)
      return y.split(",");
    var b = T.pre, S = T.body, C = T.post, x = b.split(",");
    x[x.length - 1] += "{" + S + "}";
    var A = m(C);
    return C.length && (x[x.length - 1] += A.shift(), x.push.apply(x, A)), v.push.apply(v, x), v;
  }
  function h(y) {
    return y ? (y.substr(0, 2) === "{}" && (y = "\\{\\}" + y.substr(2)), d(n(y), !0).map(p)) : [];
  }
  function l(y) {
    return "{" + y + "}";
  }
  function s(y) {
    return /^-?0\d/.test(y);
  }
  function c(y, v) {
    return y <= v;
  }
  function g(y, v) {
    return y >= v;
  }
  function d(y, v) {
    var T = [], b = t("{", "}", y);
    if (!b || /\$$/.test(b.pre)) return [y];
    var S = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(b.body), C = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(b.body), x = S || C, A = b.body.indexOf(",") >= 0;
    if (!x && !A)
      return b.post.match(/,.*\}/) ? (y = b.pre + "{" + b.body + r + b.post, d(y)) : [y];
    var R;
    if (x)
      R = b.body.split(/\.\./);
    else if (R = m(b.body), R.length === 1 && (R = d(R[0], !1).map(l), R.length === 1)) {
      var _ = b.post.length ? d(b.post, !1) : [""];
      return _.map(function(N) {
        return b.pre + R[0] + N;
      });
    }
    var L = b.pre, _ = b.post.length ? d(b.post, !1) : [""], I;
    if (x) {
      var O = a(R[0]), k = a(R[1]), w = Math.max(R[0].length, R[1].length), U = R.length == 3 ? Math.abs(a(R[2])) : 1, q = c, F = k < O;
      F && (U *= -1, q = g);
      var $ = R.some(s);
      I = [];
      for (var P = O; q(P, k); P += U) {
        var X;
        if (C)
          X = String.fromCharCode(P), X === "\\" && (X = "");
        else if (X = String(P), $) {
          var Q = w - X.length;
          if (Q > 0) {
            var ue = new Array(Q + 1).join("0");
            P < 0 ? X = "-" + ue + X.slice(1) : X = ue + X;
          }
        }
        I.push(X);
      }
    } else
      I = i(R, function(H) {
        return d(H, !1);
      });
    for (var le = 0; le < I.length; le++)
      for (var Ce = 0; Ce < _.length; Ce++) {
        var j = L + I[le] + _[Ce];
        (!v || x || j) && T.push(j);
      }
    return T;
  }
  return lf;
}
var uf, yC;
function OL() {
  if (yC) return uf;
  yC = 1, uf = s, s.Minimatch = c;
  var i = function() {
    try {
      return cn;
    } catch {
    }
  }() || {
    sep: "/"
  };
  s.sep = i.sep;
  var t = s.GLOBSTAR = c.GLOBSTAR = {}, o = NL(), f = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, r = "[^/]", u = r + "*?", e = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", a = "(?:(?!(?:\\/|^)\\.).)*?", n = p("().*{}+?[]^$\\!");
  function p(R) {
    return R.split("").reduce(function(L, _) {
      return L[_] = !0, L;
    }, {});
  }
  var m = /\/+/;
  s.filter = h;
  function h(R, L) {
    return L = L || {}, function(_, I, O) {
      return s(_, R, L);
    };
  }
  function l(R, L) {
    L = L || {};
    var _ = {};
    return Object.keys(R).forEach(function(I) {
      _[I] = R[I];
    }), Object.keys(L).forEach(function(I) {
      _[I] = L[I];
    }), _;
  }
  s.defaults = function(R) {
    if (!R || typeof R != "object" || !Object.keys(R).length)
      return s;
    var L = s, _ = function(O, k, w) {
      return L(O, k, l(R, w));
    };
    return _.Minimatch = function(O, k) {
      return new L.Minimatch(O, l(R, k));
    }, _.Minimatch.defaults = function(O) {
      return L.defaults(l(R, O)).Minimatch;
    }, _.filter = function(O, k) {
      return L.filter(O, l(R, k));
    }, _.defaults = function(O) {
      return L.defaults(l(R, O));
    }, _.makeRe = function(O, k) {
      return L.makeRe(O, l(R, k));
    }, _.braceExpand = function(O, k) {
      return L.braceExpand(O, l(R, k));
    }, _.match = function(I, O, k) {
      return L.match(I, O, l(R, k));
    }, _;
  }, c.defaults = function(R) {
    return s.defaults(R).Minimatch;
  };
  function s(R, L, _) {
    return T(L), _ || (_ = {}), !_.nocomment && L.charAt(0) === "#" ? !1 : new c(L, _).match(R);
  }
  function c(R, L) {
    if (!(this instanceof c))
      return new c(R, L);
    T(R), L || (L = {}), R = R.trim(), !L.allowWindowsEscape && i.sep !== "/" && (R = R.split(i.sep).join("/")), this.options = L, this.set = [], this.pattern = R, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!L.partial, this.make();
  }
  c.prototype.debug = function() {
  }, c.prototype.make = g;
  function g() {
    var R = this.pattern, L = this.options;
    if (!L.nocomment && R.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!R) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var _ = this.globSet = this.braceExpand();
    L.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, _), _ = this.globParts = _.map(function(I) {
      return I.split(m);
    }), this.debug(this.pattern, _), _ = _.map(function(I, O, k) {
      return I.map(this.parse, this);
    }, this), this.debug(this.pattern, _), _ = _.filter(function(I) {
      return I.indexOf(!1) === -1;
    }), this.debug(this.pattern, _), this.set = _;
  }
  c.prototype.parseNegate = d;
  function d() {
    var R = this.pattern, L = !1, _ = this.options, I = 0;
    if (!_.nonegate) {
      for (var O = 0, k = R.length; O < k && R.charAt(O) === "!"; O++)
        L = !L, I++;
      I && (this.pattern = R.substr(I)), this.negate = L;
    }
  }
  s.braceExpand = function(R, L) {
    return y(R, L);
  }, c.prototype.braceExpand = y;
  function y(R, L) {
    return L || (this instanceof c ? L = this.options : L = {}), R = typeof R > "u" ? this.pattern : R, T(R), L.nobrace || !/\{(?:(?!\{).)*\}/.test(R) ? [R] : o(R);
  }
  var v = 1024 * 64, T = function(R) {
    if (typeof R != "string")
      throw new TypeError("invalid pattern");
    if (R.length > v)
      throw new TypeError("pattern is too long");
  };
  c.prototype.parse = S;
  var b = {};
  function S(R, L) {
    T(R);
    var _ = this.options;
    if (R === "**")
      if (_.noglobstar)
        R = "*";
      else
        return t;
    if (R === "") return "";
    var I = "", O = !!_.nocase, k = !1, w = [], U = [], q, F = !1, $ = -1, P = -1, X = R.charAt(0) === "." ? "" : _.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", Q = this;
    function ue() {
      if (q) {
        switch (q) {
          case "*":
            I += u, O = !0;
            break;
          case "?":
            I += r, O = !0;
            break;
          default:
            I += "\\" + q;
            break;
        }
        Q.debug("clearStateChar %j %j", q, I), q = !1;
      }
    }
    for (var le = 0, Ce = R.length, j; le < Ce && (j = R.charAt(le)); le++) {
      if (this.debug("%s	%s %s %j", R, le, I, j), k && n[j]) {
        I += "\\" + j, k = !1;
        continue;
      }
      switch (j) {
        case "/":
          return !1;
        case "\\":
          ue(), k = !0;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", R, le, I, j), F) {
            this.debug("  in class"), j === "!" && le === P + 1 && (j = "^"), I += j;
            continue;
          }
          Q.debug("call clearStateChar %j", q), ue(), q = j, _.noext && ue();
          continue;
        case "(":
          if (F) {
            I += "(";
            continue;
          }
          if (!q) {
            I += "\\(";
            continue;
          }
          w.push({
            type: q,
            start: le - 1,
            reStart: I.length,
            open: f[q].open,
            close: f[q].close
          }), I += q === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", q, I), q = !1;
          continue;
        case ")":
          if (F || !w.length) {
            I += "\\)";
            continue;
          }
          ue(), O = !0;
          var H = w.pop();
          I += H.close, H.type === "!" && U.push(H), H.reEnd = I.length;
          continue;
        case "|":
          if (F || !w.length || k) {
            I += "\\|", k = !1;
            continue;
          }
          ue(), I += "|";
          continue;
        case "[":
          if (ue(), F) {
            I += "\\" + j;
            continue;
          }
          F = !0, P = le, $ = I.length, I += j;
          continue;
        case "]":
          if (le === P + 1 || !F) {
            I += "\\" + j, k = !1;
            continue;
          }
          var N = R.substring(P + 1, le);
          try {
            RegExp("[" + N + "]");
          } catch {
            var G = this.parse(N, b);
            I = I.substr(0, $) + "\\[" + G[0] + "\\]", O = O || G[1], F = !1;
            continue;
          }
          O = !0, F = !1, I += j;
          continue;
        default:
          ue(), k ? k = !1 : n[j] && !(j === "^" && F) && (I += "\\"), I += j;
      }
    }
    for (F && (N = R.substr(P + 1), G = this.parse(N, b), I = I.substr(0, $) + "\\[" + G[0], O = O || G[1]), H = w.pop(); H; H = w.pop()) {
      var M = I.slice(H.reStart + H.open.length);
      this.debug("setting tail", I, H), M = M.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(ot, Ct, dt) {
        return dt || (dt = "\\"), Ct + Ct + dt + "|";
      }), this.debug(`tail=%j
   %s`, M, M, H, I);
      var Z = H.type === "*" ? u : H.type === "?" ? r : "\\" + H.type;
      O = !0, I = I.slice(0, H.reStart) + Z + "\\(" + M;
    }
    ue(), k && (I += "\\\\");
    var Ee = !1;
    switch (I.charAt(0)) {
      case "[":
      case ".":
      case "(":
        Ee = !0;
    }
    for (var ke = U.length - 1; ke > -1; ke--) {
      var Ie = U[ke], Je = I.slice(0, Ie.reStart), at = I.slice(Ie.reStart, Ie.reEnd - 8), lt = I.slice(Ie.reEnd - 8, Ie.reEnd), mt = I.slice(Ie.reEnd);
      lt += mt;
      var Y = Je.split("(").length - 1, Te = mt;
      for (le = 0; le < Y; le++)
        Te = Te.replace(/\)[+*?]?/, "");
      mt = Te;
      var Ke = "";
      mt === "" && L !== b && (Ke = "$");
      var et = Je + at + mt + Ke + lt;
      I = et;
    }
    if (I !== "" && O && (I = "(?=.)" + I), Ee && (I = X + I), L === b)
      return [I, O];
    if (!O)
      return x(R);
    var nt = _.nocase ? "i" : "";
    try {
      var rt = new RegExp("^" + I + "$", nt);
    } catch {
      return new RegExp("$.");
    }
    return rt._glob = R, rt._src = I, rt;
  }
  s.makeRe = function(R, L) {
    return new c(R, L || {}).makeRe();
  }, c.prototype.makeRe = C;
  function C() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var R = this.set;
    if (!R.length)
      return this.regexp = !1, this.regexp;
    var L = this.options, _ = L.noglobstar ? u : L.dot ? e : a, I = L.nocase ? "i" : "", O = R.map(function(k) {
      return k.map(function(w) {
        return w === t ? _ : typeof w == "string" ? A(w) : w._src;
      }).join("\\/");
    }).join("|");
    O = "^(?:" + O + ")$", this.negate && (O = "^(?!" + O + ").*$");
    try {
      this.regexp = new RegExp(O, I);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  s.match = function(R, L, _) {
    _ = _ || {};
    var I = new c(L, _);
    return R = R.filter(function(O) {
      return I.match(O);
    }), I.options.nonull && !R.length && R.push(L), R;
  }, c.prototype.match = function(L, _) {
    if (typeof _ > "u" && (_ = this.partial), this.debug("match", L, this.pattern), this.comment) return !1;
    if (this.empty) return L === "";
    if (L === "/" && _) return !0;
    var I = this.options;
    i.sep !== "/" && (L = L.split(i.sep).join("/")), L = L.split(m), this.debug(this.pattern, "split", L);
    var O = this.set;
    this.debug(this.pattern, "set", O);
    var k, w;
    for (w = L.length - 1; w >= 0 && (k = L[w], !k); w--)
      ;
    for (w = 0; w < O.length; w++) {
      var U = O[w], q = L;
      I.matchBase && U.length === 1 && (q = [k]);
      var F = this.matchOne(q, U, _);
      if (F)
        return I.flipNegate ? !0 : !this.negate;
    }
    return I.flipNegate ? !1 : this.negate;
  }, c.prototype.matchOne = function(R, L, _) {
    var I = this.options;
    this.debug(
      "matchOne",
      { this: this, file: R, pattern: L }
    ), this.debug("matchOne", R.length, L.length);
    for (var O = 0, k = 0, w = R.length, U = L.length; O < w && k < U; O++, k++) {
      this.debug("matchOne loop");
      var q = L[k], F = R[O];
      if (this.debug(L, q, F), q === !1) return !1;
      if (q === t) {
        this.debug("GLOBSTAR", [L, q, F]);
        var $ = O, P = k + 1;
        if (P === U) {
          for (this.debug("** at the end"); O < w; O++)
            if (R[O] === "." || R[O] === ".." || !I.dot && R[O].charAt(0) === ".") return !1;
          return !0;
        }
        for (; $ < w; ) {
          var X = R[$];
          if (this.debug(`
globstar while`, R, $, L, P, X), this.matchOne(R.slice($), L.slice(P), _))
            return this.debug("globstar found match!", $, w, X), !0;
          if (X === "." || X === ".." || !I.dot && X.charAt(0) === ".") {
            this.debug("dot detected!", R, $, L, P);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), $++;
        }
        return !!(_ && (this.debug(`
>>> no match, partial?`, R, $, L, P), $ === w));
      }
      var Q;
      if (typeof q == "string" ? (Q = F === q, this.debug("string match", q, F, Q)) : (Q = F.match(q), this.debug("pattern match", q, F, Q)), !Q) return !1;
    }
    if (O === w && k === U)
      return !0;
    if (O === w)
      return _;
    if (k === U)
      return O === w - 1 && R[O] === "";
    throw new Error("wtf?");
  };
  function x(R) {
    return R.replace(/\\(.)/g, "$1");
  }
  function A(R) {
    return R.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return uf;
}
var Or = {}, cf = {}, ff = {}, CC;
function Pv() {
  if (CC) return ff;
  CC = 1;
  class i {
    /**
     * Merges two keys by overwriting the first with the second.
     * @param {*} value1 The value from the first object key. 
     * @param {*} value2 The value from the second object key.
     * @returns {*} The second value.
     */
    static overwrite(o, f) {
      return f;
    }
    /**
     * Merges two keys by replacing the first with the second only if the
     * second is defined.
     * @param {*} value1 The value from the first object key. 
     * @param {*} value2 The value from the second object key.
     * @returns {*} The second value if it is defined.
     */
    static replace(o, f) {
      return typeof f < "u" ? f : o;
    }
    /**
     * Merges two properties by assigning properties from the second to the first.
     * @param {*} value1 The value from the first object key.
     * @param {*} value2 The value from the second object key.
     * @returns {*} A new object containing properties from both value1 and
     *      value2.
     */
    static assign(o, f) {
      return Object.assign({}, o, f);
    }
  }
  return ff.MergeStrategy = i, ff;
}
var pf = {}, vC;
function Iv() {
  if (vC) return pf;
  vC = 1;
  class i {
    /**
     * Validates that a value is an array.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static array(o) {
      if (!Array.isArray(o))
        throw new TypeError("Expected an array.");
    }
    /**
     * Validates that a value is a boolean.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static boolean(o) {
      if (typeof o != "boolean")
        throw new TypeError("Expected a Boolean.");
    }
    /**
     * Validates that a value is a number.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static number(o) {
      if (typeof o != "number")
        throw new TypeError("Expected a number.");
    }
    /**
     * Validates that a value is a object.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static object(o) {
      if (!o || typeof o != "object")
        throw new TypeError("Expected an object.");
    }
    /**
     * Validates that a value is a object or null.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static "object?"(o) {
      if (typeof o != "object")
        throw new TypeError("Expected an object or null.");
    }
    /**
     * Validates that a value is a string.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static string(o) {
      if (typeof o != "string")
        throw new TypeError("Expected a string.");
    }
    /**
     * Validates that a value is a non-empty string.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid. 
     */
    static "string!"(o) {
      if (typeof o != "string" || o.length === 0)
        throw new TypeError("Expected a non-empty string.");
    }
  }
  return pf.ValidationStrategy = i, pf;
}
var SC;
function UL() {
  if (SC) return cf;
  SC = 1;
  const { MergeStrategy: i } = Pv(), { ValidationStrategy: t } = Iv(), o = Symbol("strategies"), f = Symbol("requiredKeys");
  function r(m, h) {
    let l = !1;
    if (h.schema)
      if (typeof h.schema == "object")
        l = !0;
      else
        throw new TypeError("Schema must be an object.");
    if (typeof h.merge == "string") {
      if (!(h.merge in i))
        throw new TypeError(`Definition for key "${m}" missing valid merge strategy.`);
    } else if (!l && typeof h.merge != "function")
      throw new TypeError(`Definition for key "${m}" must have a merge property.`);
    if (typeof h.validate == "string") {
      if (!(h.validate in t))
        throw new TypeError(`Definition for key "${m}" missing valid validation strategy.`);
    } else if (!l && typeof h.validate != "function")
      throw new TypeError(`Definition for key "${m}" must have a validate() method.`);
  }
  class u extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was unexpected. 
     */
    constructor(h) {
      super(`Unexpected key "${h}" found.`);
    }
  }
  class e extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was missing. 
     */
    constructor(h) {
      super(`Missing required key "${h}".`);
    }
  }
  class a extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was unexpected.
     * @param {Array<string>} requiredKeys The keys that are required.
     */
    constructor(h, l) {
      super(`Key "${h}" requires keys "${l.join('", "')}".`);
    }
  }
  class n extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The object key causing the error. 
     * @param {Error} source The source error. 
     */
    constructor(h, l) {
      super(`Key "${h}": ${l.message}`, { cause: l });
      for (const s of Object.keys(l))
        s in this || (this[s] = l[s]);
    }
  }
  class p {
    /**
     * Creates a new instance.
     */
    constructor(h) {
      if (!h)
        throw new Error("Schema definitions missing.");
      this[o] = /* @__PURE__ */ new Map(), this[f] = /* @__PURE__ */ new Map();
      for (const l of Object.keys(h)) {
        if (r(l, h[l]), typeof h[l].schema == "object") {
          const s = new p(h[l].schema);
          h[l] = {
            ...h[l],
            merge(c = {}, g = {}) {
              return s.merge(c, g);
            },
            validate(c) {
              t.object(c), s.validate(c);
            }
          };
        }
        typeof h[l].merge == "string" && (h[l] = {
          ...h[l],
          merge: i[h[l].merge]
        }), typeof h[l].validate == "string" && (h[l] = {
          ...h[l],
          validate: t[h[l].validate]
        }), this[o].set(l, h[l]), h[l].required && this[f].set(l, h[l]);
      }
    }
    /**
     * Determines if a strategy has been registered for the given object key.
     * @param {string} key The object key to find a strategy for.
     * @returns {boolean} True if the key has a strategy registered, false if not. 
     */
    hasKey(h) {
      return this[o].has(h);
    }
    /**
     * Merges objects together to create a new object comprised of the keys
     * of the all objects. Keys are merged based on the each key's merge
     * strategy.
     * @param {...Object} objects The objects to merge.
     * @returns {Object} A new object with a mix of all objects' keys.
     * @throws {Error} If any object is invalid.
     */
    merge(...h) {
      if (h.length < 2)
        throw new TypeError("merge() requires at least two arguments.");
      if (h.some((l) => l == null || typeof l != "object"))
        throw new TypeError("All arguments must be objects.");
      return h.reduce((l, s) => {
        this.validate(s);
        for (const [c, g] of this[o])
          try {
            if (c in l || c in s) {
              const d = g.merge.call(this, l[c], s[c]);
              d !== void 0 && (l[c] = d);
            }
          } catch (d) {
            throw new n(c, d);
          }
        return l;
      }, {});
    }
    /**
     * Validates an object's keys based on the validate strategy for each key.
     * @param {Object} object The object to validate.
     * @returns {void}
     * @throws {Error} When the object is invalid. 
     */
    validate(h) {
      for (const l of Object.keys(h)) {
        if (!this.hasKey(l))
          throw new u(l);
        const s = this[o].get(l);
        if (Array.isArray(s.requires) && !s.requires.every((c) => c in h))
          throw new a(l, s.requires);
        try {
          s.validate.call(s, h[l]);
        } catch (c) {
          throw new n(l, c);
        }
      }
      for (const [l] of this[f])
        if (!(l in h))
          throw new e(l);
    }
  }
  return cf.ObjectSchema = p, cf;
}
var AC;
function VL() {
  return AC || (AC = 1, Or.ObjectSchema = UL().ObjectSchema, Or.MergeStrategy = Pv().MergeStrategy, Or.ValidationStrategy = Iv().ValidationStrategy), Or;
}
var TC;
function ML() {
  if (TC) return an;
  TC = 1;
  var i = cn, t = OL(), o = vr(), f = VL();
  const r = {
    required: !1,
    merge() {
    },
    validate() {
    }
  }, u = Object.freeze({
    name: {
      required: !1,
      merge() {
      },
      validate(k) {
        if (typeof k != "string")
          throw new TypeError("Property must be a string.");
      }
    },
    files: r,
    ignores: r
  });
  function e(k) {
    if (!Array.isArray(k))
      throw new TypeError("Expected value to be an array.");
  }
  function a(k, w) {
    if (e(k), k.some((U) => typeof U != "string" && typeof U != "function"))
      throw new TypeError("Expected array to only contain strings and functions.");
  }
  function n(k) {
    if (!Array.isArray(k) || k.length === 0)
      throw new TypeError("Expected value to be a non-empty array.");
  }
  const p = Object.freeze({
    files: {
      required: !1,
      merge() {
      },
      validate(k) {
        n(k), k.forEach((w) => {
          if (Array.isArray(w))
            a(w);
          else if (typeof w != "string" && typeof w != "function")
            throw new TypeError("Items must be a string, a function, or an array of strings and functions.");
        });
      }
    },
    ignores: {
      required: !1,
      merge() {
      },
      validate: a
    }
  }), m = t.Minimatch, h = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), s = o("@hwc/config-array"), c = {
    // matchBase: true,
    dot: !0
  }, g = /* @__PURE__ */ new Set(["array", "function"]), d = new f.ObjectSchema(p);
  function y(k) {
    return typeof k == "string";
  }
  function v(k) {
    if (!k || typeof k != "object")
      return;
    const w = {};
    "files" in k && (w.files = k.files), "ignores" in k && (w.ignores = k.ignores), d.validate(w);
  }
  function T(k, w, U = {}) {
    let q = h;
    U.flipNegate && (q = l);
    let F = q.get(w);
    return F || (F = new m(w, Object.assign({}, c, U)), q.set(w, F)), F.match(k);
  }
  async function b(k, w, U) {
    const q = U.includes("function"), F = U.includes("array");
    async function* $(Q) {
      for (let ue of Q) {
        if (typeof ue == "function") {
          if (!q)
            throw new TypeError("Unexpected function.");
          ue = ue(w), ue.then && (ue = await ue);
        }
        if (Array.isArray(ue)) {
          if (!F)
            throw new TypeError("Unexpected array.");
          yield* $(ue);
        } else {
          if (typeof ue == "function")
            throw new TypeError("A config function can only return an object or array.");
          yield ue;
        }
      }
    }
    const P = await $(k), X = [];
    for await (const Q of P)
      X.push(Q);
    return X;
  }
  function S(k, w, U) {
    const q = U.includes("function"), F = U.includes("array");
    function* $(P) {
      for (let X of P) {
        if (typeof X == "function") {
          if (!q)
            throw new TypeError("Unexpected function.");
          if (X = X(w), X.then)
            throw new TypeError("Async config functions are not supported.");
        }
        if (Array.isArray(X)) {
          if (!F)
            throw new TypeError("Unexpected array.");
          yield* $(X);
        } else {
          if (typeof X == "function")
            throw new TypeError("A config function can only return an object or array.");
          yield X;
        }
      }
    }
    return [...$(k)];
  }
  function C(k, w, U) {
    return U.startsWith("..") ? !0 : k.reduce((q, F) => q ? typeof F == "string" && F.startsWith("!") ? !T(U, F, {
      flipNegate: !0
    }) : q : typeof F == "function" ? F(w) : F.startsWith("!") ? !1 : T(U, F), !1);
  }
  function x(k, w, U) {
    const q = i.relative(w, k);
    return Object.keys(U).length > 1 && !C(U.ignores, k, q);
  }
  function A(k, w, U) {
    const q = i.relative(w, k), F = (P) => {
      if (y(P))
        return T(q, P);
      if (typeof P == "function")
        return P(k);
      throw new TypeError(`Unexpected matcher type ${P}.`);
    };
    let $ = U.files.some((P) => Array.isArray(P) ? P.every(F) : F(P));
    return $ && U.ignores && ($ = !C(U.ignores, k, q)), $;
  }
  function R(k) {
    if (!k.isNormalized())
      throw new Error("ConfigArray must be normalized to perform this operation.");
  }
  function L(k) {
    if (k.length > 2)
      throw new TypeError("configTypes must be an array with at most two items.");
    for (const w of k)
      if (!g.has(w))
        throw new TypeError(`Unexpected config type "${w}" found. Expected one of: "object", "array", "function".`);
  }
  const _ = {
    isNormalized: Symbol("isNormalized"),
    configCache: Symbol("configCache"),
    schema: Symbol("schema"),
    finalizeConfig: Symbol("finalizeConfig"),
    preprocessConfig: Symbol("preprocessConfig")
  }, I = /* @__PURE__ */ new WeakMap();
  class O extends Array {
    /**
     * Creates a new instance of ConfigArray.
     * @param {Iterable|Function|Object} configs An iterable yielding config
     *      objects, or a config function, or a config object.
     * @param {string} [options.basePath=""] The path of the config file
     * @param {boolean} [options.normalized=false] Flag indicating if the
     *      configs have already been normalized.
     * @param {Object} [options.schema] The additional schema 
     *      definitions to use for the ConfigArray schema.
     * @param {Array<string>} [options.configTypes] List of config types supported.
     */
    constructor(w, {
      basePath: U = "",
      normalized: q = !1,
      schema: F,
      extraConfigTypes: $ = []
    } = {}) {
      super(), this[_.isNormalized] = q, this[_.schema] = new f.ObjectSchema(
        Object.assign({}, F, u)
      ), this.basePath = U, L($), this.extraConfigTypes = Object.freeze([...$]), this[_.configCache] = /* @__PURE__ */ new Map(), I.set(this, {
        explicitMatches: /* @__PURE__ */ new Map(),
        directoryMatches: /* @__PURE__ */ new Map(),
        files: void 0,
        ignores: void 0
      }), Array.isArray(w) ? this.push(...w) : this.push(w);
    }
    /**
     * Prevent normal array methods from creating a new `ConfigArray` instance.
     * This is to ensure that methods such as `slice()` won't try to create a 
     * new instance of `ConfigArray` behind the scenes as doing so may throw
     * an error due to the different constructor signature.
     * @returns {Function} The `Array` constructor.
     */
    static get [Symbol.species]() {
      return Array;
    }
    /**
     * Returns the `files` globs from every config object in the array.
     * This can be used to determine which files will be matched by a
     * config array or to use as a glob pattern when no patterns are provided
     * for a command line interface.
     * @returns {Array<string|Function>} An array of matchers.
     */
    get files() {
      R(this);
      const w = I.get(this);
      if (w.files)
        return w.files;
      const U = [];
      for (const q of this)
        q.files && q.files.forEach((F) => {
          U.push(F);
        });
      return w.files = U, I.set(this, w), U;
    }
    /**
     * Returns ignore matchers that should always be ignored regardless of
     * the matching `files` fields in any configs. This is necessary to mimic
     * the behavior of things like .gitignore and .eslintignore, allowing a
     * globbing operation to be faster.
     * @returns {string[]} An array of string patterns and functions to be ignored.
     */
    get ignores() {
      R(this);
      const w = I.get(this);
      if (w.ignores)
        return w.ignores;
      const U = [];
      for (const q of this)
        q.ignores && Object.keys(q).length === 1 && U.push(...q.ignores);
      return w.ignores = U, I.set(this, w), U;
    }
    /**
     * Indicates if the config array has been normalized.
     * @returns {boolean} True if the config array is normalized, false if not.
     */
    isNormalized() {
      return this[_.isNormalized];
    }
    /**
     * Normalizes a config array by flattening embedded arrays and executing
     * config functions.
     * @param {ConfigContext} context The context object for config functions.
     * @returns {Promise<ConfigArray>} The current ConfigArray instance.
     */
    async normalize(w = {}) {
      if (!this.isNormalized()) {
        const U = await b(this, w, this.extraConfigTypes);
        this.length = 0, this.push(...U.map(this[_.preprocessConfig].bind(this))), this.forEach(v), this[_.isNormalized] = !0, Object.freeze(this);
      }
      return this;
    }
    /**
     * Normalizes a config array by flattening embedded arrays and executing
     * config functions.
     * @param {ConfigContext} context The context object for config functions.
     * @returns {ConfigArray} The current ConfigArray instance.
     */
    normalizeSync(w = {}) {
      if (!this.isNormalized()) {
        const U = S(this, w, this.extraConfigTypes);
        this.length = 0, this.push(...U.map(this[_.preprocessConfig].bind(this))), this.forEach(v), this[_.isNormalized] = !0, Object.freeze(this);
      }
      return this;
    }
    /**
     * Finalizes the state of a config before being cached and returned by
     * `getConfig()`. Does nothing by default but is provided to be
     * overridden by subclasses as necessary.
     * @param {Object} config The config to finalize.
     * @returns {Object} The finalized config.
     */
    [_.finalizeConfig](w) {
      return w;
    }
    /**
     * Preprocesses a config during the normalization process. This is the
     * method to override if you want to convert an array item before it is
     * validated for the first time. For example, if you want to replace a
     * string with an object, this is the method to override.
     * @param {Object} config The config to preprocess.
     * @returns {Object} The config to use in place of the argument.
     */
    [_.preprocessConfig](w) {
      return w;
    }
    /**
     * Determines if a given file path explicitly matches a `files` entry
     * and also doesn't match an `ignores` entry. Configs that don't have
     * a `files` property are not considered an explicit match.
     * @param {string} filePath The complete path of a file to check.
     * @returns {boolean} True if the file path matches a `files` entry
     * 		or false if not.
     */
    isExplicitMatch(w) {
      R(this);
      const U = I.get(this);
      let q = U.explicitMatches.get(w);
      if (typeof q == "boolean")
        return q;
      const F = i.relative(this.basePath, w);
      if (C(this.ignores, w, F))
        return s(`Ignoring ${w}`), U.explicitMatches.set(w, !1), !1;
      for (const $ of this)
        if ($.files && A(w, this.basePath, $))
          return s(`Matching config found for ${w}`), U.explicitMatches.set(w, !0), !0;
      return !1;
    }
    /**
     * Returns the config object for a given file path.
     * @param {string} filePath The complete path of a file to get a config for.
     * @returns {Object} The config object for this file.
     */
    getConfig(w) {
      R(this);
      const U = this[_.configCache];
      if (U.has(w))
        return U.get(w);
      let q;
      if (this.isDirectoryIgnored(i.dirname(w)))
        return s(`Ignoring ${w} based on directory pattern`), U.set(w, q), q;
      const F = i.relative(this.basePath, w);
      if (C(this.ignores, w, F))
        return s(`Ignoring ${w} based on file pattern`), U.set(w, q), q;
      const $ = [];
      let P = !1;
      const X = /\/\*{1,2}$/;
      return this.forEach((Q, ue) => {
        if (!Q.files) {
          if (!Q.ignores) {
            s(`Anonymous universal config found for ${w}`), $.push(ue);
            return;
          }
          if (x(w, this.basePath, Q)) {
            s(`Matching config found for ${w} (based on ignores: ${Q.ignores})`), $.push(ue);
            return;
          }
          s(`Skipped config found for ${w} (based on ignores: ${Q.ignores})`);
          return;
        }
        const le = Q.files.filter(
          (Ce) => X.test(Ce)
        );
        if (le.length) {
          s("Universal files patterns found. Checking carefully.");
          const Ce = Q.files.filter(
            (j) => !X.test(j)
          );
          if (Ce.length && A(
            w,
            this.basePath,
            { files: Ce, ignores: Q.ignores }
          )) {
            s(`Matching config found for ${w}`), $.push(ue), P = !0;
            return;
          }
          if (le.length && A(
            w,
            this.basePath,
            { files: le, ignores: Q.ignores }
          )) {
            s(`Matching config found for ${w}`), $.push(ue);
            return;
          }
          return;
        }
        if (A(w, this.basePath, Q)) {
          s(`Matching config found for ${w}`), $.push(ue), P = !0;
          return;
        }
      }), P ? (q = U.get($.toString()), q ? (U.set(w, q), q) : (q = $.reduce((Q, ue) => this[_.schema].merge(Q, this[ue]), {}, this), q = this[_.finalizeConfig](q), U.set(w, q), U.set($.toString(), q), q)) : (s(`No matching configs found for ${w}`), U.set(w, q), q);
    }
    /**
     * Determines if the given filepath is ignored based on the configs.
     * @param {string} filePath The complete path of a file to check.
     * @returns {boolean} True if the path is ignored, false if not.
     * @deprecated Use `isFileIgnored` instead.
     */
    isIgnored(w) {
      return this.isFileIgnored(w);
    }
    /**
     * Determines if the given filepath is ignored based on the configs.
     * @param {string} filePath The complete path of a file to check.
     * @returns {boolean} True if the path is ignored, false if not.
     */
    isFileIgnored(w) {
      return this.getConfig(w) === void 0;
    }
    /**
     * Determines if the given directory is ignored based on the configs.
     * This checks only default `ignores` that don't have `files` in the 
     * same config. A pattern such as `/foo` be considered to ignore the directory
     * while a pattern such as `/foo/**` is not considered to ignore the
     * directory because it is matching files.
     * @param {string} directoryPath The complete path of a directory to check.
     * @returns {boolean} True if the directory is ignored, false if not. Will
     * 		return true for any directory that is not inside of `basePath`.
     * @throws {Error} When the `ConfigArray` is not normalized.
     */
    isDirectoryIgnored(w) {
      R(this);
      const U = i.relative(this.basePath, w).replace(/\\/g, "/");
      if (U.startsWith(".."))
        return !0;
      const q = I.get(this).directoryMatches;
      if (q.has(U))
        return q.get(U);
      const F = U.split("/");
      let $ = "", P = !1;
      do
        $ += F.shift() + "/", P = C(
          this.ignores,
          i.join(this.basePath, $),
          $
        ), q.set($, P);
      while (!P && F.length);
      return q.set(U, P), P;
    }
  }
  return an.ConfigArray = O, an.ConfigArraySymbol = _, an;
}
var hf = {}, mf = {}, Xt = {}, bC;
function Fv() {
  if (bC) return Xt;
  bC = 1;
  const i = -1;
  Xt.VOID = i;
  const t = 0;
  Xt.PRIMITIVE = t;
  const o = 1;
  Xt.ARRAY = o;
  const f = 2;
  Xt.OBJECT = f;
  const r = 3;
  Xt.DATE = r;
  const u = 4;
  Xt.REGEXP = u;
  const e = 5;
  Xt.MAP = e;
  const a = 6;
  Xt.SET = a;
  const n = 7;
  Xt.ERROR = n;
  const p = 8;
  return Xt.BIGINT = p, Xt;
}
var xC;
function KL() {
  if (xC) return mf;
  xC = 1;
  const {
    VOID: i,
    PRIMITIVE: t,
    ARRAY: o,
    OBJECT: f,
    DATE: r,
    REGEXP: u,
    MAP: e,
    SET: a,
    ERROR: n,
    BIGINT: p
  } = Fv(), m = typeof self == "object" ? self : globalThis, h = (s, c) => {
    const g = (y, v) => (s.set(v, y), y), d = (y) => {
      if (s.has(y))
        return s.get(y);
      const [v, T] = c[y];
      switch (v) {
        case t:
        case i:
          return g(T, y);
        case o: {
          const b = g([], y);
          for (const S of T)
            b.push(d(S));
          return b;
        }
        case f: {
          const b = g({}, y);
          for (const [S, C] of T)
            b[d(S)] = d(C);
          return b;
        }
        case r:
          return g(new Date(T), y);
        case u: {
          const { source: b, flags: S } = T;
          return g(new RegExp(b, S), y);
        }
        case e: {
          const b = g(/* @__PURE__ */ new Map(), y);
          for (const [S, C] of T)
            b.set(d(S), d(C));
          return b;
        }
        case a: {
          const b = g(/* @__PURE__ */ new Set(), y);
          for (const S of T)
            b.add(d(S));
          return b;
        }
        case n: {
          const { name: b, message: S } = T;
          return g(new m[b](S), y);
        }
        case p:
          return g(BigInt(T), y);
        case "BigInt":
          return g(Object(BigInt(T)), y);
      }
      return g(new m[v](T), y);
    };
    return d;
  }, l = (s) => h(/* @__PURE__ */ new Map(), s)(0);
  return mf.deserialize = l, mf;
}
var gf = {}, RC;
function jL() {
  if (RC) return gf;
  RC = 1;
  const {
    VOID: i,
    PRIMITIVE: t,
    ARRAY: o,
    OBJECT: f,
    DATE: r,
    REGEXP: u,
    MAP: e,
    SET: a,
    ERROR: n,
    BIGINT: p
  } = Fv(), m = "", { toString: h } = {}, { keys: l } = Object, s = (y) => {
    const v = typeof y;
    if (v !== "object" || !y)
      return [t, v];
    const T = h.call(y).slice(8, -1);
    switch (T) {
      case "Array":
        return [o, m];
      case "Object":
        return [f, m];
      case "Date":
        return [r, m];
      case "RegExp":
        return [u, m];
      case "Map":
        return [e, m];
      case "Set":
        return [a, m];
    }
    return T.includes("Array") ? [o, T] : T.includes("Error") ? [n, T] : [f, T];
  }, c = ([y, v]) => y === t && (v === "function" || v === "symbol"), g = (y, v, T, b) => {
    const S = (x, A) => {
      const R = b.push(x) - 1;
      return T.set(A, R), R;
    }, C = (x) => {
      if (T.has(x))
        return T.get(x);
      let [A, R] = s(x);
      switch (A) {
        case t: {
          let _ = x;
          switch (R) {
            case "bigint":
              A = p, _ = x.toString();
              break;
            case "function":
            case "symbol":
              if (y)
                throw new TypeError("unable to serialize " + R);
              _ = null;
              break;
            case "undefined":
              return S([i], x);
          }
          return S([A, _], x);
        }
        case o: {
          if (R)
            return S([R, [...x]], x);
          const _ = [], I = S([A, _], x);
          for (const O of x)
            _.push(C(O));
          return I;
        }
        case f: {
          if (R)
            switch (R) {
              case "BigInt":
                return S([R, x.toString()], x);
              case "Boolean":
              case "Number":
              case "String":
                return S([R, x.valueOf()], x);
            }
          if (v && "toJSON" in x)
            return C(x.toJSON());
          const _ = [], I = S([A, _], x);
          for (const O of l(x))
            (y || !c(s(x[O]))) && _.push([C(O), C(x[O])]);
          return I;
        }
        case r:
          return S([A, x.toISOString()], x);
        case u: {
          const { source: _, flags: I } = x;
          return S([A, { source: _, flags: I }], x);
        }
        case e: {
          const _ = [], I = S([A, _], x);
          for (const [O, k] of x)
            (y || !(c(s(O)) || c(s(k)))) && _.push([C(O), C(k)]);
          return I;
        }
        case a: {
          const _ = [], I = S([A, _], x);
          for (const O of x)
            (y || !c(s(O))) && _.push(C(O));
          return I;
        }
      }
      const { message: L } = x;
      return S([A, { name: R, message: L }], x);
    };
    return C;
  }, d = (y, { json: v, lossy: T } = {}) => {
    const b = [];
    return g(!(v || T), !!v, /* @__PURE__ */ new Map(), b)(y), b;
  };
  return gf.serialize = d, gf;
}
var DC;
function qL() {
  return DC || (DC = 1, function(i) {
    const { deserialize: t } = KL(), { serialize: o } = jL();
    Object.defineProperty(i, "__esModule", { value: !0 }).default = typeof structuredClone == "function" ? (
      /* c8 ignore start */
      (f, r) => r && ("json" in r || "lossy" in r) ? t(o(f, r)) : structuredClone(f)
    ) : (f, r) => t(o(f, r)), i.deserialize = t, i.serialize = o;
  }(hf)), hf;
}
var df, LC;
function Nv() {
  if (LC) return df;
  LC = 1;
  function i(o) {
    if ([2, "2", "error"].includes(o))
      return "error";
    if ([1, "1", "warn"].includes(o))
      return "warn";
    if ([0, "0", "off"].includes(o))
      return "off";
    throw new Error(`Invalid severity value: ${o}`);
  }
  function t(o) {
    if ([2, "2", "error"].includes(o))
      return 2;
    if ([1, "1", "warn"].includes(o))
      return 1;
    if ([0, "0", "off"].includes(o))
      return 0;
    throw new Error(`Invalid severity value: ${o}`);
  }
  return df = {
    normalizeSeverityToString: i,
    normalizeSeverityToNumber: t
  }, df;
}
var Ef, _C;
function Ov() {
  if (_C) return Ef;
  _C = 1;
  const i = qL().default, { normalizeSeverityToNumber: t } = Nv(), o = /* @__PURE__ */ new Map([
    [0, 0],
    ["off", 0],
    [1, 1],
    ["warn", 1],
    [2, 2],
    ["error", 2]
  ]), f = /* @__PURE__ */ new Set([
    !0,
    "true",
    "writable",
    "writeable",
    !1,
    "false",
    "readonly",
    "readable",
    null,
    "off"
  ]);
  function r(w) {
    return typeof w == "object" && w !== null;
  }
  function u(w) {
    return r(w) && !Array.isArray(w);
  }
  function e(w) {
    return typeof w > "u";
  }
  function a(w, U, q = /* @__PURE__ */ new Map()) {
    let F = q.get(w);
    if (F) {
      const P = F.get(U);
      if (P)
        return P;
    } else
      F = /* @__PURE__ */ new Map(), q.set(w, F);
    const $ = {
      ...w,
      ...U
    };
    delete $.__proto__, F.set(U, $);
    for (const P of Object.keys(U)) {
      if (P === "__proto__" || !Object.prototype.propertyIsEnumerable.call(w, P))
        continue;
      const X = w[P], Q = U[P];
      u(X) && u(Q) ? $[P] = a(X, Q, q) : e(Q) && ($[P] = X);
    }
    return $;
  }
  function n(w) {
    const U = Array.isArray(w) ? w.slice(0) : [w];
    return U[0] = o.get(U[0]), i(U);
  }
  class p extends Error {
    /**
     * @param {string} ruleId Rule name being configured.
     * @param {any} value The invalid value.
     */
    constructor(U, q) {
      super(`Key "${U}": Expected severity of "off", 0, "warn", 1, "error", or 2.`), this.messageTemplate = "invalid-rule-options", this.messageData = { ruleId: U, value: q };
    }
  }
  function m(w, U) {
    if (typeof U != "string" && typeof U != "number" && !Array.isArray(U))
      throw new p(w, U);
  }
  class h extends Error {
    /**
     * @param {string} ruleId Rule name being configured.
     * @param {any} value The invalid value.
     */
    constructor(U, q) {
      super(`Key "${U}": Expected severity of "off", 0, "warn", 1, "error", or 2.`), this.messageTemplate = "invalid-rule-severity", this.messageData = { ruleId: U, value: q };
    }
  }
  function l(w, U) {
    if (typeof o.get(U) > "u")
      throw new h(w, U);
  }
  function s(w) {
    if (!/[@a-z0-9-_$]+(?:\/(?:[a-z0-9-_$]+))+$/iu.test(w))
      throw new TypeError(`Expected string in the form "pluginName/objectName" but found "${w}".`);
  }
  function c(w) {
    if (!r(w))
      throw new TypeError("Expected an object.");
  }
  class g extends Error {
    /**
     * @param {string} key The invalid key.
     */
    constructor(U) {
      super("This appears to be in eslintrc format rather than flat config format."), this.messageTemplate = "eslintrc-incompat", this.messageData = { key: U };
    }
  }
  class d extends Error {
    /**
     * Creates a new instance.
     * @param {Array<string>} plugins The plugins array.
     */
    constructor(U) {
      super("This appears to be in eslintrc format (array of strings) rather than flat config format (object)."), this.messageTemplate = "eslintrc-plugins", this.messageData = { plugins: U };
    }
  }
  const y = {
    merge: "replace",
    validate: "boolean"
  }, v = /* @__PURE__ */ new Set(["error", "warn", "off", 2, 1, 0]), T = {
    merge(w, U) {
      const q = U === void 0 ? w : U;
      return typeof q == "boolean" ? q ? "warn" : "off" : t(q);
    },
    validate(w) {
      if (!(v.has(w) || typeof w == "boolean"))
        throw new TypeError('Expected one of: "error", "warn", "off", 0, 1, 2, or a boolean.');
    }
  }, b = {
    merge(w = {}, U = {}) {
      return a(w, U);
    },
    validate: "object"
  }, S = {
    merge: "assign",
    validate(w) {
      c(w);
      for (const U of Object.keys(w))
        if (U !== "__proto__") {
          if (U !== U.trim())
            throw new TypeError(`Global "${U}" has leading or trailing whitespace.`);
          if (!f.has(w[U]))
            throw new TypeError(`Key "${U}": Expected "readonly", "writable", or "off".`);
        }
    }
  }, C = {
    merge: "replace",
    validate(w) {
      if (!w || typeof w != "object" || typeof w.parse != "function" && typeof w.parseForESLint != "function")
        throw new TypeError("Expected object with parse() or parseForESLint() method.");
    }
  }, x = {
    merge(w = {}, U = {}) {
      const q = /* @__PURE__ */ new Set([...Object.keys(w), ...Object.keys(U)]), F = {};
      for (const $ of q)
        if ($ !== "__proto__") {
          if ($ in w && $ in U && w[$] !== U[$])
            throw new TypeError(`Cannot redefine plugin "${$}".`);
          F[$] = U[$] || w[$];
        }
      return F;
    },
    validate(w) {
      if (w === null || typeof w != "object")
        throw new TypeError("Expected an object.");
      if (Array.isArray(w))
        throw new d(w);
      for (const U of Object.keys(w))
        if (U !== "__proto__" && (w[U] === null || typeof w[U] != "object"))
          throw new TypeError(`Key "${U}": Expected an object.`);
    }
  }, A = {
    merge: "replace",
    validate(w) {
      if (typeof w == "string")
        s(w);
      else if (w && typeof w == "object") {
        if (typeof w.preprocess != "function" || typeof w.postprocess != "function")
          throw new TypeError("Object must have a preprocess() and a postprocess() method.");
      } else
        throw new TypeError("Expected an object or a string.");
    }
  }, R = {
    merge(w = {}, U = {}) {
      const q = {
        ...w,
        ...U
      };
      for (const F of Object.keys(q))
        try {
          if (F === "__proto__") {
            delete q.__proto__;
            continue;
          }
          if (q[F] = n(q[F]), !(F in w) || !(F in U))
            continue;
          const $ = n(w[F]), P = n(U[F]);
          if (P.length === 1) {
            q[F] = [P[0], ...$.slice(1)];
            continue;
          }
        } catch ($) {
          throw new Error(`Key "${F}": ${$.message}`, { cause: $ });
        }
      return q;
    },
    validate(w) {
      c(w);
      for (const U of Object.keys(w)) {
        if (U === "__proto__")
          continue;
        const q = w[U];
        m(U, q), Array.isArray(q) ? l(U, q[0]) : l(U, q);
      }
    }
  }, L = {
    merge: "replace",
    validate(w) {
      if (!(typeof w == "number" || w === "latest"))
        throw new TypeError('Expected a number or "latest".');
    }
  }, _ = {
    merge: "replace",
    validate(w) {
      if (typeof w != "string" || !/^(?:script|module|commonjs)$/u.test(w))
        throw new TypeError('Expected "script", "module", or "commonjs".');
    }
  };
  function I(w) {
    return {
      merge: "replace",
      validate() {
        throw new g(w);
      }
    };
  }
  return Ef = {
    flatConfigSchema: {
      // eslintrc-style keys that should always error
      ...Object.fromEntries([
        "env",
        "extends",
        "globals",
        "ignorePatterns",
        "noInlineConfig",
        "overrides",
        "parser",
        "parserOptions",
        "reportUnusedDisableDirectives",
        "root"
      ].map((w) => [w, I(w)])),
      // flat config keys
      settings: b,
      linterOptions: {
        schema: {
          noInlineConfig: y,
          reportUnusedDisableDirectives: T
        }
      },
      languageOptions: {
        schema: {
          ecmaVersion: L,
          sourceType: _,
          globals: S,
          parser: C,
          parserOptions: b
        }
      },
      processor: A,
      plugins: x,
      rules: R
    },
    assertIsRuleSeverity: l,
    assertIsRuleOptions: m
  }, Ef;
}
var yf = {}, $L = "http://json-schema.org/draft-04/schema#", GL = "http://json-schema.org/draft-04/schema#", WL = "Core schema meta-schema", XL = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, zL = "object", HL = {
  id: {
    type: "string"
  },
  $schema: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, JL = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, QL = {
  id: $L,
  $schema: GL,
  description: WL,
  definitions: XL,
  type: zL,
  properties: HL,
  dependencies: JL,
  default: {}
}, Cf, wC;
function YL() {
  if (wC) return Cf;
  wC = 1;
  const i = hv(), t = QL;
  return Cf = (o = {}) => {
    const f = new i({
      meta: !1,
      useDefaults: !0,
      validateSchema: !1,
      missingRefs: "ignore",
      verbose: !0,
      schemaId: "auto",
      ...o
    });
    return f.addMetaSchema(t), f._opts.defaultMeta = t.id, f;
  }, Cf;
}
var kC;
function Uv() {
  if (kC) return yf;
  kC = 1;
  const t = YL()(), {
    parseRuleId: o,
    getRuleFromConfig: f,
    getRuleOptionsSchema: r
  } = Bv(), u = kv;
  function e({ pluginName: n, ruleName: p }, m) {
    const l = `Key "rules": Key "${n === "@" ? p : `${n}/${p}`}"`;
    let s = `${l}: Could not find plugin "${n}".`;
    if (m.plugins && m.plugins[n]) {
      const c = u.rules[p];
      if (n === "@" && c)
        s = `${l}: Rule "${p}" was removed and replaced by "${c}".`;
      else {
        s = `${l}: Could not find "${p}" in plugin "${n}".`;
        for (const [g, d] of Object.entries(m.plugins))
          if (d.rules && d.rules[p]) {
            s += ` Did you mean "${g}/${p}"?`;
            break;
          }
      }
    }
    throw new TypeError(s);
  }
  class a {
    /**
     * Creates a new instance.
     */
    constructor() {
      this.validators = /* @__PURE__ */ new WeakMap();
    }
    /**
     * Validates all of the rule configurations in a config against each
     * rule's schema.
     * @param {Object} config The full config to validate. This object must
     *      contain both the rules section and the plugins section.
     * @returns {void}
     * @throws {Error} If a rule's configuration does not match its schema.
     */
    validate(p) {
      if (p.rules)
        for (const [m, h] of Object.entries(p.rules)) {
          if (m === "__proto__" || h[0] === 0)
            continue;
          const l = f(m, p);
          if (l || e(o(m), p), !this.validators.has(l)) {
            const c = r(l);
            c && this.validators.set(l, t.compile(c));
          }
          const s = this.validators.get(l);
          if (s && (s(h.slice(1)), s.errors))
            throw new Error(`Key "rules": Key "${m}": ${s.errors.map(
              (c) => `	Value ${JSON.stringify(c.data)} ${c.message}.
`
            ).join("")}`);
        }
    }
  }
  return yf.RuleValidator = a, yf;
}
var vf = {}, BC;
function ZL() {
  if (BC) return vf;
  BC = 1;
  const i = wv();
  return vf.defaultConfig = [
    {
      plugins: {
        "@": {
          /*
           * Because we try to delay loading rules until absolutely
           * necessary, a proxy allows us to hook into the lazy-loading
           * aspect of the rules map while still keeping all of the
           * relevant configuration inside of the config array.
           */
          rules: new Proxy({}, {
            get(t, o) {
              return i.get(o);
            },
            has(t, o) {
              return i.has(o);
            }
          })
        }
      },
      languageOptions: {
        sourceType: "module",
        ecmaVersion: "latest",
        parser: hn(),
        parserOptions: {}
      }
    },
    // default ignores are listed here
    {
      ignores: [
        "**/node_modules/",
        ".git/"
      ]
    },
    // intentionally empty config to ensure these files are globbed by default
    {
      files: ["**/*.js", "**/*.mjs"]
    },
    {
      files: ["**/*.cjs"],
      languageOptions: {
        sourceType: "commonjs",
        ecmaVersion: "latest"
      }
    }
  ], vf;
}
var Sf, PC;
function e_() {
  return PC || (PC = 1, Sf = Object.freeze({
    rules: {
      "accessor-pairs": "error",
      "array-callback-return": "error",
      "arrow-body-style": "error",
      "block-scoped-var": "error",
      camelcase: "error",
      "capitalized-comments": "error",
      "class-methods-use-this": "error",
      complexity: "error",
      "consistent-return": "error",
      "consistent-this": "error",
      "constructor-super": "error",
      curly: "error",
      "default-case": "error",
      "default-case-last": "error",
      "default-param-last": "error",
      "dot-notation": "error",
      eqeqeq: "error",
      "for-direction": "error",
      "func-name-matching": "error",
      "func-names": "error",
      "func-style": "error",
      "getter-return": "error",
      "grouped-accessor-pairs": "error",
      "guard-for-in": "error",
      "id-denylist": "error",
      "id-length": "error",
      "id-match": "error",
      "init-declarations": "error",
      "line-comment-position": "error",
      "logical-assignment-operators": "error",
      "max-classes-per-file": "error",
      "max-depth": "error",
      "max-lines": "error",
      "max-lines-per-function": "error",
      "max-nested-callbacks": "error",
      "max-params": "error",
      "max-statements": "error",
      "multiline-comment-style": "error",
      "new-cap": "error",
      "no-alert": "error",
      "no-array-constructor": "error",
      "no-async-promise-executor": "error",
      "no-await-in-loop": "error",
      "no-bitwise": "error",
      "no-caller": "error",
      "no-case-declarations": "error",
      "no-class-assign": "error",
      "no-compare-neg-zero": "error",
      "no-cond-assign": "error",
      "no-console": "error",
      "no-const-assign": "error",
      "no-constant-binary-expression": "error",
      "no-constant-condition": "error",
      "no-constructor-return": "error",
      "no-continue": "error",
      "no-control-regex": "error",
      "no-debugger": "error",
      "no-delete-var": "error",
      "no-div-regex": "error",
      "no-dupe-args": "error",
      "no-dupe-class-members": "error",
      "no-dupe-else-if": "error",
      "no-dupe-keys": "error",
      "no-duplicate-case": "error",
      "no-duplicate-imports": "error",
      "no-else-return": "error",
      "no-empty": "error",
      "no-empty-character-class": "error",
      "no-empty-function": "error",
      "no-empty-pattern": "error",
      "no-empty-static-block": "error",
      "no-eq-null": "error",
      "no-eval": "error",
      "no-ex-assign": "error",
      "no-extend-native": "error",
      "no-extra-bind": "error",
      "no-extra-boolean-cast": "error",
      "no-extra-label": "error",
      "no-fallthrough": "error",
      "no-func-assign": "error",
      "no-global-assign": "error",
      "no-implicit-coercion": "error",
      "no-implicit-globals": "error",
      "no-implied-eval": "error",
      "no-import-assign": "error",
      "no-inline-comments": "error",
      "no-inner-declarations": "error",
      "no-invalid-regexp": "error",
      "no-invalid-this": "error",
      "no-irregular-whitespace": "error",
      "no-iterator": "error",
      "no-label-var": "error",
      "no-labels": "error",
      "no-lone-blocks": "error",
      "no-lonely-if": "error",
      "no-loop-func": "error",
      "no-loss-of-precision": "error",
      "no-magic-numbers": "error",
      "no-misleading-character-class": "error",
      "no-multi-assign": "error",
      "no-multi-str": "error",
      "no-negated-condition": "error",
      "no-nested-ternary": "error",
      "no-new": "error",
      "no-new-func": "error",
      "no-new-native-nonconstructor": "error",
      "no-new-symbol": "error",
      "no-new-wrappers": "error",
      "no-nonoctal-decimal-escape": "error",
      "no-obj-calls": "error",
      "no-object-constructor": "error",
      "no-octal": "error",
      "no-octal-escape": "error",
      "no-param-reassign": "error",
      "no-plusplus": "error",
      "no-promise-executor-return": "error",
      "no-proto": "error",
      "no-prototype-builtins": "error",
      "no-redeclare": "error",
      "no-regex-spaces": "error",
      "no-restricted-exports": "error",
      "no-restricted-globals": "error",
      "no-restricted-imports": "error",
      "no-restricted-properties": "error",
      "no-restricted-syntax": "error",
      "no-return-assign": "error",
      "no-script-url": "error",
      "no-self-assign": "error",
      "no-self-compare": "error",
      "no-sequences": "error",
      "no-setter-return": "error",
      "no-shadow": "error",
      "no-shadow-restricted-names": "error",
      "no-sparse-arrays": "error",
      "no-template-curly-in-string": "error",
      "no-ternary": "error",
      "no-this-before-super": "error",
      "no-throw-literal": "error",
      "no-undef": "error",
      "no-undef-init": "error",
      "no-undefined": "error",
      "no-underscore-dangle": "error",
      "no-unexpected-multiline": "error",
      "no-unmodified-loop-condition": "error",
      "no-unneeded-ternary": "error",
      "no-unreachable": "error",
      "no-unreachable-loop": "error",
      "no-unsafe-finally": "error",
      "no-unsafe-negation": "error",
      "no-unsafe-optional-chaining": "error",
      "no-unused-expressions": "error",
      "no-unused-labels": "error",
      "no-unused-private-class-members": "error",
      "no-unused-vars": "error",
      "no-use-before-define": "error",
      "no-useless-backreference": "error",
      "no-useless-call": "error",
      "no-useless-catch": "error",
      "no-useless-computed-key": "error",
      "no-useless-concat": "error",
      "no-useless-constructor": "error",
      "no-useless-escape": "error",
      "no-useless-rename": "error",
      "no-useless-return": "error",
      "no-var": "error",
      "no-void": "error",
      "no-warning-comments": "error",
      "no-with": "error",
      "object-shorthand": "error",
      "one-var": "error",
      "operator-assignment": "error",
      "prefer-arrow-callback": "error",
      "prefer-const": "error",
      "prefer-destructuring": "error",
      "prefer-exponentiation-operator": "error",
      "prefer-named-capture-group": "error",
      "prefer-numeric-literals": "error",
      "prefer-object-has-own": "error",
      "prefer-object-spread": "error",
      "prefer-promise-reject-errors": "error",
      "prefer-regex-literals": "error",
      "prefer-rest-params": "error",
      "prefer-spread": "error",
      "prefer-template": "error",
      radix: "error",
      "require-atomic-updates": "error",
      "require-await": "error",
      "require-unicode-regexp": "error",
      "require-yield": "error",
      "sort-imports": "error",
      "sort-keys": "error",
      "sort-vars": "error",
      strict: "error",
      "symbol-description": "error",
      "unicode-bom": "error",
      "use-isnan": "error",
      "valid-typeof": "error",
      "vars-on-top": "error",
      yoda: "error"
    }
  })), Sf;
}
var Af, IC;
function t_() {
  return IC || (IC = 1, Af = Object.freeze({
    rules: Object.freeze({
      "constructor-super": "error",
      "for-direction": "error",
      "getter-return": "error",
      "no-async-promise-executor": "error",
      "no-case-declarations": "error",
      "no-class-assign": "error",
      "no-compare-neg-zero": "error",
      "no-cond-assign": "error",
      "no-const-assign": "error",
      "no-constant-condition": "error",
      "no-control-regex": "error",
      "no-debugger": "error",
      "no-delete-var": "error",
      "no-dupe-args": "error",
      "no-dupe-class-members": "error",
      "no-dupe-else-if": "error",
      "no-dupe-keys": "error",
      "no-duplicate-case": "error",
      "no-empty": "error",
      "no-empty-character-class": "error",
      "no-empty-pattern": "error",
      "no-ex-assign": "error",
      "no-extra-boolean-cast": "error",
      "no-extra-semi": "error",
      "no-fallthrough": "error",
      "no-func-assign": "error",
      "no-global-assign": "error",
      "no-import-assign": "error",
      "no-inner-declarations": "error",
      "no-invalid-regexp": "error",
      "no-irregular-whitespace": "error",
      "no-loss-of-precision": "error",
      "no-misleading-character-class": "error",
      "no-mixed-spaces-and-tabs": "error",
      "no-new-symbol": "error",
      "no-nonoctal-decimal-escape": "error",
      "no-obj-calls": "error",
      "no-octal": "error",
      "no-prototype-builtins": "error",
      "no-redeclare": "error",
      "no-regex-spaces": "error",
      "no-self-assign": "error",
      "no-setter-return": "error",
      "no-shadow-restricted-names": "error",
      "no-sparse-arrays": "error",
      "no-this-before-super": "error",
      "no-undef": "error",
      "no-unexpected-multiline": "error",
      "no-unreachable": "error",
      "no-unsafe-finally": "error",
      "no-unsafe-negation": "error",
      "no-unsafe-optional-chaining": "error",
      "no-unused-labels": "error",
      "no-unused-vars": "error",
      "no-useless-backreference": "error",
      "no-useless-catch": "error",
      "no-useless-escape": "error",
      "no-with": "error",
      "require-yield": "error",
      "use-isnan": "error",
      "valid-typeof": "error"
    })
  })), Af;
}
var Tf, FC;
function r_() {
  return FC || (FC = 1, Tf = {
    configs: {
      all: e_(),
      recommended: t_()
    }
  }), Tf;
}
var NC;
function n_() {
  if (NC) return sf;
  NC = 1;
  const { ConfigArray: i, ConfigArraySymbol: t } = ML(), { flatConfigSchema: o } = Ov(), { RuleValidator: f } = Uv(), { defaultConfig: r } = ZL(), u = r_(), e = new f();
  function a(h) {
    const l = h.split("/");
    return {
      objectName: l.pop(),
      pluginName: l.join("/")
    };
  }
  function n(h) {
    let l = h.name;
    if (!l && (!h.meta || (l = h.meta.name, !l)))
      return null;
    let s = h.version;
    return s || (s = h.meta && h.meta.version), s ? `${l}@${s}` : l;
  }
  const p = Symbol("originalBaseConfig");
  class m extends i {
    /**
     * Creates a new instance.
     * @param {*[]} configs An array of configuration information.
     * @param {{basePath: string, shouldIgnore: boolean, baseConfig: FlatConfig}} options The options
     *      to use for the config array instance.
     */
    constructor(l, {
      basePath: s,
      shouldIgnore: c = !0,
      baseConfig: g = r
    } = {}) {
      super(l, {
        basePath: s,
        schema: o
      }), g[Symbol.iterator] ? this.unshift(...g) : this.unshift(g), this[p] = g, Object.defineProperty(this, p, { writable: !1 }), this.shouldIgnore = c, Object.defineProperty(this, "shouldIgnore", { writable: !1 });
    }
    /* eslint-disable class-methods-use-this -- Desired as instance method */
    /**
     * Replaces a config with another config to allow us to put strings
     * in the config array that will be replaced by objects before
     * normalization.
     * @param {Object} config The config to preprocess.
     * @returns {Object} The preprocessed config.
     */
    [t.preprocessConfig](l) {
      if (l === "eslint:recommended")
        return typeof process < "u" && process.emitWarning && process.emitWarning("The 'eslint:recommended' string configuration is deprecated and will be replaced by the @eslint/js package's 'recommended' config."), u.configs.recommended;
      if (l === "eslint:all")
        return typeof process < "u" && process.emitWarning && process.emitWarning("The 'eslint:all' string configuration is deprecated and will be replaced by the @eslint/js package's 'all' config."), u.configs.all;
      if (!this.shouldIgnore && !this[p].includes(l) && l.ignores && !l.files) {
        const { ignores: s, ...c } = l;
        return c;
      }
      return l;
    }
    /**
     * Finalizes the config by replacing plugin references with their objects
     * and validating rule option schemas.
     * @param {Object} config The config to finalize.
     * @returns {Object} The finalized config.
     * @throws {TypeError} If the config is invalid.
     */
    [t.finalizeConfig](l) {
      const { plugins: s, languageOptions: c, processor: g } = l;
      let d, y, v = !1, T = !1;
      if (c && c.parser) {
        const { parser: b } = c;
        typeof b == "object" ? (d = n(b), d || (v = !0)) : v = !0;
      }
      if (g)
        if (typeof g == "string") {
          const { pluginName: b, objectName: S } = a(g);
          if (y = g, !s || !s[b] || !s[b].processors || !s[b].processors[S])
            throw new TypeError(`Key "processor": Could not find "${S}" in plugin "${b}".`);
          l.processor = s[b].processors[S];
        } else typeof g == "object" ? (y = n(g), y || (T = !0)) : T = !0;
      return e.validate(l), Object.defineProperty(l, "toJSON", {
        value: function() {
          if (v)
            throw new Error("Could not serialize parser object (missing 'meta' object).");
          if (T)
            throw new Error("Could not serialize processor object (missing 'meta' object).");
          return {
            ...this,
            plugins: Object.entries(s).map(([b, S]) => {
              const C = n(S);
              return C ? `${b}:${C}` : b;
            }),
            languageOptions: {
              ...c,
              parser: d
            },
            processor: y
          };
        }
      }), l;
    }
    /* eslint-enable class-methods-use-this -- Desired as instance method */
  }
  return sf.FlatConfigArray = m, sf;
}
var bf, OC;
function s_() {
  if (OC) return bf;
  OC = 1;
  const i = cn, t = lv(), o = qr(), f = hn(), r = RS(), u = LS, e = mn(), {
    directivesPattern: a
  } = gn(), {
    Legacy: {
      ConfigOps: n,
      ConfigValidator: p,
      environments: m
    }
  } = mv(), h = qf(), { SourceCode: l } = kA(), s = FA(), c = NA(), g = yv(), d = VA(), y = jA(), v = _L(), T = wL(), b = kL(), S = BL(), C = kv, { getRuleFromConfig: x } = Bv(), { FlatConfigArray: A } = n_(), { RuleValidator: R } = Uv(), { assertIsRuleOptions: L, assertIsRuleSeverity: _ } = Ov(), { normalizeSeverityToString: I } = Nv(), O = vr()("eslint:linter"), k = 10, w = "espree", U = 5, q = new g(), F = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } }, $ = Symbol.for("eslint.RuleTester.parser");
  function P(Ue) {
    return Ue === f || Ue[$] === f;
  }
  function X(Ue, Ve, { exportedVariables: xe, enabledGlobals: re }) {
    for (const ne of /* @__PURE__ */ new Set([...Object.keys(Ve), ...Object.keys(re)])) {
      const ae = Ve[ne] === void 0 ? void 0 : n.normalizeConfigGlobal(Ve[ne]), de = re[ne] && re[ne].value || ae, ee = re[ne] && re[ne].comments;
      if (de === "off")
        continue;
      let te = Ue.set.get(ne);
      te || (te = new t.Variable(ne, Ue), Ue.variables.push(te), Ue.set.set(ne, te)), te.eslintImplicitGlobalSetting = ae, te.eslintExplicitGlobal = ee !== void 0, te.eslintExplicitGlobalComments = ee, te.writeable = de === "writable";
    }
    Object.keys(xe).forEach((ne) => {
      const ae = Ue.set.get(ne);
      ae && (ae.eslintUsed = !0, ae.eslintExported = !0);
    }), Ue.through = Ue.through.filter((ne) => {
      const ae = ne.identifier.name, fe = Ue.set.get(ae);
      return fe ? (ne.resolved = fe, fe.references.push(ne), !1) : !0;
    });
  }
  function Q(Ue) {
    return Object.prototype.hasOwnProperty.call(C.rules, Ue) ? `Rule '${Ue}' was removed and replaced by: ${C.rules[Ue].join(", ")}` : `Definition for rule '${Ue}' was not found.`;
  }
  function ue(Ue) {
    const {
      ruleId: Ve = null,
      loc: xe = F,
      message: re = Q(Ue.ruleId),
      severity: ne = 2
    } = Ue;
    return {
      ruleId: Ve,
      message: re,
      line: xe.start.line,
      column: xe.start.column + 1,
      endLine: xe.end.line,
      endColumn: xe.end.column + 1,
      severity: ne,
      nodeType: null
    };
  }
  function le(Ue) {
    const { commentToken: Ve, type: xe, value: re, justification: ne, ruleMapper: ae } = Ue, fe = Object.keys(q.parseListConfig(re)), de = fe.length ? fe : [null], ee = {
      directives: [],
      // valid disable directives
      directiveProblems: []
      // problems in directives
    }, te = { commentToken: Ve, ruleIds: fe };
    for (const B of de)
      B === null || ae(B) ? xe === "disable-next-line" ? ee.directives.push({
        parentComment: te,
        type: xe,
        line: Ve.loc.end.line,
        column: Ve.loc.end.column + 1,
        ruleId: B,
        justification: ne
      }) : ee.directives.push({
        parentComment: te,
        type: xe,
        line: Ve.loc.start.line,
        column: Ve.loc.start.column + 1,
        ruleId: B,
        justification: ne
      }) : ee.directiveProblems.push(ue({ ruleId: B, loc: Ve.loc }));
    return ee;
  }
  function Ce(Ue, Ve, xe) {
    const re = {}, ne = /* @__PURE__ */ Object.create(null), ae = {}, fe = [], de = [], ee = new p({
      builtInRules: v
    });
    return Ue.getInlineConfigNodes().filter((te) => te.type !== "Shebang").forEach((te) => {
      const { directivePart: B, justificationPart: z } = q.extractDirectiveComment(te.value), ce = a.exec(B);
      if (!ce)
        return;
      const ye = ce[1], Be = /^eslint-disable-(next-)?line$/u.test(ye);
      if (te.type === "Line" && !Be)
        return;
      if (xe) {
        const Pe = te.type === "Block" ? `/*${ye}*/` : `//${ye}`;
        fe.push(ue({
          ruleId: null,
          message: `'${Pe}' has no effect because you have 'noInlineConfig' setting in ${xe}.`,
          loc: te.loc,
          severity: 1
        }));
        return;
      }
      if (ye === "eslint-disable-line" && te.loc.start.line !== te.loc.end.line) {
        const Pe = `${ye} comment should not span multiple lines.`;
        fe.push(ue({
          ruleId: null,
          message: Pe,
          loc: te.loc
        }));
        return;
      }
      const we = B.slice(ce.index + ye.length);
      switch (ye) {
        case "eslint-disable":
        case "eslint-enable":
        case "eslint-disable-next-line":
        case "eslint-disable-line": {
          const Pe = ye.slice(7), st = { commentToken: te, type: Pe, value: we, justification: z, ruleMapper: Ve }, { directives: We, directiveProblems: _e } = le(st);
          de.push(...We), fe.push(..._e);
          break;
        }
        case "exported":
          Object.assign(ae, q.parseStringConfig(we, te));
          break;
        case "globals":
        case "global":
          for (const [Pe, { value: st }] of Object.entries(q.parseStringConfig(we, te))) {
            let We;
            try {
              We = n.normalizeConfigGlobal(st);
            } catch (_e) {
              fe.push(ue({
                ruleId: null,
                loc: te.loc,
                message: _e.message
              }));
              continue;
            }
            ne[Pe] ? (ne[Pe].comments.push(te), ne[Pe].value = We) : ne[Pe] = {
              comments: [te],
              value: We
            };
          }
          break;
        case "eslint": {
          const Pe = q.parseJsonConfig(we, te.loc);
          Pe.success ? Object.keys(Pe.config).forEach((st) => {
            const We = Ve(st), _e = Pe.config[st];
            if (!We) {
              fe.push(ue({ ruleId: st, loc: te.loc }));
              return;
            }
            try {
              ee.validateRuleOptions(We, st, _e);
            } catch (je) {
              fe.push(ue({
                ruleId: st,
                message: je.message,
                loc: te.loc
              }));
              return;
            }
            re[st] = _e;
          }) : fe.push(Pe.error);
          break;
        }
      }
    }), {
      configuredRules: re,
      enabledGlobals: ne,
      exportedVariables: ae,
      problems: fe,
      disableDirectives: de
    };
  }
  function j(Ue, Ve) {
    const xe = [], re = [];
    return Ue.getInlineConfigNodes().filter((ne) => ne.type !== "Shebang").forEach((ne) => {
      const { directivePart: ae, justificationPart: fe } = q.extractDirectiveComment(ne.value), de = a.exec(ae);
      if (!de)
        return;
      const ee = de[1], te = /^eslint-disable-(next-)?line$/u.test(ee);
      if (ne.type === "Line" && !te)
        return;
      if (ee === "eslint-disable-line" && ne.loc.start.line !== ne.loc.end.line) {
        const z = `${ee} comment should not span multiple lines.`;
        xe.push(ue({
          ruleId: null,
          message: z,
          loc: ne.loc
        }));
        return;
      }
      const B = ae.slice(de.index + ee.length);
      switch (ee) {
        case "eslint-disable":
        case "eslint-enable":
        case "eslint-disable-next-line":
        case "eslint-disable-line": {
          const z = ee.slice(7), ce = { commentToken: ne, type: z, value: B, justification: fe, ruleMapper: Ve }, { directives: ye, directiveProblems: Be } = le(ce);
          re.push(...ye), xe.push(...Be);
          break;
        }
      }
    }), {
      problems: xe,
      disableDirectives: re
    };
  }
  function H(Ue, Ve) {
    return P(Ue) && Ve === "latest" ? f.latestEcmaVersion : Ve >= 2015 ? Ve - 2009 : Ve;
  }
  function N(Ue) {
    switch (Ue) {
      case 3:
        return 3;
      case 5:
      case void 0:
        return 5;
      default:
        if (typeof Ue == "number")
          return Ue >= 2015 ? Ue : Ue + 2009;
    }
    return f.latestEcmaVersion + 2009;
  }
  const G = /\/\*\s*eslint-env\s(.+?)(?:\*\/|$)/gsu;
  function M(Ue) {
    let Ve, xe;
    for (G.lastIndex = 0; (Ve = G.exec(Ue)) !== null; )
      Ve[0].endsWith("*/") && (xe = Object.assign(
        xe || {},
        q.parseListConfig(q.extractDirectiveComment(Ve[1]).directivePart)
      ));
    return xe;
  }
  function Z(Ue) {
    const Ve = Ue.split(i.sep), xe = Ve.lastIndexOf("<text>");
    return xe === -1 ? Ue : Ve.slice(xe).join(i.sep);
  }
  function Ee(Ue, Ve) {
    const xe = Ve.linterOptions || Ve, re = xe.noInlineConfig === !0, ne = Ue.allowInlineConfig === !1, ae = Ve.configNameOfNoInlineConfig ? ` (${Ve.configNameOfNoInlineConfig})` : "";
    let fe = Ue.reportUnusedDisableDirectives;
    return typeof fe == "boolean" && (fe = fe ? "error" : "off"), typeof fe != "string" && (typeof xe.reportUnusedDisableDirectives == "boolean" ? fe = xe.reportUnusedDisableDirectives ? "warn" : "off" : fe = xe.reportUnusedDisableDirectives === void 0 ? "off" : I(xe.reportUnusedDisableDirectives)), {
      filename: Z(Ue.filename || "<input>"),
      allowInlineConfig: !ne,
      warnInlineConfig: re && !ne ? `your config${ae}` : null,
      reportUnusedDisableDirectives: fe,
      disableFixes: !!Ue.disableFixes
    };
  }
  function ke(Ue, Ve, xe) {
    const re = xe.filter((fe) => fe.parserOptions).reduce((fe, de) => r(fe, de.parserOptions), {}), ne = r(re, Ve || {});
    return ne.sourceType === "module" && (ne.ecmaFeatures = Object.assign({}, ne.ecmaFeatures, { globalReturn: !1 })), ne.ecmaVersion = H(Ue, ne.ecmaVersion), ne;
  }
  function Ie({ globals: Ue, parser: Ve, parserOptions: xe }) {
    const {
      ecmaVersion: re,
      sourceType: ne
    } = xe;
    return {
      globals: Ue,
      ecmaVersion: N(re),
      sourceType: ne,
      parser: Ve,
      parserOptions: xe
    };
  }
  function Je(Ue, Ve) {
    return Object.assign(
      {},
      ...Ve.filter((xe) => xe.globals).map((xe) => xe.globals),
      Ue
    );
  }
  function at(Ue) {
    return Ue.charCodeAt(0) === 65279 ? Ue.slice(1) : Ue;
  }
  function lt(Ue) {
    return Array.isArray(Ue) ? Ue.slice(1) : [];
  }
  function mt(Ue, Ve, xe) {
    const ne = Ve.parserOptions.ecmaFeatures || {}, ae = Ve.ecmaVersion || U;
    return t.analyze(Ue, {
      ignoreEval: !0,
      nodejsScope: ne.globalReturn,
      impliedStrict: ne.impliedStrict,
      ecmaVersion: typeof ae == "number" ? ae : 6,
      sourceType: Ve.sourceType || "script",
      childVisitorKeys: xe || o.KEYS,
      fallback: h.getKeys
    });
  }
  function Y(Ue, Ve, xe) {
    const re = at(Ue).replace(e.shebangPattern, (ee, te) => `//${te}`), { ecmaVersion: ne, sourceType: ae, parser: fe } = Ve, de = Object.assign(
      { ecmaVersion: ne, sourceType: ae },
      Ve.parserOptions,
      {
        loc: !0,
        range: !0,
        raw: !0,
        tokens: !0,
        comment: !0,
        eslintVisitorKeys: !0,
        eslintScopeManager: !0,
        filePath: xe
      }
    );
    try {
      O("Parsing:", xe);
      const ee = typeof fe.parseForESLint == "function" ? fe.parseForESLint(re, de) : { ast: fe.parse(re, de) };
      O("Parsing successful:", xe);
      const te = ee.ast, B = ee.services || {}, z = ee.visitorKeys || o.KEYS;
      O("Scope analysis:", xe);
      const ce = ee.scopeManager || mt(te, Ve, z);
      return O("Scope analysis successful:", xe), {
        success: !0,
        /*
         * Save all values that `parseForESLint()` returned.
         * If a `SourceCode` object is given as the first parameter instead of source code text,
         * linter skips the parsing process and reuses the source code object.
         * In that case, linter needs all the values that `parseForESLint()` returned.
         */
        sourceCode: new l({
          text: Ue,
          ast: te,
          parserServices: B,
          scopeManager: ce,
          visitorKeys: z
        })
      };
    } catch (ee) {
      const te = `Parsing error: ${ee.message.replace(/^line \d+:/iu, "").trim()}`;
      return O(`%s
%s`, te, ee.stack), {
        success: !1,
        error: {
          ruleId: null,
          fatal: !0,
          severity: 2,
          message: te,
          line: ee.lineNumber,
          column: ee.column,
          nodeType: null
        }
      };
    }
  }
  function Te(Ue, Ve) {
    try {
      return Ue.create(Ve);
    } catch (xe) {
      throw xe.message = `Error while loading rule '${Ve.id}': ${xe.message}`, xe;
    }
  }
  const Ke = {
    getSource: "getText",
    getSourceLines: "getLines",
    getAllComments: "getAllComments",
    getNodeByRangeIndex: "getNodeByRangeIndex",
    getComments: "getComments",
    getCommentsBefore: "getCommentsBefore",
    getCommentsAfter: "getCommentsAfter",
    getCommentsInside: "getCommentsInside",
    getJSDocComment: "getJSDocComment",
    getFirstToken: "getFirstToken",
    getFirstTokens: "getFirstTokens",
    getLastToken: "getLastToken",
    getLastTokens: "getLastTokens",
    getTokenAfter: "getTokenAfter",
    getTokenBefore: "getTokenBefore",
    getTokenByRangeStart: "getTokenByRangeStart",
    getTokens: "getTokens",
    getTokensAfter: "getTokensAfter",
    getTokensBefore: "getTokensBefore",
    getTokensBetween: "getTokensBetween"
  }, et = Object.freeze(
    Object.keys(Ke).reduce(
      (Ue, Ve) => Object.assign(Ue, {
        [Ve](...xe) {
          return this.sourceCode[Ke[Ve]](...xe);
        }
      }),
      {}
    )
  );
  function nt(Ue, Ve, xe, re, ne, ae, fe, de, ee, te) {
    const B = T(), z = [];
    let ce = Ue.ast;
    h.traverse(Ue.ast, {
      enter(Pe, st) {
        Pe.parent = st, z.push({ isEntering: !0, node: Pe });
      },
      leave(Pe) {
        z.push({ isEntering: !1, node: Pe });
      },
      visitorKeys: Ue.visitorKeys
    });
    const ye = Object.freeze(
      Object.assign(
        Object.create(et),
        {
          getAncestors: () => Ue.getAncestors(ce),
          getDeclaredVariables: (Pe) => Ue.getDeclaredVariables(Pe),
          getCwd: () => ee,
          cwd: ee,
          getFilename: () => fe,
          filename: fe,
          getPhysicalFilename: () => te || fe,
          physicalFilename: te || fe,
          getScope: () => Ue.getScope(ce),
          getSourceCode: () => Ue,
          sourceCode: Ue,
          markVariableAsUsed: (Pe) => Ue.markVariableAsUsed(Pe, ce),
          parserOptions: {
            ...ne.parserOptions
          },
          parserPath: re,
          languageOptions: ne,
          parserServices: Ue.parserServices,
          settings: ae
        }
      )
    ), Be = [];
    Object.keys(Ve).forEach((Pe) => {
      const st = n.getRuleSeverity(Ve[Pe]);
      if (st === 0)
        return;
      const We = xe(Pe);
      if (!We) {
        Be.push(ue({ ruleId: Pe }));
        return;
      }
      const _e = We.meta && We.meta.messages;
      let je = null;
      const $e = Object.freeze(
        Object.assign(
          Object.create(ye),
          {
            id: Pe,
            options: lt(Ve[Pe]),
            report(...se) {
              je === null && (je = y({
                ruleId: Pe,
                severity: st,
                sourceCode: Ue,
                messageIds: _e,
                disableFixes: de
              }));
              const pe = je(...se);
              if (pe.fix && !(We.meta && We.meta.fixable))
                throw new Error('Fixable rules must set the `meta.fixable` property to "code" or "whitespace".');
              if (pe.suggestions && !(We.meta && We.meta.hasSuggestions === !0))
                throw We.meta && We.meta.docs && typeof We.meta.docs.suggestion < "u" ? new Error("Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.") : new Error("Rules with suggestions must set the `meta.hasSuggestions` property to `true`.");
              Be.push(pe);
            }
          }
        )
      ), Ae = S.enabled ? S.time(Pe, Te)(We, $e) : Te(We, $e);
      function oe(se) {
        return function(...ve) {
          try {
            return se(...ve);
          } catch (Se) {
            throw Se.ruleId = Pe, Se;
          }
        };
      }
      if (typeof Ae > "u" || Ae === null)
        throw new Error(`The create() function for rule '${Pe}' did not return an object.`);
      Object.keys(Ae).forEach((se) => {
        const pe = S.enabled ? S.time(Pe, Ae[se]) : Ae[se];
        B.on(
          se,
          oe(pe)
        );
      });
    });
    const we = z[0].node.type === "Program" ? new s(new d(B, { visitorKeys: Ue.visitorKeys, fallback: h.getKeys })) : new d(B, { visitorKeys: Ue.visitorKeys, fallback: h.getKeys });
    return z.forEach((Pe) => {
      ce = Pe.node;
      try {
        Pe.isEntering ? we.enterNode(ce) : we.leaveNode(ce);
      } catch (st) {
        throw st.currentNode = ce, st;
      }
    }), Be;
  }
  function rt(Ue) {
    if (typeof Ue == "object") {
      const { hasBOM: Ve, text: xe } = Ue;
      return (Ve ? "\uFEFF" : "") + xe;
    }
    return String(Ue);
  }
  function ot(Ue, Ve) {
    return Ue.lastConfigArray && Ue.lastConfigArray.pluginEnvironments.get(Ve) || m.get(Ve) || null;
  }
  function Ct(Ue, Ve) {
    return Ue.lastConfigArray && Ue.lastConfigArray.pluginRules.get(Ve) || Ue.ruleMap.get(Ve);
  }
  function dt(Ue) {
    if (Ue)
      return Ue;
    if (typeof process == "object")
      return process.cwd();
  }
  const vt = /* @__PURE__ */ new WeakMap();
  function W(Ue) {
    const { configType: Ve } = vt.get(Ue);
    if (Ve === "flat")
      throw new Error("This method cannot be used with flat config. Add your entries directly into the config array.");
  }
  class Ye {
    /**
     * Initialize the Linter.
     * @param {Object} [config] the config object
     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.
     * @param {"flat"|"eslintrc"} [config.configType="eslintrc"] the type of config used.
     */
    constructor({ cwd: Ve, configType: xe } = {}) {
      vt.set(this, {
        cwd: dt(Ve),
        lastConfigArray: null,
        lastSourceCode: null,
        lastSuppressedMessages: [],
        configType: xe,
        // TODO: Remove after flat config conversion
        parserMap: /* @__PURE__ */ new Map([["espree", f]]),
        ruleMap: new v()
      }), this.version = u.version;
    }
    /**
     * Getter for package version.
     * @static
     * @returns {string} The version from package.json.
     */
    static get version() {
      return u.version;
    }
    /**
     * Same as linter.verify, except without support for processors.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.
     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
     * @throws {Error} If during rule execution.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
     */
    _verifyWithoutProcessors(Ve, xe, re) {
      const ne = vt.get(this), ae = xe || {}, fe = Ee(re, ae);
      let de;
      typeof Ve == "string" ? (ne.lastSourceCode = null, de = Ve) : (ne.lastSourceCode = Ve, de = Ve.text);
      let ee = w, te = f;
      if (typeof ae.parser == "object" && ae.parser !== null)
        ee = ae.parser.filePath, te = ae.parser.definition;
      else if (typeof ae.parser == "string") {
        if (!ne.parserMap.has(ae.parser))
          return [{
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: `Configured parser '${ae.parser}' was not found.`,
            line: 0,
            column: 0,
            nodeType: null
          }];
        ee = ae.parser, te = ne.parserMap.get(ae.parser);
      }
      const B = fe.allowInlineConfig && !fe.warnInlineConfig ? M(de) : {}, z = Object.assign({ builtin: !0 }, ae.env, B), ce = Object.keys(z).filter(($e) => z[$e]).map(($e) => ot(ne, $e)).filter(($e) => $e), ye = ke(te, ae.parserOptions || {}, ce), Be = Je(ae.globals || {}, ce), we = ae.settings || {}, Pe = Ie({
        globals: ae.globals,
        parser: te,
        parserOptions: ye
      });
      if (ne.lastSourceCode)
        ne.lastSourceCode.scopeManager || (ne.lastSourceCode = new l({
          text: ne.lastSourceCode.text,
          ast: ne.lastSourceCode.ast,
          parserServices: ne.lastSourceCode.parserServices,
          visitorKeys: ne.lastSourceCode.visitorKeys,
          scopeManager: mt(ne.lastSourceCode.ast, Pe)
        }));
      else {
        const $e = Y(
          de,
          Pe,
          fe.filename
        );
        if (!$e.success)
          return [$e.error];
        ne.lastSourceCode = $e.sourceCode;
      }
      const st = ne.lastSourceCode, We = fe.allowInlineConfig ? Ce(st, ($e) => Ct(ne, $e), fe.warnInlineConfig) : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };
      X(
        st.scopeManager.scopes[0],
        Be,
        { exportedVariables: We.exportedVariables, enabledGlobals: We.enabledGlobals }
      );
      const _e = Object.assign({}, ae.rules, We.configuredRules);
      let je;
      try {
        je = nt(
          st,
          _e,
          ($e) => Ct(ne, $e),
          ee,
          Pe,
          we,
          fe.filename,
          fe.disableFixes,
          ne.cwd,
          re.physicalFilename
        );
      } catch ($e) {
        if ($e.message += `
Occurred while linting ${fe.filename}`, O("An error occurred while traversing"), O("Filename:", fe.filename), $e.currentNode) {
          const { line: Ae } = $e.currentNode.loc.start;
          O("Line:", Ae), $e.message += `:${Ae}`;
        }
        throw O("Parser Options:", ye), O("Parser Path:", ee), O("Settings:", we), $e.ruleId && ($e.message += `
Rule: "${$e.ruleId}"`), $e;
      }
      return c({
        directives: We.disableDirectives,
        disableFixes: fe.disableFixes,
        problems: je.concat(We.problems).sort(($e, Ae) => $e.line - Ae.line || $e.column - Ae.column),
        reportUnusedDisableDirectives: fe.reportUnusedDisableDirectives
      });
    }
    /**
     * Verifies the text against the rules specified by the second argument.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.
     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.
     *      If this is not set, the filename will default to '<input>' in the rule context. If
     *      an object, then it has "filename", "allowInlineConfig", and some properties.
     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.
     */
    verify(Ve, xe, re) {
      O("Verify");
      const { configType: ne, cwd: ae } = vt.get(this), fe = typeof re == "string" ? { filename: re } : re || {};
      if (xe) {
        if (ne === "flat") {
          let de = xe;
          return (!Array.isArray(xe) || typeof xe.getConfig != "function") && (de = new A(xe, { basePath: ae }), de.normalizeSync()), this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(Ve, de, fe, !0));
        }
        if (typeof xe.extractConfig == "function")
          return this._distinguishSuppressedMessages(this._verifyWithConfigArray(Ve, xe, fe));
      }
      return fe.preprocess || fe.postprocess ? this._distinguishSuppressedMessages(this._verifyWithProcessor(Ve, xe, fe)) : this._distinguishSuppressedMessages(this._verifyWithoutProcessors(Ve, xe, fe));
    }
    /**
     * Verify with a processor.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {FlatConfig} config The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithFlatConfigArrayAndProcessor(Ve, xe, re, ne) {
      const ae = re.filename || "<input>", fe = Z(ae), de = re.physicalFilename || fe, ee = rt(Ve), te = re.preprocess || ((we) => [we]), B = re.postprocess || ((we) => we.flat()), z = re.filterCodeBlock || ((we) => we.endsWith(".js")), ce = i.extname(ae);
      let ye;
      try {
        ye = te(ee, fe);
      } catch (we) {
        const Pe = `Preprocessing error: ${we.message.replace(/^line \d+:/iu, "").trim()}`;
        return O(`%s
%s`, Pe, we.stack), [
          {
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: Pe,
            line: we.lineNumber,
            column: we.column,
            nodeType: null
          }
        ];
      }
      const Be = ye.map((we, Pe) => {
        if (O("A code block was found: %o", we.filename || "(unnamed)"), typeof we == "string")
          return this._verifyWithFlatConfigArrayAndWithoutProcessors(we, xe, re);
        const st = we.text, We = i.join(ae, `${Pe}_${we.filename}`);
        return z(We, st) ? ne && (ee !== st || i.extname(We) !== ce) ? (O("Resolving configuration again because the file content or extension was changed."), this._verifyWithFlatConfigArray(
          st,
          ne,
          { ...re, filename: We, physicalFilename: de }
        )) : this._verifyWithFlatConfigArrayAndWithoutProcessors(
          st,
          xe,
          { ...re, filename: We, physicalFilename: de }
        ) : (O("This code block was skipped."), []);
      });
      return B(Be, fe);
    }
    /**
     * Same as linter.verify, except without support for processors.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.
     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
     * @throws {Error} If during rule execution.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
     */
    _verifyWithFlatConfigArrayAndWithoutProcessors(Ve, xe, re) {
      const ne = vt.get(this), ae = xe || {}, fe = Ee(re, ae);
      let de;
      typeof Ve == "string" ? (ne.lastSourceCode = null, de = Ve) : (ne.lastSourceCode = Ve, de = Ve.text);
      const ee = ae.languageOptions;
      if (ee.ecmaVersion = N(
        ee.ecmaVersion
      ), !ee.parser)
        throw new TypeError(`No parser specified for ${fe.filename}`);
      if (P(ee.parser)) {
        const Pe = ee.parserOptions;
        ee.sourceType && (Pe.sourceType = ee.sourceType, Pe.sourceType === "module" && Pe.ecmaFeatures && Pe.ecmaFeatures.globalReturn && (Pe.ecmaFeatures.globalReturn = !1));
      }
      const te = ae.settings || {};
      if (ne.lastSourceCode)
        ne.lastSourceCode.scopeManager || (ne.lastSourceCode = new l({
          text: ne.lastSourceCode.text,
          ast: ne.lastSourceCode.ast,
          parserServices: ne.lastSourceCode.parserServices,
          visitorKeys: ne.lastSourceCode.visitorKeys,
          scopeManager: mt(ne.lastSourceCode.ast, ee)
        }));
      else {
        const Pe = Y(
          de,
          ee,
          fe.filename
        );
        if (!Pe.success)
          return [Pe.error];
        ne.lastSourceCode = Pe.sourceCode;
      }
      const B = ne.lastSourceCode;
      B.applyLanguageOptions(ee);
      const z = {
        rules: {}
      }, ce = [];
      if (fe.allowInlineConfig)
        if (fe.warnInlineConfig)
          B.getInlineConfigNodes().forEach((Pe) => {
            ce.push(ue({
              ruleId: null,
              message: `'${B.text.slice(Pe.range[0], Pe.range[1])}' has no effect because you have 'noInlineConfig' setting in ${fe.warnInlineConfig}.`,
              loc: Pe.loc,
              severity: 1
            }));
          });
        else {
          const Pe = B.applyInlineConfig();
          ce.push(
            ...Pe.problems.map(ue).map((We) => (We.fatal = !0, We))
          );
          const st = new R();
          for (const { config: We, node: _e } of Pe.configs)
            Object.keys(We.rules).forEach((je) => {
              const $e = x(je, ae), Ae = We.rules[je];
              if (!$e) {
                ce.push(ue({ ruleId: je, loc: _e.loc }));
                return;
              }
              try {
                const oe = Array.isArray(Ae) ? Ae : [Ae];
                L(je, Ae), _(je, oe[0]), st.validate({
                  plugins: ae.plugins,
                  rules: {
                    [je]: oe
                  }
                }), z.rules[je] = Ae;
              } catch (oe) {
                let se = oe.message.slice(
                  oe.message.startsWith('Key "rules":') ? oe.message.indexOf(":", 12) + 1 : oe.message.indexOf(":") + 1
                ).trim();
                oe.messageTemplate && (se += ` You passed "${Ae}".`), ce.push(ue({
                  ruleId: je,
                  message: `Inline configuration for rule "${je}" is invalid:
	${se}
`,
                  loc: _e.loc
                }));
              }
            });
        }
      const ye = fe.allowInlineConfig && !fe.warnInlineConfig ? j(
        B,
        (Pe) => x(Pe, ae)
      ) : { problems: [], disableDirectives: [] }, Be = Object.assign({}, ae.rules, z.rules);
      let we;
      B.finalize();
      try {
        we = nt(
          B,
          Be,
          (Pe) => x(Pe, ae),
          void 0,
          ee,
          te,
          fe.filename,
          fe.disableFixes,
          ne.cwd,
          re.physicalFilename
        );
      } catch (Pe) {
        if (Pe.message += `
Occurred while linting ${fe.filename}`, O("An error occurred while traversing"), O("Filename:", fe.filename), Pe.currentNode) {
          const { line: st } = Pe.currentNode.loc.start;
          O("Line:", st), Pe.message += `:${st}`;
        }
        throw O("Parser Options:", ee.parserOptions), O("Settings:", te), Pe.ruleId && (Pe.message += `
Rule: "${Pe.ruleId}"`), Pe;
      }
      return c({
        directives: ye.disableDirectives,
        disableFixes: fe.disableFixes,
        problems: we.concat(ye.problems).concat(ce).sort((Pe, st) => Pe.line - st.line || Pe.column - st.column),
        reportUnusedDisableDirectives: fe.reportUnusedDisableDirectives
      });
    }
    /**
     * Verify a given code with `ConfigArray`.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigArray} configArray The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithConfigArray(Ve, xe, re) {
      O("With ConfigArray: %s", re.filename), vt.get(this).lastConfigArray = xe;
      const ne = xe.extractConfig(re.filename), ae = ne.processor && xe.pluginProcessors.get(ne.processor);
      if (ae) {
        O("Apply the processor: %o", ne.processor);
        const { preprocess: fe, postprocess: de, supportsAutofix: ee } = ae, te = re.disableFixes || !ee;
        return this._verifyWithProcessor(
          Ve,
          ne,
          { ...re, disableFixes: te, postprocess: de, preprocess: fe },
          xe
        );
      }
      return this._verifyWithoutProcessors(Ve, ne, re);
    }
    /**
     * Verify a given code with a flat config.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {FlatConfigArray} configArray The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {boolean} [firstCall=false] Indicates if this is being called directly
     *      from verify(). (TODO: Remove once eslintrc is removed.)
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithFlatConfigArray(Ve, xe, re, ne = !1) {
      O("With flat config: %s", re.filename);
      const ae = re.filename || "__placeholder__.js";
      vt.get(this).lastConfigArray = xe;
      const fe = xe.getConfig(ae);
      if (!fe)
        return [
          {
            ruleId: null,
            severity: 1,
            message: `No matching configuration found for ${ae}.`,
            line: 0,
            column: 0,
            nodeType: null
          }
        ];
      if (fe.processor) {
        O("Apply the processor: %o", fe.processor);
        const { preprocess: de, postprocess: ee, supportsAutofix: te } = fe.processor, B = re.disableFixes || !te;
        return this._verifyWithFlatConfigArrayAndProcessor(
          Ve,
          fe,
          { ...re, filename: ae, disableFixes: B, postprocess: ee, preprocess: de },
          xe
        );
      }
      return ne && (re.preprocess || re.postprocess) ? this._verifyWithFlatConfigArrayAndProcessor(Ve, fe, re) : this._verifyWithFlatConfigArrayAndWithoutProcessors(Ve, fe, re);
    }
    /**
     * Verify with a processor.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigData|ExtractedConfig} config The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithProcessor(Ve, xe, re, ne) {
      const ae = re.filename || "<input>", fe = Z(ae), de = re.physicalFilename || fe, ee = rt(Ve), te = re.preprocess || ((we) => [we]), B = re.postprocess || ((we) => we.flat()), z = re.filterCodeBlock || ((we) => we.endsWith(".js")), ce = i.extname(ae);
      let ye;
      try {
        ye = te(ee, fe);
      } catch (we) {
        const Pe = `Preprocessing error: ${we.message.replace(/^line \d+:/iu, "").trim()}`;
        return O(`%s
%s`, Pe, we.stack), [
          {
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: Pe,
            line: we.lineNumber,
            column: we.column,
            nodeType: null
          }
        ];
      }
      const Be = ye.map((we, Pe) => {
        if (O("A code block was found: %o", we.filename || "(unnamed)"), typeof we == "string")
          return this._verifyWithoutProcessors(we, xe, re);
        const st = we.text, We = i.join(ae, `${Pe}_${we.filename}`);
        return z(We, st) ? ne && (ee !== st || i.extname(We) !== ce) ? (O("Resolving configuration again because the file content or extension was changed."), this._verifyWithConfigArray(
          st,
          ne,
          { ...re, filename: We, physicalFilename: de }
        )) : this._verifyWithoutProcessors(
          st,
          xe,
          { ...re, filename: We, physicalFilename: de }
        ) : (O("This code block was skipped."), []);
      });
      return B(Be, fe);
    }
    /**
     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.
     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.
     * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.
     * @returns {LintMessage[]} A list of LintMessage.
     */
    _distinguishSuppressedMessages(Ve) {
      const xe = [], re = [], ne = vt.get(this);
      for (const ae of Ve)
        ae.suppressions ? re.push(ae) : xe.push(ae);
      return ne.lastSuppressedMessages = re, xe;
    }
    /**
     * Gets the SourceCode object representing the parsed source.
     * @returns {SourceCode} The SourceCode object.
     */
    getSourceCode() {
      return vt.get(this).lastSourceCode;
    }
    /**
     * Gets the list of SuppressedLintMessage produced in the last running.
     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage
     */
    getSuppressedMessages() {
      return vt.get(this).lastSuppressedMessages;
    }
    /**
     * Defines a new linting rule.
     * @param {string} ruleId A unique rule identifier
     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers
     * @returns {void}
     */
    defineRule(Ve, xe) {
      W(this), vt.get(this).ruleMap.define(Ve, xe);
    }
    /**
     * Defines many new linting rules.
     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule
     * @returns {void}
     */
    defineRules(Ve) {
      W(this), Object.getOwnPropertyNames(Ve).forEach((xe) => {
        this.defineRule(xe, Ve[xe]);
      });
    }
    /**
     * Gets an object with all loaded rules.
     * @returns {Map<string, Rule>} All loaded rules
     */
    getRules() {
      W(this);
      const { lastConfigArray: Ve, ruleMap: xe } = vt.get(this);
      return new Map(function* () {
        yield* xe, Ve && (yield* Ve.pluginRules);
      }());
    }
    /**
     * Define a new parser module
     * @param {string} parserId Name of the parser
     * @param {Parser} parserModule The parser object
     * @returns {void}
     */
    defineParser(Ve, xe) {
      W(this), vt.get(this).parserMap.set(Ve, xe);
    }
    /**
     * Performs multiple autofix passes over the text until as many fixes as possible
     * have been applied.
     * @param {string} text The source text to apply fixes to.
     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.
     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.
     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the
     *      SourceCodeFixer.
     */
    verifyAndFix(Ve, xe, re) {
      let ne = [], ae, fe = !1, de = 0, ee = Ve;
      const te = re && re.filename || `${Ve.slice(0, 10)}...`, B = re && typeof re.fix < "u" ? re.fix : !0;
      do {
        if (de++, O(`Linting code for ${te} (pass ${de})`), ne = this.verify(ee, xe, re), O(`Generating fixed text for ${te} (pass ${de})`), ae = b.applyFixes(ee, ne, B), ne.length === 1 && ne[0].fatal)
          break;
        fe = fe || ae.fixed, ee = ae.output;
      } while (ae.fixed && de < k);
      return ae.fixed && (ae.messages = this.verify(ee, xe, re)), ae.fixed = fe, ae.output = ee, ae;
    }
  }
  return bf = {
    Linter: Ye,
    /**
     * Get the internal slots of a given Linter instance for tests.
     * @param {Linter} instance The Linter instance to get.
     * @returns {LinterInternalSlots} The internal slots.
     */
    getLinterInternalSlots(Ue) {
      return vt.get(Ue);
    }
  }, bf;
}
const i_ = () => {
  if (typeof globalThis < "u") return globalThis;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof Mt < "u") return Mt;
  throw new Error("Unable to locate global `this`");
};
typeof process > "u" && (i_().process = Kv());
function a_() {
  return s_().Linter;
}
var o_ = a_();
const l_ = {
  env: {
    browser: !0,
    es6: !0
  },
  parserOptions: {
    ecmaFeatures: {
      jsx: !0
    },
    ecmaVersion: "latest",
    sourceType: "module"
  }
}, u_ = {
  ...l_,
  rules: {
    ...Mv,
    // JS 面板中，仅定义 function，但可能不使用该方法
    "no-unused-vars": "off",
    "no-alert": "off",
    "no-console": "off"
  },
  settings: {}
}, c_ = {
  2: "Error",
  1: "Warning"
}, UC = new o_();
self.addEventListener("message", (i) => {
  const { code: t, version: o } = i.data, f = UC.getRules(), u = UC.verify(t, u_).map(({ ruleId: e = "", line: a, endLine: n, column: p, endColumn: m, message: h, severity: l }) => {
    var s, c, g;
    return {
      code: {
        value: e || "",
        target: ((g = (c = (s = f.get(e)) == null ? void 0 : s.meta) == null ? void 0 : c.docs) == null ? void 0 : g.url) || ""
      },
      startLineNumber: a,
      endLineNumber: n,
      startColumn: p,
      endColumn: m,
      message: h,
      severity: c_[l],
      source: "ESLint"
    };
  });
  self.postMessage({ markers: u, version: o });
});
//# sourceMappingURL=eslint.worker.js.map
