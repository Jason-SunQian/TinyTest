{"version":3,"file":"ast.js","sources":["../../js/ast.js"],"sourcesContent":["/**\n * Copyright (c) 2023 - present TinyEngine Authors.\n * Copyright (c) 2023 - present Huawei Cloud Computing Technologies Co., Ltd.\n *\n * Use of this source code is governed by an MIT-style license.\n *\n * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,\n * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR\n * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.\n *\n */\n\nimport { parse, parseExpression } from '@babel/parser'\nimport generate from '@babel/generator'\nimport traverse from '@babel/traverse'\nimport prettier from 'prettier'\nimport parserHtml from 'prettier/parser-html'\nimport parseCss from 'prettier/parser-postcss'\nimport parserBabel from 'prettier/parser-babel'\nimport prettierConfig from './config-files/prettierrc'\n\nconst METHOD_REGEXP = /function.*?\\(/\n\nexport const insertName = (name, content) => content.replace(METHOD_REGEXP, `function ${name}(`)\n\nexport const removeName = (content) => content.replace(METHOD_REGEXP, 'function (')\n\nexport const string2Ast = (string = '') => parse(string, { sourceType: 'module', plugins: ['typescript', 'jsx'] })\n\nexport const ast2String = (ast) => generate(ast, { retainLines: true }).code\n\nconst formatScript = (string) => {\n  let newStr = string\n  const options = {\n    parser: 'babel',\n    plugins: [parserBabel],\n    ...prettierConfig\n  }\n  try {\n    const ast = string2Ast(string)\n    // javascript 在 prettier 格式化的时候，会自动在前面加上逗号“；”，因此该种情形需要特殊处理格式化\n    if (ast.program.body?.length === 1 && ast.program.body?.[0]?.type === 'ExpressionStatement') {\n      // 将 javascript 表达式 包裹在 \"!()\" 中，格式化完成之后，再从里面取出来格式化之后的值\n      newStr = prettier.format(`!(${string})`, options).replace(/\\r?\\n$/, '')\n\n      // 格式化后，仍存在包裹的 \"!()\"\n      if (newStr.match(/^!\\([\\s\\S]*\\)$/)) {\n        newStr = newStr.replace(/^!\\(([\\s\\S]*)\\)$/, '$1')\n      } else {\n        // 格式化后，仅存在开头的 \"!\"\n        newStr = newStr.replace(/^!/, '')\n      }\n    } else {\n      // 其他类型，不需要特殊处理\n      newStr = prettier.format(string, options)\n    }\n  } catch (error) {\n    newStr = prettier.format(newStr, options)\n  }\n\n  return newStr\n}\n\nconst formatJson = (string) =>\n  prettier.format(string, {\n    parser: 'json',\n    plugins: [parserBabel],\n    trailingComma: 'es5',\n    ...prettierConfig\n  })\n\nconst formatHtml = (string) =>\n  prettier.format(string, {\n    parser: 'html',\n    plugins: [parserBabel, parserHtml],\n    ...prettierConfig\n  })\n\nconst formatCss = (string) =>\n  prettier.format(string, {\n    parser: 'css',\n    plugins: [parseCss],\n    ...prettierConfig\n  })\n\nconst formatterMap = {\n  json: formatJson,\n  typescript: formatScript,\n  javascript: formatScript,\n  html: formatHtml,\n  css: formatCss\n}\n\nexport const formatString = (str, language) => {\n  const formatter = formatterMap[language] || formatJson\n  let result = str\n  try {\n    result = formatter(str)\n  } catch (error) {\n    const printer = console\n    printer.log(error)\n  }\n\n  return result\n}\n\nexport { parse, parseExpression, traverse, generate }\n\nexport const includedExpression = (code, expression) => {\n  let flag = false\n  try {\n    traverse(parse(code), {\n      ExpressionStatement(path) {\n        if (path.toString().includes(expression)) {\n          flag = true\n\n          return\n        }\n      }\n    })\n  } catch (err) {\n    const printer = console\n    printer.log(err)\n  }\n\n  return flag\n}\n\nexport const includedExpressionInSchema = (schemaObj, expression) => {\n  let hadFlag = false\n\n  const checkReferencedFromSchema = (_schemaObj) => {\n    Object.values(_schemaObj).forEach((schemaObjIner) => {\n      if (\n        ['[object Array]', '[object Object]'].includes(Object.prototype.toString.call(schemaObjIner)) &&\n        Object.keys(schemaObjIner).length\n      ) {\n        if (schemaObjIner.type && ['jsstring', 'JSExpression', 'JSFunction'].includes(schemaObjIner.type)) {\n          if (includedExpression(schemaObjIner.value, expression)) {\n            hadFlag = true\n\n            return\n          }\n        } else {\n          checkReferencedFromSchema(schemaObjIner)\n        }\n      }\n    })\n  }\n\n  checkReferencedFromSchema(schemaObj)\n\n  return hadFlag\n}\n\nexport const findExpressionInAppSchema = (pageSchemas, expression) => {\n  const includedPage = []\n\n  pageSchemas.forEach((pageSchema) => {\n    if (includedExpressionInSchema(pageSchema, expression)) {\n      includedPage.push(pageSchema.fileName)\n    }\n  })\n\n  return includedPage\n}\n"],"names":["METHOD_REGEXP","insertName","name","content","removeName","string2Ast","string","parse","ast2String","ast","generate","formatScript","newStr","options","parserBabel","prettierConfig","_a","_c","_b","prettier","formatJson","formatHtml","parserHtml","formatCss","parseCss","formatterMap","formatString","str","language","formatter","result","error","includedExpression","code","expression","flag","traverse","path","err","includedExpressionInSchema","schemaObj","hadFlag","checkReferencedFromSchema","_schemaObj","schemaObjIner","findExpressionInAppSchema","pageSchemas","includedPage","pageSchema"],"mappings":";;;;;;;;;;;AAqBA,MAAMA,IAAgB,iBAETC,IAAa,CAACC,GAAMC,MAAYA,EAAQ,QAAQH,GAAe,YAAYE,CAAI,GAAG,GAElFE,IAAa,CAACD,MAAYA,EAAQ,QAAQH,GAAe,YAAY,GAErEK,IAAa,CAACC,IAAS,OAAOC,EAAMD,GAAQ,EAAE,YAAY,UAAU,SAAS,CAAC,cAAc,KAAK,EAAC,CAAE,GAEpGE,IAAa,CAACC,MAAQC,EAASD,GAAK,EAAE,aAAa,GAAI,CAAE,EAAE,MAElEE,IAAe,CAACL,MAAW;;AAC/B,MAAIM,IAASN;AACb,QAAMO,IAAU;AAAA,IACd,QAAQ;AAAA,IACR,SAAS,CAACC,CAAW;AAAA,IACrB,GAAGC;AAAAA,EACP;AACE,MAAI;AACF,UAAMN,IAAMJ,EAAWC,CAAM;AAE7B,MAAIU,IAAAP,EAAI,QAAQ,SAAZ,gBAAAO,EAAkB,YAAW,OAAKC,KAAAC,IAAAT,EAAI,QAAQ,SAAZ,gBAAAS,EAAmB,OAAnB,gBAAAD,EAAuB,UAAS,yBAEpEL,IAASO,EAAS,OAAO,KAAKb,CAAM,KAAKO,CAAO,EAAE,QAAQ,UAAU,EAAE,GAGlED,EAAO,MAAM,gBAAgB,IAC/BA,IAASA,EAAO,QAAQ,oBAAoB,IAAI,IAGhDA,IAASA,EAAO,QAAQ,MAAM,EAAE,KAIlCA,IAASO,EAAS,OAAOb,GAAQO,CAAO;AAAA,EAE5C,QAAgB;AACd,IAAAD,IAASO,EAAS,OAAOP,GAAQC,CAAO;AAAA,EAC1C;AAEA,SAAOD;AACT,GAEMQ,IAAa,CAACd,MAClBa,EAAS,OAAOb,GAAQ;AAAA,EACtB,QAAQ;AAAA,EACR,SAAS,CAACQ,CAAW;AAAA,EACrB,eAAe;AAAA,EACf,GAAGC;AACP,CAAG,GAEGM,IAAa,CAACf,MAClBa,EAAS,OAAOb,GAAQ;AAAA,EACtB,QAAQ;AAAA,EACR,SAAS,CAACQ,GAAaQ,CAAU;AAAA,EACjC,GAAGP;AACP,CAAG,GAEGQ,IAAY,CAACjB,MACjBa,EAAS,OAAOb,GAAQ;AAAA,EACtB,QAAQ;AAAA,EACR,SAAS,CAACkB,CAAQ;AAAA,EAClB,GAAGT;AACP,CAAG,GAEGU,IAAe;AAAA,EACnB,MAAML;AAAA,EACN,YAAYT;AAAA,EACZ,YAAYA;AAAA,EACZ,MAAMU;AAAA,EACN,KAAKE;AACP,GAEaG,IAAe,CAACC,GAAKC,MAAa;AAC7C,QAAMC,IAAYJ,EAAaG,CAAQ,KAAKR;AAC5C,MAAIU,IAASH;AACb,MAAI;AACF,IAAAG,IAASD,EAAUF,CAAG;AAAA,EACxB,SAASI,GAAO;AAEd,IADgB,QACR,IAAIA,CAAK;AAAA,EACnB;AAEA,SAAOD;AACT,GAIaE,IAAqB,CAACC,GAAMC,MAAe;AACtD,MAAIC,IAAO;AACX,MAAI;AACF,IAAAC,EAAS7B,EAAM0B,CAAI,GAAG;AAAA,MACpB,oBAAoBI,GAAM;AACxB,YAAIA,EAAK,SAAQ,EAAG,SAASH,CAAU,GAAG;AACxC,UAAAC,IAAO;AAEP;AAAA,QACF;AAAA,MACF;AAAA,IACN,CAAK;AAAA,EACH,SAASG,GAAK;AAEZ,IADgB,QACR,IAAIA,CAAG;AAAA,EACjB;AAEA,SAAOH;AACT,GAEaI,IAA6B,CAACC,GAAWN,MAAe;AACnE,MAAIO,IAAU;AAEd,QAAMC,IAA4B,CAACC,MAAe;AAChD,WAAO,OAAOA,CAAU,EAAE,QAAQ,CAACC,MAAkB;AACnD,UACE,CAAC,kBAAkB,iBAAiB,EAAE,SAAS,OAAO,UAAU,SAAS,KAAKA,CAAa,CAAC,KAC5F,OAAO,KAAKA,CAAa,EAAE;AAE3B,YAAIA,EAAc,QAAQ,CAAC,YAAY,gBAAgB,YAAY,EAAE,SAASA,EAAc,IAAI;AAC9F,cAAIZ,EAAmBY,EAAc,OAAOV,CAAU,GAAG;AACvD,YAAAO,IAAU;AAEV;AAAA,UACF;AAAA;AAEA,UAAAC,EAA0BE,CAAa;AAAA,IAG7C,CAAC;AAAA,EACH;AAEA,SAAAF,EAA0BF,CAAS,GAE5BC;AACT,GAEaI,IAA4B,CAACC,GAAaZ,MAAe;AACpE,QAAMa,IAAe,CAAA;AAErB,SAAAD,EAAY,QAAQ,CAACE,MAAe;AAClC,IAAIT,EAA2BS,GAAYd,CAAU,KACnDa,EAAa,KAAKC,EAAW,QAAQ;AAAA,EAEzC,CAAC,GAEMD;AACT;"}